{
    "parent_c4db0b58-b255-4df9-95c2-4a73939a2cb6": "A L G O R I T H M S\nI N T R O D U C T I O N  T O\nT H I R D  E D I T I O N\nT H O M A S  H. \nC H A R L E S  E.      \nR O N A L D  L. \nC L I F F O R D\nS T E I N\nR I V E S T\nL E I S E R S O N\nC O R M E N\nIntroduction to Algorithms\nThird Edition\nThomas H. Cormen\nCharles E. Leiserson\nRonald L. Rivest\nClifford Stein\nIntroduction to Algorithms\nThird Edition\nThe MIT Press\nCambridge, Massachusetts\nLondon, England\nc\u0002 2009 Massachusetts Institute of Technology\nAll rights reserved. No part of this book may be reproduced in any form or by any electronic or mechanical means\n(including photocopying, recording, or information storage and retrieval) without permission in writing from the\npublisher.\nFor information about special quantity discounts, please email special sales@mitpress.mit.edu.\nThis book was set in Times Roman and Mathtime Pro 2 by the authors.\nPrinted and bound in the United States of America.\nLibrary of Congress Cataloging-in-Publication Data\nIntroduction to algorithms / Thomas H. Cormen . . . [et al.].—3rd ed.\np. cm.\nIncludes bibliographical references and index.\nISBN 978-0-262-03384-8 (hardcover : alk. paper)—ISBN 978-0-262-53305-8 (pbk. : alk. paper)\n1. Computer programming.\n2. Computer algorithms. I. Cormen, Thomas H.\nQA76.6.I5858 2009\n005.1—dc22\n2009008593\n10 9 8 7 6 5 4 3 2\nContents\nPreface\nxiii\nI\nFoundations\nIntroduction\n3\n1\nThe Role of Algorithms in Computing\n5\n1.1\nAlgorithms\n5\n1.2\nAlgorithms as a technology\n11\n2\nGetting Started\n16\n2.1\nInsertion sort\n16\n2.2\nAnalyzing algorithms\n23\n2.3\nDesigning algorithms\n29\n3\nGrowth of Functions\n43\n3.1\nAsymptotic notation\n43\n3.2\nStandard notations and common functions\n53\n4\nDivide-and-Conquer\n65\n4.1\nThe maximum-subarray problem\n68\n4.2\nStrassen’s algorithm for matrix multiplication\n75\n4.3\nThe substitution method for solving recurrences\n83\n4.4\nThe recursion-tree method for solving recurrences\n88\n4.5\nThe master method for solving recurrences\n93\n?\n4.6\nProof of the master theorem\n97\n5",
    "parent_3fdf6db8-2eb3-4da0-a6ba-5c60a90d97fa": "65\n4.1\nThe maximum-subarray problem\n68\n4.2\nStrassen’s algorithm for matrix multiplication\n75\n4.3\nThe substitution method for solving recurrences\n83\n4.4\nThe recursion-tree method for solving recurrences\n88\n4.5\nThe master method for solving recurrences\n93\n?\n4.6\nProof of the master theorem\n97\n5\nProbabilistic Analysis and Randomized Algorithms\n114\n5.1\nThe hiring problem\n114\n5.2\nIndicator random variables\n118\n5.3\nRandomized algorithms\n122\n?\n5.4\nProbabilistic analysis and further uses of indicator random variables\n130\nvi\nContents\nII\nSorting and Order Statistics\nIntroduction\n147\n6\nHeapsort\n151\n6.1\nHeaps\n151\n6.2\nMaintaining the heap property\n154\n6.3\nBuilding a heap\n156\n6.4\nThe heapsort algorithm\n159\n6.5\nPriority queues\n162\n7\nQuicksort\n170\n7.1\nDescription of quicksort\n170\n7.2\nPerformance of quicksort\n174\n7.3\nA randomized version of quicksort\n179\n7.4\nAnalysis of quicksort\n180\n8\nSorting in Linear Time\n191\n8.1\nLower bounds for sorting\n191\n8.2\nCounting sort\n194\n8.3\nRadix sort\n197\n8.4\nBucket sort\n200\n9\nMedians and Order Statistics\n213\n9.1\nMinimum and maximum\n214\n9.2\nSelection in expected linear time\n215\n9.3\nSelection in worst-case linear time\n220\nIII\nData Structures\nIntroduction\n229\n10\nElementary Data Structures\n232\n10.1 Stacks and queues\n232\n10.2 Linked lists\n236\n10.3 Implementing pointers and objects\n241\n10.4 Representing rooted trees\n246\n11\nHash Tables\n253\n11.1 Direct-address tables\n254\n11.2 Hash tables\n256\n11.3 Hash functions\n262\n11.4 Open addressing\n269\n?\n11.5 Perfect hashing\n277\nContents\nvii\n12\nBinary Search Trees\n286\n12.1 What is a binary search tree?\n286\n12.2 Querying a binary search tree\n289\n12.3 Insertion and deletion\n294\n?\n12.4 Randomly built binary search trees\n299\n13\nRed-Black Trees\n308\n13.1 Properties of red-black trees\n308\n13.2 Rotations\n312\n13.3 Insertion\n315\n13.4 Deletion\n323\n14\nAugmenting Data Structures\n339\n14.1 Dynamic order statistics\n339\n14.2 How to augment a data structure\n345\n14.3 Interval trees\n348\nIV\nAdvanced Design and Analysis Techniques\nIntroduction",
    "parent_351273c6-46af-45cf-867b-26173e972ed0": "308\n13.1 Properties of red-black trees\n308\n13.2 Rotations\n312\n13.3 Insertion\n315\n13.4 Deletion\n323\n14\nAugmenting Data Structures\n339\n14.1 Dynamic order statistics\n339\n14.2 How to augment a data structure\n345\n14.3 Interval trees\n348\nIV\nAdvanced Design and Analysis Techniques\nIntroduction\n357\n15\nDynamic Programming\n359\n15.1 Rod cutting\n360\n15.2 Matrix-chain multiplication\n370\n15.3 Elements of dynamic programming\n378\n15.4 Longest common subsequence\n390\n15.5 Optimal binary search trees\n397\n16\nGreedy Algorithms\n414\n16.1 An activity-selection problem\n415\n16.2 Elements of the greedy strategy\n423\n16.3 Huffman codes\n428\n?\n16.4 Matroids and greedy methods\n437\n?\n16.5 A task-scheduling problem as a matroid\n443\n17\nAmortized Analysis\n451\n17.1 Aggregate analysis\n452\n17.2 The accounting method\n456\n17.3 The potential method\n459\n17.4 Dynamic tables\n463\nviii\nContents\nV\nAdvanced Data Structures\nIntroduction\n481\n18\nB-Trees\n484\n18.1 Deﬁnition of B-trees\n488\n18.2 Basic operations on B-trees\n491\n18.3 Deleting a key from a B-tree\n499\n19\nFibonacci Heaps\n505\n19.1 Structure of Fibonacci heaps\n507\n19.2 Mergeable-heap operations\n510\n19.3 Decreasing a key and deleting a node\n518\n19.4 Bounding the maximum degree\n523\n20\nvan Emde Boas Trees\n531\n20.1 Preliminary approaches\n532\n20.2 A recursive structure\n536\n20.3 The van Emde Boas tree\n545\n21\nData Structures for Disjoint Sets\n561\n21.1 Disjoint-set operations\n561\n21.2 Linked-list representation of disjoint sets\n564\n21.3 Disjoint-set forests\n568\n?\n21.4 Analysis of union by rank with path compression\n573\nVI\nGraph Algorithms\nIntroduction\n587\n22\nElementary Graph Algorithms\n589\n22.1 Representations of graphs\n589\n22.2 Breadth-ﬁrst search\n594\n22.3 Depth-ﬁrst search\n603\n22.4 Topological sort\n612\n22.5 Strongly connected components\n615\n23\nMinimum Spanning Trees\n624\n23.1 Growing a minimum spanning tree\n625\n23.2 The algorithms of Kruskal and Prim\n631\nContents\nix\n24\nSingle-Source Shortest Paths\n643\n24.1 The Bellman-Ford algorithm\n651",
    "parent_bff036bb-95cd-4ef0-898f-235358974577": "594\n22.3 Depth-ﬁrst search\n603\n22.4 Topological sort\n612\n22.5 Strongly connected components\n615\n23\nMinimum Spanning Trees\n624\n23.1 Growing a minimum spanning tree\n625\n23.2 The algorithms of Kruskal and Prim\n631\nContents\nix\n24\nSingle-Source Shortest Paths\n643\n24.1 The Bellman-Ford algorithm\n651\n24.2 Single-source shortest paths in directed acyclic graphs\n655\n24.3 Dijkstra’s algorithm\n658\n24.4 Difference constraints and shortest paths\n664\n24.5 Proofs of shortest-paths properties\n671\n25\nAll-Pairs Shortest Paths\n684\n25.1 Shortest paths and matrix multiplication\n686\n25.2 The Floyd-Warshall algorithm\n693\n25.3 Johnson’s algorithm for sparse graphs\n700\n26\nMaximum Flow\n708\n26.1 Flow networks\n709\n26.2 The Ford-Fulkerson method\n714\n26.3 Maximum bipartite matching\n732\n?\n26.4 Push-relabel algorithms\n736\n?\n26.5 The relabel-to-front algorithm\n748\nVII\nSelected Topics\nIntroduction\n769\n27\nMultithreaded Algorithms\n772\n27.1 The basics of dynamic multithreading\n774\n27.2 Multithreaded matrix multiplication\n792\n27.3 Multithreaded merge sort\n797\n28\nMatrix Operations\n813\n28.1 Solving systems of linear equations\n813\n28.2 Inverting matrices\n827\n28.3 Symmetric positive-deﬁnite matrices and least-squares approximation\n832\n29\nLinear Programming\n843\n29.1 Standard and slack forms\n850\n29.2 Formulating problems as linear programs\n859\n29.3 The simplex algorithm\n864\n29.4 Duality\n879\n29.5 The initial basic feasible solution\n886\nx\nContents\n30\nPolynomials and the FFT\n898\n30.1 Representing polynomials\n900\n30.2 The DFT and FFT\n906\n30.3 Efﬁcient FFT implementations\n915\n31\nNumber-Theoretic Algorithms\n926\n31.1 Elementary number-theoretic notions\n927\n31.2 Greatest common divisor\n933\n31.3 Modular arithmetic\n939\n31.4 Solving modular linear equations\n946\n31.5 The Chinese remainder theorem\n950\n31.6 Powers of an element\n954\n31.7 The RSA public-key cryptosystem\n958\n?\n31.8 Primality testing\n965\n?\n31.9 Integer factorization\n975\n32\nString Matching\n985\n32.1 The naive string-matching algorithm\n988",
    "parent_56666865-46c2-4fa0-9e69-84d2bd4f86d8": "939\n31.4 Solving modular linear equations\n946\n31.5 The Chinese remainder theorem\n950\n31.6 Powers of an element\n954\n31.7 The RSA public-key cryptosystem\n958\n?\n31.8 Primality testing\n965\n?\n31.9 Integer factorization\n975\n32\nString Matching\n985\n32.1 The naive string-matching algorithm\n988\n32.2 The Rabin-Karp algorithm\n990\n32.3 String matching with ﬁnite automata\n995\n?\n32.4 The Knuth-Morris-Pratt algorithm\n1002\n33\nComputational Geometry\n1014\n33.1 Line-segment properties\n1015\n33.2 Determining whether any pair of segments intersects\n1021\n33.3 Finding the convex hull\n1029\n33.4 Finding the closest pair of points\n1039\n34\nNP-Completeness\n1048\n34.1 Polynomial time\n1053\n34.2 Polynomial-time veriﬁcation\n1061\n34.3 NP-completeness and reducibility\n1067\n34.4 NP-completeness proofs\n1078\n34.5 NP-complete problems\n1086\n35\nApproximation Algorithms\n1106\n35.1 The vertex-cover problem\n1108\n35.2 The traveling-salesman problem\n1111\n35.3 The set-covering problem\n1117\n35.4 Randomization and linear programming\n1123\n35.5 The subset-sum problem\n1128\nContents\nxi\nVIII\nAppendix: Mathematical Background\nIntroduction\n1143\nA\nSummations\n1145\nA.1\nSummation formulas and properties\n1145\nA.2\nBounding summations\n1149\nB\nSets, Etc.\n1158\nB.1\nSets\n1158\nB.2\nRelations\n1163\nB.3\nFunctions\n1166\nB.4\nGraphs\n1168\nB.5\nTrees\n1173\nC\nCounting and Probability\n1183\nC.1\nCounting\n1183\nC.2\nProbability\n1189\nC.3\nDiscrete random variables\n1196\nC.4\nThe geometric and binomial distributions\n1201\n?\nC.5\nThe tails of the binomial distribution\n1208\nD\nMatrices\n1217\nD.1\nMatrices and matrix operations\n1217\nD.2\nBasic matrix properties\n1222\nBibliography\n1231\nIndex\n1251\nPreface\nBefore there were computers, there were algorithms. But now that there are com-\nputers, there are even more algorithms, and algorithms lie at the heart of computing.\nThis book provides a comprehensive introduction to the modern study of com-\nputer algorithms. It presents many algorithms and covers them in considerable",
    "parent_05c123ca-e0a6-4428-8292-3f6a598fd8ae": "puters, there are even more algorithms, and algorithms lie at the heart of computing.\nThis book provides a comprehensive introduction to the modern study of com-\nputer algorithms. It presents many algorithms and covers them in considerable\ndepth, yet makes their design and analysis accessible to all levels of readers. We\nhave tried to keep explanations elementary without sacriﬁcing depth of coverage\nor mathematical rigor.\nEach chapter presents an algorithm, a design technique, an application area, or a\nrelated topic. Algorithms are described in English and in a pseudocode designed to\nbe readable by anyone who has done a little programming. The book contains 244\nﬁgures—many with multiple parts—illustrating how the algorithms work. Since\nwe emphasize efﬁciency as a design criterion, we include careful analyses of the\nrunning times of all our algorithms.\nThe text is intended primarily for use in undergraduate or graduate courses in\nalgorithms or data structures. Because it discusses engineering issues in algorithm\ndesign, as well as mathematical aspects, it is equally well suited for self-study by\ntechnical professionals.\nIn this, the third edition, we have once again updated the entire book. The\nchanges cover a broad spectrum, including new chapters, revised pseudocode, and\na more active writing style.\nTo the teacher\nWe have designed this book to be both versatile and complete. You should ﬁnd it\nuseful for a variety of courses, from an undergraduate course in data structures up\nthrough a graduate course in algorithms. Because we have provided considerably\nmore material than can ﬁt in a typical one-term course, you can consider this book\nto be a “buffet” or “smorgasbord” from which you can pick and choose the material\nthat best supports the course you wish to teach.\nxiv\nPreface\nYou should ﬁnd it easy to organize your course around just the chapters you\nneed. We have made chapters relatively self-contained, so that you need not worry",
    "parent_6a7360f2-0c90-48c5-99c5-dfe2909c80fd": "that best supports the course you wish to teach.\nxiv\nPreface\nYou should ﬁnd it easy to organize your course around just the chapters you\nneed. We have made chapters relatively self-contained, so that you need not worry\nabout an unexpected and unnecessary dependence of one chapter on another. Each\nchapter presents the easier material ﬁrst and the more difﬁcult material later, with\nsection boundaries marking natural stopping points. In an undergraduate course,\nyou might use only the earlier sections from a chapter; in a graduate course, you\nmight cover the entire chapter.\nWe have included 957 exercises and 158 problems. Each section ends with exer-\ncises, and each chapter ends with problems. The exercises are generally short ques-\ntions that test basic mastery of the material. Some are simple self-check thought\nexercises, whereas others are more substantial and are suitable as assigned home-\nwork. The problems are more elaborate case studies that often introduce new ma-\nterial; they often consist of several questions that lead the student through the steps\nrequired to arrive at a solution.\nDeparting from our practice in previous editions of this book, we have made\npublicly available solutions to some, but by no means all, of the problems and ex-\nercises. Our Web site, http://mitpress.mit.edu/algorithms/, links to these solutions.\nYou will want to check this site to make sure that it does not contain the solution to\nan exercise or problem that you plan to assign. We expect the set of solutions that\nwe post to grow slowly over time, so you will need to check it each time you teach\nthe course.\nWe have starred (?) the sections and exercises that are more suitable for graduate\nstudents than for undergraduates. A starred section is not necessarily more difﬁ-\ncult than an unstarred one, but it may require an understanding of more advanced\nmathematics. Likewise, starred exercises may require an advanced background or\nmore than average creativity.\nTo the student",
    "parent_fa7a2ec3-ce72-4645-adb0-e1acb1dec0c4": "students than for undergraduates. A starred section is not necessarily more difﬁ-\ncult than an unstarred one, but it may require an understanding of more advanced\nmathematics. Likewise, starred exercises may require an advanced background or\nmore than average creativity.\nTo the student\nWe hope that this textbook provides you with an enjoyable introduction to the\nﬁeld of algorithms. We have attempted to make every algorithm accessible and\ninteresting. To help you when you encounter unfamiliar or difﬁcult algorithms, we\ndescribe each one in a step-by-step manner. We also provide careful explanations\nof the mathematics needed to understand the analysis of the algorithms. If you\nalready have some familiarity with a topic, you will ﬁnd the chapters organized so\nthat you can skim introductory sections and proceed quickly to the more advanced\nmaterial.\nThis is a large book, and your class will probably cover only a portion of its\nmaterial. We have tried, however, to make this a book that will be useful to you\nnow as a course textbook and also later in your career as a mathematical desk\nreference or an engineering handbook.\nPreface\nxv\nWhat are the prerequisites for reading this book?\n\u0002\nYou should have some programming experience. In particular, you should un-\nderstand recursive procedures and simple data structures such as arrays and\nlinked lists.\n\u0002\nYou should have some facility with mathematical proofs, and especially proofs\nby mathematical induction. A few portions of the book rely on some knowledge\nof elementary calculus. Beyond that, Parts I and VIII of this book teach you all\nthe mathematical techniques you will need.\nWe have heard, loud and clear, the call to supply solutions to problems and\nexercises. Our Web site, http://mitpress.mit.edu/algorithms/, links to solutions for\na few of the problems and exercises. Feel free to check your solutions against ours.\nWe ask, however, that you do not send your solutions to us.\nTo the professional",
    "parent_b48d09eb-2738-4fc6-863b-cc796aaa6025": "exercises. Our Web site, http://mitpress.mit.edu/algorithms/, links to solutions for\na few of the problems and exercises. Feel free to check your solutions against ours.\nWe ask, however, that you do not send your solutions to us.\nTo the professional\nThe wide range of topics in this book makes it an excellent handbook on algo-\nrithms. Because each chapter is relatively self-contained, you can focus in on the\ntopics that most interest you.\nMost of the algorithms we discuss have great practical utility. We therefore\naddress implementation concerns and other engineering issues. We often provide\npractical alternatives to the few algorithms that are primarily of theoretical interest.\nIf you wish to implement any of the algorithms, you should ﬁnd the transla-\ntion of our pseudocode into your favorite programming language to be a fairly\nstraightforward task. We have designed the pseudocode to present each algorithm\nclearly and succinctly. Consequently, we do not address error-handling and other\nsoftware-engineering issues that require speciﬁc assumptions about your program-\nming environment. We attempt to present each algorithm simply and directly with-\nout allowing the idiosyncrasies of a particular programming language to obscure\nits essence.\nWe understand that if you are using this book outside of a course, then you\nmight be unable to check your solutions to problems and exercises against solutions\nprovided by an instructor. Our Web site, http://mitpress.mit.edu/algorithms/, links\nto solutions for some of the problems and exercises so that you can check your\nwork. Please do not send your solutions to us.\nTo our colleagues\nWe have supplied an extensive bibliography and pointers to the current literature.\nEach chapter ends with a set of chapter notes that give historical details and ref-\nerences. The chapter notes do not provide a complete reference to the whole ﬁeld\nxvi\nPreface\nof algorithms, however. Though it may be hard to believe for a book of this size,",
    "parent_10a08d42-430e-419a-b49e-2c854831244e": "Each chapter ends with a set of chapter notes that give historical details and ref-\nerences. The chapter notes do not provide a complete reference to the whole ﬁeld\nxvi\nPreface\nof algorithms, however. Though it may be hard to believe for a book of this size,\nspace constraints prevented us from including many interesting algorithms.\nDespite myriad requests from students for solutions to problems and exercises,\nwe have chosen as a matter of policy not to supply references for problems and\nexercises, to remove the temptation for students to look up a solution rather than to\nﬁnd it themselves.\nChanges for the third edition\nWhat has changed between the second and third editions of this book? The mag-\nnitude of the changes is on a par with the changes between the ﬁrst and second\neditions. As we said about the second-edition changes, depending on how you\nlook at it, the book changed either not much or quite a bit.\nA quick look at the table of contents shows that most of the second-edition chap-\nters and sections appear in the third edition. We removed two chapters and one\nsection, but we have added three new chapters and two new sections apart from\nthese new chapters.\nWe kept the hybrid organization from the ﬁrst two editions. Rather than organiz-\ning chapters by only problem domains or according only to techniques, this book\nhas elements of both. It contains technique-based chapters on divide-and-conquer,\ndynamic programming, greedy algorithms, amortized analysis, NP-Completeness,\nand approximation algorithms. But it also has entire parts on sorting, on data\nstructures for dynamic sets, and on algorithms for graph problems. We ﬁnd that\nalthough you need to know how to apply techniques for designing and analyzing al-\ngorithms, problems seldom announce to you which techniques are most amenable\nto solving them.\nHere is a summary of the most signiﬁcant changes for the third edition:\n\u0002\nWe added new chapters on van Emde Boas trees and multithreaded algorithms,",
    "parent_f36c9d04-b298-4505-a10f-e736cc4d6a19": "gorithms, problems seldom announce to you which techniques are most amenable\nto solving them.\nHere is a summary of the most signiﬁcant changes for the third edition:\n\u0002\nWe added new chapters on van Emde Boas trees and multithreaded algorithms,\nand we have broken out material on matrix basics into its own appendix chapter.\n\u0002\nWe revised the chapter on recurrences to more broadly cover the divide-and-\nconquer technique, and its ﬁrst two sections apply divide-and-conquer to solve\ntwo problems. The second section of this chapter presents Strassen’s algorithm\nfor matrix multiplication, which we have moved from the chapter on matrix\noperations.\n\u0002\nWe removed two chapters that were rarely taught: binomial heaps and sorting\nnetworks. One key idea in the sorting networks chapter, the 0-1 principle, ap-\npears in this edition within Problem 8-7 as the 0-1 sorting lemma for compare-\nexchange algorithms. The treatment of Fibonacci heaps no longer relies on\nbinomial heaps as a precursor.\nPreface\nxvii\n\u0002\nWe revised our treatment of dynamic programming and greedy algorithms. Dy-\nnamic programming now leads off with a more interesting problem, rod cutting,\nthan the assembly-line scheduling problem from the second edition. Further-\nmore, we emphasize memoization a bit more than we did in the second edition,\nand we introduce the notion of the subproblem graph as a way to understand\nthe running time of a dynamic-programming algorithm. In our opening exam-\nple of greedy algorithms, the activity-selection problem, we get to the greedy\nalgorithm more directly than we did in the second edition.\n\u0002\nThe way we delete a node from binary search trees (which includes red-black\ntrees) now guarantees that the node requested for deletion is the node that is\nactually deleted. In the ﬁrst two editions, in certain cases, some other node\nwould be deleted, with its contents moving into the node passed to the deletion\nprocedure. With our new way to delete nodes, if other components of a program",
    "parent_45332dea-7ad2-4e74-9f5e-e8b17ed89050": "actually deleted. In the ﬁrst two editions, in certain cases, some other node\nwould be deleted, with its contents moving into the node passed to the deletion\nprocedure. With our new way to delete nodes, if other components of a program\nmaintain pointers to nodes in the tree, they will not mistakenly end up with stale\npointers to nodes that have been deleted.\n\u0002\nThe material on ﬂow networks now bases ﬂows entirely on edges. This ap-\nproach is more intuitive than the net ﬂow used in the ﬁrst two editions.\n\u0002\nWith the material on matrix basics and Strassen’s algorithm moved to other\nchapters, the chapter on matrix operations is smaller than in the second edition.\n\u0002\nWe have modiﬁed our treatment of the Knuth-Morris-Pratt string-matching al-\ngorithm.\n\u0002\nWe corrected several errors. Most of these errors were posted on our Web site\nof second-edition errata, but a few were not.\n\u0002\nBased on many requests, we changed the syntax (as it were) of our pseudocode.\nWe now use “D” to indicate assignment and “==” to test for equality, just as C,\nC++, Java, and Python do. Likewise, we have eliminated the keywords do and\nthen and adopted “//” as our comment-to-end-of-line symbol. We also now use\ndot-notation to indicate object attributes. Our pseudocode remains procedural,\nrather than object-oriented. In other words, rather than running methods on\nobjects, we simply call procedures, passing objects as parameters.\n\u0002\nWe added 100 new exercises and 28 new problems. We also updated many\nbibliography entries and added several new ones.\n\u0002\nFinally, we went through the entire book and rewrote sentences, paragraphs,\nand sections to make the writing clearer and more active.\nxviii\nPreface\nWeb site\nYou can use our Web site, http://mitpress.mit.edu/algorithms/, to obtain supple-\nmentary information and to communicate with us. The Web site links to a list of\nknown errors, solutions to selected exercises and problems, and (of course) a list",
    "parent_54fde98d-0db9-42b2-b7ec-ed643a1f0c85": "xviii\nPreface\nWeb site\nYou can use our Web site, http://mitpress.mit.edu/algorithms/, to obtain supple-\nmentary information and to communicate with us. The Web site links to a list of\nknown errors, solutions to selected exercises and problems, and (of course) a list\nexplaining the corny professor jokes, as well as other content that we might add.\nThe Web site also tells you how to report errors or make suggestions.\nHow we produced this book\nLike the second edition, the third edition was produced in LATEX 2\". We used the\nTimes font with mathematics typeset using the MathTime Pro 2 fonts. We thank\nMichael Spivak from Publish or Perish, Inc., Lance Carnes from Personal TeX,\nInc., and Tim Tregubov from Dartmouth College for technical support. As in the\nprevious two editions, we compiled the index using Windex, a C program that we\nwrote, and the bibliography was produced with BIBTEX. The PDF ﬁles for this\nbook were created on a MacBook running OS 10.5.\nWe drew the illustrations for the third edition using MacDraw Pro, with some\nof the mathematical expressions in illustrations laid in with the psfrag package\nfor LATEX 2\". Unfortunately, MacDraw Pro is legacy software, having not been\nmarketed for over a decade now. Happily, we still have a couple of Macintoshes\nthat can run the Classic environment under OS 10.4, and hence they can run Mac-\nDraw Pro—mostly. Even under the Classic environment, we ﬁnd MacDraw Pro to\nbe far easier to use than any other drawing software for the types of illustrations\nthat accompany computer-science text, and it produces beautiful output.1 Who\nknows how long our pre-Intel Macs will continue to run, so if anyone from Apple\nis listening: Please create an OS X-compatible version of MacDraw Pro!\nAcknowledgments for the third edition\nWe have been working with the MIT Press for over two decades now, and what a\nterriﬁc relationship it has been! We thank Ellen Faran, Bob Prior, Ada Brunstein,\nand Mary Reilly for their help and support.",
    "parent_31481ecc-e2de-4c3d-b4a7-e0413e6d2621": "Acknowledgments for the third edition\nWe have been working with the MIT Press for over two decades now, and what a\nterriﬁc relationship it has been! We thank Ellen Faran, Bob Prior, Ada Brunstein,\nand Mary Reilly for their help and support.\nWe were geographically distributed while producing the third edition, working\nin the Dartmouth College Department of Computer Science, the MIT Computer\n1We investigated several drawing programs that run under Mac OS X, but all had signiﬁcant short-\ncomings compared with MacDraw Pro. We brieﬂy attempted to produce the illustrations for this\nbook with a different, well known drawing program. We found that it took at least ﬁve times as long\nto produce each illustration as it took with MacDraw Pro, and the resulting illustrations did not look\nas good. Hence the decision to revert to MacDraw Pro running on older Macintoshes.\nPreface\nxix\nScience and Artiﬁcial Intelligence Laboratory, and the Columbia University De-\npartment of Industrial Engineering and Operations Research. We thank our re-\nspective universities and colleagues for providing such supportive and stimulating\nenvironments.\nJulie Sussman, P.P.A., once again bailed us out as the technical copyeditor. Time\nand again, we were amazed at the errors that eluded us, but that Julie caught. She\nalso helped us improve our presentation in several places. If there is a Hall of Fame\nfor technical copyeditors, Julie is a sure-ﬁre, ﬁrst-ballot inductee. She is nothing\nshort of phenomenal. Thank you, thank you, thank you, Julie! Priya Natarajan also\nfound some errors that we were able to correct before this book went to press. Any\nerrors that remain (and undoubtedly, some do) are the responsibility of the authors\n(and probably were inserted after Julie read the material).\nThe treatment for van Emde Boas trees derives from Erik Demaine’s notes,\nwhich were in turn inﬂuenced by Michael Bender. We also incorporated ideas\nfrom Javed Aslam, Bradley Kuszmaul, and Hui Zha into this edition.",
    "parent_dcbb2096-933c-41d0-94ba-80ddc0a7dff1": "(and probably were inserted after Julie read the material).\nThe treatment for van Emde Boas trees derives from Erik Demaine’s notes,\nwhich were in turn inﬂuenced by Michael Bender. We also incorporated ideas\nfrom Javed Aslam, Bradley Kuszmaul, and Hui Zha into this edition.\nThe chapter on multithreading was based on notes originally written jointly with\nHarald Prokop. The material was inﬂuenced by several others working on the Cilk\nproject at MIT, including Bradley Kuszmaul and Matteo Frigo. The design of the\nmultithreaded pseudocode took its inspiration from the MIT Cilk extensions to C\nand by Cilk Arts’s Cilk++ extensions to C++.\nWe also thank the many readers of the ﬁrst and second editions who reported\nerrors or submitted suggestions for how to improve this book. We corrected all the\nbona ﬁde errors that were reported, and we incorporated as many suggestions as\nwe could. We rejoice that the number of such contributors has grown so great that\nwe must regret that it has become impractical to list them all.\nFinally, we thank our wives—Nicole Cormen, Wendy Leiserson, Gail Rivest,\nand Rebecca Ivry—and our children—Ricky, Will, Debby, and Katie Leiserson;\nAlex and Christopher Rivest; and Molly, Noah, and Benjamin Stein—for their love\nand support while we prepared this book. The patience and encouragement of our\nfamilies made this project possible. We affectionately dedicate this book to them.\nTHOMAS H. CORMEN\nLebanon, New Hampshire\nCHARLES E. LEISERSON\nCambridge, Massachusetts\nRONALD L. RIVEST\nCambridge, Massachusetts\nCLIFFORD STEIN\nNew York, New York\nFebruary 2009\nIntroduction to Algorithms\nThird Edition\nI\nFoundations\nIntroduction\nThis part will start you thinking about designing and analyzing algorithms. It is\nintended to be a gentle introduction to how we specify algorithms, some of the\ndesign strategies we will use throughout this book, and many of the fundamental\nideas used in algorithm analysis. Later parts of this book will build upon this base.",
    "parent_1c6093d5-4efd-4f01-be55-543c8f90a96d": "intended to be a gentle introduction to how we specify algorithms, some of the\ndesign strategies we will use throughout this book, and many of the fundamental\nideas used in algorithm analysis. Later parts of this book will build upon this base.\nChapter 1 provides an overview of algorithms and their place in modern com-\nputing systems. This chapter deﬁnes what an algorithm is and lists some examples.\nIt also makes a case that we should consider algorithms as a technology, along-\nside technologies such as fast hardware, graphical user interfaces, object-oriented\nsystems, and networks.\nIn Chapter 2, we see our ﬁrst algorithms, which solve the problem of sorting\na sequence of n numbers. They are written in a pseudocode which, although not\ndirectly translatable to any conventional programming language, conveys the struc-\nture of the algorithm clearly enough that you should be able to implement it in the\nlanguage of your choice. The sorting algorithms we examine are insertion sort,\nwhich uses an incremental approach, and merge sort, which uses a recursive tech-\nnique known as “divide-and-conquer.” Although the time each requires increases\nwith the value of n, the rate of increase differs between the two algorithms. We\ndetermine these running times in Chapter 2, and we develop a useful notation to\nexpress them.\nChapter 3 precisely deﬁnes this notation, which we call asymptotic notation. It\nstarts by deﬁning several asymptotic notations, which we use for bounding algo-\nrithm running times from above and/or below. The rest of Chapter 3 is primarily\na presentation of mathematical notation, more to ensure that your use of notation\nmatches that in this book than to teach you new mathematical concepts.\n4\nPart I\nFoundations\nChapter 4 delves further into the divide-and-conquer method introduced in\nChapter 2. It provides additional examples of divide-and-conquer algorithms, in-\ncluding Strassen’s surprising method for multiplying two square matrices. Chap-",
    "parent_d9b22984-c206-4e26-8fc4-6a57cf4867f0": "4\nPart I\nFoundations\nChapter 4 delves further into the divide-and-conquer method introduced in\nChapter 2. It provides additional examples of divide-and-conquer algorithms, in-\ncluding Strassen’s surprising method for multiplying two square matrices. Chap-\nter 4 contains methods for solving recurrences, which are useful for describing\nthe running times of recursive algorithms. One powerful technique is the “mas-\nter method,” which we often use to solve recurrences that arise from divide-and-\nconquer algorithms. Although much of Chapter 4 is devoted to proving the cor-\nrectness of the master method, you may skip this proof yet still employ the master\nmethod.\nChapter 5 introduces probabilistic analysis and randomized algorithms. We typ-\nically use probabilistic analysis to determine the running time of an algorithm in\ncases in which, due to the presence of an inherent probability distribution, the\nrunning time may differ on different inputs of the same size. In some cases, we\nassume that the inputs conform to a known probability distribution, so that we are\naveraging the running time over all possible inputs. In other cases, the probability\ndistribution comes not from the inputs but from random choices made during the\ncourse of the algorithm. An algorithm whose behavior is determined not only by its\ninput but by the values produced by a random-number generator is a randomized\nalgorithm. We can use randomized algorithms to enforce a probability distribution\non the inputs—thereby ensuring that no particular input always causes poor perfor-\nmance—or even to bound the error rate of algorithms that are allowed to produce\nincorrect results on a limited basis.\nAppendices A–D contain other mathematical material that you will ﬁnd helpful\nas you read this book. You are likely to have seen much of the material in the\nappendix chapters before having read this book (although the speciﬁc deﬁnitions\nand notational conventions we use may differ in some cases from what you have",
    "parent_a99b36f3-973a-4bcc-84b5-bf710965c55f": "as you read this book. You are likely to have seen much of the material in the\nappendix chapters before having read this book (although the speciﬁc deﬁnitions\nand notational conventions we use may differ in some cases from what you have\nseen in the past), and so you should think of the Appendices as reference material.\nOn the other hand, you probably have not already seen most of the material in\nPart I. All the chapters in Part I and the Appendices are written with a tutorial\nﬂavor.\n1\nThe Role of Algorithms in Computing\nWhat are algorithms? Why is the study of algorithms worthwhile? What is the role\nof algorithms relative to other technologies used in computers? In this chapter, we\nwill answer these questions.\n1.1\nAlgorithms\nInformally, an algorithm is any well-deﬁned computational procedure that takes\nsome value, or set of values, as input and produces some value, or set of values, as\noutput. An algorithm is thus a sequence of computational steps that transform the\ninput into the output.\nWe can also view an algorithm as a tool for solving a well-speciﬁed computa-\ntional problem. The statement of the problem speciﬁes in general terms the desired\ninput/output relationship. The algorithm describes a speciﬁc computational proce-\ndure for achieving that input/output relationship.\nFor example, we might need to sort a sequence of numbers into nondecreasing\norder. This problem arises frequently in practice and provides fertile ground for\nintroducing many standard design techniques and analysis tools. Here is how we\nformally deﬁne the sorting problem:\nInput: A sequence of n numbers ha1; a2; : : : ; ani.\nOutput: A permutation (reordering) ha0\n1; a0\n2; : : : ; a0\nni of the input sequence such\nthat a0\n1 \u0002 a0\n2 \u0002 \u0003 \u0003 \u0003 \u0002 a0\nn.\nFor example, given the input sequence h31; 41; 59; 26; 41; 58i, a sorting algorithm\nreturns as output the sequence h26; 31; 41; 41; 58; 59i. Such an input sequence is\ncalled an instance of the sorting problem. In general, an instance of a problem",
    "parent_0ce99045-c0fa-404c-bc3f-978c40c0674e": "that a0\n1 \u0002 a0\n2 \u0002 \u0003 \u0003 \u0003 \u0002 a0\nn.\nFor example, given the input sequence h31; 41; 59; 26; 41; 58i, a sorting algorithm\nreturns as output the sequence h26; 31; 41; 41; 58; 59i. Such an input sequence is\ncalled an instance of the sorting problem. In general, an instance of a problem\nconsists of the input (satisfying whatever constraints are imposed in the problem\nstatement) needed to compute a solution to the problem.\n6\nChapter 1\nThe Role of Algorithms in Computing\nBecause many programs use it as an intermediate step, sorting is a fundamental\noperation in computer science. As a result, we have a large number of good sorting\nalgorithms at our disposal. Which algorithm is best for a given application depends\non—among other factors—the number of items to be sorted, the extent to which\nthe items are already somewhat sorted, possible restrictions on the item values,\nthe architecture of the computer, and the kind of storage devices to be used: main\nmemory, disks, or even tapes.\nAn algorithm is said to be correct if, for every input instance, it halts with the\ncorrect output. We say that a correct algorithm solves the given computational\nproblem. An incorrect algorithm might not halt at all on some input instances, or it\nmight halt with an incorrect answer. Contrary to what you might expect, incorrect\nalgorithms can sometimes be useful, if we can control their error rate. We shall see\nan example of an algorithm with a controllable error rate in Chapter 31 when we\nstudy algorithms for ﬁnding large prime numbers. Ordinarily, however, we shall\nbe concerned only with correct algorithms.\nAn algorithm can be speciﬁed in English, as a computer program, or even as\na hardware design. The only requirement is that the speciﬁcation must provide a\nprecise description of the computational procedure to be followed.\nWhat kinds of problems are solved by algorithms?\nSorting is by no means the only computational problem for which algorithms have",
    "parent_46d9a305-9b62-4d7e-9129-daa943e0cef8": "a hardware design. The only requirement is that the speciﬁcation must provide a\nprecise description of the computational procedure to be followed.\nWhat kinds of problems are solved by algorithms?\nSorting is by no means the only computational problem for which algorithms have\nbeen developed. (You probably suspected as much when you saw the size of this\nbook.) Practical applications of algorithms are ubiquitous and include the follow-\ning examples:\n\u0002\nThe Human Genome Project has made great progress toward the goals of iden-\ntifying all the 100,000 genes in human DNA, determining the sequences of the\n3 billion chemical base pairs that make up human DNA, storing this informa-\ntion in databases, and developing tools for data analysis. Each of these steps\nrequires sophisticated algorithms. Although the solutions to the various prob-\nlems involved are beyond the scope of this book, many methods to solve these\nbiological problems use ideas from several of the chapters in this book, thereby\nenabling scientists to accomplish tasks while using resources efﬁciently. The\nsavings are in time, both human and machine, and in money, as more informa-\ntion can be extracted from laboratory techniques.\n\u0002\nThe Internet enables people all around the world to quickly access and retrieve\nlarge amounts of information. With the aid of clever algorithms, sites on the\nInternet are able to manage and manipulate this large volume of data. Examples\nof problems that make essential use of algorithms include ﬁnding good routes\non which the data will travel (techniques for solving such problems appear in\n1.1\nAlgorithms\n7\nChapter 24), and using a search engine to quickly ﬁnd pages on which particular\ninformation resides (related techniques are in Chapters 11 and 32).\n\u0002\nElectronic commerce enables goods and services to be negotiated and ex-\nchanged electronically, and it depends on the privacy of personal informa-\ntion such as credit card numbers, passwords, and bank statements. The core",
    "parent_0cdcb104-676c-4fba-86a4-76ea1fed3a69": "information resides (related techniques are in Chapters 11 and 32).\n\u0002\nElectronic commerce enables goods and services to be negotiated and ex-\nchanged electronically, and it depends on the privacy of personal informa-\ntion such as credit card numbers, passwords, and bank statements. The core\ntechnologies used in electronic commerce include public-key cryptography and\ndigital signatures (covered in Chapter 31), which are based on numerical algo-\nrithms and number theory.\n\u0002\nManufacturing and other commercial enterprises often need to allocate scarce\nresources in the most beneﬁcial way. An oil company may wish to know where\nto place its wells in order to maximize its expected proﬁt. A political candidate\nmay want to determine where to spend money buying campaign advertising in\norder to maximize the chances of winning an election. An airline may wish\nto assign crews to ﬂights in the least expensive way possible, making sure that\neach ﬂight is covered and that government regulations regarding crew schedul-\ning are met. An Internet service provider may wish to determine where to place\nadditional resources in order to serve its customers more effectively. All of\nthese are examples of problems that can be solved using linear programming,\nwhich we shall study in Chapter 29.\nAlthough some of the details of these examples are beyond the scope of this\nbook, we do give underlying techniques that apply to these problems and problem\nareas. We also show how to solve many speciﬁc problems, including the following:\n\u0002\nWe are given a road map on which the distance between each pair of adjacent\nintersections is marked, and we wish to determine the shortest route from one\nintersection to another. The number of possible routes can be huge, even if we\ndisallow routes that cross over themselves. How do we choose which of all\npossible routes is the shortest? Here, we model the road map (which is itself\na model of the actual roads) as a graph (which we will meet in Part VI and",
    "parent_119c4b14-7397-41a9-bb9e-41ccdc19d4fd": "disallow routes that cross over themselves. How do we choose which of all\npossible routes is the shortest? Here, we model the road map (which is itself\na model of the actual roads) as a graph (which we will meet in Part VI and\nAppendix B), and we wish to ﬁnd the shortest path from one vertex to another\nin the graph. We shall see how to solve this problem efﬁciently in Chapter 24.\n\u0002\nWe are given two ordered sequences of symbols, X D hx1; x2; : : : ; xmi and\nY D hy1; y2; : : : ; yni, and we wish to ﬁnd a longest common subsequence of\nX and Y . A subsequence of X is just X with some (or possibly all or none) of\nits elements removed. For example, one subsequence of hA; B; C; D; E; F; Gi\nwould be hB; C; E; Gi. The length of a longest common subsequence of X\nand Y gives one measure of how similar these two sequences are. For example,\nif the two sequences are base pairs in DNA strands, then we might consider\nthem similar if they have a long common subsequence. If X has m symbols\nand Y has n symbols, then X and Y have 2m and 2n possible subsequences,\n8\nChapter 1\nThe Role of Algorithms in Computing\nrespectively. Selecting all possible subsequences of X and Y and matching\nthem up could take a prohibitively long time unless m and n are very small.\nWe shall see in Chapter 15 how to use a general technique known as dynamic\nprogramming to solve this problem much more efﬁciently.\n\u0002\nWe are given a mechanical design in terms of a library of parts, where each part\nmay include instances of other parts, and we need to list the parts in order so\nthat each part appears before any part that uses it. If the design comprises n\nparts, then there are nŠ possible orders, where nŠ denotes the factorial function.\nBecause the factorial function grows faster than even an exponential function,\nwe cannot feasibly generate each possible order and then verify that, within\nthat order, each part appears before the parts using it (unless we have only a",
    "parent_a5c43a3f-7424-469d-a14b-e1d729d3ad98": "Because the factorial function grows faster than even an exponential function,\nwe cannot feasibly generate each possible order and then verify that, within\nthat order, each part appears before the parts using it (unless we have only a\nfew parts). This problem is an instance of topological sorting, and we shall see\nin Chapter 22 how to solve this problem efﬁciently.\n\u0002\nWe are given n points in the plane, and we wish to ﬁnd the convex hull of\nthese points. The convex hull is the smallest convex polygon containing the\npoints. Intuitively, we can think of each point as being represented by a nail\nsticking out from a board. The convex hull would be represented by a tight\nrubber band that surrounds all the nails. Each nail around which the rubber\nband makes a turn is a vertex of the convex hull. (See Figure 33.6 on page 1029\nfor an example.) Any of the 2n subsets of the points might be the vertices\nof the convex hull. Knowing which points are vertices of the convex hull is\nnot quite enough, either, since we also need to know the order in which they\nappear. There are many choices, therefore, for the vertices of the convex hull.\nChapter 33 gives two good methods for ﬁnding the convex hull.\nThese lists are far from exhaustive (as you again have probably surmised from\nthis book’s heft), but exhibit two characteristics that are common to many interest-\ning algorithmic problems:\n1. They have many candidate solutions, the overwhelming majority of which do\nnot solve the problem at hand. Finding one that does, or one that is “best,” can\npresent quite a challenge.\n2. They have practical applications. Of the problems in the above list, ﬁnding the\nshortest path provides the easiest examples. A transportation ﬁrm, such as a\ntrucking or railroad company, has a ﬁnancial interest in ﬁnding shortest paths\nthrough a road or rail network because taking shorter paths results in lower\nlabor and fuel costs. Or a routing node on the Internet may need to ﬁnd the",
    "parent_ca0177fa-1757-4b28-8172-af45e9af082e": "trucking or railroad company, has a ﬁnancial interest in ﬁnding shortest paths\nthrough a road or rail network because taking shorter paths results in lower\nlabor and fuel costs. Or a routing node on the Internet may need to ﬁnd the\nshortest path through the network in order to route a message quickly. Or a\nperson wishing to drive from New York to Boston may want to ﬁnd driving\ndirections from an appropriate Web site, or she may use her GPS while driving.\n1.1\nAlgorithms\n9\nNot every problem solved by algorithms has an easily identiﬁed set of candidate\nsolutions. For example, suppose we are given a set of numerical values represent-\ning samples of a signal, and we want to compute the discrete Fourier transform of\nthese samples. The discrete Fourier transform converts the time domain to the fre-\nquency domain, producing a set of numerical coefﬁcients, so that we can determine\nthe strength of various frequencies in the sampled signal. In addition to lying at\nthe heart of signal processing, discrete Fourier transforms have applications in data\ncompression and multiplying large polynomials and integers. Chapter 30 gives\nan efﬁcient algorithm, the fast Fourier transform (commonly called the FFT), for\nthis problem, and the chapter also sketches out the design of a hardware circuit to\ncompute the FFT.\nData structures\nThis book also contains several data structures. A data structure is a way to store\nand organize data in order to facilitate access and modiﬁcations. No single data\nstructure works well for all purposes, and so it is important to know the strengths\nand limitations of several of them.\nTechnique\nAlthough you can use this book as a “cookbook” for algorithms, you may someday\nencounter a problem for which you cannot readily ﬁnd a published algorithm (many\nof the exercises and problems in this book, for example). This book will teach you\ntechniques of algorithm design and analysis so that you can develop algorithms on",
    "parent_70a8f9ee-df4a-4dd6-a6bd-18455f7e93b1": "encounter a problem for which you cannot readily ﬁnd a published algorithm (many\nof the exercises and problems in this book, for example). This book will teach you\ntechniques of algorithm design and analysis so that you can develop algorithms on\nyour own, show that they give the correct answer, and understand their efﬁciency.\nDifferent chapters address different aspects of algorithmic problem solving. Some\nchapters address speciﬁc problems, such as ﬁnding medians and order statistics in\nChapter 9, computing minimum spanning trees in Chapter 23, and determining a\nmaximum ﬂow in a network in Chapter 26. Other chapters address techniques,\nsuch as divide-and-conquer in Chapter 4, dynamic programming in Chapter 15,\nand amortized analysis in Chapter 17.\nHard problems\nMost of this book is about efﬁcient algorithms. Our usual measure of efﬁciency\nis speed, i.e., how long an algorithm takes to produce its result. There are some\nproblems, however, for which no efﬁcient solution is known. Chapter 34 studies\nan interesting subset of these problems, which are known as NP-complete.\nWhy are NP-complete problems interesting? First, although no efﬁcient algo-\nrithm for an NP-complete problem has ever been found, nobody has ever proven\n10\nChapter 1\nThe Role of Algorithms in Computing\nthat an efﬁcient algorithm for one cannot exist. In other words, no one knows\nwhether or not efﬁcient algorithms exist for NP-complete problems. Second, the\nset of NP-complete problems has the remarkable property that if an efﬁcient algo-\nrithm exists for any one of them, then efﬁcient algorithms exist for all of them. This\nrelationship among the NP-complete problems makes the lack of efﬁcient solutions\nall the more tantalizing. Third, several NP-complete problems are similar, but not\nidentical, to problems for which we do know of efﬁcient algorithms. Computer\nscientists are intrigued by how a small change to the problem statement can cause\na big change to the efﬁciency of the best known algorithm.",
    "parent_76448035-0204-4275-a9fd-2c0abf02eb45": "identical, to problems for which we do know of efﬁcient algorithms. Computer\nscientists are intrigued by how a small change to the problem statement can cause\na big change to the efﬁciency of the best known algorithm.\nYou should know about NP-complete problems because some of them arise sur-\nprisingly often in real applications. If you are called upon to produce an efﬁcient\nalgorithm for an NP-complete problem, you are likely to spend a lot of time in a\nfruitless search. If you can show that the problem is NP-complete, you can instead\nspend your time developing an efﬁcient algorithm that gives a good, but not the\nbest possible, solution.\nAs a concrete example, consider a delivery company with a central depot. Each\nday, it loads up each delivery truck at the depot and sends it around to deliver goods\nto several addresses. At the end of the day, each truck must end up back at the depot\nso that it is ready to be loaded for the next day. To reduce costs, the company wants\nto select an order of delivery stops that yields the lowest overall distance traveled\nby each truck. This problem is the well-known “traveling-salesman problem,” and\nit is NP-complete. It has no known efﬁcient algorithm. Under certain assumptions,\nhowever, we know of efﬁcient algorithms that give an overall distance which is\nnot too far above the smallest possible. Chapter 35 discusses such “approximation\nalgorithms.”\nParallelism\nFor many years, we could count on processor clock speeds increasing at a steady\nrate. Physical limitations present a fundamental roadblock to ever-increasing clock\nspeeds, however: because power density increases superlinearly with clock speed,\nchips run the risk of melting once their clock speeds become high enough. In order\nto perform more computations per second, therefore, chips are being designed to\ncontain not just one but several processing “cores.” We can liken these multicore\ncomputers to several sequential computers on a single chip; in other words, they are",
    "parent_201d8844-4459-463a-8115-a9676411fc38": "to perform more computations per second, therefore, chips are being designed to\ncontain not just one but several processing “cores.” We can liken these multicore\ncomputers to several sequential computers on a single chip; in other words, they are\na type of “parallel computer.” In order to elicit the best performance from multicore\ncomputers, we need to design algorithms with parallelism in mind. Chapter 27\npresents a model for “multithreaded” algorithms, which take advantage of multiple\ncores. This model has advantages from a theoretical standpoint, and it forms the\nbasis of several successful computer programs, including a championship chess\nprogram.\n1.2\nAlgorithms as a technology\n11\nExercises\n1.1-1\nGive a real-world example that requires sorting or a real-world example that re-\nquires computing a convex hull.\n1.1-2\nOther than speed, what other measures of efﬁciency might one use in a real-world\nsetting?\n1.1-3\nSelect a data structure that you have seen previously, and discuss its strengths and\nlimitations.\n1.1-4\nHow are the shortest-path and traveling-salesman problems given above similar?\nHow are they different?\n1.1-5\nCome up with a real-world problem in which only the best solution will do. Then\ncome up with one in which a solution that is “approximately” the best is good\nenough.\n1.2\nAlgorithms as a technology\nSuppose computers were inﬁnitely fast and computer memory was free. Would\nyou have any reason to study algorithms? The answer is yes, if for no other reason\nthan that you would still like to demonstrate that your solution method terminates\nand does so with the correct answer.\nIf computers were inﬁnitely fast, any correct method for solving a problem\nwould do. You would probably want your implementation to be within the bounds\nof good software engineering practice (for example, your implementation should\nbe well designed and documented), but you would most often use whichever\nmethod was the easiest to implement.",
    "parent_f45c87bf-6c49-4ac2-9d02-a670ae10ff7f": "would do. You would probably want your implementation to be within the bounds\nof good software engineering practice (for example, your implementation should\nbe well designed and documented), but you would most often use whichever\nmethod was the easiest to implement.\nOf course, computers may be fast, but they are not inﬁnitely fast. And memory\nmay be inexpensive, but it is not free. Computing time is therefore a bounded\nresource, and so is space in memory. You should use these resources wisely, and\nalgorithms that are efﬁcient in terms of time or space will help you do so.\n12\nChapter 1\nThe Role of Algorithms in Computing\nEfﬁciency\nDifferent algorithms devised to solve the same problem often differ dramatically in\ntheir efﬁciency. These differences can be much more signiﬁcant than differences\ndue to hardware and software.\nAs an example, in Chapter 2, we will see two algorithms for sorting. The ﬁrst,\nknown as insertion sort, takes time roughly equal to c1n2 to sort n items, where c1\nis a constant that does not depend on n. That is, it takes time roughly proportional\nto n2. The second, merge sort, takes time roughly equal to c2n lg n, where lg n\nstands for log2 n and c2 is another constant that also does not depend on n. Inser-\ntion sort typically has a smaller constant factor than merge sort, so that c1 < c2.\nWe shall see that the constant factors can have far less of an impact on the running\ntime than the dependence on the input size n. Let’s write insertion sort’s running\ntime as c1n \u0003 n and merge sort’s running time as c2n \u0003 lg n. Then we see that where\ninsertion sort has a factor of n in its running time, merge sort has a factor of lg n,\nwhich is much smaller. (For example, when n D 1000, lg n is approximately 10,\nand when n equals one million, lg n is approximately only 20.) Although insertion\nsort usually runs faster than merge sort for small input sizes, once the input size n\nbecomes large enough, merge sort’s advantage of lg n vs. n will more than com-",
    "parent_756b2e67-b9e8-45d1-b002-dea2c015b79a": "and when n equals one million, lg n is approximately only 20.) Although insertion\nsort usually runs faster than merge sort for small input sizes, once the input size n\nbecomes large enough, merge sort’s advantage of lg n vs. n will more than com-\npensate for the difference in constant factors. No matter how much smaller c1 is\nthan c2, there will always be a crossover point beyond which merge sort is faster.\nFor a concrete example, let us pit a faster computer (computer A) running inser-\ntion sort against a slower computer (computer B) running merge sort. They each\nmust sort an array of 10 million numbers. (Although 10 million numbers might\nseem like a lot, if the numbers are eight-byte integers, then the input occupies\nabout 80 megabytes, which ﬁts in the memory of even an inexpensive laptop com-\nputer many times over.) Suppose that computer A executes 10 billion instructions\nper second (faster than any single sequential computer at the time of this writing)\nand computer B executes only 10 million instructions per second, so that com-\nputer A is 1000 times faster than computer B in raw computing power. To make\nthe difference even more dramatic, suppose that the world’s craftiest programmer\ncodes insertion sort in machine language for computer A, and the resulting code\nrequires 2n2 instructions to sort n numbers. Suppose further that just an average\nprogrammer implements merge sort, using a high-level language with an inefﬁcient\ncompiler, with the resulting code taking 50n lg n instructions. To sort 10 million\nnumbers, computer A takes\n2 \u0003 .107/2 instructions\n1010 instructions/second D 20,000 seconds (more than 5.5 hours) ;\nwhile computer B takes\n1.2\nAlgorithms as a technology\n13\n50 \u0003 107 lg 107 instructions\n107 instructions/second\n\u0004 1163 seconds (less than 20 minutes) :\nBy using an algorithm whose running time grows more slowly, even with a poor\ncompiler, computer B runs more than 17 times faster than computer A! The advan-",
    "parent_38279666-a200-40cb-bc53-63f0feb63cde": "1.2\nAlgorithms as a technology\n13\n50 \u0003 107 lg 107 instructions\n107 instructions/second\n\u0004 1163 seconds (less than 20 minutes) :\nBy using an algorithm whose running time grows more slowly, even with a poor\ncompiler, computer B runs more than 17 times faster than computer A! The advan-\ntage of merge sort is even more pronounced when we sort 100 million numbers:\nwhere insertion sort takes more than 23 days, merge sort takes under four hours.\nIn general, as the problem size increases, so does the relative advantage of merge\nsort.\nAlgorithms and other technologies\nThe example above shows that we should consider algorithms, like computer hard-\nware, as a technology. Total system performance depends on choosing efﬁcient\nalgorithms as much as on choosing fast hardware. Just as rapid advances are being\nmade in other computer technologies, they are being made in algorithms as well.\nYou might wonder whether algorithms are truly that important on contemporary\ncomputers in light of other advanced technologies, such as\n\u0002\nadvanced computer architectures and fabrication technologies,\n\u0002\neasy-to-use, intuitive, graphical user interfaces (GUIs),\n\u0002\nobject-oriented systems,\n\u0002\nintegrated Web technologies, and\n\u0002\nfast networking, both wired and wireless.\nThe answer is yes. Although some applications do not explicitly require algorith-\nmic content at the application level (such as some simple, Web-based applications),\nmany do. For example, consider a Web-based service that determines how to travel\nfrom one location to another. Its implementation would rely on fast hardware, a\ngraphical user interface, wide-area networking, and also possibly on object ori-\nentation. However, it would also require algorithms for certain operations, such\nas ﬁnding routes (probably using a shortest-path algorithm), rendering maps, and\ninterpolating addresses.\nMoreover, even an application that does not require algorithmic content at the",
    "parent_8719b746-a09b-4586-a0af-bd3641427adf": "entation. However, it would also require algorithms for certain operations, such\nas ﬁnding routes (probably using a shortest-path algorithm), rendering maps, and\ninterpolating addresses.\nMoreover, even an application that does not require algorithmic content at the\napplication level relies heavily upon algorithms. Does the application rely on fast\nhardware? The hardware design used algorithms. Does the application rely on\ngraphical user interfaces? The design of any GUI relies on algorithms. Does the\napplication rely on networking? Routing in networks relies heavily on algorithms.\nWas the application written in a language other than machine code? Then it was\nprocessed by a compiler, interpreter, or assembler, all of which make extensive use\n14\nChapter 1\nThe Role of Algorithms in Computing\nof algorithms. Algorithms are at the core of most technologies used in contempo-\nrary computers.\nFurthermore, with the ever-increasing capacities of computers, we use them to\nsolve larger problems than ever before. As we saw in the above comparison be-\ntween insertion sort and merge sort, it is at larger problem sizes that the differences\nin efﬁciency between algorithms become particularly prominent.\nHaving a solid base of algorithmic knowledge and technique is one characteristic\nthat separates the truly skilled programmers from the novices. With modern com-\nputing technology, you can accomplish some tasks without knowing much about\nalgorithms, but with a good background in algorithms, you can do much, much\nmore.\nExercises\n1.2-1\nGive an example of an application that requires algorithmic content at the applica-\ntion level, and discuss the function of the algorithms involved.\n1.2-2\nSuppose we are comparing implementations of insertion sort and merge sort on the\nsame machine. For inputs of size n, insertion sort runs in 8n2 steps, while merge\nsort runs in 64n lg n steps. For which values of n does insertion sort beat merge\nsort?\n1.2-3",
    "parent_38a1071e-13ef-44ef-9581-afa1b50c7b6e": "1.2-2\nSuppose we are comparing implementations of insertion sort and merge sort on the\nsame machine. For inputs of size n, insertion sort runs in 8n2 steps, while merge\nsort runs in 64n lg n steps. For which values of n does insertion sort beat merge\nsort?\n1.2-3\nWhat is the smallest value of n such that an algorithm whose running time is 100n2\nruns faster than an algorithm whose running time is 2n on the same machine?\nProblems\n1-1\nComparison of running times\nFor each function f .n/ and time t in the following table, determine the largest\nsize n of a problem that can be solved in time t, assuming that the algorithm to\nsolve the problem takes f .n/ microseconds.\nNotes for Chapter 1\n15\n1\n1\n1\n1\n1\n1\n1\nsecond\nminute\nhour\nday\nmonth\nyear\ncentury\nlg n\npn\nn\nn lg n\nn2\nn3\n2n\nnŠ\nChapter notes\nThere are many excellent texts on the general topic of algorithms, including those\nby Aho, Hopcroft, and Ullman [5, 6]; Baase and Van Gelder [28]; Brassard and\nBratley [54]; Dasgupta, Papadimitriou, and Vazirani [82]; Goodrich and Tamassia\n[148]; Hofri [175]; Horowitz, Sahni, and Rajasekaran [181]; Johnsonbaugh and\nSchaefer [193]; Kingston [205]; Kleinberg and Tardos [208]; Knuth [209, 210,\n211]; Kozen [220]; Levitin [235]; Manber [242]; Mehlhorn [249, 250, 251]; Pur-\ndom and Brown [287]; Reingold, Nievergelt, and Deo [293]; Sedgewick [306];\nSedgewick and Flajolet [307]; Skiena [318]; and Wilf [356]. Some of the more\npractical aspects of algorithm design are discussed by Bentley [42, 43] and Gonnet\n[145]. Surveys of the ﬁeld of algorithms can also be found in the Handbook of The-\noretical Computer Science, Volume A [342] and the CRC Algorithms and Theory of\nComputation Handbook [25]. Overviews of the algorithms used in computational\nbiology can be found in textbooks by Gusﬁeld [156], Pevzner [275], Setubal and\nMeidanis [310], and Waterman [350].\n2\nGetting Started\nThis chapter will familiarize you with the framework we shall use throughout the",
    "parent_04d43a9d-6ee0-4b15-a385-f4c0df9ae6a4": "Computation Handbook [25]. Overviews of the algorithms used in computational\nbiology can be found in textbooks by Gusﬁeld [156], Pevzner [275], Setubal and\nMeidanis [310], and Waterman [350].\n2\nGetting Started\nThis chapter will familiarize you with the framework we shall use throughout the\nbook to think about the design and analysis of algorithms. It is self-contained, but\nit does include several references to material that we introduce in Chapters 3 and 4.\n(It also contains several summations, which Appendix A shows how to solve.)\nWe begin by examining the insertion sort algorithm to solve the sorting problem\nintroduced in Chapter 1. We deﬁne a “pseudocode” that should be familiar to you if\nyou have done computer programming, and we use it to show how we shall specify\nour algorithms. Having speciﬁed the insertion sort algorithm, we then argue that it\ncorrectly sorts, and we analyze its running time. The analysis introduces a notation\nthat focuses on how that time increases with the number of items to be sorted.\nFollowing our discussion of insertion sort, we introduce the divide-and-conquer\napproach to the design of algorithms and use it to develop an algorithm called\nmerge sort. We end with an analysis of merge sort’s running time.\n2.1\nInsertion sort\nOur ﬁrst algorithm, insertion sort, solves the sorting problem introduced in Chap-\nter 1:\nInput: A sequence of n numbers ha1; a2; : : : ; ani.\nOutput: A permutation (reordering) ha0\n1; a0\n2; : : : ; a0\nni of the input sequence such\nthat a0\n1 \u0002 a0\n2 \u0002 \u0003 \u0003 \u0003 \u0002 a0\nn.\nThe numbers that we wish to sort are also known as the keys. Although conceptu-\nally we are sorting a sequence, the input comes to us in the form of an array with n\nelements.\nIn this book, we shall typically describe algorithms as programs written in a\npseudocode that is similar in many respects to C, C++, Java, Python, or Pascal. If\nyou have been introduced to any of these languages, you should have little trouble\n2.1\nInsertion sort\n17\n2♣♣\n♣\n2♣\n4♣♣♣\n♣♣\n4♣",
    "parent_5264809b-bbb0-428b-b48d-ae8e26a2ddef": "elements.\nIn this book, we shall typically describe algorithms as programs written in a\npseudocode that is similar in many respects to C, C++, Java, Python, or Pascal. If\nyou have been introduced to any of these languages, you should have little trouble\n2.1\nInsertion sort\n17\n2♣♣\n♣\n2♣\n4♣♣♣\n♣♣\n4♣\n5♣♣♣\n♣♣\n5♣\n♣\n7♣♣\n♣♣\n♣♣\n♣♣\n7♣\n10\n♣♣\n♣♣\n♣♣\n♣\n♣♣\n♣♣\n10\n♣\nFigure 2.1\nSorting a hand of cards using insertion sort.\nreading our algorithms. What separates pseudocode from “real” code is that in\npseudocode, we employ whatever expressive method is most clear and concise to\nspecify a given algorithm. Sometimes, the clearest method is English, so do not\nbe surprised if you come across an English phrase or sentence embedded within\na section of “real” code. Another difference between pseudocode and real code\nis that pseudocode is not typically concerned with issues of software engineering.\nIssues of data abstraction, modularity, and error handling are often ignored in order\nto convey the essence of the algorithm more concisely.\nWe start with insertion sort, which is an efﬁcient algorithm for sorting a small\nnumber of elements. Insertion sort works the way many people sort a hand of\nplaying cards. We start with an empty left hand and the cards face down on the\ntable. We then remove one card at a time from the table and insert it into the\ncorrect position in the left hand. To ﬁnd the correct position for a card, we compare\nit with each of the cards already in the hand, from right to left, as illustrated in\nFigure 2.1. At all times, the cards held in the left hand are sorted, and these cards\nwere originally the top cards of the pile on the table.\nWe present our pseudocode for insertion sort as a procedure called INSERTION-\nSORT, which takes as a parameter an array AŒ1 : : n\u0002 containing a sequence of\nlength n that is to be sorted. (In the code, the number n of elements in A is denoted\nby A:length.) The algorithm sorts the input numbers in place: it rearranges the",
    "parent_9b920fdd-4607-4670-9201-72e58113e51f": "SORT, which takes as a parameter an array AŒ1 : : n\u0002 containing a sequence of\nlength n that is to be sorted. (In the code, the number n of elements in A is denoted\nby A:length.) The algorithm sorts the input numbers in place: it rearranges the\nnumbers within the array A, with at most a constant number of them stored outside\nthe array at any time. The input array A contains the sorted output sequence when\nthe INSERTION-SORT procedure is ﬁnished.\n18\nChapter 2\nGetting Started\n1\n2\n3\n4\n5\n6\n5\n2\n4\n6\n1\n3\n(a)\n1\n2\n3\n4\n5\n6\n2\n5\n4\n6\n1\n3\n(b)\n1\n2\n3\n4\n5\n6\n2\n4\n5\n6\n1\n3\n(c)\n1\n2\n3\n4\n5\n6\n2\n4\n5\n6\n1\n3\n(d)\n1\n2\n3\n4\n5\n6\n2\n4\n5\n6\n1\n3\n(e)\n1\n2\n3\n4\n5\n6\n2\n4\n5\n6\n1\n3\n(f)\nFigure 2.2\nThe operation of INSERTION-SORT on the array A D h5; 2; 4; 6; 1; 3i. Array indices\nappear above the rectangles, and values stored in the array positions appear within the rectangles.\n(a)–(e) The iterations of the for loop of lines 1–8. In each iteration, the black rectangle holds the\nkey taken from AŒj\u0002, which is compared with the values in shaded rectangles to its left in the test of\nline 5. Shaded arrows show array values moved one position to the right in line 6, and black arrows\nindicate where the key moves to in line 8. (f) The ﬁnal sorted array.\nINSERTION-SORT.A/\n1\nfor j D 2 to A:length\n2\nkey D AŒj \u0002\n3\n// Insert AŒj \u0002 into the sorted sequence AŒ1 : : j \u0005 1\u0002.\n4\ni D j \u0005 1\n5\nwhile i > 0 and AŒi\u0002 > key\n6\nAŒi C 1\u0002 D AŒi\u0002\n7\ni D i \u0005 1\n8\nAŒi C 1\u0002 D key\nLoop invariants and the correctness of insertion sort\nFigure 2.2 shows how this algorithm works for A D h5; 2; 4; 6; 1; 3i. The in-\ndex j indicates the “current card” being inserted into the hand. At the beginning\nof each iteration of the for loop, which is indexed by j , the subarray consisting\nof elements AŒ1 : : j \u0005 1\u0002 constitutes the currently sorted hand, and the remaining\nsubarray AŒj C 1 : : n\u0002 corresponds to the pile of cards still on the table. In fact,\nelements AŒ1 : : j \u0005 1\u0002 are the elements originally in positions 1 through j \u0005 1, but",
    "parent_f8c4ea54-1de4-4b07-9207-22d26d84cbf1": "of elements AŒ1 : : j \u0005 1\u0002 constitutes the currently sorted hand, and the remaining\nsubarray AŒj C 1 : : n\u0002 corresponds to the pile of cards still on the table. In fact,\nelements AŒ1 : : j \u0005 1\u0002 are the elements originally in positions 1 through j \u0005 1, but\nnow in sorted order. We state these properties of AŒ1 : : j \u0005 1\u0002 formally as a loop\ninvariant:\nAt the start of each iteration of the for loop of lines 1–8, the subarray\nAŒ1 : : j \u00051\u0002 consists of the elements originally in AŒ1 : : j \u00051\u0002, but in sorted\norder.\nWe use loop invariants to help us understand why an algorithm is correct. We\nmust show three things about a loop invariant:\n2.1\nInsertion sort\n19\nInitialization: It is true prior to the ﬁrst iteration of the loop.\nMaintenance: If it is true before an iteration of the loop, it remains true before the\nnext iteration.\nTermination: When the loop terminates, the invariant gives us a useful property\nthat helps show that the algorithm is correct.\nWhen the ﬁrst two properties hold, the loop invariant is true prior to every iteration\nof the loop. (Of course, we are free to use established facts other than the loop\ninvariant itself to prove that the loop invariant remains true before each iteration.)\nNote the similarity to mathematical induction, where to prove that a property holds,\nyou prove a base case and an inductive step. Here, showing that the invariant holds\nbefore the ﬁrst iteration corresponds to the base case, and showing that the invariant\nholds from iteration to iteration corresponds to the inductive step.\nThe third property is perhaps the most important one, since we are using the loop\ninvariant to show correctness. Typically, we use the loop invariant along with the\ncondition that caused the loop to terminate. The termination property differs from\nhow we usually use mathematical induction, in which we apply the inductive step\ninﬁnitely; here, we stop the “induction” when the loop terminates.\nLet us see how these properties hold for insertion sort.",
    "parent_fcbcacc8-f384-460b-9b4a-d043cc9744ec": "condition that caused the loop to terminate. The termination property differs from\nhow we usually use mathematical induction, in which we apply the inductive step\ninﬁnitely; here, we stop the “induction” when the loop terminates.\nLet us see how these properties hold for insertion sort.\nInitialization: We start by showing that the loop invariant holds before the ﬁrst\nloop iteration, when j D 2.1 The subarray AŒ1 : : j \u0005 1\u0002, therefore, consists\nof just the single element AŒ1\u0002, which is in fact the original element in AŒ1\u0002.\nMoreover, this subarray is sorted (trivially, of course), which shows that the\nloop invariant holds prior to the ﬁrst iteration of the loop.\nMaintenance: Next, we tackle the second property: showing that each iteration\nmaintains the loop invariant. Informally, the body of the for loop works by\nmoving AŒj \u0005 1\u0002, AŒj \u0005 2\u0002, AŒj \u0005 3\u0002, and so on by one position to the right\nuntil it ﬁnds the proper position for AŒj \u0002 (lines 4–7), at which point it inserts\nthe value of AŒj \u0002 (line 8). The subarray AŒ1 : : j \u0002 then consists of the elements\noriginally in AŒ1 : : j \u0002, but in sorted order. Incrementing j for the next iteration\nof the for loop then preserves the loop invariant.\nA more formal treatment of the second property would require us to state and\nshow a loop invariant for the while loop of lines 5–7. At this point, however,\n1When the loop is a for loop, the moment at which we check the loop invariant just prior to the ﬁrst\niteration is immediately after the initial assignment to the loop-counter variable and just before the\nﬁrst test in the loop header. In the case of INSERTION-SORT, this time is after assigning 2 to the\nvariable j but before the ﬁrst test of whether j \u0002 A:length.\n20\nChapter 2\nGetting Started\nwe prefer not to get bogged down in such formalism, and so we rely on our\ninformal analysis to show that the second property holds for the outer loop.\nTermination: Finally, we examine what happens when the loop terminates. The",
    "parent_7fbfb34c-f44a-4521-adc9-a2e68d8870aa": "20\nChapter 2\nGetting Started\nwe prefer not to get bogged down in such formalism, and so we rely on our\ninformal analysis to show that the second property holds for the outer loop.\nTermination: Finally, we examine what happens when the loop terminates. The\ncondition causing the for loop to terminate is that j > A:length D n. Because\neach loop iteration increases j by 1, we must have j D n C 1 at that time.\nSubstituting n C 1 for j in the wording of loop invariant, we have that the\nsubarray AŒ1 : : n\u0002 consists of the elements originally in AŒ1 : : n\u0002, but in sorted\norder. Observing that the subarray AŒ1 : : n\u0002 is the entire array, we conclude that\nthe entire array is sorted. Hence, the algorithm is correct.\nWe shall use this method of loop invariants to show correctness later in this\nchapter and in other chapters as well.\nPseudocode conventions\nWe use the following conventions in our pseudocode.\n\u0002\nIndentation indicates block structure. For example, the body of the for loop that\nbegins on line 1 consists of lines 2–8, and the body of the while loop that begins\non line 5 contains lines 6–7 but not line 8. Our indentation style applies to\nif-else statements2 as well. Using indentation instead of conventional indicators\nof block structure, such as begin and end statements, greatly reduces clutter\nwhile preserving, or even enhancing, clarity.3\n\u0002\nThe looping constructs while, for, and repeat-until and the if-else conditional\nconstruct have interpretations similar to those in C, C++, Java, Python, and\nPascal.4 In this book, the loop counter retains its value after exiting the loop,\nunlike some situations that arise in C++, Java, and Pascal. Thus, immediately\nafter a for loop, the loop counter’s value is the value that ﬁrst exceeded the for\nloop bound. We used this property in our correctness argument for insertion\nsort. The for loop header in line 1 is for j D 2 to A:length, and so when\nthis loop terminates, j D A:length C 1 (or, equivalently, j D n C 1, since",
    "parent_a7aeb706-e57a-4e0c-ac1e-fdbb1fa77cd8": "loop bound. We used this property in our correctness argument for insertion\nsort. The for loop header in line 1 is for j D 2 to A:length, and so when\nthis loop terminates, j D A:length C 1 (or, equivalently, j D n C 1, since\nn D A:length). We use the keyword to when a for loop increments its loop\n2In an if-else statement, we indent else at the same level as its matching if. Although we omit the\nkeyword then, we occasionally refer to the portion executed when the test following if is true as a\nthen clause. For multiway tests, we use elseif for tests after the ﬁrst one.\n3Each pseudocode procedure in this book appears on one page so that you will not have to discern\nlevels of indentation in code that is split across pages.\n4Most block-structured languages have equivalent constructs, though the exact syntax may differ.\nPython lacks repeat-until loops, and its for loops operate a little differently from the for loops in\nthis book.\n2.1\nInsertion sort\n21\ncounter in each iteration, and we use the keyword downto when a for loop\ndecrements its loop counter. When the loop counter changes by an amount\ngreater than 1, the amount of change follows the optional keyword by.\n\u0002\nThe symbol “//” indicates that the remainder of the line is a comment.\n\u0002\nA multiple assignment of the form i D j D e assigns to both variables i and j\nthe value of expression e; it should be treated as equivalent to the assignment\nj D e followed by the assignment i D j .\n\u0002\nVariables (such as i, j , and key) are local to the given procedure. We shall not\nuse global variables without explicit indication.\n\u0002\nWe access array elements by specifying the array name followed by the in-\ndex in square brackets.\nFor example, AŒi\u0002 indicates the ith element of the\narray A. The notation “: :” is used to indicate a range of values within an ar-\nray. Thus, AŒ1 : : j \u0002 indicates the subarray of A consisting of the j elements\nAŒ1\u0002; AŒ2\u0002; : : : ; AŒj \u0002.\n\u0002\nWe typically organize compound data into objects, which are composed of",
    "parent_a15deafc-2aa9-4751-b9cd-70a441908b7c": "array A. The notation “: :” is used to indicate a range of values within an ar-\nray. Thus, AŒ1 : : j \u0002 indicates the subarray of A consisting of the j elements\nAŒ1\u0002; AŒ2\u0002; : : : ; AŒj \u0002.\n\u0002\nWe typically organize compound data into objects, which are composed of\nattributes. We access a particular attribute using the syntax found in many\nobject-oriented programming languages: the object name, followed by a dot,\nfollowed by the attribute name. For example, we treat an array as an object\nwith the attribute length indicating how many elements it contains. To specify\nthe number of elements in an array A, we write A:length.\nWe treat a variable representing an array or object as a pointer to the data rep-\nresenting the array or object. For all attributes f of an object x, setting y D x\ncauses y:f to equal x:f. Moreover, if we now set x:f D 3, then afterward not\nonly does x:f equal 3, but y:f equals 3 as well. In other words, x and y point\nto the same object after the assignment y D x.\nOur attribute notation can “cascade.” For example, suppose that the attribute f\nis itself a pointer to some type of object that has an attribute g. Then the notation\nx:f:g is implicitly parenthesized as .x:f/:g. In other words, if we had assigned\ny D x:f, then x:f:g is the same as y:g.\nSometimes, a pointer will refer to no object at all. In this case, we give it the\nspecial value NIL.\n\u0002\nWe pass parameters to a procedure by value: the called procedure receives its\nown copy of the parameters, and if it assigns a value to a parameter, the change\nis not seen by the calling procedure. When objects are passed, the pointer to\nthe data representing the object is copied, but the object’s attributes are not. For\nexample, if x is a parameter of a called procedure, the assignment x D y within\nthe called procedure is not visible to the calling procedure. The assignment\nx:f D 3, however, is visible. Similarly, arrays are passed by pointer, so that\n22\nChapter 2\nGetting Started",
    "parent_0f252ca6-355d-4f65-96c1-dec7601893f7": "example, if x is a parameter of a called procedure, the assignment x D y within\nthe called procedure is not visible to the calling procedure. The assignment\nx:f D 3, however, is visible. Similarly, arrays are passed by pointer, so that\n22\nChapter 2\nGetting Started\na pointer to the array is passed, rather than the entire array, and changes to\nindividual array elements are visible to the calling procedure.\n\u0002\nA return statement immediately transfers control back to the point of call in\nthe calling procedure. Most return statements also take a value to pass back to\nthe caller. Our pseudocode differs from many programming languages in that\nwe allow multiple values to be returned in a single return statement.\n\u0002\nThe boolean operators “and” and “or” are short circuiting. That is, when we\nevaluate the expression “x and y” we ﬁrst evaluate x. If x evaluates to FALSE,\nthen the entire expression cannot evaluate to TRUE, and so we do not evaluate y.\nIf, on the other hand, x evaluates to TRUE, we must evaluate y to determine the\nvalue of the entire expression. Similarly, in the expression “x or y” we eval-\nuate the expression y only if x evaluates to FALSE. Short-circuiting operators\nallow us to write boolean expressions such as “x ¤ NIL and x:f D y” without\nworrying about what happens when we try to evaluate x:f when x is NIL.\n\u0002\nThe keyword error indicates that an error occurred because conditions were\nwrong for the procedure to have been called. The calling procedure is respon-\nsible for handling the error, and so we do not specify what action to take.\nExercises\n2.1-1\nUsing Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the\narray A D h31; 41; 59; 26; 41; 58i.\n2.1-2\nRewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non-\ndecreasing order.\n2.1-3\nConsider the searching problem:\nInput: A sequence of n numbers A D ha1; a2; : : : ; ani and a value \u0003.\nOutput: An index i such that \u0003 D AŒi\u0002 or the special value NIL if \u0003 does not",
    "parent_f9b588db-20c3-4afe-b004-16d0a8edcf3c": "2.1-2\nRewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non-\ndecreasing order.\n2.1-3\nConsider the searching problem:\nInput: A sequence of n numbers A D ha1; a2; : : : ; ani and a value \u0003.\nOutput: An index i such that \u0003 D AŒi\u0002 or the special value NIL if \u0003 does not\nappear in A.\nWrite pseudocode for linear search, which scans through the sequence, looking\nfor \u0003. Using a loop invariant, prove that your algorithm is correct. Make sure that\nyour loop invariant fulﬁlls the three necessary properties.\n2.1-4\nConsider the problem of adding two n-bit binary integers, stored in two n-element\narrays A and B. The sum of the two integers should be stored in binary form in\n2.2\nAnalyzing algorithms\n23\nan .n C 1/-element array C. State the problem formally and write pseudocode for\nadding the two integers.\n2.2\nAnalyzing algorithms\nAnalyzing an algorithm has come to mean predicting the resources that the algo-\nrithm requires. Occasionally, resources such as memory, communication band-\nwidth, or computer hardware are of primary concern, but most often it is compu-\ntational time that we want to measure. Generally, by analyzing several candidate\nalgorithms for a problem, we can identify a most efﬁcient one. Such analysis may\nindicate more than one viable candidate, but we can often discard several inferior\nalgorithms in the process.\nBefore we can analyze an algorithm, we must have a model of the implemen-\ntation technology that we will use, including a model for the resources of that\ntechnology and their costs. For most of this book, we shall assume a generic one-\nprocessor, random-access machine (RAM) model of computation as our imple-\nmentation technology and understand that our algorithms will be implemented as\ncomputer programs. In the RAM model, instructions are executed one after an-\nother, with no concurrent operations.\nStrictly speaking, we should precisely deﬁne the instructions of the RAM model",
    "parent_2346dd6d-e21f-443e-a1bc-a93f1ae5b8dc": "mentation technology and understand that our algorithms will be implemented as\ncomputer programs. In the RAM model, instructions are executed one after an-\nother, with no concurrent operations.\nStrictly speaking, we should precisely deﬁne the instructions of the RAM model\nand their costs. To do so, however, would be tedious and would yield little insight\ninto algorithm design and analysis. Yet we must be careful not to abuse the RAM\nmodel. For example, what if a RAM had an instruction that sorts? Then we could\nsort in just one instruction. Such a RAM would be unrealistic, since real computers\ndo not have such instructions. Our guide, therefore, is how real computers are de-\nsigned. The RAM model contains instructions commonly found in real computers:\narithmetic (such as add, subtract, multiply, divide, remainder, ﬂoor, ceiling), data\nmovement (load, store, copy), and control (conditional and unconditional branch,\nsubroutine call and return). Each such instruction takes a constant amount of time.\nThe data types in the RAM model are integer and ﬂoating point (for storing real\nnumbers). Although we typically do not concern ourselves with precision in this\nbook, in some applications precision is crucial. We also assume a limit on the size\nof each word of data. For example, when working with inputs of size n, we typ-\nically assume that integers are represented by c lg n bits for some constant c \u0006 1.\nWe require c \u0006 1 so that each word can hold the value of n, enabling us to index the\nindividual input elements, and we restrict c to be a constant so that the word size\ndoes not grow arbitrarily. (If the word size could grow arbitrarily, we could store\nhuge amounts of data in one word and operate on it all in constant time—clearly\nan unrealistic scenario.)\n24\nChapter 2\nGetting Started\nReal computers contain instructions not listed above, and such instructions rep-\nresent a gray area in the RAM model. For example, is exponentiation a constant-",
    "parent_79c9d1dc-b624-4e67-a7ee-0993aac322a7": "huge amounts of data in one word and operate on it all in constant time—clearly\nan unrealistic scenario.)\n24\nChapter 2\nGetting Started\nReal computers contain instructions not listed above, and such instructions rep-\nresent a gray area in the RAM model. For example, is exponentiation a constant-\ntime instruction? In the general case, no; it takes several instructions to compute xy\nwhen x and y are real numbers. In restricted situations, however, exponentiation is\na constant-time operation. Many computers have a “shift left” instruction, which\nin constant time shifts the bits of an integer by k positions to the left. In most\ncomputers, shifting the bits of an integer by one position to the left is equivalent\nto multiplication by 2, so that shifting the bits by k positions to the left is equiv-\nalent to multiplication by 2k. Therefore, such computers can compute 2k in one\nconstant-time instruction by shifting the integer 1 by k positions to the left, as long\nas k is no more than the number of bits in a computer word. We will endeavor to\navoid such gray areas in the RAM model, but we will treat computation of 2k as a\nconstant-time operation when k is a small enough positive integer.\nIn the RAM model, we do not attempt to model the memory hierarchy that is\ncommon in contemporary computers. That is, we do not model caches or virtual\nmemory. Several computational models attempt to account for memory-hierarchy\neffects, which are sometimes signiﬁcant in real programs on real machines. A\nhandful of problems in this book examine memory-hierarchy effects, but for the\nmost part, the analyses in this book will not consider them. Models that include\nthe memory hierarchy are quite a bit more complex than the RAM model, and so\nthey can be difﬁcult to work with. Moreover, RAM-model analyses are usually\nexcellent predictors of performance on actual machines.\nAnalyzing even a simple algorithm in the RAM model can be a challenge. The",
    "parent_92136b41-b446-42d1-a2b1-a766db240159": "the memory hierarchy are quite a bit more complex than the RAM model, and so\nthey can be difﬁcult to work with. Moreover, RAM-model analyses are usually\nexcellent predictors of performance on actual machines.\nAnalyzing even a simple algorithm in the RAM model can be a challenge. The\nmathematical tools required may include combinatorics, probability theory, alge-\nbraic dexterity, and the ability to identify the most signiﬁcant terms in a formula.\nBecause the behavior of an algorithm may be different for each possible input, we\nneed a means for summarizing that behavior in simple, easily understood formulas.\nEven though we typically select only one machine model to analyze a given al-\ngorithm, we still face many choices in deciding how to express our analysis. We\nwould like a way that is simple to write and manipulate, shows the important char-\nacteristics of an algorithm’s resource requirements, and suppresses tedious details.\nAnalysis of insertion sort\nThe time taken by the INSERTION-SORT procedure depends on the input: sorting a\nthousand numbers takes longer than sorting three numbers. Moreover, INSERTION-\nSORT can take different amounts of time to sort two input sequences of the same\nsize depending on how nearly sorted they already are. In general, the time taken\nby an algorithm grows with the size of the input, so it is traditional to describe the\nrunning time of a program as a function of the size of its input. To do so, we need\nto deﬁne the terms “running time” and “size of input” more carefully.\n2.2\nAnalyzing algorithms\n25\nThe best notion for input size depends on the problem being studied. For many\nproblems, such as sorting or computing discrete Fourier transforms, the most nat-\nural measure is the number of items in the input—for example, the array size n\nfor sorting. For many other problems, such as multiplying two integers, the best\nmeasure of input size is the total number of bits needed to represent the input in",
    "parent_a466c907-6d71-43d1-ab37-180882c5a82f": "ural measure is the number of items in the input—for example, the array size n\nfor sorting. For many other problems, such as multiplying two integers, the best\nmeasure of input size is the total number of bits needed to represent the input in\nordinary binary notation. Sometimes, it is more appropriate to describe the size of\nthe input with two numbers rather than one. For instance, if the input to an algo-\nrithm is a graph, the input size can be described by the numbers of vertices and\nedges in the graph. We shall indicate which input size measure is being used with\neach problem we study.\nThe running time of an algorithm on a particular input is the number of primitive\noperations or “steps” executed. It is convenient to deﬁne the notion of step so\nthat it is as machine-independent as possible. For the moment, let us adopt the\nfollowing view. A constant amount of time is required to execute each line of our\npseudocode. One line may take a different amount of time than another line, but\nwe shall assume that each execution of the ith line takes time ci, where ci is a\nconstant. This viewpoint is in keeping with the RAM model, and it also reﬂects\nhow the pseudocode would be implemented on most actual computers.5\nIn the following discussion, our expression for the running time of INSERTION-\nSORT will evolve from a messy formula that uses all the statement costs ci to a\nmuch simpler notation that is more concise and more easily manipulated. This\nsimpler notation will also make it easy to determine whether one algorithm is more\nefﬁcient than another.\nWe start by presenting the INSERTION-SORT procedure with the time “cost”\nof each statement and the number of times each statement is executed. For each\nj D 2; 3; : : : ; n, where n D A:length, we let tj denote the number of times the\nwhile loop test in line 5 is executed for that value of j . When a for or while loop\nexits in the usual way (i.e., due to the test in the loop header), the test is executed",
    "parent_a84e08fa-ab07-4f85-891c-1b593b4bd994": "j D 2; 3; : : : ; n, where n D A:length, we let tj denote the number of times the\nwhile loop test in line 5 is executed for that value of j . When a for or while loop\nexits in the usual way (i.e., due to the test in the loop header), the test is executed\none time more than the loop body. We assume that comments are not executable\nstatements, and so they take no time.\n5There are some subtleties here. Computational steps that we specify in English are often variants\nof a procedure that requires more than just a constant amount of time. For example, later in this\nbook we might say “sort the points by x-coordinate,” which, as we shall see, takes more than a\nconstant amount of time. Also, note that a statement that calls a subroutine takes constant time,\nthough the subroutine, once invoked, may take more. That is, we separate the process of calling the\nsubroutine—passing parameters to it, etc.—from the process of executing the subroutine.\n26\nChapter 2\nGetting Started\nINSERTION-SORT.A/\ncost\ntimes\n1\nfor j D 2 to A:length\nc1\nn\n2\nkey D AŒj \u0002\nc2\nn \u0005 1\n3\n// Insert AŒj \u0002 into the sorted\nsequence AŒ1 : : j \u0005 1\u0002.\n0\nn \u0005 1\n4\ni D j \u0005 1\nc4\nn \u0005 1\n5\nwhile i > 0 and AŒi\u0002 > key\nc5\nPn\njD2 tj\n6\nAŒi C 1\u0002 D AŒi\u0002\nc6\nPn\njD2.tj \u0005 1/\n7\ni D i \u0005 1\nc7\nPn\njD2.tj \u0005 1/\n8\nAŒi C 1\u0002 D key\nc8\nn \u0005 1\nThe running time of the algorithm is the sum of running times for each state-\nment executed; a statement that takes ci steps to execute and executes n times will\ncontribute cin to the total running time.6 To compute T .n/, the running time of\nINSERTION-SORT on an input of n values, we sum the products of the cost and\ntimes columns, obtaining\nT .n/\nD\nc1n C c2.n \u0005 1/ C c4.n \u0005 1/ C c5\nn\nX\njD2\ntj C c6\nn\nX\njD2\n.tj \u0005 1/\nC c7\nn\nX\njD2\n.tj \u0005 1/ C c8.n \u0005 1/ :\nEven for inputs of a given size, an algorithm’s running time may depend on\nwhich input of that size is given. For example, in INSERTION-SORT, the best\ncase occurs if the array is already sorted. For each j D 2; 3; : : : ; n, we then ﬁnd",
    "parent_40f50532-fcef-4400-a7e0-b5c95b2c3644": "tj C c6\nn\nX\njD2\n.tj \u0005 1/\nC c7\nn\nX\njD2\n.tj \u0005 1/ C c8.n \u0005 1/ :\nEven for inputs of a given size, an algorithm’s running time may depend on\nwhich input of that size is given. For example, in INSERTION-SORT, the best\ncase occurs if the array is already sorted. For each j D 2; 3; : : : ; n, we then ﬁnd\nthat AŒi\u0002 \u0002 key in line 5 when i has its initial value of j \u0005 1. Thus tj D 1 for\nj D 2; 3; : : : ; n, and the best-case running time is\nT .n/\nD\nc1n C c2.n \u0005 1/ C c4.n \u0005 1/ C c5.n \u0005 1/ C c8.n \u0005 1/\nD\n.c1 C c2 C c4 C c5 C c8/n \u0005 .c2 C c4 C c5 C c8/ :\nWe can express this running time as an C b for constants a and b that depend on\nthe statement costs ci; it is thus a linear function of n.\nIf the array is in reverse sorted order—that is, in decreasing order—the worst\ncase results. We must compare each element AŒj \u0002 with each element in the entire\nsorted subarray AŒ1 : : j \u0005 1\u0002, and so tj D j for j D 2; 3; : : : ; n. Noting that\n6This characteristic does not necessarily hold for a resource such as memory. A statement that\nreferences m words of memory and is executed n times does not necessarily reference mn distinct\nwords of memory.\n2.2\nAnalyzing algorithms\n27\nn\nX\njD2\nj D n.n C 1/\n2\n\u0005 1\nand\nn\nX\njD2\n.j \u0005 1/ D n.n \u0005 1/\n2\n(see Appendix A for a review of how to solve these summations), we ﬁnd that in\nthe worst case, the running time of INSERTION-SORT is\nT .n/\nD\nc1n C c2.n \u0005 1/ C c4.n \u0005 1/ C c5\n\u0002n.n C 1/\n2\n\u0005 1\n\u0003\nC c6\n\u0002n.n \u0005 1/\n2\n\u0003\nC c7\n\u0002n.n \u0005 1/\n2\n\u0003\nC c8.n \u0005 1/\nD\n\u0004c5\n2 C c6\n2 C c7\n2\n\u0005\nn2 C\n\u0004\nc1 C c2 C c4 C c5\n2 \u0005 c6\n2 \u0005 c7\n2 C c8\n\u0005\nn\n\u0005 .c2 C c4 C c5 C c8/ :\nWe can express this worst-case running time as an2 C bn C c for constants a, b,\nand c that again depend on the statement costs ci; it is thus a quadratic function\nof n.\nTypically, as in insertion sort, the running time of an algorithm is ﬁxed for a\ngiven input, although in later chapters we shall see some interesting “randomized”\nalgorithms whose behavior can vary even for a ﬁxed input.\nWorst-case and average-case analysis",
    "parent_6715a102-2bc8-4167-8b07-143ab96ee8f9": "of n.\nTypically, as in insertion sort, the running time of an algorithm is ﬁxed for a\ngiven input, although in later chapters we shall see some interesting “randomized”\nalgorithms whose behavior can vary even for a ﬁxed input.\nWorst-case and average-case analysis\nIn our analysis of insertion sort, we looked at both the best case, in which the input\narray was already sorted, and the worst case, in which the input array was reverse\nsorted. For the remainder of this book, though, we shall usually concentrate on\nﬁnding only the worst-case running time, that is, the longest running time for any\ninput of size n. We give three reasons for this orientation.\n\u0002\nThe worst-case running time of an algorithm gives us an upper bound on the\nrunning time for any input. Knowing it provides a guarantee that the algorithm\nwill never take any longer. We need not make some educated guess about the\nrunning time and hope that it never gets much worse.\n\u0002\nFor some algorithms, the worst case occurs fairly often. For example, in search-\ning a database for a particular piece of information, the searching algorithm’s\nworst case will often occur when the information is not present in the database.\nIn some applications, searches for absent information may be frequent.\n28\nChapter 2\nGetting Started\n\u0002\nThe “average case” is often roughly as bad as the worst case. Suppose that we\nrandomly choose n numbers and apply insertion sort. How long does it take to\ndetermine where in subarray AŒ1 : : j \u0005 1\u0002 to insert element AŒj \u0002? On average,\nhalf the elements in AŒ1 : : j \u0005 1\u0002 are less than AŒj \u0002, and half the elements are\ngreater. On average, therefore, we check half of the subarray AŒ1 : : j \u0005 1\u0002, and\nso tj is about j=2. The resulting average-case running time turns out to be a\nquadratic function of the input size, just like the worst-case running time.\nIn some particular cases, we shall be interested in the average-case running time",
    "parent_20b33b34-1d3e-47c0-8e13-f27f0d5d82a5": "so tj is about j=2. The resulting average-case running time turns out to be a\nquadratic function of the input size, just like the worst-case running time.\nIn some particular cases, we shall be interested in the average-case running time\nof an algorithm; we shall see the technique of probabilistic analysis applied to\nvarious algorithms throughout this book. The scope of average-case analysis is\nlimited, because it may not be apparent what constitutes an “average” input for\na particular problem. Often, we shall assume that all inputs of a given size are\nequally likely. In practice, this assumption may be violated, but we can sometimes\nuse a randomized algorithm, which makes random choices, to allow a probabilistic\nanalysis and yield an expected running time. We explore randomized algorithms\nmore in Chapter 5 and in several other subsequent chapters.\nOrder of growth\nWe used some simplifying abstractions to ease our analysis of the INSERTION-\nSORT procedure. First, we ignored the actual cost of each statement, using the\nconstants ci to represent these costs. Then, we observed that even these constants\ngive us more detail than we really need: we expressed the worst-case running time\nas an2 C bn C c for some constants a, b, and c that depend on the statement\ncosts ci. We thus ignored not only the actual statement costs, but also the abstract\ncosts ci.\nWe shall now make one more simplifying abstraction: it is the rate of growth,\nor order of growth, of the running time that really interests us. We therefore con-\nsider only the leading term of a formula (e.g., an2), since the lower-order terms are\nrelatively insigniﬁcant for large values of n. We also ignore the leading term’s con-\nstant coefﬁcient, since constant factors are less signiﬁcant than the rate of growth\nin determining computational efﬁciency for large inputs. For insertion sort, when\nwe ignore the lower-order terms and the leading term’s constant coefﬁcient, we are",
    "parent_a26806a7-36cf-4796-97ed-41d5f8c6cf1f": "stant coefﬁcient, since constant factors are less signiﬁcant than the rate of growth\nin determining computational efﬁciency for large inputs. For insertion sort, when\nwe ignore the lower-order terms and the leading term’s constant coefﬁcient, we are\nleft with the factor of n2 from the leading term. We write that insertion sort has a\nworst-case running time of ‚.n2/ (pronounced “theta of n-squared”). We shall use\n‚-notation informally in this chapter, and we will deﬁne it precisely in Chapter 3.\nWe usually consider one algorithm to be more efﬁcient than another if its worst-\ncase running time has a lower order of growth. Due to constant factors and lower-\norder terms, an algorithm whose running time has a higher order of growth might\ntake less time for small inputs than an algorithm whose running time has a lower\n2.3\nDesigning algorithms\n29\norder of growth. But for large enough inputs, a ‚.n2/ algorithm, for example, will\nrun more quickly in the worst case than a ‚.n3/ algorithm.\nExercises\n2.2-1\nExpress the function n3=1000 \u0005 100n2 \u0005 100n C 3 in terms of ‚-notation.\n2.2-2\nConsider sorting n numbers stored in array A by ﬁrst ﬁnding the smallest element\nof A and exchanging it with the element in AŒ1\u0002. Then ﬁnd the second smallest\nelement of A, and exchange it with AŒ2\u0002. Continue in this manner for the ﬁrst n\u00051\nelements of A. Write pseudocode for this algorithm, which is known as selection\nsort. What loop invariant does this algorithm maintain? Why does it need to run\nfor only the ﬁrst n \u0005 1 elements, rather than for all n elements? Give the best-case\nand worst-case running times of selection sort in ‚-notation.\n2.2-3\nConsider linear search again (see Exercise 2.1-3). How many elements of the in-\nput sequence need to be checked on the average, assuming that the element being\nsearched for is equally likely to be any element in the array? How about in the\nworst case? What are the average-case and worst-case running times of linear",
    "parent_4e54e1fc-dc74-477f-9e24-38e921079e38": "put sequence need to be checked on the average, assuming that the element being\nsearched for is equally likely to be any element in the array? How about in the\nworst case? What are the average-case and worst-case running times of linear\nsearch in ‚-notation? Justify your answers.\n2.2-4\nHow can we modify almost any algorithm to have a good best-case running time?\n2.3\nDesigning algorithms\nWe can choose from a wide range of algorithm design techniques. For insertion\nsort, we used an incremental approach: having sorted the subarray AŒ1 : : j \u0005 1\u0002,\nwe inserted the single element AŒj \u0002 into its proper place, yielding the sorted\nsubarray AŒ1 : : j \u0002.\nIn this section, we examine an alternative design approach, known as “divide-\nand-conquer,” which we shall explore in more detail in Chapter 4. We’ll use divide-\nand-conquer to design a sorting algorithm whose worst-case running time is much\nless than that of insertion sort. One advantage of divide-and-conquer algorithms is\nthat their running times are often easily determined using techniques that we will\nsee in Chapter 4.\n30\nChapter 2\nGetting Started\n2.3.1\nThe divide-and-conquer approach\nMany useful algorithms are recursive in structure: to solve a given problem, they\ncall themselves recursively one or more times to deal with closely related sub-\nproblems. These algorithms typically follow a divide-and-conquer approach: they\nbreak the problem into several subproblems that are similar to the original prob-\nlem but smaller in size, solve the subproblems recursively, and then combine these\nsolutions to create a solution to the original problem.\nThe divide-and-conquer paradigm involves three steps at each level of the recur-\nsion:\nDivide the problem into a number of subproblems that are smaller instances of the\nsame problem.\nConquer the subproblems by solving them recursively. If the subproblem sizes are\nsmall enough, however, just solve the subproblems in a straightforward manner.",
    "parent_ec06deaa-29fc-4a98-b849-aab7cd9b8927": "sion:\nDivide the problem into a number of subproblems that are smaller instances of the\nsame problem.\nConquer the subproblems by solving them recursively. If the subproblem sizes are\nsmall enough, however, just solve the subproblems in a straightforward manner.\nCombine the solutions to the subproblems into the solution for the original prob-\nlem.\nThe merge sort algorithm closely follows the divide-and-conquer paradigm. In-\ntuitively, it operates as follows.\nDivide: Divide the n-element sequence to be sorted into two subsequences of n=2\nelements each.\nConquer: Sort the two subsequences recursively using merge sort.\nCombine: Merge the two sorted subsequences to produce the sorted answer.\nThe recursion “bottoms out” when the sequence to be sorted has length 1, in which\ncase there is no work to be done, since every sequence of length 1 is already in\nsorted order.\nThe key operation of the merge sort algorithm is the merging of two sorted\nsequences in the “combine” step. We merge by calling an auxiliary procedure\nMERGE.A; p; q; r/, where A is an array and p, q, and r are indices into the array\nsuch that p \u0002 q < r. The procedure assumes that the subarrays AŒp : : q\u0002 and\nAŒq C 1 : : r\u0002 are in sorted order. It merges them to form a single sorted subarray\nthat replaces the current subarray AŒp : : r\u0002.\nOur MERGE procedure takes time ‚.n/, where n D r \u0005 p C 1 is the total\nnumber of elements being merged, and it works as follows. Returning to our card-\nplaying motif, suppose we have two piles of cards face up on a table. Each pile is\nsorted, with the smallest cards on top. We wish to merge the two piles into a single\nsorted output pile, which is to be face down on the table. Our basic step consists\nof choosing the smaller of the two cards on top of the face-up piles, removing it\nfrom its pile (which exposes a new top card), and placing this card face down onto\n2.3\nDesigning algorithms\n31\nthe output pile. We repeat this step until one input pile is empty, at which time",
    "parent_34fde074-29d9-4b50-8d19-7555e56955a4": "of choosing the smaller of the two cards on top of the face-up piles, removing it\nfrom its pile (which exposes a new top card), and placing this card face down onto\n2.3\nDesigning algorithms\n31\nthe output pile. We repeat this step until one input pile is empty, at which time\nwe just take the remaining input pile and place it face down onto the output pile.\nComputationally, each basic step takes constant time, since we are comparing just\nthe two top cards. Since we perform at most n basic steps, merging takes ‚.n/\ntime.\nThe following pseudocode implements the above idea, but with an additional\ntwist that avoids having to check whether either pile is empty in each basic step.\nWe place on the bottom of each pile a sentinel card, which contains a special value\nthat we use to simplify our code. Here, we use 1 as the sentinel value, so that\nwhenever a card with 1 is exposed, it cannot be the smaller card unless both piles\nhave their sentinel cards exposed. But once that happens, all the nonsentinel cards\nhave already been placed onto the output pile. Since we know in advance that\nexactly r \u0005 p C 1 cards will be placed onto the output pile, we can stop once we\nhave performed that many basic steps.\nMERGE.A; p; q; r/\n1\nn1 D q \u0005 p C 1\n2\nn2 D r \u0005 q\n3\nlet LŒ1 : : n1 C 1\u0002 and RŒ1 : : n2 C 1\u0002 be new arrays\n4\nfor i D 1 to n1\n5\nLŒi\u0002 D AŒp C i \u0005 1\u0002\n6\nfor j D 1 to n2\n7\nRŒj \u0002 D AŒq C j \u0002\n8\nLŒn1 C 1\u0002 D 1\n9\nRŒn2 C 1\u0002 D 1\n10\ni D 1\n11\nj D 1\n12\nfor k D p to r\n13\nif LŒi\u0002 \u0002 RŒj \u0002\n14\nAŒk\u0002 D LŒi\u0002\n15\ni D i C 1\n16\nelse AŒk\u0002 D RŒj \u0002\n17\nj D j C 1\nIn detail, the MERGE procedure works as follows. Line 1 computes the length n1\nof the subarray AŒp : : q\u0002, and line 2 computes the length n2 of the subarray\nAŒq C 1 : : r\u0002. We create arrays L and R (“left” and “right”), of lengths n1 C 1\nand n2 C 1, respectively, in line 3; the extra position in each array will hold the\nsentinel. The for loop of lines 4–5 copies the subarray AŒp : : q\u0002 into LŒ1 : : n1\u0002,",
    "parent_d750e9c1-dd8f-4350-aa01-abb9c20f6377": "AŒq C 1 : : r\u0002. We create arrays L and R (“left” and “right”), of lengths n1 C 1\nand n2 C 1, respectively, in line 3; the extra position in each array will hold the\nsentinel. The for loop of lines 4–5 copies the subarray AŒp : : q\u0002 into LŒ1 : : n1\u0002,\nand the for loop of lines 6–7 copies the subarray AŒq C 1 : : r\u0002 into RŒ1 : : n2\u0002.\nLines 8–9 put the sentinels at the ends of the arrays L and R. Lines 10–17, illus-\n32\nChapter 2\nGetting Started\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(a)\n2\n4\n5\n7\n1\n2\n3\n6\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(b)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n2\n4\n5\n7\n1\n2\n3\n6\n4\n5\n7\n1\n2\n3\n6\nA\nL\nR\n9\n10\n11\n12\n13\n14\n15\n16\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(c)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n5\n7\n1\n2\n3\n6\n2\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(d)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n7\n1\n2\n3\n6\n2\n2\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n9\n10\n11\n12\n13\n14\n15\n16\n9\n10\n11\n12\n13\n14\n15\n16\n9\n10\n11\n12\n13\n14\n15\n16\n8\n…\n17\n…\n8\n…\n17\n…\n8\n…\n17\n…\n8\n…\n17\n…\nFigure 2.3\nThe operation of lines 10–17 in the call MERGE.A; 9; 12; 16/, when the subarray\nAŒ9 : : 16\u0002 contains the sequence h2; 4; 5; 7; 1; 2; 3; 6i. After copying and inserting sentinels, the\narray L contains h2; 4; 5; 7; 1i, and the array R contains h1; 2; 3; 6; 1i. Lightly shaded positions\nin A contain their ﬁnal values, and lightly shaded positions in L and R contain values that have yet\nto be copied back into A. Taken together, the lightly shaded positions always comprise the values\noriginally in AŒ9 : : 16\u0002, along with the two sentinels. Heavily shaded positions in A contain values\nthat will be copied over, and heavily shaded positions in L and R contain values that have already\nbeen copied back into A. (a)–(h) The arrays A, L, and R, and their respective indices k, i, and j\nprior to each iteration of the loop of lines 12–17.\ntrated in Figure 2.3, perform the r \u0005p C1 basic steps by maintaining the following\nloop invariant:\nAt the start of each iteration of the for loop of lines 12–17, the subarray\nAŒp : : k \u0005 1\u0002 contains the k \u0005 p smallest elements of LŒ1 : : n1 C 1\u0002 and",
    "parent_56497514-3668-4f1d-b7eb-850f75db734b": "trated in Figure 2.3, perform the r \u0005p C1 basic steps by maintaining the following\nloop invariant:\nAt the start of each iteration of the for loop of lines 12–17, the subarray\nAŒp : : k \u0005 1\u0002 contains the k \u0005 p smallest elements of LŒ1 : : n1 C 1\u0002 and\nRŒ1 : : n2 C 1\u0002, in sorted order. Moreover, LŒi\u0002 and RŒj \u0002 are the smallest\nelements of their arrays that have not been copied back into A.\nWe must show that this loop invariant holds prior to the ﬁrst iteration of the for\nloop of lines 12–17, that each iteration of the loop maintains the invariant, and\nthat the invariant provides a useful property to show correctness when the loop\nterminates.\nInitialization: Prior to the ﬁrst iteration of the loop, we have k D p, so that the\nsubarray AŒp : : k \u0005 1\u0002 is empty. This empty subarray contains the k \u0005 p D 0\nsmallest elements of L and R, and since i D j D 1, both LŒi\u0002 and RŒj \u0002 are the\nsmallest elements of their arrays that have not been copied back into A.\n2.3\nDesigning algorithms\n33\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(e)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n1\n2\n3\n6\n2\n2\n3\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(f)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n2\n3\n6\n2\n2\n3\n4\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(g)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n3\n6\n2\n2\n3\n4\n5\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(h)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n6\n2\n2\n3\n4\n5\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n5\n∞\n6\nA\nL\nR\n1\n2\n3\n4\n1\n2\n3\n4\ni\nj\nk\n(i)\n2\n4\n5\n7\n1\n2\n3\n6\n1\n7\n2\n2\n3\n4\n5\n5\n∞\n5\n∞\n6\n9\n10\n11\n12\n13\n14\n15\n16\n9\n10\n11\n12\n13\n14\n15\n16\n9\n10\n11\n12\n13\n14\n15\n16\n9\n10\n11\n12\n13\n14\n15\n16\n9\n10\n11\n12\n13\n14\n15\n16\n8\n…\n17\n…\n8\n…\n17\n…\n8\n…\n17\n…\n8\n…\n17\n…\n8\n…\n17\n…\nFigure 2.3, continued\n(i) The arrays and indices at termination. At this point, the subarray in\nAŒ9 : : 16\u0002 is sorted, and the two sentinels in L and R are the only two elements in these arrays that\nhave not been copied into A.\nMaintenance: To see that each iteration maintains the loop invariant, let us ﬁrst\nsuppose that LŒi\u0002 \u0002 RŒj \u0002. Then LŒi\u0002 is the smallest element not yet copied\nback into A. Because AŒp : : k \u0005 1\u0002 contains the k \u0005 p smallest elements, after",
    "parent_8165ff21-bd51-4c38-87a2-55f4c30a29a3": "have not been copied into A.\nMaintenance: To see that each iteration maintains the loop invariant, let us ﬁrst\nsuppose that LŒi\u0002 \u0002 RŒj \u0002. Then LŒi\u0002 is the smallest element not yet copied\nback into A. Because AŒp : : k \u0005 1\u0002 contains the k \u0005 p smallest elements, after\nline 14 copies LŒi\u0002 into AŒk\u0002, the subarray AŒp : : k\u0002 will contain the k \u0005 p C 1\nsmallest elements. Incrementing k (in the for loop update) and i (in line 15)\nreestablishes the loop invariant for the next iteration. If instead LŒi\u0002 > RŒj \u0002,\nthen lines 16–17 perform the appropriate action to maintain the loop invariant.\nTermination: At termination, k D r C 1. By the loop invariant, the subarray\nAŒp : : k \u0005 1\u0002, which is AŒp : : r\u0002, contains the k \u0005 p D r \u0005 p C 1 smallest\nelements of LŒ1 : : n1 C 1\u0002 and RŒ1 : : n2 C 1\u0002, in sorted order. The arrays L\nand R together contain n1 C n2 C 2 D r \u0005 p C 3 elements. All but the two\nlargest have been copied back into A, and these two largest elements are the\nsentinels.\n34\nChapter 2\nGetting Started\nTo see that the MERGE procedure runs in ‚.n/ time, where n D r \u0005 p C 1,\nobserve that each of lines 1–3 and 8–11 takes constant time, the for loops of\nlines 4–7 take ‚.n1 C n2/ D ‚.n/ time,7 and there are n iterations of the for\nloop of lines 12–17, each of which takes constant time.\nWe can now use the MERGE procedure as a subroutine in the merge sort al-\ngorithm. The procedure MERGE-SORT.A; p; r/ sorts the elements in the subar-\nray AŒp : : r\u0002. If p \u0006 r, the subarray has at most one element and is therefore\nalready sorted. Otherwise, the divide step simply computes an index q that par-\ntitions AŒp : : r\u0002 into two subarrays: AŒp : : q\u0002, containing dn=2e elements, and\nAŒq C 1 : : r\u0002, containing bn=2c elements.8\nMERGE-SORT.A; p; r/\n1\nif p < r\n2\nq D b.p C r/=2c\n3\nMERGE-SORT.A; p; q/\n4\nMERGE-SORT.A; q C 1; r/\n5\nMERGE.A; p; q; r/\nTo sort the entire sequence A D hAŒ1\u0002; AŒ2\u0002; : : : ; AŒn\u0002i, we make the initial call",
    "parent_33754c9c-cd18-4ec9-a931-0e3bd7f50e6b": "AŒq C 1 : : r\u0002, containing bn=2c elements.8\nMERGE-SORT.A; p; r/\n1\nif p < r\n2\nq D b.p C r/=2c\n3\nMERGE-SORT.A; p; q/\n4\nMERGE-SORT.A; q C 1; r/\n5\nMERGE.A; p; q; r/\nTo sort the entire sequence A D hAŒ1\u0002; AŒ2\u0002; : : : ; AŒn\u0002i, we make the initial call\nMERGE-SORT.A; 1; A:length/, where once again A:length D n. Figure 2.4 il-\nlustrates the operation of the procedure bottom-up when n is a power of 2. The\nalgorithm consists of merging pairs of 1-item sequences to form sorted sequences\nof length 2, merging pairs of sequences of length 2 to form sorted sequences of\nlength 4, and so on, until two sequences of length n=2 are merged to form the ﬁnal\nsorted sequence of length n.\n2.3.2\nAnalyzing divide-and-conquer algorithms\nWhen an algorithm contains a recursive call to itself, we can often describe its\nrunning time by a recurrence equation or recurrence, which describes the overall\nrunning time on a problem of size n in terms of the running time on smaller inputs.\nWe can then use mathematical tools to solve the recurrence and provide bounds on\nthe performance of the algorithm.\n7We shall see in Chapter 3 how to formally interpret equations containing ‚-notation.\n8The expression dxe denotes the least integer greater than or equal to x, and bxc denotes the greatest\ninteger less than or equal to x. These notations are deﬁned in Chapter 3. The easiest way to verify\nthat setting q to b.p C r/=2c yields subarrays AŒp : : q\u0002 and AŒq C 1 : : r\u0002 of sizes dn=2e and bn=2c,\nrespectively, is to examine the four cases that arise depending on whether each of p and r is odd or\neven.\n2.3\nDesigning algorithms\n35\n5\n2\n4\n7\n1\n3\n2\n6\n2\n5\n4\n7\n1\n3\n2\n6\n2\n4\n5\n7\n1\n2\n3\n6\n1\n2\n2\n3\n4\n5\n6\n7\nmerge\nmerge\nmerge\nsorted sequence\ninitial sequence\nmerge\nmerge\nmerge\nmerge\nFigure 2.4\nThe operation of merge sort on the array A D h5; 2; 4; 7; 1; 3; 2; 6i. The lengths of the\nsorted sequences being merged increase as the algorithm progresses from bottom to top.",
    "parent_14f1ee25-5d5a-4347-af1b-ae556dee28b6": "2\n6\n2\n4\n5\n7\n1\n2\n3\n6\n1\n2\n2\n3\n4\n5\n6\n7\nmerge\nmerge\nmerge\nsorted sequence\ninitial sequence\nmerge\nmerge\nmerge\nmerge\nFigure 2.4\nThe operation of merge sort on the array A D h5; 2; 4; 7; 1; 3; 2; 6i. The lengths of the\nsorted sequences being merged increase as the algorithm progresses from bottom to top.\nA recurrence for the running time of a divide-and-conquer algorithm falls out\nfrom the three steps of the basic paradigm. As before, we let T .n/ be the running\ntime on a problem of size n. If the problem size is small enough, say n \u0002 c\nfor some constant c, the straightforward solution takes constant time, which we\nwrite as ‚.1/. Suppose that our division of the problem yields a subproblems,\neach of which is 1=b the size of the original. (For merge sort, both a and b are 2,\nbut we shall see many divide-and-conquer algorithms in which a ¤ b.) It takes\ntime T .n=b/ to solve one subproblem of size n=b, and so it takes time aT .n=b/\nto solve a of them. If we take D.n/ time to divide the problem into subproblems\nand C.n/ time to combine the solutions to the subproblems into the solution to the\noriginal problem, we get the recurrence\nT .n/ D\n(\n‚.1/\nif n \u0002 c ;\naT .n=b/ C D.n/ C C.n/\notherwise :\nIn Chapter 4, we shall see how to solve common recurrences of this form.\nAnalysis of merge sort\nAlthough the pseudocode for MERGE-SORT works correctly when the number of\nelements is not even, our recurrence-based analysis is simpliﬁed if we assume that\n36\nChapter 2\nGetting Started\nthe original problem size is a power of 2. Each divide step then yields two subse-\nquences of size exactly n=2. In Chapter 4, we shall see that this assumption does\nnot affect the order of growth of the solution to the recurrence.\nWe reason as follows to set up the recurrence for T .n/, the worst-case running\ntime of merge sort on n numbers. Merge sort on just one element takes constant\ntime. When we have n > 1 elements, we break down the running time as follows.",
    "parent_f709baa9-307c-4313-b8f5-9ef4e6f13244": "We reason as follows to set up the recurrence for T .n/, the worst-case running\ntime of merge sort on n numbers. Merge sort on just one element takes constant\ntime. When we have n > 1 elements, we break down the running time as follows.\nDivide: The divide step just computes the middle of the subarray, which takes\nconstant time. Thus, D.n/ D ‚.1/.\nConquer: We recursively solve two subproblems, each of size n=2, which con-\ntributes 2T .n=2/ to the running time.\nCombine: We have already noted that the MERGE procedure on an n-element\nsubarray takes time ‚.n/, and so C.n/ D ‚.n/.\nWhen we add the functions D.n/ and C.n/ for the merge sort analysis, we are\nadding a function that is ‚.n/ and a function that is ‚.1/. This sum is a linear\nfunction of n, that is, ‚.n/. Adding it to the 2T .n=2/ term from the “conquer”\nstep gives the recurrence for the worst-case running time T .n/ of merge sort:\nT .n/ D\n(\n‚.1/\nif n D 1 ;\n2T .n=2/ C ‚.n/\nif n > 1 :\n(2.1)\nIn Chapter 4, we shall see the “master theorem,” which we can use to show\nthat T .n/ is ‚.n lg n/, where lg n stands for log2 n. Because the logarithm func-\ntion grows more slowly than any linear function, for large enough inputs, merge\nsort, with its ‚.n lg n/ running time, outperforms insertion sort, whose running\ntime is ‚.n2/, in the worst case.\nWe do not need the master theorem to intuitively understand why the solution to\nthe recurrence (2.1) is T .n/ D ‚.n lg n/. Let us rewrite recurrence (2.1) as\nT .n/ D\n(\nc\nif n D 1 ;\n2T .n=2/ C cn\nif n > 1 ;\n(2.2)\nwhere the constant c represents the time required to solve problems of size 1 as\nwell as the time per array element of the divide and combine steps.9\n9It is unlikely that the same constant exactly represents both the time to solve problems of size 1\nand the time per array element of the divide and combine steps. We can get around this problem by\nletting c be the larger of these times and understanding that our recurrence gives an upper bound on",
    "parent_e10c7234-a0f0-4c54-a331-a2c8c5f6c954": "9It is unlikely that the same constant exactly represents both the time to solve problems of size 1\nand the time per array element of the divide and combine steps. We can get around this problem by\nletting c be the larger of these times and understanding that our recurrence gives an upper bound on\nthe running time, or by letting c be the lesser of these times and understanding that our recurrence\ngives a lower bound on the running time. Both bounds are on the order of n lg n and, taken together,\ngive a ‚.n lg n/ running time.\n2.3\nDesigning algorithms\n37\nFigure 2.5 shows how we can solve recurrence (2.2). For convenience, we as-\nsume that n is an exact power of 2. Part (a) of the ﬁgure shows T .n/, which we\nexpand in part (b) into an equivalent tree representing the recurrence. The cn term\nis the root (the cost incurred at the top level of recursion), and the two subtrees of\nthe root are the two smaller recurrences T .n=2/. Part (c) shows this process carried\none step further by expanding T .n=2/. The cost incurred at each of the two sub-\nnodes at the second level of recursion is cn=2. We continue expanding each node\nin the tree by breaking it into its constituent parts as determined by the recurrence,\nuntil the problem sizes get down to 1, each with a cost of c. Part (d) shows the\nresulting recursion tree.\nNext, we add the costs across each level of the tree. The top level has total\ncost cn, the next level down has total cost c.n=2/ C c.n=2/ D cn, the level after\nthat has total cost c.n=4/Cc.n=4/Cc.n=4/Cc.n=4/ D cn, and so on. In general,\nthe level i below the top has 2i nodes, each contributing a cost of c.n=2i/, so that\nthe ith level below the top has total cost 2i c.n=2i/ D cn. The bottom level has n\nnodes, each contributing a cost of c, for a total cost of cn.\nThe total number of levels of the recursion tree in Figure 2.5 is lg n C 1, where\nn is the number of leaves, corresponding to the input size. An informal inductive",
    "parent_3719bb95-69ca-496c-9451-648cf5400f84": "nodes, each contributing a cost of c, for a total cost of cn.\nThe total number of levels of the recursion tree in Figure 2.5 is lg n C 1, where\nn is the number of leaves, corresponding to the input size. An informal inductive\nargument justiﬁes this claim. The base case occurs when n D 1, in which case the\ntree has only one level. Since lg 1 D 0, we have that lg n C 1 gives the correct\nnumber of levels. Now assume as an inductive hypothesis that the number of levels\nof a recursion tree with 2i leaves is lg 2i C 1 D i C 1 (since for any value of i,\nwe have that lg 2i D i). Because we are assuming that the input size is a power\nof 2, the next input size to consider is 2iC1. A tree with n D 2iC1 leaves has\none more level than a tree with 2i leaves, and so the total number of levels is\n.i C 1/ C 1 D lg 2iC1 C 1.\nTo compute the total cost represented by the recurrence (2.2), we simply add up\nthe costs of all the levels. The recursion tree has lg n C 1 levels, each costing cn,\nfor a total cost of cn.lg n C 1/ D cn lg n C cn. Ignoring the low-order term and\nthe constant c gives the desired result of ‚.n lg n/.\nExercises\n2.3-1\nUsing Figure 2.4 as a model, illustrate the operation of merge sort on the array\nA D h3; 41; 52; 26; 38; 57; 9; 49i.\n2.3-2\nRewrite the MERGE procedure so that it does not use sentinels, instead stopping\nonce either array L or R has had all its elements copied back to A and then copying\nthe remainder of the other array back into A.\n38\nChapter 2\nGetting Started\ncn\ncn\n…\nTotal: cn lg n + cn\ncn\nlg n\ncn\nn\nc\nc\nc\nc\nc\nc\nc\n…\n(d)\n(c)\ncn\nT(n/2)\nT(n/2)\n(b)\nT(n)\n(a)\ncn\ncn/2\nT(n/4)\nT(n/4)\ncn/2\nT(n/4)\nT(n/4)\ncn\ncn/2\ncn/4\ncn/4\ncn/2\ncn/4\ncn/4\nFigure 2.5\nHow to construct a recursion tree for the recurrence T .n/ D 2T .n=2/ C cn.\nPart (a) shows T .n/, which progressively expands in (b)–(d) to form the recursion tree. The fully\nexpanded tree in part (d) has lg n C 1 levels (i.e., it has height lg n, as indicated), and each level",
    "parent_c19c7315-171c-4854-8782-3f22645f3aa6": "cn/4\ncn/4\nFigure 2.5\nHow to construct a recursion tree for the recurrence T .n/ D 2T .n=2/ C cn.\nPart (a) shows T .n/, which progressively expands in (b)–(d) to form the recursion tree. The fully\nexpanded tree in part (d) has lg n C 1 levels (i.e., it has height lg n, as indicated), and each level\ncontributes a total cost of cn. The total cost, therefore, is cn lg n C cn, which is ‚.n lg n/.\nProblems for Chapter 2\n39\n2.3-3\nUse mathematical induction to show that when n is an exact power of 2, the solu-\ntion of the recurrence\nT .n/ D\n(\n2\nif n D 2 ;\n2T .n=2/ C n\nif n D 2k, for k > 1\nis T .n/ D n lg n.\n2.3-4\nWe can express insertion sort as a recursive procedure as follows. In order to sort\nAŒ1 : : n\u0002, we recursively sort AŒ1 : : n\u00051\u0002 and then insert AŒn\u0002 into the sorted array\nAŒ1 : : n \u0005 1\u0002. Write a recurrence for the running time of this recursive version of\ninsertion sort.\n2.3-5\nReferring back to the searching problem (see Exercise 2.1-3), observe that if the\nsequence A is sorted, we can check the midpoint of the sequence against \u0003 and\neliminate half of the sequence from further consideration. The binary search al-\ngorithm repeats this procedure, halving the size of the remaining portion of the\nsequence each time. Write pseudocode, either iterative or recursive, for binary\nsearch. Argue that the worst-case running time of binary search is ‚.lg n/.\n2.3-6\nObserve that the while loop of lines 5–7 of the INSERTION-SORT procedure in\nSection 2.1 uses a linear search to scan (backward) through the sorted subarray\nAŒ1 : : j \u0005 1\u0002. Can we use a binary search (see Exercise 2.3-5) instead to improve\nthe overall worst-case running time of insertion sort to ‚.n lg n/?\n2.3-7\n?\nDescribe a ‚.n lg n/-time algorithm that, given a set S of n integers and another\ninteger x, determines whether or not there exist two elements in S whose sum is\nexactly x.\nProblems\n2-1\nInsertion sort on small arrays in merge sort\nAlthough merge sort runs in ‚.n lg n/ worst-case time and insertion sort runs",
    "parent_3b0aa89d-17bf-43bc-8b55-06d308d01e8b": "integer x, determines whether or not there exist two elements in S whose sum is\nexactly x.\nProblems\n2-1\nInsertion sort on small arrays in merge sort\nAlthough merge sort runs in ‚.n lg n/ worst-case time and insertion sort runs\nin ‚.n2/ worst-case time, the constant factors in insertion sort can make it faster\nin practice for small problem sizes on many machines. Thus, it makes sense to\ncoarsen the leaves of the recursion by using insertion sort within merge sort when\n40\nChapter 2\nGetting Started\nsubproblems become sufﬁciently small. Consider a modiﬁcation to merge sort in\nwhich n=k sublists of length k are sorted using insertion sort and then merged\nusing the standard merging mechanism, where k is a value to be determined.\na. Show that insertion sort can sort the n=k sublists, each of length k, in ‚.nk/\nworst-case time.\nb. Show how to merge the sublists in ‚.n lg.n=k// worst-case time.\nc. Given that the modiﬁed algorithm runs in ‚.nk C n lg.n=k// worst-case time,\nwhat is the largest value of k as a function of n for which the modiﬁed algorithm\nhas the same running time as standard merge sort, in terms of ‚-notation?\nd. How should we choose k in practice?\n2-2\nCorrectness of bubblesort\nBubblesort is a popular, but inefﬁcient, sorting algorithm. It works by repeatedly\nswapping adjacent elements that are out of order.\nBUBBLESORT.A/\n1\nfor i D 1 to A:length \u0005 1\n2\nfor j D A:length downto i C 1\n3\nif AŒj \u0002 < AŒj \u0005 1\u0002\n4\nexchange AŒj \u0002 with AŒj \u0005 1\u0002\na. Let A0 denote the output of BUBBLESORT.A/. To prove that BUBBLESORT is\ncorrect, we need to prove that it terminates and that\nA0Œ1\u0002 \u0002 A0Œ2\u0002 \u0002 \u0003 \u0003 \u0003 \u0002 A0Œn\u0002 ;\n(2.3)\nwhere n D A:length. In order to show that BUBBLESORT actually sorts, what\nelse do we need to prove?\nThe next two parts will prove inequality (2.3).\nb. State precisely a loop invariant for the for loop in lines 2–4, and prove that this\nloop invariant holds. Your proof should use the structure of the loop invariant\nproof presented in this chapter.",
    "parent_047cd53a-d099-4265-9a1e-ad5b4130ed0d": "else do we need to prove?\nThe next two parts will prove inequality (2.3).\nb. State precisely a loop invariant for the for loop in lines 2–4, and prove that this\nloop invariant holds. Your proof should use the structure of the loop invariant\nproof presented in this chapter.\nc. Using the termination condition of the loop invariant proved in part (b), state\na loop invariant for the for loop in lines 1–4 that will allow you to prove in-\nequality (2.3). Your proof should use the structure of the loop invariant proof\npresented in this chapter.\nProblems for Chapter 2\n41\nd. What is the worst-case running time of bubblesort? How does it compare to the\nrunning time of insertion sort?\n2-3\nCorrectness of Horner’s rule\nThe following code fragment implements Horner’s rule for evaluating a polynomial\nP.x/\nD\nn\nX\nkD0\nakxk\nD\na0 C x.a1 C x.a2 C \u0003 \u0003 \u0003 C x.an\u00031 C xan/ \u0003 \u0003 \u0003// ;\ngiven the coefﬁcients a0; a1; : : : ; an and a value for x:\n1\ny D 0\n2\nfor i D n downto 0\n3\ny D ai C x \u0003 y\na. In terms of ‚-notation, what is the running time of this code fragment for\nHorner’s rule?\nb. Write pseudocode to implement the naive polynomial-evaluation algorithm that\ncomputes each term of the polynomial from scratch. What is the running time\nof this algorithm? How does it compare to Horner’s rule?\nc. Consider the following loop invariant:\nAt the start of each iteration of the for loop of lines 2–3,\ny D\nn\u0003.iC1/\nX\nkD0\nakCiC1xk :\nInterpret a summation with no terms as equaling 0. Following the structure of\nthe loop invariant proof presented in this chapter, use this loop invariant to show\nthat, at termination, y D Pn\nkD0 akxk.\nd. Conclude by arguing that the given code fragment correctly evaluates a poly-\nnomial characterized by the coefﬁcients a0; a1; : : : ; an.\n2-4\nInversions\nLet AŒ1 : : n\u0002 be an array of n distinct numbers. If i < j and AŒi\u0002 > AŒj \u0002, then the\npair .i; j / is called an inversion of A.\na. List the ﬁve inversions of the array h2; 3; 8; 6; 1i.\n42\nChapter 2\nGetting Started",
    "parent_a457deb8-927c-4085-a688-4eafa565cf48": "nomial characterized by the coefﬁcients a0; a1; : : : ; an.\n2-4\nInversions\nLet AŒ1 : : n\u0002 be an array of n distinct numbers. If i < j and AŒi\u0002 > AŒj \u0002, then the\npair .i; j / is called an inversion of A.\na. List the ﬁve inversions of the array h2; 3; 8; 6; 1i.\n42\nChapter 2\nGetting Started\nb. What array with elements from the set f1; 2; : : : ; ng has the most inversions?\nHow many does it have?\nc. What is the relationship between the running time of insertion sort and the\nnumber of inversions in the input array? Justify your answer.\nd. Give an algorithm that determines the number of inversions in any permutation\non n elements in ‚.n lg n/ worst-case time. (Hint: Modify merge sort.)\nChapter notes\nIn 1968, Knuth published the ﬁrst of three volumes with the general title The Art of\nComputer Programming [209, 210, 211]. The ﬁrst volume ushered in the modern\nstudy of computer algorithms with a focus on the analysis of running time, and the\nfull series remains an engaging and worthwhile reference for many of the topics\npresented here. According to Knuth, the word “algorithm” is derived from the\nname “al-Khowˆarizmˆı,” a ninth-century Persian mathematician.\nAho, Hopcroft, and Ullman [5] advocated the asymptotic analysis of algo-\nrithms—using notations that Chapter 3 introduces, including ‚-notation—as a\nmeans of comparing relative performance. They also popularized the use of re-\ncurrence relations to describe the running times of recursive algorithms.\nKnuth [211] provides an encyclopedic treatment of many sorting algorithms. His\ncomparison of sorting algorithms (page 381) includes exact step-counting analyses,\nlike the one we performed here for insertion sort. Knuth’s discussion of insertion\nsort encompasses several variations of the algorithm. The most important of these\nis Shell’s sort, introduced by D. L. Shell, which uses insertion sort on periodic\nsubsequences of the input to produce a faster sorting algorithm.",
    "parent_df0b4625-8339-4876-8992-a6563ca980e7": "sort encompasses several variations of the algorithm. The most important of these\nis Shell’s sort, introduced by D. L. Shell, which uses insertion sort on periodic\nsubsequences of the input to produce a faster sorting algorithm.\nMerge sort is also described by Knuth. He mentions that a mechanical colla-\ntor capable of merging two decks of punched cards in a single pass was invented\nin 1938. J. von Neumann, one of the pioneers of computer science, apparently\nwrote a program for merge sort on the EDVAC computer in 1945.\nThe early history of proving programs correct is described by Gries [153], who\ncredits P. Naur with the ﬁrst article in this ﬁeld. Gries attributes loop invariants to\nR. W. Floyd. The textbook by Mitchell [256] describes more recent progress in\nproving programs correct.\n3\nGrowth of Functions\nThe order of growth of the running time of an algorithm, deﬁned in Chapter 2,\ngives a simple characterization of the algorithm’s efﬁciency and also allows us to\ncompare the relative performance of alternative algorithms. Once the input size n\nbecomes large enough, merge sort, with its ‚.n lg n/ worst-case running time,\nbeats insertion sort, whose worst-case running time is ‚.n2/. Although we can\nsometimes determine the exact running time of an algorithm, as we did for insertion\nsort in Chapter 2, the extra precision is not usually worth the effort of computing\nit. For large enough inputs, the multiplicative constants and lower-order terms of\nan exact running time are dominated by the effects of the input size itself.\nWhen we look at input sizes large enough to make only the order of growth of\nthe running time relevant, we are studying the asymptotic efﬁciency of algorithms.\nThat is, we are concerned with how the running time of an algorithm increases with\nthe size of the input in the limit, as the size of the input increases without bound.\nUsually, an algorithm that is asymptotically more efﬁcient will be the best choice\nfor all but very small inputs.",
    "parent_7926a73b-7b1a-4d5b-a79d-bce847f63762": "That is, we are concerned with how the running time of an algorithm increases with\nthe size of the input in the limit, as the size of the input increases without bound.\nUsually, an algorithm that is asymptotically more efﬁcient will be the best choice\nfor all but very small inputs.\nThis chapter gives several standard methods for simplifying the asymptotic anal-\nysis of algorithms. The next section begins by deﬁning several types of “asymp-\ntotic notation,” of which we have already seen an example in ‚-notation. We then\npresent several notational conventions used throughout this book, and ﬁnally we\nreview the behavior of functions that commonly arise in the analysis of algorithms.\n3.1\nAsymptotic notation\nThe notations we use to describe the asymptotic running time of an algorithm\nare deﬁned in terms of functions whose domains are the set of natural numbers\nN D f0; 1; 2; : : :g. Such notations are convenient for describing the worst-case\nrunning-time function T .n/, which usually is deﬁned only on integer input sizes.\nWe sometimes ﬁnd it convenient, however, to abuse asymptotic notation in a va-\n44\nChapter 3\nGrowth of Functions\nriety of ways. For example, we might extend the notation to the domain of real\nnumbers or, alternatively, restrict it to a subset of the natural numbers. We should\nmake sure, however, to understand the precise meaning of the notation so that when\nwe abuse, we do not misuse it. This section deﬁnes the basic asymptotic notations\nand also introduces some common abuses.\nAsymptotic notation, functions, and running times\nWe will use asymptotic notation primarily to describe the running times of algo-\nrithms, as when we wrote that insertion sort’s worst-case running time is ‚.n2/.\nAsymptotic notation actually applies to functions, however. Recall that we charac-\nterized insertion sort’s worst-case running time as an2CbnCc, for some constants\na, b, and c. By writing that insertion sort’s running time is ‚.n2/, we abstracted",
    "parent_d0aef773-a6e1-414a-b15f-c447f3a3de20": "Asymptotic notation actually applies to functions, however. Recall that we charac-\nterized insertion sort’s worst-case running time as an2CbnCc, for some constants\na, b, and c. By writing that insertion sort’s running time is ‚.n2/, we abstracted\naway some details of this function. Because asymptotic notation applies to func-\ntions, what we were writing as ‚.n2/ was the function an2 C bn C c, which in\nthat case happened to characterize the worst-case running time of insertion sort.\nIn this book, the functions to which we apply asymptotic notation will usually\ncharacterize the running times of algorithms. But asymptotic notation can apply to\nfunctions that characterize some other aspect of algorithms (the amount of space\nthey use, for example), or even to functions that have nothing whatsoever to do\nwith algorithms.\nEven when we use asymptotic notation to apply to the running time of an al-\ngorithm, we need to understand which running time we mean. Sometimes we are\ninterested in the worst-case running time. Often, however, we wish to characterize\nthe running time no matter what the input. In other words, we often wish to make\na blanket statement that covers all inputs, not just the worst case. We shall see\nasymptotic notations that are well suited to characterizing running times no matter\nwhat the input.\n‚-notation\nIn Chapter 2, we found that the worst-case running time of insertion sort is\nT .n/ D ‚.n2/. Let us deﬁne what this notation means. For a given function g.n/,\nwe denote by ‚.g.n// the set of functions\n‚.g.n// D ff .n/ W there exist positive constants c1, c2, and n0 such that\n0 \u0002 c1g.n/ \u0002 f .n/ \u0002 c2g.n/ for all n \u0006 n0g :1\n1Within set notation, a colon means “such that.”\n3.1\nAsymptotic notation\n45\n(b)\n(c)\n(a)\nn\nn\nn\nn0\nn0\nn0\nf .n/ D ‚.g.n//\nf .n/ D O.g.n//\nf .n/ D \u0004.g.n//\nf .n/\nf .n/\nf .n/\ncg.n/\ncg.n/\nc1g.n/\nc2g.n/\nFigure 3.1\nGraphic examples of the ‚, O, and \u0004 notations. In each part, the value of n0 shown",
    "parent_43f5836c-9b69-43a9-98ad-ff94d7653265": "1Within set notation, a colon means “such that.”\n3.1\nAsymptotic notation\n45\n(b)\n(c)\n(a)\nn\nn\nn\nn0\nn0\nn0\nf .n/ D ‚.g.n//\nf .n/ D O.g.n//\nf .n/ D \u0004.g.n//\nf .n/\nf .n/\nf .n/\ncg.n/\ncg.n/\nc1g.n/\nc2g.n/\nFigure 3.1\nGraphic examples of the ‚, O, and \u0004 notations. In each part, the value of n0 shown\nis the minimum possible value; any greater value would also work. (a) ‚-notation bounds a func-\ntion to within constant factors. We write f .n/ D ‚.g.n// if there exist positive constants n0, c1,\nand c2 such that at and to the right of n0, the value of f .n/ always lies between c1g.n/ and c2g.n/\ninclusive. (b) O-notation gives an upper bound for a function to within a constant factor. We write\nf .n/ D O.g.n// if there are positive constants n0 and c such that at and to the right of n0, the value\nof f .n/ always lies on or below cg.n/. (c) \u0004-notation gives a lower bound for a function to within\na constant factor. We write f .n/ D \u0004.g.n// if there are positive constants n0 and c such that at and\nto the right of n0, the value of f .n/ always lies on or above cg.n/.\nA function f .n/ belongs to the set ‚.g.n// if there exist positive constants c1\nand c2 such that it can be “sandwiched” between c1g.n/ and c2g.n/, for sufﬁ-\nciently large n. Because ‚.g.n// is a set, we could write “f .n/ 2 ‚.g.n//”\nto indicate that f .n/ is a member of ‚.g.n//. Instead, we will usually write\n“f .n/ D ‚.g.n//” to express the same notion. You might be confused because\nwe abuse equality in this way, but we shall see later in this section that doing so\nhas its advantages.\nFigure 3.1(a) gives an intuitive picture of functions f .n/ and g.n/, where\nf .n/ D ‚.g.n//. For all values of n at and to the right of n0, the value of f .n/\nlies at or above c1g.n/ and at or below c2g.n/. In other words, for all n \u0006 n0, the\nfunction f .n/ is equal to g.n/ to within a constant factor. We say that g.n/ is an\nasymptotically tight bound for f .n/.\nThe deﬁnition of ‚.g.n// requires that every member f .n/ 2 ‚.g.n// be",
    "parent_e9b55476-1249-4def-ac3d-be9022c5cb6d": "lies at or above c1g.n/ and at or below c2g.n/. In other words, for all n \u0006 n0, the\nfunction f .n/ is equal to g.n/ to within a constant factor. We say that g.n/ is an\nasymptotically tight bound for f .n/.\nThe deﬁnition of ‚.g.n// requires that every member f .n/ 2 ‚.g.n// be\nasymptotically nonnegative, that is, that f .n/ be nonnegative whenever n is suf-\nﬁciently large. (An asymptotically positive function is one that is positive for all\nsufﬁciently large n.) Consequently, the function g.n/ itself must be asymptotically\nnonnegative, or else the set ‚.g.n// is empty. We shall therefore assume that every\nfunction used within ‚-notation is asymptotically nonnegative. This assumption\nholds for the other asymptotic notations deﬁned in this chapter as well.\n46\nChapter 3\nGrowth of Functions\nIn Chapter 2, we introduced an informal notion of ‚-notation that amounted\nto throwing away lower-order terms and ignoring the leading coefﬁcient of the\nhighest-order term. Let us brieﬂy justify this intuition by using the formal deﬁ-\nnition to show that 1\n2n2 \u0005 3n D ‚.n2/. To do so, we must determine positive\nconstants c1, c2, and n0 such that\nc1n2 \u0002 1\n2n2 \u0005 3n \u0002 c2n2\nfor all n \u0006 n0. Dividing by n2 yields\nc1 \u0002 1\n2 \u0005 3\nn \u0002 c2 :\nWe can make the right-hand inequality hold for any value of n \u0006 1 by choosing any\nconstant c2 \u0006 1=2. Likewise, we can make the left-hand inequality hold for any\nvalue of n \u0006 7 by choosing any constant c1 \u0002 1=14. Thus, by choosing c1 D 1=14,\nc2 D 1=2, and n0 D 7, we can verify that 1\n2n2 \u0005 3n D ‚.n2/. Certainly, other\nchoices for the constants exist, but the important thing is that some choice exists.\nNote that these constants depend on the function 1\n2n2 \u0005 3n; a different function\nbelonging to ‚.n2/ would usually require different constants.\nWe can also use the formal deﬁnition to verify that 6n3 ¤ ‚.n2/. Suppose\nfor the purpose of contradiction that c2 and n0 exist such that 6n3 \u0002 c2n2 for",
    "parent_87975ce8-fbd8-43c8-ad69-cb9de07a5903": "Note that these constants depend on the function 1\n2n2 \u0005 3n; a different function\nbelonging to ‚.n2/ would usually require different constants.\nWe can also use the formal deﬁnition to verify that 6n3 ¤ ‚.n2/. Suppose\nfor the purpose of contradiction that c2 and n0 exist such that 6n3 \u0002 c2n2 for\nall n \u0006 n0. But then dividing by n2 yields n \u0002 c2=6, which cannot possibly hold\nfor arbitrarily large n, since c2 is constant.\nIntuitively, the lower-order terms of an asymptotically positive function can be\nignored in determining asymptotically tight bounds because they are insigniﬁcant\nfor large n. When n is large, even a tiny fraction of the highest-order term suf-\nﬁces to dominate the lower-order terms. Thus, setting c1 to a value that is slightly\nsmaller than the coefﬁcient of the highest-order term and setting c2 to a value that\nis slightly larger permits the inequalities in the deﬁnition of ‚-notation to be sat-\nisﬁed. The coefﬁcient of the highest-order term can likewise be ignored, since it\nonly changes c1 and c2 by a constant factor equal to the coefﬁcient.\nAs an example, consider any quadratic function f .n/ D an2 C bn C c, where\na, b, and c are constants and a > 0. Throwing away the lower-order terms and\nignoring the constant yields f .n/ D ‚.n2/. Formally, to show the same thing, we\ntake the constants c1 D a=4, c2 D 7a=4, and n0 D 2 \u0003 max.jbj =a;\np\njcj =a/. You\nmay verify that 0 \u0002 c1n2 \u0002 an2 C bn C c \u0002 c2n2 for all n \u0006 n0. In general,\nfor any polynomial p.n/ D Pd\niD0 aini, where the ai are constants and ad > 0, we\nhave p.n/ D ‚.nd/ (see Problem 3-1).\nSince any constant is a degree-0 polynomial, we can express any constant func-\ntion as ‚.n0/, or ‚.1/. This latter notation is a minor abuse, however, because the\n3.1\nAsymptotic notation\n47\nexpression does not indicate what variable is tending to inﬁnity.2 We shall often\nuse the notation ‚.1/ to mean either a constant or a constant function with respect\nto some variable.\nO-notation",
    "parent_55ac2640-188f-4888-9861-dc5291623826": "3.1\nAsymptotic notation\n47\nexpression does not indicate what variable is tending to inﬁnity.2 We shall often\nuse the notation ‚.1/ to mean either a constant or a constant function with respect\nto some variable.\nO-notation\nThe ‚-notation asymptotically bounds a function from above and below. When\nwe have only an asymptotic upper bound, we use O-notation. For a given func-\ntion g.n/, we denote by O.g.n// (pronounced “big-oh of g of n” or sometimes\njust “oh of g of n”) the set of functions\nO.g.n// D ff .n/ W there exist positive constants c and n0 such that\n0 \u0002 f .n/ \u0002 cg.n/ for all n \u0006 n0g :\nWe use O-notation to give an upper bound on a function, to within a constant\nfactor. Figure 3.1(b) shows the intuition behind O-notation. For all values n at and\nto the right of n0, the value of the function f .n/ is on or below cg.n/.\nWe write f .n/ D O.g.n// to indicate that a function f .n/ is a member of the\nset O.g.n//. Note that f .n/ D ‚.g.n// implies f .n/ D O.g.n//, since ‚-\nnotation is a stronger notion than O-notation. Written set-theoretically, we have\n‚.g.n// \u0007 O.g.n//. Thus, our proof that any quadratic function an2 C bn C c,\nwhere a > 0, is in ‚.n2/ also shows that any such quadratic function is in O.n2/.\nWhat may be more surprising is that when a > 0, any linear function an C b is\nin O.n2/, which is easily veriﬁed by taking c D a C jbj and n0 D max.1; \u0005b=a/.\nIf you have seen O-notation before, you might ﬁnd it strange that we should\nwrite, for example, n D O.n2/. In the literature, we sometimes ﬁnd O-notation\ninformally describing asymptotically tight bounds, that is, what we have deﬁned\nusing ‚-notation. In this book, however, when we write f .n/ D O.g.n//, we\nare merely claiming that some constant multiple of g.n/ is an asymptotic upper\nbound on f .n/, with no claim about how tight an upper bound it is. Distinguish-\ning asymptotic upper bounds from asymptotically tight bounds is standard in the\nalgorithms literature.",
    "parent_49033fcf-71c8-4ed1-bb24-9e8a46228afd": "are merely claiming that some constant multiple of g.n/ is an asymptotic upper\nbound on f .n/, with no claim about how tight an upper bound it is. Distinguish-\ning asymptotic upper bounds from asymptotically tight bounds is standard in the\nalgorithms literature.\nUsing O-notation, we can often describe the running time of an algorithm\nmerely by inspecting the algorithm’s overall structure. For example, the doubly\nnested loop structure of the insertion sort algorithm from Chapter 2 immediately\nyields an O.n2/ upper bound on the worst-case running time: the cost of each it-\neration of the inner loop is bounded from above by O.1/ (constant), the indices i\n2The real problem is that our ordinary notation for functions does not distinguish functions from\nvalues. In \u0005-calculus, the parameters to a function are clearly speciﬁed: the function n2 could be\nwritten as \u0005n:n2, or even \u0005r:r2. Adopting a more rigorous notation, however, would complicate\nalgebraic manipulations, and so we choose to tolerate the abuse.\n48\nChapter 3\nGrowth of Functions\nand j are both at most n, and the inner loop is executed at most once for each of\nthe n2 pairs of values for i and j .\nSince O-notation describes an upper bound, when we use it to bound the worst-\ncase running time of an algorithm, we have a bound on the running time of the algo-\nrithm on every input—the blanket statement we discussed earlier. Thus, the O.n2/\nbound on worst-case running time of insertion sort also applies to its running time\non every input. The ‚.n2/ bound on the worst-case running time of insertion sort,\nhowever, does not imply a ‚.n2/ bound on the running time of insertion sort on\nevery input. For example, we saw in Chapter 2 that when the input is already\nsorted, insertion sort runs in ‚.n/ time.\nTechnically, it is an abuse to say that the running time of insertion sort is O.n2/,\nsince for a given n, the actual running time varies, depending on the particular",
    "parent_9d890a98-c47d-40e1-89aa-3ee99e8b9218": "every input. For example, we saw in Chapter 2 that when the input is already\nsorted, insertion sort runs in ‚.n/ time.\nTechnically, it is an abuse to say that the running time of insertion sort is O.n2/,\nsince for a given n, the actual running time varies, depending on the particular\ninput of size n. When we say “the running time is O.n2/,” we mean that there is a\nfunction f .n/ that is O.n2/ such that for any value of n, no matter what particular\ninput of size n is chosen, the running time on that input is bounded from above by\nthe value f .n/. Equivalently, we mean that the worst-case running time is O.n2/.\n\u0002-notation\nJust as O-notation provides an asymptotic upper bound on a function, \u0004-notation\nprovides an asymptotic lower bound.\nFor a given function g.n/, we denote\nby \u0004.g.n// (pronounced “big-omega of g of n” or sometimes just “omega of g\nof n”) the set of functions\n\u0004.g.n// D ff .n/ W there exist positive constants c and n0 such that\n0 \u0002 cg.n/ \u0002 f .n/ for all n \u0006 n0g :\nFigure 3.1(c) shows the intuition behind \u0004-notation. For all values n at or to the\nright of n0, the value of f .n/ is on or above cg.n/.\nFrom the deﬁnitions of the asymptotic notations we have seen thus far, it is easy\nto prove the following important theorem (see Exercise 3.1-5).\nTheorem 3.1\nFor any two functions f .n/ and g.n/, we have f .n/ D ‚.g.n// if and only if\nf .n/ D O.g.n// and f .n/ D \u0004.g.n//.\nAs an example of the application of this theorem, our proof that an2 C bn C c D\n‚.n2/ for any constants a, b, and c, where a > 0, immediately implies that\nan2 C bn C c D \u0004.n2/ and an2 CbnCc D O.n2/. In practice, rather than using\nTheorem 3.1 to obtain asymptotic upper and lower bounds from asymptotically\ntight bounds, as we did for this example, we usually use it to prove asymptotically\ntight bounds from asymptotic upper and lower bounds.\n3.1\nAsymptotic notation\n49\nWhen we say that the running time (no modiﬁer) of an algorithm is \u0004.g.n//,",
    "parent_02985d64-d0ee-400a-855c-59641e24f5ba": "tight bounds, as we did for this example, we usually use it to prove asymptotically\ntight bounds from asymptotic upper and lower bounds.\n3.1\nAsymptotic notation\n49\nWhen we say that the running time (no modiﬁer) of an algorithm is \u0004.g.n//,\nwe mean that no matter what particular input of size n is chosen for each value\nof n, the running time on that input is at least a constant times g.n/, for sufﬁciently\nlarge n. Equivalently, we are giving a lower bound on the best-case running time\nof an algorithm. For example, the best-case running time of insertion sort is \u0004.n/,\nwhich implies that the running time of insertion sort is \u0004.n/.\nThe running time of insertion sort therefore belongs to both \u0004.n/ and O.n2/,\nsince it falls anywhere between a linear function of n and a quadratic function of n.\nMoreover, these bounds are asymptotically as tight as possible: for instance, the\nrunning time of insertion sort is not \u0004.n2/, since there exists an input for which\ninsertion sort runs in ‚.n/ time (e.g., when the input is already sorted). It is not\ncontradictory, however, to say that the worst-case running time of insertion sort\nis \u0004.n2/, since there exists an input that causes the algorithm to take \u0004.n2/ time.\nAsymptotic notation in equations and inequalities\nWe have already seen how asymptotic notation can be used within mathematical\nformulas. For example, in introducing O-notation, we wrote “n D O.n2/.” We\nmight also write 2n2 C3nC1 D 2n2 C‚.n/. How do we interpret such formulas?\nWhen the asymptotic notation stands alone (that is, not within a larger formula)\non the right-hand side of an equation (or inequality), as in n D O.n2/, we have\nalready deﬁned the equal sign to mean set membership: n 2 O.n2/. In general,\nhowever, when asymptotic notation appears in a formula, we interpret it as stand-\ning for some anonymous function that we do not care to name. For example, the\nformula 2n2 C 3n C 1 D 2n2 C ‚.n/ means that 2n2 C 3n C 1 D 2n2 C f .n/,",
    "parent_07a6388a-9083-4dee-890b-3cc8f6c490d4": "however, when asymptotic notation appears in a formula, we interpret it as stand-\ning for some anonymous function that we do not care to name. For example, the\nformula 2n2 C 3n C 1 D 2n2 C ‚.n/ means that 2n2 C 3n C 1 D 2n2 C f .n/,\nwhere f .n/ is some function in the set ‚.n/. In this case, we let f .n/ D 3n C 1,\nwhich indeed is in ‚.n/.\nUsing asymptotic notation in this manner can help eliminate inessential detail\nand clutter in an equation. For example, in Chapter 2 we expressed the worst-case\nrunning time of merge sort as the recurrence\nT .n/ D 2T .n=2/ C ‚.n/ :\nIf we are interested only in the asymptotic behavior of T .n/, there is no point in\nspecifying all the lower-order terms exactly; they are all understood to be included\nin the anonymous function denoted by the term ‚.n/.\nThe number of anonymous functions in an expression is understood to be equal\nto the number of times the asymptotic notation appears. For example, in the ex-\npression\nn\nX\niD1\nO.i/ ;\n50\nChapter 3\nGrowth of Functions\nthere is only a single anonymous function (a function of i). This expression is thus\nnot the same as O.1/ C O.2/ C \u0003 \u0003 \u0003 C O.n/, which doesn’t really have a clean\ninterpretation.\nIn some cases, asymptotic notation appears on the left-hand side of an equation,\nas in\n2n2 C ‚.n/ D ‚.n2/ :\nWe interpret such equations using the following rule: No matter how the anony-\nmous functions are chosen on the left of the equal sign, there is a way to choose\nthe anonymous functions on the right of the equal sign to make the equation valid.\nThus, our example means that for any function f .n/ 2 ‚.n/, there is some func-\ntion g.n/ 2 ‚.n2/ such that 2n2 C f .n/ D g.n/ for all n. In other words, the\nright-hand side of an equation provides a coarser level of detail than the left-hand\nside.\nWe can chain together a number of such relationships, as in\n2n2 C 3n C 1\nD\n2n2 C ‚.n/\nD\n‚.n2/ :\nWe can interpret each equation separately by the rules above.\nThe ﬁrst equa-",
    "parent_fa776cdd-a0a4-41fd-9798-0beb5331e670": "right-hand side of an equation provides a coarser level of detail than the left-hand\nside.\nWe can chain together a number of such relationships, as in\n2n2 C 3n C 1\nD\n2n2 C ‚.n/\nD\n‚.n2/ :\nWe can interpret each equation separately by the rules above.\nThe ﬁrst equa-\ntion says that there is some function f .n/ 2 ‚.n/ such that 2n2 C 3n C 1 D\n2n2 C f .n/ for all n. The second equation says that for any function g.n/ 2 ‚.n/\n(such as the f .n/ just mentioned), there is some function h.n/ 2 ‚.n2/ such\nthat 2n2 C g.n/ D h.n/ for all n.\nNote that this interpretation implies that\n2n2 C 3n C 1 D ‚.n2/, which is what the chaining of equations intuitively gives\nus.\no-notation\nThe asymptotic upper bound provided by O-notation may or may not be asymp-\ntotically tight. The bound 2n2 D O.n2/ is asymptotically tight, but the bound\n2n D O.n2/ is not. We use o-notation to denote an upper bound that is not asymp-\ntotically tight. We formally deﬁne o.g.n// (“little-oh of g of n”) as the set\no.g.n// D ff .n/ W for any positive constant c > 0, there exists a constant\nn0 > 0 such that 0 \u0002 f .n/ < cg.n/ for all n \u0006 n0g :\nFor example, 2n D o.n2/, but 2n2 ¤ o.n2/.\nThe deﬁnitions of O-notation and o-notation are similar. The main difference\nis that in f .n/ D O.g.n//, the bound 0 \u0002 f .n/ \u0002 cg.n/ holds for some con-\nstant c > 0, but in f .n/ D o.g.n//, the bound 0 \u0002 f .n/ < cg.n/ holds for all\nconstants c > 0. Intuitively, in o-notation, the function f .n/ becomes insigniﬁcant\nrelative to g.n/ as n approaches inﬁnity; that is,\n3.1\nAsymptotic notation\n51\nlim\nn!1\nf .n/\ng.n/ D 0 :\n(3.1)\nSome authors use this limit as a deﬁnition of the o-notation; the deﬁnition in this\nbook also restricts the anonymous functions to be asymptotically nonnegative.\n!-notation\nBy analogy, !-notation is to \u0004-notation as o-notation is to O-notation. We use\n!-notation to denote a lower bound that is not asymptotically tight. One way to\ndeﬁne it is by\nf .n/ 2 !.g.n// if and only if g.n/ 2 o.f .n// :",
    "parent_cc5f49c6-9501-4f26-a70b-b6f721aa2beb": "!-notation\nBy analogy, !-notation is to \u0004-notation as o-notation is to O-notation. We use\n!-notation to denote a lower bound that is not asymptotically tight. One way to\ndeﬁne it is by\nf .n/ 2 !.g.n// if and only if g.n/ 2 o.f .n// :\nFormally, however, we deﬁne !.g.n// (“little-omega of g of n”) as the set\n!.g.n// D ff .n/ W for any positive constant c > 0, there exists a constant\nn0 > 0 such that 0 \u0002 cg.n/ < f .n/ for all n \u0006 n0g :\nFor example, n2=2 D !.n/, but n2=2 ¤ !.n2/. The relation f .n/ D !.g.n//\nimplies that\nlim\nn!1\nf .n/\ng.n/ D 1 ;\nif the limit exists. That is, f .n/ becomes arbitrarily large relative to g.n/ as n\napproaches inﬁnity.\nComparing functions\nMany of the relational properties of real numbers apply to asymptotic comparisons\nas well. For the following, assume that f .n/ and g.n/ are asymptotically positive.\nTransitivity:\nf .n/ D ‚.g.n// and g.n/ D ‚.h.n//\nimply\nf .n/ D ‚.h.n// ;\nf .n/ D O.g.n// and g.n/ D O.h.n//\nimply\nf .n/ D O.h.n// ;\nf .n/ D \u0004.g.n// and g.n/ D \u0004.h.n//\nimply\nf .n/ D \u0004.h.n// ;\nf .n/ D o.g.n//\nand g.n/ D o.h.n//\nimply\nf .n/ D o.h.n// ;\nf .n/ D !.g.n// and g.n/ D !.h.n//\nimply\nf .n/ D !.h.n// :\nReﬂexivity:\nf .n/\nD\n‚.f .n// ;\nf .n/\nD\nO.f .n// ;\nf .n/\nD\n\u0004.f .n// :\n52\nChapter 3\nGrowth of Functions\nSymmetry:\nf .n/ D ‚.g.n// if and only if g.n/ D ‚.f .n// :\nTranspose symmetry:\nf .n/ D O.g.n// if and only if g.n/ D \u0004.f .n// ;\nf .n/ D o.g.n//\nif and only if g.n/ D !.f .n// :\nBecause these properties hold for asymptotic notations, we can draw an analogy\nbetween the asymptotic comparison of two functions f and g and the comparison\nof two real numbers a and b:\nf .n/ D O.g.n//\nis like\na \u0002 b ;\nf .n/ D \u0004.g.n//\nis like\na \u0006 b ;\nf .n/ D ‚.g.n//\nis like\na D b ;\nf .n/ D o.g.n//\nis like\na < b ;\nf .n/ D !.g.n//\nis like\na > b :\nWe say that f .n/ is asymptotically smaller than g.n/ if f .n/ D o.g.n//, and f .n/\nis asymptotically larger than g.n/ if f .n/ D !.g.n//.\nOne property of real numbers, however, does not carry over to asymptotic nota-\ntion:",
    "parent_645028f2-22d0-4864-84f9-7610d46e77a3": "a D b ;\nf .n/ D o.g.n//\nis like\na < b ;\nf .n/ D !.g.n//\nis like\na > b :\nWe say that f .n/ is asymptotically smaller than g.n/ if f .n/ D o.g.n//, and f .n/\nis asymptotically larger than g.n/ if f .n/ D !.g.n//.\nOne property of real numbers, however, does not carry over to asymptotic nota-\ntion:\nTrichotomy: For any two real numbers a and b, exactly one of the following must\nhold: a < b, a D b, or a > b.\nAlthough any two real numbers can be compared, not all functions are asymptot-\nically comparable. That is, for two functions f .n/ and g.n/, it may be the case\nthat neither f .n/ D O.g.n// nor f .n/ D \u0004.g.n// holds. For example, we cannot\ncompare the functions n and n1Csin n using asymptotic notation, since the value of\nthe exponent in n1Csin n oscillates between 0 and 2, taking on all values in between.\nExercises\n3.1-1\nLet f .n/ and g.n/ be asymptotically nonnegative functions. Using the basic deﬁ-\nnition of ‚-notation, prove that max.f .n/; g.n// D ‚.f .n/ C g.n//.\n3.1-2\nShow that for any real constants a and b, where b > 0,\n.n C a/b D ‚.nb/ :\n(3.2)\n3.2\nStandard notations and common functions\n53\n3.1-3\nExplain why the statement, “The running time of algorithm A is at least O.n2/,” is\nmeaningless.\n3.1-4\nIs 2nC1 D O.2n/? Is 22n D O.2n/?\n3.1-5\nProve Theorem 3.1.\n3.1-6\nProve that the running time of an algorithm is ‚.g.n// if and only if its worst-case\nrunning time is O.g.n// and its best-case running time is \u0004.g.n//.\n3.1-7\nProve that o.g.n// \\ !.g.n// is the empty set.\n3.1-8\nWe can extend our notation to the case of two parameters n and m that can go to\ninﬁnity independently at different rates. For a given function g.n; m/, we denote\nby O.g.n; m// the set of functions\nO.g.n; m// D ff .n; m/ W there exist positive constants c, n0, and m0\nsuch that 0 \u0002 f .n; m/ \u0002 cg.n; m/\nfor all n \u0006 n0 or m \u0006 m0g :\nGive corresponding deﬁnitions for \u0004.g.n; m// and ‚.g.n; m//.\n3.2\nStandard notations and common functions",
    "parent_47647ccf-1234-4585-88e3-2948ad02a663": "by O.g.n; m// the set of functions\nO.g.n; m// D ff .n; m/ W there exist positive constants c, n0, and m0\nsuch that 0 \u0002 f .n; m/ \u0002 cg.n; m/\nfor all n \u0006 n0 or m \u0006 m0g :\nGive corresponding deﬁnitions for \u0004.g.n; m// and ‚.g.n; m//.\n3.2\nStandard notations and common functions\nThis section reviews some standard mathematical functions and notations and ex-\nplores the relationships among them. It also illustrates the use of the asymptotic\nnotations.\nMonotonicity\nA function f .n/ is monotonically increasing if m \u0002 n implies f .m/ \u0002 f .n/.\nSimilarly, it is monotonically decreasing if m \u0002 n implies f .m/ \u0006 f .n/. A\nfunction f .n/ is strictly increasing if m < n implies f .m/ < f .n/ and strictly\ndecreasing if m < n implies f .m/ > f .n/.\n54\nChapter 3\nGrowth of Functions\nFloors and ceilings\nFor any real number x, we denote the greatest integer less than or equal to x by bxc\n(read “the ﬂoor of x”) and the least integer greater than or equal to x by dxe (read\n“the ceiling of x”). For all real x,\nx \u0005 1 < bxc \u0002 x \u0002 dxe < x C 1 :\n(3.3)\nFor any integer n,\ndn=2e C bn=2c D n ;\nand for any real number x \u0006 0 and integers a; b > 0,\n\u0006dx=ae\nb\n\u0007\nD\nl x\nab\nm\n;\n(3.4)\n\bbx=ac\nb\n\t\nD\nj x\nab\nk\n;\n(3.5)\nla\nb\nm\n\u0002\na C .b \u0005 1/\nb\n;\n(3.6)\nja\nb\nk\n\u0006\na \u0005 .b \u0005 1/\nb\n:\n(3.7)\nThe ﬂoor function f .x/ D bxc is monotonically increasing, as is the ceiling func-\ntion f .x/ D dxe.\nModular arithmetic\nFor any integer a and any positive integer n, the value a mod n is the remainder\n(or residue) of the quotient a=n:\na mod n D a \u0005 n ba=nc :\n(3.8)\nIt follows that\n0 \u0002 a mod n < n :\n(3.9)\nGiven a well-deﬁned notion of the remainder of one integer when divided by an-\nother, it is convenient to provide special notation to indicate equality of remainders.\nIf .a mod n/ D .b mod n/, we write a \b b .mod n/ and say that a is equivalent\nto b, modulo n. In other words, a \b b .mod n/ if a and b have the same remain-\nder when divided by n. Equivalently, a \b b .mod n/ if and only if n is a divisor",
    "parent_4a7d0645-d533-4388-a2ba-e721b25ec28c": "If .a mod n/ D .b mod n/, we write a \b b .mod n/ and say that a is equivalent\nto b, modulo n. In other words, a \b b .mod n/ if a and b have the same remain-\nder when divided by n. Equivalently, a \b b .mod n/ if and only if n is a divisor\nof b \u0005 a. We write a 6\b b .mod n/ if a is not equivalent to b, modulo n.\n3.2\nStandard notations and common functions\n55\nPolynomials\nGiven a nonnegative integer d, a polynomial in n of degree d is a function p.n/\nof the form\np.n/ D\nd\nX\niD0\naini ;\nwhere the constants a0; a1; : : : ; ad are the coefﬁcients of the polynomial and\nad ¤ 0. A polynomial is asymptotically positive if and only if ad > 0. For an\nasymptotically positive polynomial p.n/ of degree d, we have p.n/ D ‚.nd/. For\nany real constant a \u0006 0, the function na is monotonically increasing, and for any\nreal constant a \u0002 0, the function na is monotonically decreasing. We say that a\nfunction f .n/ is polynomially bounded if f .n/ D O.nk/ for some constant k.\nExponentials\nFor all real a > 0, m, and n, we have the following identities:\na0\nD\n1 ;\na1\nD\na ;\na\u00031\nD\n1=a ;\n.am/n\nD\namn ;\n.am/n\nD\n.an/m ;\naman\nD\namCn :\nFor all n and a \u0006 1, the function an is monotonically increasing in n. When\nconvenient, we shall assume 00 D 1.\nWe can relate the rates of growth of polynomials and exponentials by the fol-\nlowing fact. For all real constants a and b such that a > 1,\nlim\nn!1\nnb\nan D 0 ;\n(3.10)\nfrom which we can conclude that\nnb D o.an/ :\nThus, any exponential function with a base strictly greater than 1 grows faster than\nany polynomial function.\nUsing e to denote 2:71828 : : :, the base of the natural logarithm function, we\nhave for all real x,\nex D 1 C x C x2\n2Š C x3\n3Š C \u0003 \u0003 \u0003 D\n1\nX\niD0\nxi\niŠ ;\n(3.11)\n56\nChapter 3\nGrowth of Functions\nwhere “Š” denotes the factorial function deﬁned later in this section. For all real x,\nwe have the inequality\nex \u0006 1 C x ;\n(3.12)\nwhere equality holds only when x D 0. When jxj \u0002 1, we have the approximation\n1 C x \u0002 ex \u0002 1 C x C x2 :\n(3.13)",
    "parent_bc69fb86-9697-4747-b083-0761976499af": "1\nX\niD0\nxi\niŠ ;\n(3.11)\n56\nChapter 3\nGrowth of Functions\nwhere “Š” denotes the factorial function deﬁned later in this section. For all real x,\nwe have the inequality\nex \u0006 1 C x ;\n(3.12)\nwhere equality holds only when x D 0. When jxj \u0002 1, we have the approximation\n1 C x \u0002 ex \u0002 1 C x C x2 :\n(3.13)\nWhen x ! 0, the approximation of ex by 1 C x is quite good:\nex D 1 C x C ‚.x2/ :\n(In this equation, the asymptotic notation is used to describe the limiting behavior\nas x ! 0 rather than as x ! 1.) We have for all x,\nlim\nn!1\n\u0004\n1 C x\nn\n\u0005n\nD ex :\n(3.14)\nLogarithms\nWe shall use the following notations:\nlg n\nD\nlog2 n\n(binary logarithm) ,\nln n\nD\nloge n\n(natural logarithm) ,\nlgk n\nD\n.lg n/k\n(exponentiation) ,\nlg lg n\nD\nlg.lg n/\n(composition) .\nAn important notational convention we shall adopt is that logarithm functions will\napply only to the next term in the formula, so that lg n C k will mean .lg n/ C k\nand not lg.n C k/. If we hold b > 1 constant, then for n > 0, the function logb n\nis strictly increasing.\nFor all real a > 0, b > 0, c > 0, and n,\na\nD\nblogb a ;\nlogc.ab/\nD\nlogc a C logc b ;\nlogb an\nD\nn logb a ;\nlogb a\nD\nlogc a\nlogc b ;\n(3.15)\nlogb.1=a/\nD\n\u0005 logb a ;\nlogb a\nD\n1\nloga b ;\nalogb c\nD\nclogb a ;\n(3.16)\nwhere, in each equation above, logarithm bases are not 1.\n3.2\nStandard notations and common functions\n57\nBy equation (3.15), changing the base of a logarithm from one constant to an-\nother changes the value of the logarithm by only a constant factor, and so we shall\noften use the notation “lg n” when we don’t care about constant factors, such as in\nO-notation. Computer scientists ﬁnd 2 to be the most natural base for logarithms\nbecause so many algorithms and data structures involve splitting a problem into\ntwo parts.\nThere is a simple series expansion for ln.1 C x/ when jxj < 1:\nln.1 C x/ D x \u0005 x2\n2 C x3\n3 \u0005 x4\n4 C x5\n5 \u0005 \u0003 \u0003 \u0003 :\nWe also have the following inequalities for x > \u00051:\nx\n1 C x \u0002 ln.1 C x/ \u0002 x ;\n(3.17)\nwhere equality holds only for x D 0.",
    "parent_22808493-9f36-4c0d-9f25-84d9ed017db2": "two parts.\nThere is a simple series expansion for ln.1 C x/ when jxj < 1:\nln.1 C x/ D x \u0005 x2\n2 C x3\n3 \u0005 x4\n4 C x5\n5 \u0005 \u0003 \u0003 \u0003 :\nWe also have the following inequalities for x > \u00051:\nx\n1 C x \u0002 ln.1 C x/ \u0002 x ;\n(3.17)\nwhere equality holds only for x D 0.\nWe say that a function f .n/ is polylogarithmically bounded if f .n/ D O.lgk n/\nfor some constant k. We can relate the growth of polynomials and polylogarithms\nby substituting lg n for n and 2a for a in equation (3.10), yielding\nlim\nn!1\nlgb n\n.2a/lg n D lim\nn!1\nlgb n\nna\nD 0 :\nFrom this limit, we can conclude that\nlgb n D o.na/\nfor any constant a > 0. Thus, any positive polynomial function grows faster than\nany polylogarithmic function.\nFactorials\nThe notation nŠ (read “n factorial”) is deﬁned for integers n \u0006 0 as\nnŠ D\n(\n1\nif n D 0 ;\nn \u0003 .n \u0005 1/Š\nif n > 0 :\nThus, nŠ D 1 \u0003 2 \u0003 3 \u0003 \u0003 \u0003 n.\nA weak upper bound on the factorial function is nŠ \u0002 nn, since each of the n\nterms in the factorial product is at most n. Stirling’s approximation,\nnŠ D\np\n2\u0006n\n\u0004n\ne\n\u0005n \u0002\n1 C ‚\n\u00021\nn\n\u0003\u0003\n;\n(3.18)\n58\nChapter 3\nGrowth of Functions\nwhere e is the base of the natural logarithm, gives us a tighter upper bound, and a\nlower bound as well. As Exercise 3.2-3 asks you to prove,\nnŠ\nD\no.nn/ ;\nnŠ\nD\n!.2n/ ;\nlg.nŠ/\nD\n‚.n lg n/ ;\n(3.19)\nwhere Stirling’s approximation is helpful in proving equation (3.19). The following\nequation also holds for all n \u0006 1:\nnŠ D\np\n2\u0006n\n\u0004n\ne\n\u0005n\ne˛n\n(3.20)\nwhere\n1\n12n C 1 < ˛n <\n1\n12n :\n(3.21)\nFunctional iteration\nWe use the notation f .i/.n/ to denote the function f .n/ iteratively applied i times\nto an initial value of n. Formally, let f .n/ be a function over the reals. For non-\nnegative integers i, we recursively deﬁne\nf .i/.n/ D\n(\nn\nif i D 0 ;\nf .f .i\u00031/.n//\nif i > 0 :\nFor example, if f .n/ D 2n, then f .i/.n/ D 2in.\nThe iterated logarithm function\nWe use the notation lg\u0004 n (read “log star of n”) to denote the iterated logarithm, de-\nﬁned as follows. Let lg.i/ n be as deﬁned above, with f .n/ D lg n. Because the log-",
    "parent_ea2bbf29-1b63-4b8f-b8fe-92ef53b92cfb": "(\nn\nif i D 0 ;\nf .f .i\u00031/.n//\nif i > 0 :\nFor example, if f .n/ D 2n, then f .i/.n/ D 2in.\nThe iterated logarithm function\nWe use the notation lg\u0004 n (read “log star of n”) to denote the iterated logarithm, de-\nﬁned as follows. Let lg.i/ n be as deﬁned above, with f .n/ D lg n. Because the log-\narithm of a nonpositive number is undeﬁned, lg.i/ n is deﬁned only if lg.i\u00031/ n > 0.\nBe sure to distinguish lg.i/ n (the logarithm function applied i times in succession,\nstarting with argument n) from lgi n (the logarithm of n raised to the ith power).\nThen we deﬁne the iterated logarithm function as\nlg\u0004 n D min\n˚\ni \u0006 0 W lg.i/ n \u0002 1",
    "parent_8aa6867e-ea9b-466d-bb77-7cbddebeda5e": ":\nThe iterated logarithm is a very slowly growing function:\nlg\u0004 2\nD\n1 ;\nlg\u0004 4\nD\n2 ;\nlg\u0004 16\nD\n3 ;\nlg\u0004 65536\nD\n4 ;\nlg\u0004.265536/\nD\n5 :\n3.2\nStandard notations and common functions\n59\nSince the number of atoms in the observable universe is estimated to be about 1080,\nwhich is much less than 265536, we rarely encounter an input size n such that\nlg\u0004 n > 5.\nFibonacci numbers\nWe deﬁne the Fibonacci numbers by the following recurrence:\nF0\nD\n0 ;\nF1\nD\n1 ;\n(3.22)\nFi\nD\nFi\u00031 C Fi\u00032\nfor i \u0006 2 :\nThus, each Fibonacci number is the sum of the two previous ones, yielding the\nsequence\n0; 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; : : : :\nFibonacci numbers are related to the golden ratio \u0007 and to its conjugate y\u0007, which\nare the two roots of the equation\nx2 D x C 1\n(3.23)\nand are given by the following formulas (see Exercise 3.2-6):\n\u0007\nD\n1 C\np\n5\n2\n(3.24)\nD\n1:61803 : : : ;\ny\u0007\nD\n1 \u0005\np\n5\n2\nD\n\u0005:61803 : : : :\nSpeciﬁcally, we have\nFi D \u0007i \u0005 y\u0007i\np\n5\n;\nwhich we can prove by induction (Exercise 3.2-7). Since\nˇˇy\u0007\nˇˇ < 1, we have\nˇˇy\u0007iˇˇ\np\n5\n<\n1\np\n5\n<\n1\n2 ;\nwhich implies that\n60\nChapter 3\nGrowth of Functions\nFi D\n\b \u0007i\np\n5\nC 1\n2\n\t\n;\n(3.25)\nwhich is to say that the ith Fibonacci number Fi is equal to \u0007i=\np\n5 rounded to the\nnearest integer. Thus, Fibonacci numbers grow exponentially.\nExercises\n3.2-1\nShow that if f .n/ and g.n/ are monotonically increasing functions, then so are\nthe functions f .n/ C g.n/ and f .g.n//, and if f .n/ and g.n/ are in addition\nnonnegative, then f .n/ \u0003 g.n/ is monotonically increasing.\n3.2-2\nProve equation (3.16).\n3.2-3\nProve equation (3.19). Also prove that nŠ D !.2n/ and nŠ D o.nn/.\n3.2-4\n?\nIs the function dlg neŠ polynomially bounded? Is the function dlg lg neŠ polynomi-\nally bounded?\n3.2-5\n?\nWhich is asymptotically larger: lg.lg\u0004 n/ or lg\u0004.lg n/?\n3.2-6\nShow that the golden ratio \u0007 and its conjugate y\u0007 both satisfy the equation\nx2 D x C 1.\n3.2-7\nProve by induction that the ith Fibonacci number satisﬁes the equality\nFi D \u0007i \u0005 y\u0007i\np\n5\n;",
    "parent_786fdb90-0c49-458a-aa23-d5b9dedab772": "ally bounded?\n3.2-5\n?\nWhich is asymptotically larger: lg.lg\u0004 n/ or lg\u0004.lg n/?\n3.2-6\nShow that the golden ratio \u0007 and its conjugate y\u0007 both satisfy the equation\nx2 D x C 1.\n3.2-7\nProve by induction that the ith Fibonacci number satisﬁes the equality\nFi D \u0007i \u0005 y\u0007i\np\n5\n;\nwhere \u0007 is the golden ratio and y\u0007 is its conjugate.\n3.2-8\nShow that k ln k D ‚.n/ implies k D ‚.n= ln n/.\nProblems for Chapter 3\n61\nProblems\n3-1\nAsymptotic behavior of polynomials\nLet\np.n/ D\nd\nX\niD0\naini ;\nwhere ad > 0, be a degree-d polynomial in n, and let k be a constant. Use the\ndeﬁnitions of the asymptotic notations to prove the following properties.\na. If k \u0006 d, then p.n/ D O.nk/.\nb. If k \u0002 d, then p.n/ D \u0004.nk/.\nc. If k D d, then p.n/ D ‚.nk/.\nd. If k > d, then p.n/ D o.nk/.\ne. If k < d, then p.n/ D !.nk/.\n3-2\nRelative asymptotic growths\nIndicate, for each pair of expressions .A; B/ in the table below, whether A is O, o,\n\u0004, !, or ‚ of B. Assume that k \u0006 1, \b > 0, and c > 1 are constants. Your answer\nshould be in the form of the table with “yes” or “no” written in each box.\nA\nB\nO\no\n\u0004\n!\n‚\na.\nlgk n\nn\u0002\nb.\nnk\ncn\nc.\npn\nnsin n\nd.\n2n\n2n=2\ne.\nnlg c\nclg n\nf.\nlg.nŠ/\nlg.nn/\n3-3\nOrdering by asymptotic growth rates\na. Rank the following functions by order of growth; that is, ﬁnd an arrangement\ng1; g2; : : : ; g30 of the functions satisfying g1 D \u0004.g2/, g2 D \u0004.g3/, . . . ,\ng29 D \u0004.g30/. Partition your list into equivalence classes such that functions\nf .n/ and g.n/ are in the same class if and only if f .n/ D ‚.g.n//.\n62\nChapter 3\nGrowth of Functions\nlg.lg\u0004 n/\n2lg\u0003 n\n.\np\n2/lg n\nn2\nnŠ\n.lg n/Š\n. 3\n2/n\nn3\nlg2 n\nlg.nŠ/\n22n\nn1= lg n\nln ln n\nlg\u0004 n\nn \u0003 2n\nnlg lg n\nln n\n1\n2lg n\n.lg n/lg n\nen\n4lg n\n.n C 1/Š\np\nlg n\nlg\u0004.lg n/\n2\np2 lg n\nn\n2n\nn lg n\n22nC1\nb. Give an example of a single nonnegative function f .n/ such that for all func-\ntions gi.n/ in part (a), f .n/ is neither O.gi.n// nor \u0004.gi.n//.\n3-4\nAsymptotic notation properties\nLet f .n/ and g.n/ be asymptotically positive functions. Prove or disprove each of",
    "parent_44f04390-9531-4236-9eaf-95200008ffea": "2\np2 lg n\nn\n2n\nn lg n\n22nC1\nb. Give an example of a single nonnegative function f .n/ such that for all func-\ntions gi.n/ in part (a), f .n/ is neither O.gi.n// nor \u0004.gi.n//.\n3-4\nAsymptotic notation properties\nLet f .n/ and g.n/ be asymptotically positive functions. Prove or disprove each of\nthe following conjectures.\na. f .n/ D O.g.n// implies g.n/ D O.f .n//.\nb. f .n/ C g.n/ D ‚.min.f .n/; g.n///.\nc. f .n/ D O.g.n// implies lg.f .n// D O.lg.g.n///, where lg.g.n// \u0006 1 and\nf .n/ \u0006 1 for all sufﬁciently large n.\nd. f .n/ D O.g.n// implies 2f.n/ D O\n\u000b\n2g.n/\f\n.\ne. f .n/ D O ..f .n//2/.\nf.\nf .n/ D O.g.n// implies g.n/ D \u0004.f .n//.\ng. f .n/ D ‚.f .n=2//.\nh. f .n/ C o.f .n// D ‚.f .n//.\n3-5\nVariations on O and ˝\nSome authors deﬁne \u0004 in a slightly different way than we do; let’s use\n1\u0004 (read\n“omega inﬁnity”) for this alternative deﬁnition. We say that f .n/ D\n1\u0004.g.n// if\nthere exists a positive constant c such that f .n/ \u0006 cg.n/ \u0006 0 for inﬁnitely many\nintegers n.\na. Show that for any two functions f .n/ and g.n/ that are asymptotically nonneg-\native, either f .n/ D O.g.n// or f .n/ D\n1\u0004.g.n// or both, whereas this is not\ntrue if we use \u0004 in place of\n1\u0004.\nProblems for Chapter 3\n63\nb. Describe the potential advantages and disadvantages of using\n1\u0004 instead of \u0004 to\ncharacterize the running times of programs.\nSome authors also deﬁne O in a slightly different manner; let’s use O0 for the\nalternative deﬁnition. We say that f .n/ D O0.g.n// if and only if jf .n/j D\nO.g.n//.\nc. What happens to each direction of the “if and only if” in Theorem 3.1 if we\nsubstitute O0 for O but still use \u0004?\nSome authors deﬁne eO (read “soft-oh”) to mean O with logarithmic factors ig-\nnored:\neO.g.n// D ff .n/ W there exist positive constants c, k, and n0 such that\n0 \u0002 f .n/ \u0002 cg.n/ lgk.n/ for all n \u0006 n0g :\nd. Deﬁne e\u0004 and e‚ in a similar manner. Prove the corresponding analog to Theo-\nrem 3.1.\n3-6\nIterated functions\nWe can apply the iteration operator \u0004 used in the lg\u0004 function to any monotonically",
    "parent_0cf1046c-4149-43e8-a501-686f24bd6a6b": "0 \u0002 f .n/ \u0002 cg.n/ lgk.n/ for all n \u0006 n0g :\nd. Deﬁne e\u0004 and e‚ in a similar manner. Prove the corresponding analog to Theo-\nrem 3.1.\n3-6\nIterated functions\nWe can apply the iteration operator \u0004 used in the lg\u0004 function to any monotonically\nincreasing function f .n/ over the reals. For a given constant c 2 R, we deﬁne the\niterated function f \u0004\nc by\nf \u0004\nc .n/ D min\n˚\ni \u0006 0 W f .i/.n/ \u0002 c",
    "parent_f25fc39c-7ac7-422c-943b-f571fb9665a6": ";\nwhich need not be well deﬁned in all cases. In other words, the quantity f \u0004\nc .n/ is\nthe number of iterated applications of the function f required to reduce its argu-\nment down to c or less.\nFor each of the following functions f .n/ and constants c, give as tight a bound\nas possible on f \u0004\nc .n/.\nf .n/\nc\nf \u0004\nc .n/\na.\nn \u0005 1\n0\nb.\nlg n\n1\nc.\nn=2\n1\nd.\nn=2\n2\ne.\npn\n2\nf.\npn\n1\ng.\nn1=3\n2\nh.\nn= lg n\n2\n64\nChapter 3\nGrowth of Functions\nChapter notes\nKnuth [209] traces the origin of the O-notation to a number-theory text by P. Bach-\nmann in 1892. The o-notation was invented by E. Landau in 1909 for his discussion\nof the distribution of prime numbers. The \u0004 and ‚ notations were advocated by\nKnuth [213] to correct the popular, but technically sloppy, practice in the literature\nof using O-notation for both upper and lower bounds. Many people continue to\nuse the O-notation where the ‚-notation is more technically precise. Further dis-\ncussion of the history and development of asymptotic notations appears in works\nby Knuth [209, 213] and Brassard and Bratley [54].\nNot all authors deﬁne the asymptotic notations in the same way, although the\nvarious deﬁnitions agree in most common situations. Some of the alternative def-\ninitions encompass functions that are not asymptotically nonnegative, as long as\ntheir absolute values are appropriately bounded.\nEquation (3.20) is due to Robbins [297]. Other properties of elementary math-\nematical functions can be found in any good mathematical reference, such as\nAbramowitz and Stegun [1] or Zwillinger [362], or in a calculus book, such as\nApostol [18] or Thomas et al. [334]. Knuth [209] and Graham, Knuth, and Patash-\nnik [152] contain a wealth of material on discrete mathematics as used in computer\nscience.\n4\nDivide-and-Conquer\nIn Section 2.3.1, we saw how merge sort serves as an example of the divide-and-\nconquer paradigm. Recall that in divide-and-conquer, we solve a problem recur-\nsively, applying three steps at each level of the recursion:",
    "parent_c6d5eef2-1932-4d29-a424-282e50ee53bb": "science.\n4\nDivide-and-Conquer\nIn Section 2.3.1, we saw how merge sort serves as an example of the divide-and-\nconquer paradigm. Recall that in divide-and-conquer, we solve a problem recur-\nsively, applying three steps at each level of the recursion:\nDivide the problem into a number of subproblems that are smaller instances of the\nsame problem.\nConquer the subproblems by solving them recursively. If the subproblem sizes are\nsmall enough, however, just solve the subproblems in a straightforward manner.\nCombine the solutions to the subproblems into the solution for the original prob-\nlem.\nWhen the subproblems are large enough to solve recursively, we call that the recur-\nsive case. Once the subproblems become small enough that we no longer recurse,\nwe say that the recursion “bottoms out” and that we have gotten down to the base\ncase. Sometimes, in addition to subproblems that are smaller instances of the same\nproblem, we have to solve subproblems that are not quite the same as the original\nproblem. We consider solving such subproblems as part of the combine step.\nIn this chapter, we shall see more algorithms based on divide-and-conquer. The\nﬁrst one solves the maximum-subarray problem: it takes as input an array of num-\nbers, and it determines the contiguous subarray whose values have the greatest sum.\nThen we shall see two divide-and-conquer algorithms for multiplying n \t n matri-\nces. One runs in ‚.n3/ time, which is no better than the straightforward method of\nmultiplying square matrices. But the other, Strassen’s algorithm, runs in O.n2:81/\ntime, which beats the straightforward method asymptotically.\nRecurrences\nRecurrences go hand in hand with the divide-and-conquer paradigm, because they\ngive us a natural way to characterize the running times of divide-and-conquer algo-\nrithms. A recurrence is an equation or inequality that describes a function in terms\n66\nChapter 4\nDivide-and-Conquer\nof its value on smaller inputs. For example, in Section 2.3.2 we described the",
    "parent_7026beb7-7f7f-4513-87f7-cedfd0c1dd7e": "give us a natural way to characterize the running times of divide-and-conquer algo-\nrithms. A recurrence is an equation or inequality that describes a function in terms\n66\nChapter 4\nDivide-and-Conquer\nof its value on smaller inputs. For example, in Section 2.3.2 we described the\nworst-case running time T .n/ of the MERGE-SORT procedure by the recurrence\nT .n/ D\n(\n‚.1/\nif n D 1 ;\n2T .n=2/ C ‚.n/\nif n > 1 ;\n(4.1)\nwhose solution we claimed to be T .n/ D ‚.n lg n/.\nRecurrences can take many forms. For example, a recursive algorithm might\ndivide subproblems into unequal sizes, such as a 2=3-to-1=3 split. If the divide and\ncombine steps take linear time, such an algorithm would give rise to the recurrence\nT .n/ D T .2n=3/ C T .n=3/ C ‚.n/.\nSubproblems are not necessarily constrained to being a constant fraction of\nthe original problem size.\nFor example, a recursive version of linear search\n(see Exercise 2.1-3) would create just one subproblem containing only one el-\nement fewer than the original problem.\nEach recursive call would take con-\nstant time plus the time for the recursive calls it makes, yielding the recurrence\nT .n/ D T .n \u0005 1/ C ‚.1/.\nThis chapter offers three methods for solving recurrences—that is, for obtaining\nasymptotic “‚” or “O” bounds on the solution:\n\u0002\nIn the substitution method, we guess a bound and then use mathematical in-\nduction to prove our guess correct.\n\u0002\nThe recursion-tree method converts the recurrence into a tree whose nodes\nrepresent the costs incurred at various levels of the recursion. We use techniques\nfor bounding summations to solve the recurrence.\n\u0002\nThe master method provides bounds for recurrences of the form\nT .n/ D aT .n=b/ C f .n/ ;\n(4.2)\nwhere a \u0006 1, b > 1, and f .n/ is a given function. Such recurrences arise\nfrequently. A recurrence of the form in equation (4.2) characterizes a divide-\nand-conquer algorithm that creates a subproblems, each of which is 1=b the",
    "parent_5acd0f77-bd0b-4b34-bcb4-38963204f2d2": "T .n/ D aT .n=b/ C f .n/ ;\n(4.2)\nwhere a \u0006 1, b > 1, and f .n/ is a given function. Such recurrences arise\nfrequently. A recurrence of the form in equation (4.2) characterizes a divide-\nand-conquer algorithm that creates a subproblems, each of which is 1=b the\nsize of the original problem, and in which the divide and combine steps together\ntake f .n/ time.\nTo use the master method, you will need to memorize three cases, but once\nyou do that, you will easily be able to determine asymptotic bounds for many\nsimple recurrences. We will use the master method to determine the running\ntimes of the divide-and-conquer algorithms for the maximum-subarray problem\nand for matrix multiplication, as well as for other algorithms based on divide-\nand-conquer elsewhere in this book.\nChapter 4\nDivide-and-Conquer\n67\nOccasionally, we shall see recurrences that are not equalities but rather inequal-\nities, such as T .n/ \u0002 2T .n=2/ C ‚.n/. Because such a recurrence states only\nan upper bound on T .n/, we will couch its solution using O-notation rather than\n‚-notation. Similarly, if the inequality were reversed to T .n/ \u0006 2T .n=2/ C ‚.n/,\nthen because the recurrence gives only a lower bound on T .n/, we would use\n\u0004-notation in its solution.\nTechnicalities in recurrences\nIn practice, we neglect certain technical details when we state and solve recur-\nrences. For example, if we call MERGE-SORT on n elements when n is odd, we\nend up with subproblems of size bn=2c and dn=2e. Neither size is actually n=2,\nbecause n=2 is not an integer when n is odd. Technically, the recurrence describing\nthe worst-case running time of MERGE-SORT is really\nT .n/ D\n(\n‚.1/\nif n D 1 ;\nT .dn=2e/ C T .bn=2c/ C ‚.n/\nif n > 1 :\n(4.3)\nBoundary conditions represent another class of details that we typically ignore.\nSince the running time of an algorithm on a constant-sized input is a constant,\nthe recurrences that arise from the running times of algorithms generally have",
    "parent_b6af449a-88a8-4258-818e-840d66ba8e5d": "if n D 1 ;\nT .dn=2e/ C T .bn=2c/ C ‚.n/\nif n > 1 :\n(4.3)\nBoundary conditions represent another class of details that we typically ignore.\nSince the running time of an algorithm on a constant-sized input is a constant,\nthe recurrences that arise from the running times of algorithms generally have\nT .n/ D ‚.1/ for sufﬁciently small n. Consequently, for convenience, we shall\ngenerally omit statements of the boundary conditions of recurrences and assume\nthat T .n/ is constant for small n. For example, we normally state recurrence (4.1)\nas\nT .n/ D 2T .n=2/ C ‚.n/ ;\n(4.4)\nwithout explicitly giving values for small n. The reason is that although changing\nthe value of T .1/ changes the exact solution to the recurrence, the solution typi-\ncally doesn’t change by more than a constant factor, and so the order of growth is\nunchanged.\nWhen we state and solve recurrences, we often omit ﬂoors, ceilings, and bound-\nary conditions. We forge ahead without these details and later determine whether\nor not they matter. They usually do not, but you should know when they do. Ex-\nperience helps, and so do some theorems stating that these details do not affect the\nasymptotic bounds of many recurrences characterizing divide-and-conquer algo-\nrithms (see Theorem 4.1). In this chapter, however, we shall address some of these\ndetails and illustrate the ﬁne points of recurrence solution methods.\n68\nChapter 4\nDivide-and-Conquer\n4.1\nThe maximum-subarray problem\nSuppose that you been offered the opportunity to invest in the Volatile Chemical\nCorporation. Like the chemicals the company produces, the stock price of the\nVolatile Chemical Corporation is rather volatile. You are allowed to buy one unit\nof stock only one time and then sell it at a later date, buying and selling after the\nclose of trading for the day. To compensate for this restriction, you are allowed to\nlearn what the price of the stock will be in the future. Your goal is to maximize",
    "parent_ab6dc49e-e861-49bf-8b57-0944f6534414": "of stock only one time and then sell it at a later date, buying and selling after the\nclose of trading for the day. To compensate for this restriction, you are allowed to\nlearn what the price of the stock will be in the future. Your goal is to maximize\nyour proﬁt. Figure 4.1 shows the price of the stock over a 17-day period. You\nmay buy the stock at any one time, starting after day 0, when the price is $100\nper share. Of course, you would want to “buy low, sell high”—buy at the lowest\npossible price and later on sell at the highest possible price—to maximize your\nproﬁt. Unfortunately, you might not be able to buy at the lowest price and then sell\nat the highest price within a given period. In Figure 4.1, the lowest price occurs\nafter day 7, which occurs after the highest price, after day 1.\nYou might think that you can always maximize proﬁt by either buying at the\nlowest price or selling at the highest price. For example, in Figure 4.1, we would\nmaximize proﬁt by buying at the lowest price, after day 7. If this strategy always\nworked, then it would be easy to determine how to maximize proﬁt: ﬁnd the highest\nand lowest prices, and then work left from the highest price to ﬁnd the lowest prior\nprice, work right from the lowest price to ﬁnd the highest later price, and take\nthe pair with the greater difference. Figure 4.2 shows a simple counterexample,\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n120\n110\n100\n90\n80\n70\n60\nDay\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13 14\n15 16\nPrice\n100 113 110\n85 105 102\n86\n63 81 101\n94 106 101\n79 94\n90 97\nChange\n13\n\u00053 \u000525\n20\n\u00053 \u000516 \u000523 18\n20 \u00057\n12\n\u00055 \u000522 15 \u00054\n7\nFigure 4.1\nInformation about the price of stock in the Volatile Chemical Corporation after the close\nof trading over a period of 17 days. The horizontal axis of the chart indicates the day, and the vertical\naxis shows the price. The bottom row of the table gives the change in price from the previous day.\n4.1\nThe maximum-subarray problem\n69\n0\n1\n2\n3\n4\n11\n10\n9\n8\n7\n6\nDay\n0\n1\n2\n3\n4\nPrice\n10\n11\n7",
    "parent_05f0687b-54e4-40bf-b7d0-58c021f3a289": "of trading over a period of 17 days. The horizontal axis of the chart indicates the day, and the vertical\naxis shows the price. The bottom row of the table gives the change in price from the previous day.\n4.1\nThe maximum-subarray problem\n69\n0\n1\n2\n3\n4\n11\n10\n9\n8\n7\n6\nDay\n0\n1\n2\n3\n4\nPrice\n10\n11\n7\n10\n6\nChange\n1\n\u00054\n3\n\u00054\nFigure 4.2\nAn example showing that the maximum proﬁt does not always start at the lowest price\nor end at the highest price. Again, the horizontal axis indicates the day, and the vertical axis shows\nthe price. Here, the maximum proﬁt of $3 per share would be earned by buying after day 2 and\nselling after day 3. The price of $7 after day 2 is not the lowest price overall, and the price of $10\nafter day 3 is not the highest price overall.\ndemonstrating that the maximum proﬁt sometimes comes neither by buying at the\nlowest price nor by selling at the highest price.\nA brute-force solution\nWe can easily devise a brute-force solution to this problem: just try every possible\npair of buy and sell dates in which the buy date precedes the sell date. A period of n\ndays has\n\u000bn\n2\n\f\nsuch pairs of dates. Since\n\u000bn\n2\n\f\nis ‚.n2/, and the best we can hope for\nis to evaluate each pair of dates in constant time, this approach would take \u0004.n2/\ntime. Can we do better?\nA transformation\nIn order to design an algorithm with an o.n2/ running time, we will look at the\ninput in a slightly different way. We want to ﬁnd a sequence of days over which\nthe net change from the ﬁrst day to the last is maximum. Instead of looking at the\ndaily prices, let us instead consider the daily change in price, where the change on\nday i is the difference between the prices after day i \u0005 1 and after day i. The table\nin Figure 4.1 shows these daily changes in the bottom row. If we treat this row as\nan array A, shown in Figure 4.3, we now want to ﬁnd the nonempty, contiguous\nsubarray of A whose values have the largest sum. We call this contiguous subarray",
    "parent_a87adfc4-da9d-44db-9296-fae9045bae1c": "in Figure 4.1 shows these daily changes in the bottom row. If we treat this row as\nan array A, shown in Figure 4.3, we now want to ﬁnd the nonempty, contiguous\nsubarray of A whose values have the largest sum. We call this contiguous subarray\nthe maximum subarray. For example, in the array of Figure 4.3, the maximum\nsubarray of AŒ1 : : 16\u0002 is AŒ8 : : 11\u0002, with the sum 43. Thus, you would want to buy\nthe stock just before day 8 (that is, after day 7) and sell it after day 11, earning a\nproﬁt of $43 per share.\nAt ﬁrst glance, this transformation does not help.\nWe still need to check\n\u000bn\u00031\n2\n\f\nD ‚.n2/ subarrays for a period of n days. Exercise 4.1-2 asks you to show\n70\nChapter 4\nDivide-and-Conquer\n13\n1\n–3\n2\n–25\n3\n20\n4\n–3\n5\n–16\n6\n–23\n7\n8\n9\n10\nmaximum subarray\n11\n18\n12\n20\n13\n–7\n14\n12\n15\n7\n16\n–5 –22 15\n–4\nA\nFigure 4.3\nThe change in stock prices as a maximum-subarray problem.\nHere, the subar-\nray AŒ8 : : 11\u0002, with sum 43, has the greatest sum of any contiguous subarray of array A.\nthat although computing the cost of one subarray might take time proportional to\nthe length of the subarray, when computing all ‚.n2/ subarray sums, we can orga-\nnize the computation so that each subarray sum takes O.1/ time, given the values\nof previously computed subarray sums, so that the brute-force solution takes ‚.n2/\ntime.\nSo let us seek a more efﬁcient solution to the maximum-subarray problem.\nWhen doing so, we will usually speak of “a” maximum subarray rather than “the”\nmaximum subarray, since there could be more than one subarray that achieves the\nmaximum sum.\nThe maximum-subarray problem is interesting only when the array contains\nsome negative numbers.\nIf all the array entries were nonnegative, then the\nmaximum-subarray problem would present no challenge, since the entire array\nwould give the greatest sum.\nA solution using divide-and-conquer\nLet’s think about how we might solve the maximum-subarray problem using\nthe divide-and-conquer technique. Suppose we want to ﬁnd a maximum subar-",
    "parent_9575a5f8-315c-4a3d-8e05-82c95d82f363": "maximum-subarray problem would present no challenge, since the entire array\nwould give the greatest sum.\nA solution using divide-and-conquer\nLet’s think about how we might solve the maximum-subarray problem using\nthe divide-and-conquer technique. Suppose we want to ﬁnd a maximum subar-\nray of the subarray AŒlow : : high\u0002. Divide-and-conquer suggests that we divide\nthe subarray into two subarrays of as equal size as possible.\nThat is, we ﬁnd\nthe midpoint, say mid, of the subarray, and consider the subarrays AŒlow : : mid\u0002\nand AŒmid C 1 : : high\u0002. As Figure 4.4(a) shows, any contiguous subarray AŒi : : j \u0002\nof AŒlow : : high\u0002 must lie in exactly one of the following places:\n\u0002\nentirely in the subarray AŒlow : : mid\u0002, so that low \u0002 i \u0002 j \u0002 mid,\n\u0002\nentirely in the subarray AŒmid C 1 : : high\u0002, so that mid < i \u0002 j \u0002 high, or\n\u0002\ncrossing the midpoint, so that low \u0002 i \u0002 mid < j \u0002 high.\nTherefore, a maximum subarray of AŒlow : : high\u0002 must lie in exactly one of these\nplaces.\nIn fact, a maximum subarray of AŒlow : : high\u0002 must have the greatest\nsum over all subarrays entirely in AŒlow : : mid\u0002, entirely in AŒmid C 1 : : high\u0002,\nor crossing the midpoint. We can ﬁnd maximum subarrays of AŒlow : : mid\u0002 and\nAŒmidC1 : : high\u0002 recursively, because these two subproblems are smaller instances\nof the problem of ﬁnding a maximum subarray. Thus, all that is left to do is ﬁnd a\n4.1\nThe maximum-subarray problem\n71\n(a)\n(b)\nlow\nlow\nmid\nmid\nhigh\nhigh\ncrosses the midpoint\nmid C 1\nmid C 1\nentirely in AŒlow : : mid\u0002\nentirely in AŒmid C 1 : : high\u0002\ni\nj\nAŒi : : mid\u0002\nAŒmid C 1 : : j \u0002\nFigure 4.4\n(a) Possible locations of subarrays of AŒlow : : high\u0002: entirely in AŒlow : : mid\u0002, entirely\nin AŒmid C 1 : : high\u0002, or crossing the midpoint mid. (b) Any subarray of AŒlow : : high\u0002 crossing\nthe midpoint comprises two subarrays AŒi : : mid\u0002 and AŒmid C 1 : : j\u0002, where low \u0002 i \u0002 mid and\nmid < j \u0002 high.\nmaximum subarray that crosses the midpoint, and take a subarray with the largest\nsum of the three.",
    "parent_3e37ac9f-65b5-46fa-b355-ad4e73d04fab": "the midpoint comprises two subarrays AŒi : : mid\u0002 and AŒmid C 1 : : j\u0002, where low \u0002 i \u0002 mid and\nmid < j \u0002 high.\nmaximum subarray that crosses the midpoint, and take a subarray with the largest\nsum of the three.\nWe can easily ﬁnd a maximum subarray crossing the midpoint in time linear\nin the size of the subarray AŒlow : : high\u0002. This problem is not a smaller instance\nof our original problem, because it has the added restriction that the subarray it\nchooses must cross the midpoint. As Figure 4.4(b) shows, any subarray crossing\nthe midpoint is itself made of two subarrays AŒi : : mid\u0002 and AŒmid C 1 : : j \u0002, where\nlow \u0002 i \u0002 mid and mid < j \u0002 high. Therefore, we just need to ﬁnd maximum\nsubarrays of the form AŒi : : mid\u0002 and AŒmid C 1 : : j \u0002 and then combine them. The\nprocedure FIND-MAX-CROSSING-SUBARRAY takes as input the array A and the\nindices low, mid, and high, and it returns a tuple containing the indices demarcating\na maximum subarray that crosses the midpoint, along with the sum of the values in\na maximum subarray.\nFIND-MAX-CROSSING-SUBARRAY.A; low; mid; high/\n1\nleft-sum D \u00051\n2\nsum D 0\n3\nfor i D mid downto low\n4\nsum D sum C AŒi\u0002\n5\nif sum > left-sum\n6\nleft-sum D sum\n7\nmax-left D i\n8\nright-sum D \u00051\n9\nsum D 0\n10\nfor j D mid C 1 to high\n11\nsum D sum C AŒj \u0002\n12\nif sum > right-sum\n13\nright-sum D sum\n14\nmax-right D j\n15\nreturn .max-left; max-right; left-sum C right-sum/\n72\nChapter 4\nDivide-and-Conquer\nThis procedure works as follows. Lines 1–7 ﬁnd a maximum subarray of the\nleft half, AŒlow : : mid\u0002. Since this subarray must contain AŒmid\u0002, the for loop of\nlines 3–7 starts the index i at mid and works down to low, so that every subarray\nit considers is of the form AŒi : : mid\u0002. Lines 1–2 initialize the variables left-sum,\nwhich holds the greatest sum found so far, and sum, holding the sum of the entries\nin AŒi : : mid\u0002. Whenever we ﬁnd, in line 5, a subarray AŒi : : mid\u0002 with a sum of",
    "parent_eb293061-400d-4a28-b5f9-36948c3d078b": "it considers is of the form AŒi : : mid\u0002. Lines 1–2 initialize the variables left-sum,\nwhich holds the greatest sum found so far, and sum, holding the sum of the entries\nin AŒi : : mid\u0002. Whenever we ﬁnd, in line 5, a subarray AŒi : : mid\u0002 with a sum of\nvalues greater than left-sum, we update left-sum to this subarray’s sum in line 6, and\nin line 7 we update the variable max-left to record this index i. Lines 8–14 work\nanalogously for the right half, AŒmidC1 : : high\u0002. Here, the for loop of lines 10–14\nstarts the index j at midC1 and works up to high, so that every subarray it considers\nis of the form AŒmid C 1 : : j \u0002. Finally, line 15 returns the indices max-left and\nmax-right that demarcate a maximum subarray crossing the midpoint, along with\nthe sum left-sumCright-sum of the values in the subarray AŒmax-left : : max-right\u0002.\nIf the subarray AŒlow : : high\u0002 contains n entries (so that n D high \u0005 low C 1),\nwe claim that the call FIND-MAX-CROSSING-SUBARRAY.A; low; mid; high/\ntakes ‚.n/ time. Since each iteration of each of the two for loops takes ‚.1/\ntime, we just need to count up how many iterations there are altogether. The for\nloop of lines 3–7 makes mid \u0005 low C 1 iterations, and the for loop of lines 10–14\nmakes high \u0005 mid iterations, and so the total number of iterations is\n.mid \u0005 low C 1/ C .high \u0005 mid/\nD\nhigh \u0005 low C 1\nD\nn :\nWith a linear-time FIND-MAX-CROSSING-SUBARRAY procedure in hand, we\ncan write pseudocode for a divide-and-conquer algorithm to solve the maximum-\nsubarray problem:\nFIND-MAXIMUM-SUBARRAY.A; low; high/\n1\nif high == low\n2\nreturn .low; high; AŒlow\u0002/\n// base case: only one element\n3\nelse mid D b.low C high/=2c\n4\n.left-low; left-high; left-sum/ D\nFIND-MAXIMUM-SUBARRAY.A; low; mid/\n5\n.right-low; right-high; right-sum/ D\nFIND-MAXIMUM-SUBARRAY.A; mid C 1; high/\n6\n.cross-low; cross-high; cross-sum/ D\nFIND-MAX-CROSSING-SUBARRAY.A; low; mid; high/\n7\nif left-sum \u0006 right-sum and left-sum \u0006 cross-sum\n8\nreturn .left-low; left-high; left-sum/\n9",
    "parent_620b3d06-2e40-4f7e-8430-ef5515d02e8b": "FIND-MAXIMUM-SUBARRAY.A; low; mid/\n5\n.right-low; right-high; right-sum/ D\nFIND-MAXIMUM-SUBARRAY.A; mid C 1; high/\n6\n.cross-low; cross-high; cross-sum/ D\nFIND-MAX-CROSSING-SUBARRAY.A; low; mid; high/\n7\nif left-sum \u0006 right-sum and left-sum \u0006 cross-sum\n8\nreturn .left-low; left-high; left-sum/\n9\nelseif right-sum \u0006 left-sum and right-sum \u0006 cross-sum\n10\nreturn .right-low; right-high; right-sum/\n11\nelse return .cross-low; cross-high; cross-sum/\n4.1\nThe maximum-subarray problem\n73\nThe initial call FIND-MAXIMUM-SUBARRAY.A; 1; A:length/ will ﬁnd a maxi-\nmum subarray of AŒ1 : : n\u0002.\nSimilar to FIND-MAX-CROSSING-SUBARRAY, the recursive procedure FIND-\nMAXIMUM-SUBARRAY returns a tuple containing the indices that demarcate a\nmaximum subarray, along with the sum of the values in a maximum subarray.\nLine 1 tests for the base case, where the subarray has just one element. A subar-\nray with just one element has only one subarray—itself—and so line 2 returns a\ntuple with the starting and ending indices of just the one element, along with its\nvalue. Lines 3–11 handle the recursive case. Line 3 does the divide part, comput-\ning the index mid of the midpoint. Let’s refer to the subarray AŒlow : : mid\u0002 as the\nleft subarray and to AŒmid C 1 : : high\u0002 as the right subarray. Because we know\nthat the subarray AŒlow : : high\u0002 contains at least two elements, each of the left and\nright subarrays must have at least one element. Lines 4 and 5 conquer by recur-\nsively ﬁnding maximum subarrays within the left and right subarrays, respectively.\nLines 6–11 form the combine part. Line 6 ﬁnds a maximum subarray that crosses\nthe midpoint. (Recall that because line 6 solves a subproblem that is not a smaller\ninstance of the original problem, we consider it to be in the combine part.) Line 7\ntests whether the left subarray contains a subarray with the maximum sum, and\nline 8 returns that maximum subarray. Otherwise, line 9 tests whether the right",
    "parent_1a034f6f-303d-4f65-be11-35f3b44ebdbb": "instance of the original problem, we consider it to be in the combine part.) Line 7\ntests whether the left subarray contains a subarray with the maximum sum, and\nline 8 returns that maximum subarray. Otherwise, line 9 tests whether the right\nsubarray contains a subarray with the maximum sum, and line 10 returns that max-\nimum subarray. If neither the left nor right subarrays contain a subarray achieving\nthe maximum sum, then a maximum subarray must cross the midpoint, and line 11\nreturns it.\nAnalyzing the divide-and-conquer algorithm\nNext we set up a recurrence that describes the running time of the recursive FIND-\nMAXIMUM-SUBARRAY procedure. As we did when we analyzed merge sort in\nSection 2.3.2, we make the simplifying assumption that the original problem size\nis a power of 2, so that all subproblem sizes are integers. We denote by T .n/ the\nrunning time of FIND-MAXIMUM-SUBARRAY on a subarray of n elements. For\nstarters, line 1 takes constant time. The base case, when n D 1, is easy: line 2\ntakes constant time, and so\nT .1/ D ‚.1/ :\n(4.5)\nThe recursive case occurs when n > 1. Lines 1 and 3 take constant time. Each\nof the subproblems solved in lines 4 and 5 is on a subarray of n=2 elements (our\nassumption that the original problem size is a power of 2 ensures that n=2 is an\ninteger), and so we spend T .n=2/ time solving each of them. Because we have\nto solve two subproblems—for the left subarray and for the right subarray—the\ncontribution to the running time from lines 4 and 5 comes to 2T .n=2/. As we have\n74\nChapter 4\nDivide-and-Conquer\nalready seen, the call to FIND-MAX-CROSSING-SUBARRAY in line 6 takes ‚.n/\ntime. Lines 7–11 take only ‚.1/ time. For the recursive case, therefore, we have\nT .n/\nD\n‚.1/ C 2T .n=2/ C ‚.n/ C ‚.1/\nD\n2T .n=2/ C ‚.n/ :\n(4.6)\nCombining equations (4.5) and (4.6) gives us a recurrence for the running\ntime T .n/ of FIND-MAXIMUM-SUBARRAY:\nT .n/ D\n(\n‚.1/\nif n D 1 ;\n2T .n=2/ C ‚.n/\nif n > 1 :\n(4.7)",
    "parent_af8c2888-41cf-4863-9403-972d0609187e": "T .n/\nD\n‚.1/ C 2T .n=2/ C ‚.n/ C ‚.1/\nD\n2T .n=2/ C ‚.n/ :\n(4.6)\nCombining equations (4.5) and (4.6) gives us a recurrence for the running\ntime T .n/ of FIND-MAXIMUM-SUBARRAY:\nT .n/ D\n(\n‚.1/\nif n D 1 ;\n2T .n=2/ C ‚.n/\nif n > 1 :\n(4.7)\nThis recurrence is the same as recurrence (4.1) for merge sort.\nAs we shall\nsee from the master method in Section 4.5, this recurrence has the solution\nT .n/ D ‚.n lg n/. You might also revisit the recursion tree in Figure 2.5 to un-\nderstand why the solution should be T .n/ D ‚.n lg n/.\nThus, we see that the divide-and-conquer method yields an algorithm that is\nasymptotically faster than the brute-force method. With merge sort and now the\nmaximum-subarray problem, we begin to get an idea of how powerful the divide-\nand-conquer method can be. Sometimes it will yield the asymptotically fastest\nalgorithm for a problem, and other times we can do even better. As Exercise 4.1-5\nshows, there is in fact a linear-time algorithm for the maximum-subarray problem,\nand it does not use divide-and-conquer.\nExercises\n4.1-1\nWhat does FIND-MAXIMUM-SUBARRAY return when all elements of A are nega-\ntive?\n4.1-2\nWrite pseudocode for the brute-force method of solving the maximum-subarray\nproblem. Your procedure should run in ‚.n2/ time.\n4.1-3\nImplement both the brute-force and recursive algorithms for the maximum-\nsubarray problem on your own computer. What problem size n0 gives the crossover\npoint at which the recursive algorithm beats the brute-force algorithm?\nThen,\nchange the base case of the recursive algorithm to use the brute-force algorithm\nwhenever the problem size is less than n0. Does that change the crossover point?\n4.1-4\nSuppose we change the deﬁnition of the maximum-subarray problem to allow the\nresult to be an empty subarray, where the sum of the values of an empty subar-\n4.2\nStrassen’s algorithm for matrix multiplication\n75\nray is 0. How would you change any of the algorithms that do not allow empty",
    "parent_cdc8095e-f715-4039-8c02-bf5714632cfc": "4.1-4\nSuppose we change the deﬁnition of the maximum-subarray problem to allow the\nresult to be an empty subarray, where the sum of the values of an empty subar-\n4.2\nStrassen’s algorithm for matrix multiplication\n75\nray is 0. How would you change any of the algorithms that do not allow empty\nsubarrays to permit an empty subarray to be the result?\n4.1-5\nUse the following ideas to develop a nonrecursive, linear-time algorithm for the\nmaximum-subarray problem. Start at the left end of the array, and progress toward\nthe right, keeping track of the maximum subarray seen so far. Knowing a maximum\nsubarray of AŒ1 : : j \u0002, extend the answer to ﬁnd a maximum subarray ending at in-\ndex j C1 by using the following observation: a maximum subarray of AŒ1 : : j C 1\u0002\nis either a maximum subarray of AŒ1 : : j \u0002 or a subarray AŒi : : j C 1\u0002, for some\n1 \u0002 i \u0002 j C 1. Determine a maximum subarray of the form AŒi : : j C 1\u0002 in\nconstant time based on knowing a maximum subarray ending at index j .\n4.2\nStrassen’s algorithm for matrix multiplication\nIf you have seen matrices before, then you probably know how to multiply them.\n(Otherwise, you should read Section D.1 in Appendix D.)\nIf A D .aij/ and\nB D .bij/ are square n \t n matrices, then in the product C D A \u0003 B, we deﬁne the\nentry cij, for i; j D 1; 2; : : : ; n, by\ncij D\nn\nX\nkD1\naik \u0003 bkj :\n(4.8)\nWe must compute n2 matrix entries, and each is the sum of n values. The following\nprocedure takes n \t n matrices A and B and multiplies them, returning their n \t n\nproduct C. We assume that each matrix has an attribute rows, giving the number\nof rows in the matrix.\nSQUARE-MATRIX-MULTIPLY.A; B/\n1\nn D A:rows\n2\nlet C be a new n \t n matrix\n3\nfor i D 1 to n\n4\nfor j D 1 to n\n5\ncij D 0\n6\nfor k D 1 to n\n7\ncij D cij C aik \u0003 bkj\n8\nreturn C\nThe SQUARE-MATRIX-MULTIPLY procedure works as follows. The for loop\nof lines 3–7 computes the entries of each row i, and within a given row i, the\n76\nChapter 4\nDivide-and-Conquer",
    "parent_7f217c96-941d-4d50-b781-ba55eed21cec": "3\nfor i D 1 to n\n4\nfor j D 1 to n\n5\ncij D 0\n6\nfor k D 1 to n\n7\ncij D cij C aik \u0003 bkj\n8\nreturn C\nThe SQUARE-MATRIX-MULTIPLY procedure works as follows. The for loop\nof lines 3–7 computes the entries of each row i, and within a given row i, the\n76\nChapter 4\nDivide-and-Conquer\nfor loop of lines 4–7 computes each of the entries cij, for each column j . Line 5\ninitializes cij to 0 as we start computing the sum given in equation (4.8), and each\niteration of the for loop of lines 6–7 adds in one more term of equation (4.8).\nBecause each of the triply-nested for loops runs exactly n iterations, and each\nexecution of line 7 takes constant time, the SQUARE-MATRIX-MULTIPLY proce-\ndure takes ‚.n3/ time.\nYou might at ﬁrst think that any matrix multiplication algorithm must take \u0004.n3/\ntime, since the natural deﬁnition of matrix multiplication requires that many mul-\ntiplications. You would be incorrect, however: we have a way to multiply matrices\nin o.n3/ time. In this section, we shall see Strassen’s remarkable recursive algo-\nrithm for multiplying n \t n matrices. It runs in ‚.nlg 7/ time, which we shall show\nin Section 4.5. Since lg 7 lies between 2:80 and 2:81, Strassen’s algorithm runs in\nO.n2:81/ time, which is asymptotically better than the simple SQUARE-MATRIX-\nMULTIPLY procedure.\nA simple divide-and-conquer algorithm\nTo keep things simple, when we use a divide-and-conquer algorithm to compute\nthe matrix product C D A \u0003 B, we assume that n is an exact power of 2 in each of\nthe n \t n matrices. We make this assumption because in each divide step, we will\ndivide n \t n matrices into four n=2 \t n=2 matrices, and by assuming that n is an\nexact power of 2, we are guaranteed that as long as n \u0006 2, the dimension n=2 is an\ninteger.\nSuppose that we partition each of A, B, and C into four n=2 \t n=2 matrices\nA D\n\u0002 A11\nA12\nA21\nA22\n\u0003\n;\nB D\n\u0002 B11\nB12\nB21\nB22\n\u0003\n;\nC D\n\u0002 C11\nC12\nC21\nC22\n\u0003\n;\n(4.9)\nso that we rewrite the equation C D A \u0003 B as\n\u0002 C11\nC12\nC21\nC22\n\u0003\nD\n\u0002 A11\nA12\nA21\nA22\n\u0003\n\u0003\n\u0002 B11",
    "parent_2aa2ba03-7df1-44ad-bc84-7d3abb8159df": "integer.\nSuppose that we partition each of A, B, and C into four n=2 \t n=2 matrices\nA D\n\u0002 A11\nA12\nA21\nA22\n\u0003\n;\nB D\n\u0002 B11\nB12\nB21\nB22\n\u0003\n;\nC D\n\u0002 C11\nC12\nC21\nC22\n\u0003\n;\n(4.9)\nso that we rewrite the equation C D A \u0003 B as\n\u0002 C11\nC12\nC21\nC22\n\u0003\nD\n\u0002 A11\nA12\nA21\nA22\n\u0003\n\u0003\n\u0002 B11\nB12\nB21\nB22\n\u0003\n:\n(4.10)\nEquation (4.10) corresponds to the four equations\nC11\nD\nA11 \u0003 B11 C A12 \u0003 B21 ;\n(4.11)\nC12\nD\nA11 \u0003 B12 C A12 \u0003 B22 ;\n(4.12)\nC21\nD\nA21 \u0003 B11 C A22 \u0003 B21 ;\n(4.13)\nC22\nD\nA21 \u0003 B12 C A22 \u0003 B22 :\n(4.14)\nEach of these four equations speciﬁes two multiplications of n=2 \t n=2 matrices\nand the addition of their n=2 \t n=2 products. We can use these equations to create\na straightforward, recursive, divide-and-conquer algorithm:\n4.2\nStrassen’s algorithm for matrix multiplication\n77\nSQUARE-MATRIX-MULTIPLY-RECURSIVE.A; B/\n1\nn D A:rows\n2\nlet C be a new n \t n matrix\n3\nif n == 1\n4\nc11 D a11 \u0003 b11\n5\nelse partition A, B, and C as in equations (4.9)\n6\nC11 D SQUARE-MATRIX-MULTIPLY-RECURSIVE.A11; B11/\nC SQUARE-MATRIX-MULTIPLY-RECURSIVE.A12; B21/\n7\nC12 D SQUARE-MATRIX-MULTIPLY-RECURSIVE.A11; B12/\nC SQUARE-MATRIX-MULTIPLY-RECURSIVE.A12; B22/\n8\nC21 D SQUARE-MATRIX-MULTIPLY-RECURSIVE.A21; B11/\nC SQUARE-MATRIX-MULTIPLY-RECURSIVE.A22; B21/\n9\nC22 D SQUARE-MATRIX-MULTIPLY-RECURSIVE.A21; B12/\nC SQUARE-MATRIX-MULTIPLY-RECURSIVE.A22; B22/\n10\nreturn C\nThis pseudocode glosses over one subtle but important implementation detail.\nHow do we partition the matrices in line 5? If we were to create 12 new n=2 \t n=2\nmatrices, we would spend ‚.n2/ time copying entries. In fact, we can partition\nthe matrices without copying entries. The trick is to use index calculations. We\nidentify a submatrix by a range of row indices and a range of column indices of\nthe original matrix. We end up representing a submatrix a little differently from\nhow we represent the original matrix, which is the subtlety we are glossing over.\nThe advantage is that, since we can specify submatrices by index calculations,",
    "parent_a19e4a29-1e83-4321-a64d-c264c0f6c68c": "the original matrix. We end up representing a submatrix a little differently from\nhow we represent the original matrix, which is the subtlety we are glossing over.\nThe advantage is that, since we can specify submatrices by index calculations,\nexecuting line 5 takes only ‚.1/ time (although we shall see that it makes no\ndifference asymptotically to the overall running time whether we copy or partition\nin place).\nNow, we derive a recurrence to characterize the running time of SQUARE-\nMATRIX-MULTIPLY-RECURSIVE. Let T .n/ be the time to multiply two n \t n\nmatrices using this procedure. In the base case, when n D 1, we perform just the\none scalar multiplication in line 4, and so\nT .1/ D ‚.1/ :\n(4.15)\nThe recursive case occurs when n > 1. As discussed, partitioning the matrices in\nline 5 takes ‚.1/ time, using index calculations. In lines 6–9, we recursively call\nSQUARE-MATRIX-MULTIPLY-RECURSIVE a total of eight times. Because each\nrecursive call multiplies two n=2 \t n=2 matrices, thereby contributing T .n=2/ to\nthe overall running time, the time taken by all eight recursive calls is 8T .n=2/. We\nalso must account for the four matrix additions in lines 6–9. Each of these matrices\ncontains n2=4 entries, and so each of the four matrix additions takes ‚.n2/ time.\nSince the number of matrix additions is a constant, the total time spent adding ma-\n78\nChapter 4\nDivide-and-Conquer\ntrices in lines 6–9 is ‚.n2/. (Again, we use index calculations to place the results\nof the matrix additions into the correct positions of matrix C, with an overhead\nof ‚.1/ time per entry.) The total time for the recursive case, therefore, is the sum\nof the partitioning time, the time for all the recursive calls, and the time to add the\nmatrices resulting from the recursive calls:\nT .n/\nD\n‚.1/ C 8T .n=2/ C ‚.n2/\nD\n8T .n=2/ C ‚.n2/ :\n(4.16)\nNotice that if we implemented partitioning by copying matrices, which would cost\n‚.n2/ time, the recurrence would not change, and hence the overall running time",
    "parent_2ce9d871-4c35-471d-a7fc-62460e335259": "matrices resulting from the recursive calls:\nT .n/\nD\n‚.1/ C 8T .n=2/ C ‚.n2/\nD\n8T .n=2/ C ‚.n2/ :\n(4.16)\nNotice that if we implemented partitioning by copying matrices, which would cost\n‚.n2/ time, the recurrence would not change, and hence the overall running time\nwould increase by only a constant factor.\nCombining equations (4.15) and (4.16) gives us the recurrence for the running\ntime of SQUARE-MATRIX-MULTIPLY-RECURSIVE:\nT .n/ D\n(\n‚.1/\nif n D 1 ;\n8T .n=2/ C ‚.n2/\nif n > 1 :\n(4.17)\nAs we shall see from the master method in Section 4.5, recurrence (4.17) has the\nsolution T .n/ D ‚.n3/. Thus, this simple divide-and-conquer approach is no\nfaster than the straightforward SQUARE-MATRIX-MULTIPLY procedure.\nBefore we continue on to examining Strassen’s algorithm, let us review where\nthe components of equation (4.16) came from. Partitioning each n \t n matrix by\nindex calculation takes ‚.1/ time, but we have two matrices to partition. Although\nyou could say that partitioning the two matrices takes ‚.2/ time, the constant of 2\nis subsumed by the ‚-notation. Adding two matrices, each with, say, k entries,\ntakes ‚.k/ time. Since the matrices we add each have n2=4 entries, you could\nsay that adding each pair takes ‚.n2=4/ time. Again, however, the ‚-notation\nsubsumes the constant factor of 1=4, and we say that adding two n2=4 \t n2=4\nmatrices takes ‚.n2/ time. We have four such matrix additions, and once again,\ninstead of saying that they take ‚.4n2/ time, we say that they take ‚.n2/ time.\n(Of course, you might observe that we could say that the four matrix additions\ntake ‚.4n2=4/ time, and that 4n2=4 D n2, but the point here is that ‚-notation\nsubsumes constant factors, whatever they are.) Thus, we end up with two terms\nof ‚.n2/, which we can combine into one.\nWhen we account for the eight recursive calls, however, we cannot just sub-\nsume the constant factor of 8. In other words, we must say that together they take",
    "parent_5c426534-9e31-45a8-99a3-fe39d3080a41": "subsumes constant factors, whatever they are.) Thus, we end up with two terms\nof ‚.n2/, which we can combine into one.\nWhen we account for the eight recursive calls, however, we cannot just sub-\nsume the constant factor of 8. In other words, we must say that together they take\n8T .n=2/ time, rather than just T .n=2/ time. You can get a feel for why by looking\nback at the recursion tree in Figure 2.5, for recurrence (2.1) (which is identical to\nrecurrence (4.7)), with the recursive case T .n/ D 2T .n=2/C‚.n/. The factor of 2\ndetermined how many children each tree node had, which in turn determined how\nmany terms contributed to the sum at each level of the tree. If we were to ignore\n4.2\nStrassen’s algorithm for matrix multiplication\n79\nthe factor of 8 in equation (4.16) or the factor of 2 in recurrence (4.1), the recursion\ntree would just be linear, rather than “bushy,” and each level would contribute only\none term to the sum.\nBear in mind, therefore, that although asymptotic notation subsumes constant\nmultiplicative factors, recursive notation such as T .n=2/ does not.\nStrassen’s method\nThe key to Strassen’s method is to make the recursion tree slightly less bushy. That\nis, instead of performing eight recursive multiplications of n=2 \t n=2 matrices,\nit performs only seven. The cost of eliminating one matrix multiplication will be\nseveral new additions of n=2 \t n=2 matrices, but still only a constant number of\nadditions. As before, the constant number of matrix additions will be subsumed\nby ‚-notation when we set up the recurrence equation to characterize the running\ntime.\nStrassen’s method is not at all obvious. (This might be the biggest understate-\nment in this book.) It has four steps:\n1. Divide the input matrices A and B and output matrix C into n=2 \t n=2 subma-\ntrices, as in equation (4.9). This step takes ‚.1/ time by index calculation, just\nas in SQUARE-MATRIX-MULTIPLY-RECURSIVE.",
    "parent_a7a4a538-bc5f-49f8-b595-f5b25aabfe3e": "ment in this book.) It has four steps:\n1. Divide the input matrices A and B and output matrix C into n=2 \t n=2 subma-\ntrices, as in equation (4.9). This step takes ‚.1/ time by index calculation, just\nas in SQUARE-MATRIX-MULTIPLY-RECURSIVE.\n2. Create 10 matrices S1; S2; : : : ; S10, each of which is n=2 \t n=2 and is the sum\nor difference of two matrices created in step 1. We can create all 10 matrices in\n‚.n2/ time.\n3. Using the submatrices created in step 1 and the 10 matrices created in step 2,\nrecursively compute seven matrix products P1; P2; : : : ; P7. Each matrix Pi is\nn=2 \t n=2.\n4. Compute the desired submatrices C11; C12; C21; C22 of the result matrix C by\nadding and subtracting various combinations of the Pi matrices. We can com-\npute all four submatrices in ‚.n2/ time.\nWe shall see the details of steps 2–4 in a moment, but we already have enough\ninformation to set up a recurrence for the running time of Strassen’s method. Let us\nassume that once the matrix size n gets down to 1, we perform a simple scalar mul-\ntiplication, just as in line 4 of SQUARE-MATRIX-MULTIPLY-RECURSIVE. When\nn > 1, steps 1, 2, and 4 take a total of ‚.n2/ time, and step 3 requires us to per-\nform seven multiplications of n=2 \t n=2 matrices. Hence, we obtain the following\nrecurrence for the running time T .n/ of Strassen’s algorithm:\nT .n/ D\n(\n‚.1/\nif n D 1 ;\n7T .n=2/ C ‚.n2/\nif n > 1 :\n(4.18)\n80\nChapter 4\nDivide-and-Conquer\nWe have traded off one matrix multiplication for a constant number of matrix ad-\nditions. Once we understand recurrences and their solutions, we shall see that this\ntradeoff actually leads to a lower asymptotic running time. By the master method\nin Section 4.5, recurrence (4.18) has the solution T .n/ D ‚.nlg 7/.\nWe now proceed to describe the details. In step 2, we create the following 10\nmatrices:\nS1\nD\nB12 \u0005 B22 ;\nS2\nD\nA11 C A12 ;\nS3\nD\nA21 C A22 ;\nS4\nD\nB21 \u0005 B11 ;\nS5\nD\nA11 C A22 ;\nS6\nD\nB11 C B22 ;\nS7\nD\nA12 \u0005 A22 ;\nS8\nD\nB21 C B22 ;\nS9\nD\nA11 \u0005 A21 ;\nS10\nD",
    "parent_5d71a89d-2538-4683-b472-26fc58418b44": "We now proceed to describe the details. In step 2, we create the following 10\nmatrices:\nS1\nD\nB12 \u0005 B22 ;\nS2\nD\nA11 C A12 ;\nS3\nD\nA21 C A22 ;\nS4\nD\nB21 \u0005 B11 ;\nS5\nD\nA11 C A22 ;\nS6\nD\nB11 C B22 ;\nS7\nD\nA12 \u0005 A22 ;\nS8\nD\nB21 C B22 ;\nS9\nD\nA11 \u0005 A21 ;\nS10\nD\nB11 C B12 :\nSince we must add or subtract n=2 \t n=2 matrices 10 times, this step does indeed\ntake ‚.n2/ time.\nIn step 3, we recursively multiply n=2\tn=2 matrices seven times to compute the\nfollowing n=2 \t n=2 matrices, each of which is the sum or difference of products\nof A and B submatrices:\nP1 D A11 \u0003 S1 D A11 \u0003 B12 \u0005 A11 \u0003 B22 ;\nP2 D S2 \u0003 B22 D A11 \u0003 B22 C A12 \u0003 B22 ;\nP3 D S3 \u0003 B11 D A21 \u0003 B11 C A22 \u0003 B11 ;\nP4 D A22 \u0003 S4 D A22 \u0003 B21 \u0005 A22 \u0003 B11 ;\nP5 D S5 \u0003 S6\nD A11 \u0003 B11 C A11 \u0003 B22 C A22 \u0003 B11 C A22 \u0003 B22 ;\nP6 D S7 \u0003 S8\nD A12 \u0003 B21 C A12 \u0003 B22 \u0005 A22 \u0003 B21 \u0005 A22 \u0003 B22 ;\nP7 D S9 \u0003 S10\nD A11 \u0003 B11 C A11 \u0003 B12 \u0005 A21 \u0003 B11 \u0005 A21 \u0003 B12 :\nNote that the only multiplications we need to perform are those in the middle col-\numn of the above equations. The right-hand column just shows what these products\nequal in terms of the original submatrices created in step 1.\nStep 4 adds and subtracts the Pi matrices created in step 3 to construct the four\nn=2 \t n=2 submatrices of the product C. We start with\nC11 D P5 C P4 \u0005 P2 C P6 :\n4.2\nStrassen’s algorithm for matrix multiplication\n81\nExpanding out the right-hand side, with the expansion of each Pi on its own line\nand vertically aligning terms that cancel out, we see that C11 equals\nA11 \u0003B11 CA11 \u0003B22 CA22 \u0003B11 CA22 \u0003B22\n\u0005 A22 \u0003B11\nCA22 \u0003B21\n\u0005 A11 \u0003B22\n\u0005 A12 \u0003B22\n\u0005 A22 \u0003B22 \u0005 A22 \u0003B21 CA12 \u0003B22 CA12 \u0003B21\nA11 \u0003B11\nCA12 \u0003B21 ;\nwhich corresponds to equation (4.11).\nSimilarly, we set\nC12 D P1 C P2 ;\nand so C12 equals\nA11 \u0003B12 \u0005 A11 \u0003B22\nC A11 \u0003B22 C A12 \u0003B22\nA11 \u0003B12\nC A12 \u0003B22 ;\ncorresponding to equation (4.12).\nSetting\nC21 D P3 C P4\nmakes C21 equal\nA21 \u0003B11 C A22 \u0003B11\n\u0005 A22 \u0003B11 C A22 \u0003B21\nA21 \u0003B11\nC A22 \u0003B21 ;\ncorresponding to equation (4.13).\nFinally, we set\nC22 D P5 C P1 \u0005 P3 \u0005 P7 ;",
    "parent_d5b8718d-bc4e-4476-981b-f9de77877c8b": "and so C12 equals\nA11 \u0003B12 \u0005 A11 \u0003B22\nC A11 \u0003B22 C A12 \u0003B22\nA11 \u0003B12\nC A12 \u0003B22 ;\ncorresponding to equation (4.12).\nSetting\nC21 D P3 C P4\nmakes C21 equal\nA21 \u0003B11 C A22 \u0003B11\n\u0005 A22 \u0003B11 C A22 \u0003B21\nA21 \u0003B11\nC A22 \u0003B21 ;\ncorresponding to equation (4.13).\nFinally, we set\nC22 D P5 C P1 \u0005 P3 \u0005 P7 ;\nso that C22 equals\nA11 \u0003B11 CA11 \u0003B22 CA22 \u0003B11 CA22 \u0003B22\n\u0005 A11 \u0003B22\nCA11 \u0003B12\n\u0005 A22 \u0003B11\n\u0005 A21 \u0003B11\n\u0005A11 \u0003B11\n\u0005 A11 \u0003B12 CA21 \u0003B11 CA21 \u0003B12\nA22 \u0003B22\nCA21 \u0003B12 ;\n82\nChapter 4\nDivide-and-Conquer\nwhich corresponds to equation (4.14). Altogether, we add or subtract n=2 \t n=2\nmatrices eight times in step 4, and so this step indeed takes ‚.n2/ time.\nThus, we see that Strassen’s algorithm, comprising steps 1–4, produces the cor-\nrect matrix product and that recurrence (4.18) characterizes its running time. Since\nwe shall see in Section 4.5 that this recurrence has the solution T .n/ D ‚.nlg 7/,\nStrassen’s method is asymptotically faster than the straightforward SQUARE-\nMATRIX-MULTIPLY procedure. The notes at the end of this chapter discuss some\nof the practical aspects of Strassen’s algorithm.\nExercises\nNote: Although Exercises 4.2-3, 4.2-4, and 4.2-5 are about variants on Strassen’s\nalgorithm, you should read Section 4.5 before trying to solve them.\n4.2-1\nUse Strassen’s algorithm to compute the matrix product\n\u0002 1\n3\n7\n5\n\u0003\u0002 6\n8\n4\n2\n\u0003\n:\nShow your work.\n4.2-2\nWrite pseudocode for Strassen’s algorithm.\n4.2-3\nHow would you modify Strassen’s algorithm to multiply n\tn matrices in which n\nis not an exact power of 2? Show that the resulting algorithm runs in time ‚.nlg 7/.\n4.2-4\nWhat is the largest k such that if you can multiply 3 \t 3 matrices using k multi-\nplications (not assuming commutativity of multiplication), then you can multiply\nn \t n matrices in time o.nlg 7/? What would the running time of this algorithm be?\n4.2-5\nV. Pan has discovered a way of multiplying 68 \t 68 matrices using 132,464 mul-\ntiplications, a way of multiplying 70 \t 70 matrices using 143,640 multiplications,",
    "parent_f8eb9eb0-6e57-46c6-8b8a-dcf03e6a3b75": "n \t n matrices in time o.nlg 7/? What would the running time of this algorithm be?\n4.2-5\nV. Pan has discovered a way of multiplying 68 \t 68 matrices using 132,464 mul-\ntiplications, a way of multiplying 70 \t 70 matrices using 143,640 multiplications,\nand a way of multiplying 72 \t 72 matrices using 155,424 multiplications. Which\nmethod yields the best asymptotic running time when used in a divide-and-conquer\nmatrix-multiplication algorithm? How does it compare to Strassen’s algorithm?\n4.3\nThe substitution method for solving recurrences\n83\n4.2-6\nHow quickly can you multiply a kn\tn matrix by an n\tkn matrix, using Strassen’s\nalgorithm as a subroutine? Answer the same question with the order of the input\nmatrices reversed.\n4.2-7\nShow how to multiply the complex numbers a C bi and c C di using only three\nmultiplications of real numbers. The algorithm should take a, b, c, and d as input\nand produce the real component ac \u0005 bd and the imaginary component ad C bc\nseparately.\n4.3\nThe substitution method for solving recurrences\nNow that we have seen how recurrences characterize the running times of divide-\nand-conquer algorithms, we will learn how to solve recurrences. We start in this\nsection with the “substitution” method.\nThe substitution method for solving recurrences comprises two steps:\n1. Guess the form of the solution.\n2. Use mathematical induction to ﬁnd the constants and show that the solution\nworks.\nWe substitute the guessed solution for the function when applying the inductive\nhypothesis to smaller values; hence the name “substitution method.” This method\nis powerful, but we must be able to guess the form of the answer in order to apply it.\nWe can use the substitution method to establish either upper or lower bounds on\na recurrence. As an example, let us determine an upper bound on the recurrence\nT .n/ D 2T .bn=2c/ C n ;\n(4.19)\nwhich is similar to recurrences (4.3) and (4.4).\nWe guess that the solution is\nT .n/ D O.n lg n/.",
    "parent_feccc9ec-935a-4fb3-9d63-3e9e9f103011": "We can use the substitution method to establish either upper or lower bounds on\na recurrence. As an example, let us determine an upper bound on the recurrence\nT .n/ D 2T .bn=2c/ C n ;\n(4.19)\nwhich is similar to recurrences (4.3) and (4.4).\nWe guess that the solution is\nT .n/ D O.n lg n/.\nThe substitution method requires us to prove that T .n/ \u0002\ncn lg n for an appropriate choice of the constant c > 0. We start by assuming\nthat this bound holds for all positive m < n, in particular for m D bn=2c, yielding\nT .bn=2c/ \u0002 c bn=2c lg.bn=2c/. Substituting into the recurrence yields\nT .n/\n\u0002\n2.c bn=2c lg.bn=2c// C n\n\u0002\ncn lg.n=2/ C n\nD\ncn lg n \u0005 cn lg 2 C n\nD\ncn lg n \u0005 cn C n\n\u0002\ncn lg n ;\n84\nChapter 4\nDivide-and-Conquer\nwhere the last step holds as long as c \u0006 1.\nMathematical induction now requires us to show that our solution holds for the\nboundary conditions. Typically, we do so by showing that the boundary condi-\ntions are suitable as base cases for the inductive proof. For the recurrence (4.19),\nwe must show that we can choose the constant c large enough so that the bound\nT .n/ \u0002 cn lg n works for the boundary conditions as well.\nThis requirement\ncan sometimes lead to problems. Let us assume, for the sake of argument, that\nT .1/ D 1 is the sole boundary condition of the recurrence. Then for n D 1, the\nbound T .n/ \u0002 cn lg n yields T .1/ \u0002 c1 lg 1 D 0, which is at odds with T .1/ D 1.\nConsequently, the base case of our inductive proof fails to hold.\nWe can overcome this obstacle in proving an inductive hypothesis for a spe-\nciﬁc boundary condition with only a little more effort. In the recurrence (4.19),\nfor example, we take advantage of asymptotic notation requiring us only to prove\nT .n/ \u0002 cn lg n for n \u0006 n0, where n0 is a constant that we get to choose. We\nkeep the troublesome boundary condition T .1/ D 1, but remove it from consid-\neration in the inductive proof. We do so by ﬁrst observing that for n > 3, the",
    "parent_74455182-f9aa-496a-ac69-e3e9532ec7a9": "T .n/ \u0002 cn lg n for n \u0006 n0, where n0 is a constant that we get to choose. We\nkeep the troublesome boundary condition T .1/ D 1, but remove it from consid-\neration in the inductive proof. We do so by ﬁrst observing that for n > 3, the\nrecurrence does not depend directly on T .1/. Thus, we can replace T .1/ by T .2/\nand T .3/ as the base cases in the inductive proof, letting n0 D 2. Note that we\nmake a distinction between the base case of the recurrence (n D 1) and the base\ncases of the inductive proof (n D 2 and n D 3). With T .1/ D 1, we derive from\nthe recurrence that T .2/ D 4 and T .3/ D 5. Now we can complete the inductive\nproof that T .n/ \u0002 cn lg n for some constant c \u0006 1 by choosing c large enough\nso that T .2/ \u0002 c2 lg 2 and T .3/ \u0002 c3 lg 3. As it turns out, any choice of c \u0006 2\nsufﬁces for the base cases of n D 2 and n D 3 to hold. For most of the recurrences\nwe shall examine, it is straightforward to extend boundary conditions to make the\ninductive assumption work for small n, and we shall not always explicitly work out\nthe details.\nMaking a good guess\nUnfortunately, there is no general way to guess the correct solutions to recurrences.\nGuessing a solution takes experience and, occasionally, creativity. Fortunately,\nthough, you can use some heuristics to help you become a good guesser. You\ncan also use recursion trees, which we shall see in Section 4.4, to generate good\nguesses.\nIf a recurrence is similar to one you have seen before, then guessing a similar\nsolution is reasonable. As an example, consider the recurrence\nT .n/ D 2T .bn=2c C 17/ C n ;\nwhich looks difﬁcult because of the added “17” in the argument to T on the right-\nhand side. Intuitively, however, this additional term cannot substantially affect the\n4.3\nThe substitution method for solving recurrences\n85\nsolution to the recurrence. When n is large, the difference between bn=2c and\nbn=2c C 17 is not that large: both cut n nearly evenly in half. Consequently, we",
    "parent_8752745a-e9f8-4902-93ea-a9f64187a827": "hand side. Intuitively, however, this additional term cannot substantially affect the\n4.3\nThe substitution method for solving recurrences\n85\nsolution to the recurrence. When n is large, the difference between bn=2c and\nbn=2c C 17 is not that large: both cut n nearly evenly in half. Consequently, we\nmake the guess that T .n/ D O.n lg n/, which you can verify as correct by using\nthe substitution method (see Exercise 4.3-6).\nAnother way to make a good guess is to prove loose upper and lower bounds on\nthe recurrence and then reduce the range of uncertainty. For example, we might\nstart with a lower bound of T .n/ D \u0004.n/ for the recurrence (4.19), since we\nhave the term n in the recurrence, and we can prove an initial upper bound of\nT .n/ D O.n2/. Then, we can gradually lower the upper bound and raise the\nlower bound until we converge on the correct, asymptotically tight solution of\nT .n/ D ‚.n lg n/.\nSubtleties\nSometimes you might correctly guess an asymptotic bound on the solution of a\nrecurrence, but somehow the math fails to work out in the induction. The problem\nfrequently turns out to be that the inductive assumption is not strong enough to\nprove the detailed bound. If you revise the guess by subtracting a lower-order term\nwhen you hit such a snag, the math often goes through.\nConsider the recurrence\nT .n/ D T .bn=2c/ C T .dn=2e/ C 1 :\nWe guess that the solution is T .n/ D O.n/, and we try to show that T .n/ \u0002 cn for\nan appropriate choice of the constant c. Substituting our guess in the recurrence,\nwe obtain\nT .n/\n\u0002\nc bn=2c C c dn=2e C 1\nD\ncn C 1 ;\nwhich does not imply T .n/ \u0002 cn for any choice of c. We might be tempted to try\na larger guess, say T .n/ D O.n2/. Although we can make this larger guess work,\nour original guess of T .n/ D O.n/ is correct. In order to show that it is correct,\nhowever, we must make a stronger inductive hypothesis.\nIntuitively, our guess is nearly right: we are off only by the constant 1, a",
    "parent_1397c00e-d305-4671-af68-c5b0e3e0ccc2": "a larger guess, say T .n/ D O.n2/. Although we can make this larger guess work,\nour original guess of T .n/ D O.n/ is correct. In order to show that it is correct,\nhowever, we must make a stronger inductive hypothesis.\nIntuitively, our guess is nearly right: we are off only by the constant 1, a\nlower-order term. Nevertheless, mathematical induction does not work unless we\nprove the exact form of the inductive hypothesis.\nWe overcome our difﬁculty\nby subtracting a lower-order term from our previous guess. Our new guess is\nT .n/ \u0002 cn \u0005 d, where d \u0006 0 is a constant. We now have\nT .n/\n\u0002\n.c bn=2c \u0005 d/ C .c dn=2e \u0005 d/ C 1\nD\ncn \u0005 2d C 1\n\u0002\ncn \u0005 d ;\n86\nChapter 4\nDivide-and-Conquer\nas long as d \u0006 1. As before, we must choose the constant c large enough to handle\nthe boundary conditions.\nYou might ﬁnd the idea of subtracting a lower-order term counterintuitive. Af-\nter all, if the math does not work out, we should increase our guess, right?\nNot necessarily! When proving an upper bound by induction, it may actually be\nmore difﬁcult to prove that a weaker upper bound holds, because in order to prove\nthe weaker bound, we must use the same weaker bound inductively in the proof.\nIn our current example, when the recurrence has more than one recursive term, we\nget to subtract out the lower-order term of the proposed bound once per recursive\nterm. In the above example, we subtracted out the constant d twice, once for the\nT .bn=2c/ term and once for the T .dn=2e/ term. We ended up with the inequality\nT .n/ \u0002 cn \u0005 2d C 1, and it was easy to ﬁnd values of d to make cn \u0005 2d C 1 be\nless than or equal to cn \u0005 d.\nAvoiding pitfalls\nIt is easy to err in the use of asymptotic notation.\nFor example, in the recur-\nrence (4.19) we can falsely “prove” T .n/ D O.n/ by guessing T .n/ \u0002 cn and\nthen arguing\nT .n/\n\u0002\n2.c bn=2c/ C n\n\u0002\ncn C n\nD\nO.n/ ;",
    "parent_f9019db4-7f48-4a11-a869-49ed266e8936": "wrong!!\nsince c is a constant. The error is that we have not proved the exact form of the\ninductive hypothesis, that is, that T .n/ \u0002 cn. We therefore will explicitly prove\nthat T .n/ \u0002 cn when we want to show that T .n/ D O.n/.\nChanging variables\nSometimes, a little algebraic manipulation can make an unknown recurrence simi-\nlar to one you have seen before. As an example, consider the recurrence\nT .n/ D 2T\n\u000b\rpn\n˘\f\nC lg n ;\nwhich looks difﬁcult. We can simplify this recurrence, though, with a change of\nvariables. For convenience, we shall not worry about rounding off values, such\nas pn, to be integers. Renaming m D lg n yields\nT .2m/ D 2T .2m=2/ C m :\nWe can now rename S.m/ D T .2m/ to produce the new recurrence\nS.m/ D 2S.m=2/ C m ;\n4.3\nThe substitution method for solving recurrences\n87\nwhich is very much like recurrence (4.19). Indeed, this new recurrence has the\nsame solution: S.m/ D O.m lg m/. Changing back from S.m/ to T .n/, we obtain\nT .n/ D T .2m/ D S.m/ D O.m lg m/ D O.lg n lg lg n/ :\nExercises\n4.3-1\nShow that the solution of T .n/ D T .n \u0005 1/ C n is O.n2/.\n4.3-2\nShow that the solution of T .n/ D T .dn=2e/ C 1 is O.lg n/.\n4.3-3\nWe saw that the solution of T .n/ D 2T .bn=2c/Cn is O.n lg n/. Show that the so-\nlution of this recurrence is also \u0004.n lg n/. Conclude that the solution is ‚.n lg n/.\n4.3-4\nShow that by making a different inductive hypothesis, we can overcome the difﬁ-\nculty with the boundary condition T .1/ D 1 for recurrence (4.19) without adjusting\nthe boundary conditions for the inductive proof.\n4.3-5\nShow that ‚.n lg n/ is the solution to the “exact” recurrence (4.3) for merge sort.\n4.3-6\nShow that the solution to T .n/ D 2T .bn=2c C 17/ C n is O.n lg n/.\n4.3-7\nUsing the master method in Section 4.5, you can show that the solution to the\nrecurrence T .n/ D 4T .n=3/ C n is T .n/ D ‚.nlog3 4/. Show that a substitution\nproof with the assumption T .n/ \u0002 cnlog3 4 fails. Then show how to subtract off a",
    "parent_f9821c74-1435-438e-858f-25af4e1bbf88": "4.3-7\nUsing the master method in Section 4.5, you can show that the solution to the\nrecurrence T .n/ D 4T .n=3/ C n is T .n/ D ‚.nlog3 4/. Show that a substitution\nproof with the assumption T .n/ \u0002 cnlog3 4 fails. Then show how to subtract off a\nlower-order term to make a substitution proof work.\n4.3-8\nUsing the master method in Section 4.5, you can show that the solution to the\nrecurrence T .n/ D 4T .n=2/ C n2 is T .n/ D ‚.n2/. Show that a substitution\nproof with the assumption T .n/ \u0002 cn2 fails. Then show how to subtract off a\nlower-order term to make a substitution proof work.\n88\nChapter 4\nDivide-and-Conquer\n4.3-9\nSolve the recurrence T .n/ D 3T .pn/ C log n by making a change of variables.\nYour solution should be asymptotically tight. Do not worry about whether values\nare integral.\n4.4\nThe recursion-tree method for solving recurrences\nAlthough you can use the substitution method to provide a succinct proof that\na solution to a recurrence is correct, you might have trouble coming up with a\ngood guess. Drawing out a recursion tree, as we did in our analysis of the merge\nsort recurrence in Section 2.3.2, serves as a straightforward way to devise a good\nguess. In a recursion tree, each node represents the cost of a single subproblem\nsomewhere in the set of recursive function invocations. We sum the costs within\neach level of the tree to obtain a set of per-level costs, and then we sum all the\nper-level costs to determine the total cost of all levels of the recursion.\nA recursion tree is best used to generate a good guess, which you can then verify\nby the substitution method. When using a recursion tree to generate a good guess,\nyou can often tolerate a small amount of “sloppiness,” since you will be verifying\nyour guess later on. If you are very careful when drawing out a recursion tree and\nsumming the costs, however, you can use a recursion tree as a direct proof of a\nsolution to a recurrence. In this section, we will use recursion trees to generate",
    "parent_628db3c1-d4f4-4929-8bd4-9048a0cb98e4": "your guess later on. If you are very careful when drawing out a recursion tree and\nsumming the costs, however, you can use a recursion tree as a direct proof of a\nsolution to a recurrence. In this section, we will use recursion trees to generate\ngood guesses, and in Section 4.6, we will use recursion trees directly to prove the\ntheorem that forms the basis of the master method.\nFor example, let us see how a recursion tree would provide a good guess for\nthe recurrence T .n/ D 3T .bn=4c/ C ‚.n2/. We start by focusing on ﬁnding an\nupper bound for the solution. Because we know that ﬂoors and ceilings usually do\nnot matter when solving recurrences (here’s an example of sloppiness that we can\ntolerate), we create a recursion tree for the recurrence T .n/ D 3T .n=4/ C cn2,\nhaving written out the implied constant coefﬁcient c > 0.\nFigure 4.5 shows how we derive the recursion tree for T .n/ D 3T .n=4/ C cn2.\nFor convenience, we assume that n is an exact power of 4 (another example of\ntolerable sloppiness) so that all subproblem sizes are integers. Part (a) of the ﬁgure\nshows T .n/, which we expand in part (b) into an equivalent tree representing the\nrecurrence. The cn2 term at the root represents the cost at the top level of recursion,\nand the three subtrees of the root represent the costs incurred by the subproblems\nof size n=4. Part (c) shows this process carried one step further by expanding each\nnode with cost T .n=4/ from part (b). The cost for each of the three children of the\nroot is c.n=4/2. We continue expanding each node in the tree by breaking it into\nits constituent parts as determined by the recurrence.\n4.4\nThe recursion-tree method for solving recurrences\n89\n…\n…\n(d)\n(c)\n(b)\n(a)\nT .n/\ncn2\ncn2\ncn2\nT\n\u000b n\n4\n\f\nT\n\u000b n\n4\n\f\nT\n\u000b n\n4\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\ncn2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16",
    "parent_49874f2c-c76b-4a7c-a772-932b7e57094d": "(c)\n(b)\n(a)\nT .n/\ncn2\ncn2\ncn2\nT\n\u000b n\n4\n\f\nT\n\u000b n\n4\n\f\nT\n\u000b n\n4\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\nT\n\u000b n\n16\n\f\ncn2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n4\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\nc\n\u000b n\n16\n\f2\n3\n16 cn2\n\u000b 3\n16\n\f2 cn2\nlog4 n\nnlog4 3\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\nT .1/\n‚.nlog4 3/\nTotal: O.n2/\nFigure 4.5\nConstructing a recursion tree for the recurrence T .n/ D 3T .n=4/ C cn2. Part (a)\nshows T .n/, which progressively expands in (b)–(d) to form the recursion tree. The fully expanded\ntree in part (d) has height log4 n (it has log4 n C 1 levels).\n90\nChapter 4\nDivide-and-Conquer\nBecause subproblem sizes decrease by a factor of 4 each time we go down one\nlevel, we eventually must reach a boundary condition. How far from the root do\nwe reach one? The subproblem size for a node at depth i is n=4i. Thus, the\nsubproblem size hits n D 1 when n=4i D 1 or, equivalently, when i D log4 n.\nThus, the tree has log4 n C 1 levels (at depths 0; 1; 2; : : : ; log4 n).\nNext we determine the cost at each level of the tree. Each level has three times\nmore nodes than the level above, and so the number of nodes at depth i is 3i.\nBecause subproblem sizes reduce by a factor of 4 for each level we go down\nfrom the root, each node at depth i, for i D 0; 1; 2; : : : ; log4 n \u0005 1, has a cost\nof c.n=4i/2. Multiplying, we see that the total cost over all nodes at depth i, for\ni D 0; 1; 2; : : : ; log4 n \u0005 1, is 3ic.n=4i/2 D .3=16/icn2. The bottom level, at\ndepth log4 n, has 3log4 n D nlog4 3 nodes, each contributing cost T .1/, for a total\ncost of nlog4 3T .1/, which is ‚.nlog4 3/, since we assume that T .1/ is a constant.\nNow we add up the costs over all levels to determine the cost for the entire tree:\nT .n/\nD\ncn2 C 3\n16 cn2 C\n\u0002 3\n16\n\u00032\ncn2 C \u0003 \u0003 \u0003 C\n\u0002 3\n16\n\u0003log4 n\u00031\ncn2 C ‚.nlog4 3/\nD\nlog4 n\u00031\nX\niD0\n\u0002 3\n16\n\u0003i",
    "parent_f89e9465-a71a-4b29-bb4c-72c93d406ec7": "cost of nlog4 3T .1/, which is ‚.nlog4 3/, since we assume that T .1/ is a constant.\nNow we add up the costs over all levels to determine the cost for the entire tree:\nT .n/\nD\ncn2 C 3\n16 cn2 C\n\u0002 3\n16\n\u00032\ncn2 C \u0003 \u0003 \u0003 C\n\u0002 3\n16\n\u0003log4 n\u00031\ncn2 C ‚.nlog4 3/\nD\nlog4 n\u00031\nX\niD0\n\u0002 3\n16\n\u0003i\ncn2 C ‚.nlog4 3/\nD\n.3=16/log4 n \u0005 1\n.3=16/ \u0005 1\ncn2 C ‚.nlog4 3/\n(by equation (A.5)) :\nThis last formula looks somewhat messy until we realize that we can again take\nadvantage of small amounts of sloppiness and use an inﬁnite decreasing geometric\nseries as an upper bound. Backing up one step and applying equation (A.6), we\nhave\nT .n/\nD\nlog4 n\u00031\nX\niD0\n\u0002 3\n16\n\u0003i\ncn2 C ‚.nlog4 3/\n<\n1\nX\niD0\n\u0002 3\n16\n\u0003i\ncn2 C ‚.nlog4 3/\nD\n1\n1 \u0005 .3=16/ cn2 C ‚.nlog4 3/\nD\n16\n13 cn2 C ‚.nlog4 3/\nD\nO.n2/ :\nThus, we have derived a guess of T .n/ D O.n2/ for our original recurrence\nT .n/ D 3T .bn=4c/ C ‚.n2/. In this example, the coefﬁcients of cn2 form a\ndecreasing geometric series and, by equation (A.6), the sum of these coefﬁcients\n4.4\nThe recursion-tree method for solving recurrences\n91\n…\n…\ncn\ncn\ncn\ncn\nc\n\u000b n\n3\n\f\nc\n\u000b 2n\n3\n\f\nc\n\u000b n\n9\n\f\nc\n\u000b 2n\n9\n\f\nc\n\u000b 2n\n9\n\f\nc\n\u000b 4n\n9\n\f\nlog3=2 n\nTotal: O.n lg n/\nFigure 4.6\nA recursion tree for the recurrence T .n/ D T .n=3/ C T .2n=3/ C cn.\nis bounded from above by the constant 16=13. Since the root’s contribution to the\ntotal cost is cn2, the root contributes a constant fraction of the total cost. In other\nwords, the cost of the root dominates the total cost of the tree.\nIn fact, if O.n2/ is indeed an upper bound for the recurrence (as we shall verify in\na moment), then it must be a tight bound. Why? The ﬁrst recursive call contributes\na cost of ‚.n2/, and so \u0004.n2/ must be a lower bound for the recurrence.\nNow we can use the substitution method to verify that our guess was cor-\nrect, that is, T .n/ D O.n2/ is an upper bound for the recurrence T .n/ D\n3T .bn=4c/ C ‚.n2/. We want to show that T .n/ \u0002 dn2 for some constant d > 0.\nUsing the same constant c > 0 as before, we have\nT .n/\n\u0002",
    "parent_df8587c3-9a49-40b8-84cf-2e0712c803ea": "Now we can use the substitution method to verify that our guess was cor-\nrect, that is, T .n/ D O.n2/ is an upper bound for the recurrence T .n/ D\n3T .bn=4c/ C ‚.n2/. We want to show that T .n/ \u0002 dn2 for some constant d > 0.\nUsing the same constant c > 0 as before, we have\nT .n/\n\u0002\n3T .bn=4c/ C cn2\n\u0002\n3d bn=4c2 C cn2\n\u0002\n3d.n=4/2 C cn2\nD\n3\n16 dn2 C cn2\n\u0002\ndn2 ;\nwhere the last step holds as long as d \u0006 .16=13/c.\nIn another, more intricate, example, Figure 4.6 shows the recursion tree for\nT .n/ D T .n=3/ C T .2n=3/ C O.n/ :\n(Again, we omit ﬂoor and ceiling functions for simplicity.) As before, we let c\nrepresent the constant factor in the O.n/ term. When we add the values across the\nlevels of the recursion tree shown in the ﬁgure, we get a value of cn for every level.\n92\nChapter 4\nDivide-and-Conquer\nThe longest simple path from the root to a leaf is n ! .2=3/n ! .2=3/2n !\n\u0003 \u0003 \u0003 ! 1. Since .2=3/kn D 1 when k D log3=2 n, the height of the tree is log3=2 n.\nIntuitively, we expect the solution to the recurrence to be at most the number\nof levels times the cost of each level, or O.cn log3=2 n/ D O.n lg n/. Figure 4.6\nshows only the top levels of the recursion tree, however, and not every level in the\ntree contributes a cost of cn. Consider the cost of the leaves. If this recursion tree\nwere a complete binary tree of height log3=2 n, there would be 2log3=2 n D nlog3=2 2\nleaves. Since the cost of each leaf is a constant, the total cost of all leaves would\nthen be ‚.nlog3=2 2/ which, since log3=2 2 is a constant strictly greater than 1,\nis !.n lg n/. This recursion tree is not a complete binary tree, however, and so\nit has fewer than nlog3=2 2 leaves. Moreover, as we go down from the root, more\nand more internal nodes are absent. Consequently, levels toward the bottom of the\nrecursion tree contribute less than cn to the total cost. We could work out an accu-\nrate accounting of all costs, but remember that we are just trying to come up with a",
    "parent_d7bf4946-3c1d-4626-9ee2-9cbea27048ed": "and more internal nodes are absent. Consequently, levels toward the bottom of the\nrecursion tree contribute less than cn to the total cost. We could work out an accu-\nrate accounting of all costs, but remember that we are just trying to come up with a\nguess to use in the substitution method. Let us tolerate the sloppiness and attempt\nto show that a guess of O.n lg n/ for the upper bound is correct.\nIndeed, we can use the substitution method to verify that O.n lg n/ is an upper\nbound for the solution to the recurrence. We show that T .n/ \u0002 dn lg n, where d is\na suitable positive constant. We have\nT .n/\n\u0002\nT .n=3/ C T .2n=3/ C cn\n\u0002\nd.n=3/ lg.n=3/ C d.2n=3/ lg.2n=3/ C cn\nD\n.d.n=3/ lg n \u0005 d.n=3/ lg 3/\nC .d.2n=3/ lg n \u0005 d.2n=3/ lg.3=2// C cn\nD\ndn lg n \u0005 d..n=3/ lg 3 C .2n=3/ lg.3=2// C cn\nD\ndn lg n \u0005 d..n=3/ lg 3 C .2n=3/ lg 3 \u0005 .2n=3/ lg 2/ C cn\nD\ndn lg n \u0005 dn.lg 3 \u0005 2=3/ C cn\n\u0002\ndn lg n ;\nas long as d \u0006 c=.lg 3\u0005.2=3//. Thus, we did not need to perform a more accurate\naccounting of costs in the recursion tree.\nExercises\n4.4-1\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/ D 3T .bn=2c/ C n. Use the substitution method to verify your answer.\n4.4-2\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/ D T .n=2/ C n2. Use the substitution method to verify your answer.\n4.5\nThe master method for solving recurrences\n93\n4.4-3\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/ D 4T .n=2 C 2/ C n. Use the substitution method to verify your answer.\n4.4-4\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/ D 2T .n \u0005 1/ C 1. Use the substitution method to verify your answer.\n4.4-5\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/ D T .n\u00051/CT .n=2/Cn. Use the substitution method to verify your answer.\n4.4-6\nArgue that the solution to the recurrence T .n/ D T .n=3/CT .2n=3/Ccn, where c",
    "parent_9335072f-4496-41b0-aa7b-3cbbea7dd3b7": "4.4-5\nUse a recursion tree to determine a good asymptotic upper bound on the recurrence\nT .n/ D T .n\u00051/CT .n=2/Cn. Use the substitution method to verify your answer.\n4.4-6\nArgue that the solution to the recurrence T .n/ D T .n=3/CT .2n=3/Ccn, where c\nis a constant, is \u0004.n lg n/ by appealing to a recursion tree.\n4.4-7\nDraw the recursion tree for T .n/ D 4T .bn=2c/ C cn, where c is a constant, and\nprovide a tight asymptotic bound on its solution. Verify your bound by the substi-\ntution method.\n4.4-8\nUse a recursion tree to give an asymptotically tight solution to the recurrence\nT .n/ D T .n \u0005 a/ C T .a/ C cn, where a \u0006 1 and c > 0 are constants.\n4.4-9\nUse a recursion tree to give an asymptotically tight solution to the recurrence\nT .n/ D T .˛n/ C T ..1 \u0005 ˛/n/ C cn, where ˛ is a constant in the range 0 < ˛ < 1\nand c > 0 is also a constant.\n4.5\nThe master method for solving recurrences\nThe master method provides a “cookbook” method for solving recurrences of the\nform\nT .n/ D aT .n=b/ C f .n/ ;\n(4.20)\nwhere a \u0006 1 and b > 1 are constants and f .n/ is an asymptotically positive\nfunction. To use the master method, you will need to memorize three cases, but\nthen you will be able to solve many recurrences quite easily, often without pencil\nand paper.\n94\nChapter 4\nDivide-and-Conquer\nThe recurrence (4.20) describes the running time of an algorithm that divides a\nproblem of size n into a subproblems, each of size n=b, where a and b are positive\nconstants. The a subproblems are solved recursively, each in time T .n=b/. The\nfunction f .n/ encompasses the cost of dividing the problem and combining the\nresults of the subproblems. For example, the recurrence arising from Strassen’s\nalgorithm has a D 7, b D 2, and f .n/ D ‚.n2/.\nAs a matter of technical correctness, the recurrence is not actually well deﬁned,\nbecause n=b might not be an integer. Replacing each of the a terms T .n=b/ with\neither T .bn=bc/ or T .dn=be/ will not affect the asymptotic behavior of the recur-",
    "parent_09e9de2e-4918-4fd0-a040-3398466974a0": "algorithm has a D 7, b D 2, and f .n/ D ‚.n2/.\nAs a matter of technical correctness, the recurrence is not actually well deﬁned,\nbecause n=b might not be an integer. Replacing each of the a terms T .n=b/ with\neither T .bn=bc/ or T .dn=be/ will not affect the asymptotic behavior of the recur-\nrence, however. (We will prove this assertion in the next section.) We normally\nﬁnd it convenient, therefore, to omit the ﬂoor and ceiling functions when writing\ndivide-and-conquer recurrences of this form.\nThe master theorem\nThe master method depends on the following theorem.\nTheorem 4.1 (Master theorem)\nLet a \u0006 1 and b > 1 be constants, let f .n/ be a function, and let T .n/ be deﬁned\non the nonnegative integers by the recurrence\nT .n/ D aT .n=b/ C f .n/ ;\nwhere we interpret n=b to mean either bn=bc or dn=be. Then T .n/ has the follow-\ning asymptotic bounds:\n1. If f .n/ D O.nlogb a\u0003\u0002/ for some constant \b > 0, then T .n/ D ‚.nlogb a/.\n2. If f .n/ D ‚.nlogb a/, then T .n/ D ‚.nlogb a lg n/.\n3. If f .n/ D \u0004.nlogb aC\u0002/ for some constant \b > 0, and if af .n=b/ \u0002 cf .n/ for\nsome constant c < 1 and all sufﬁciently large n, then T .n/ D ‚.f .n//.\nBefore applying the master theorem to some examples, let’s spend a moment\ntrying to understand what it says. In each of the three cases, we compare the\nfunction f .n/ with the function nlogb a. Intuitively, the larger of the two functions\ndetermines the solution to the recurrence. If, as in case 1, the function nlogb a is the\nlarger, then the solution is T .n/ D ‚.nlogb a/. If, as in case 3, the function f .n/\nis the larger, then the solution is T .n/ D ‚.f .n//. If, as in case 2, the two func-\ntions are the same size, we multiply by a logarithmic factor, and the solution is\nT .n/ D ‚.nlogb a lg n/ D ‚.f .n/ lgn/.\nBeyond this intuition, you need to be aware of some technicalities. In the ﬁrst\ncase, not only must f .n/ be smaller than nlogb a, it must be polynomially smaller.\n4.5\nThe master method for solving recurrences\n95",
    "parent_6a9d0fa7-22a0-4526-b355-a4b3dea88f6b": "T .n/ D ‚.nlogb a lg n/ D ‚.f .n/ lgn/.\nBeyond this intuition, you need to be aware of some technicalities. In the ﬁrst\ncase, not only must f .n/ be smaller than nlogb a, it must be polynomially smaller.\n4.5\nThe master method for solving recurrences\n95\nThat is, f .n/ must be asymptotically smaller than nlogb a by a factor of n\u0002 for some\nconstant \b > 0. In the third case, not only must f .n/ be larger than nlogb a, it also\nmust be polynomially larger and in addition satisfy the “regularity” condition that\naf .n=b/ \u0002 cf .n/. This condition is satisﬁed by most of the polynomially bounded\nfunctions that we shall encounter.\nNote that the three cases do not cover all the possibilities for f .n/. There is\na gap between cases 1 and 2 when f .n/ is smaller than nlogb a but not polynomi-\nally smaller. Similarly, there is a gap between cases 2 and 3 when f .n/ is larger\nthan nlogb a but not polynomially larger. If the function f .n/ falls into one of these\ngaps, or if the regularity condition in case 3 fails to hold, you cannot use the master\nmethod to solve the recurrence.\nUsing the master method\nTo use the master method, we simply determine which case (if any) of the master\ntheorem applies and write down the answer.\nAs a ﬁrst example, consider\nT .n/ D 9T .n=3/ C n :\nFor this recurrence, we have a D 9, b D 3, f .n/ D n, and thus we have that\nnlogb a D nlog3 9 D ‚.n2). Since f .n/ D O.nlog3 9\u0003\u0002/, where \b D 1, we can apply\ncase 1 of the master theorem and conclude that the solution is T .n/ D ‚.n2/.\nNow consider\nT .n/ D T .2n=3/ C 1;\nin which a D 1, b D 3=2, f .n/ D 1, and nlogb a D nlog3=2 1 D n0 D 1. Case 2\napplies, since f .n/ D ‚.nlogb a/ D ‚.1/, and thus the solution to the recurrence\nis T .n/ D ‚.lg n/.\nFor the recurrence\nT .n/ D 3T .n=4/ C n lg n ;\nwe have a D 3, b D 4, f .n/ D n lg n, and nlogb a D nlog4 3 D O.n0:793/.\nSince f .n/ D \u0004.nlog4 3C\u0002/, where \b \u0004 0:2, case 3 applies if we can show that",
    "parent_9242717c-4e3b-4abb-b09d-8dc2c57e12aa": "applies, since f .n/ D ‚.nlogb a/ D ‚.1/, and thus the solution to the recurrence\nis T .n/ D ‚.lg n/.\nFor the recurrence\nT .n/ D 3T .n=4/ C n lg n ;\nwe have a D 3, b D 4, f .n/ D n lg n, and nlogb a D nlog4 3 D O.n0:793/.\nSince f .n/ D \u0004.nlog4 3C\u0002/, where \b \u0004 0:2, case 3 applies if we can show that\nthe regularity condition holds for f .n/. For sufﬁciently large n, we have that\naf .n=b/ D 3.n=4/ lg.n=4/ \u0002 .3=4/n lg n D cf .n/ for c D 3=4. Consequently,\nby case 3, the solution to the recurrence is T .n/ D ‚.n lg n/.\nThe master method does not apply to the recurrence\nT .n/ D 2T .n=2/ C n lg n ;\neven though it appears to have the proper form: a D 2, b D 2, f .n/ D n lg n,\nand nlogb a D n.\nYou might mistakenly think that case 3 should apply, since\n96\nChapter 4\nDivide-and-Conquer\nf .n/ D n lg n is asymptotically larger than nlogb a D n. The problem is that it\nis not polynomially larger. The ratio f .n/=nlogb a D .n lg n/=n D lg n is asymp-\ntotically less than n\u0002 for any positive constant \b. Consequently, the recurrence falls\ninto the gap between case 2 and case 3. (See Exercise 4.6-2 for a solution.)\nLet’s use the master method to solve the recurrences we saw in Sections 4.1\nand 4.2. Recurrence (4.7),\nT .n/ D 2T .n=2/ C ‚.n/ ;\ncharacterizes the running times of the divide-and-conquer algorithm for both the\nmaximum-subarray problem and merge sort. (As is our practice, we omit stating\nthe base case in the recurrence.) Here, we have a D 2, b D 2, f .n/ D ‚.n/, and\nthus we have that nlogb a D nlog2 2 D n. Case 2 applies, since f .n/ D ‚.n/, and so\nwe have the solution T .n/ D ‚.n lg n/.\nRecurrence (4.17),\nT .n/ D 8T .n=2/ C ‚.n2/ ;\ndescribes the running time of the ﬁrst divide-and-conquer algorithm that we saw\nfor matrix multiplication. Now we have a D 8, b D 2, and f .n/ D ‚.n2/,\nand so nlogb a D nlog2 8 D n3. Since n3 is polynomially larger than f .n/ (that is,\nf .n/ D O.n3\u0003\u0002/ for \b D 1), case 1 applies, and T .n/ D ‚.n3/.\nFinally, consider recurrence (4.18),",
    "parent_aba1680f-7023-4cb2-a52e-171e1595833f": "for matrix multiplication. Now we have a D 8, b D 2, and f .n/ D ‚.n2/,\nand so nlogb a D nlog2 8 D n3. Since n3 is polynomially larger than f .n/ (that is,\nf .n/ D O.n3\u0003\u0002/ for \b D 1), case 1 applies, and T .n/ D ‚.n3/.\nFinally, consider recurrence (4.18),\nT .n/ D 7T .n=2/ C ‚.n2/ ;\nwhich describes the running time of Strassen’s algorithm. Here, we have a D 7,\nb D 2, f .n/ D ‚.n2/, and thus nlogb a D nlog2 7. Rewriting log2 7 as lg 7 and\nrecalling that 2:80 < lg 7 < 2:81, we see that f .n/ D O.nlg 7\u0003\u0002/ for \b D 0:8.\nAgain, case 1 applies, and we have the solution T .n/ D ‚.nlg 7/.\nExercises\n4.5-1\nUse the master method to give tight asymptotic bounds for the following recur-\nrences.\na. T .n/ D 2T .n=4/ C 1.\nb. T .n/ D 2T .n=4/ C pn.\nc. T .n/ D 2T .n=4/ C n.\nd. T .n/ D 2T .n=4/ C n2.\n4.6\nProof of the master theorem\n97\n4.5-2\nProfessor Caesar wishes to develop a matrix-multiplication algorithm that is\nasymptotically faster than Strassen’s algorithm. His algorithm will use the divide-\nand-conquer method, dividing each matrix into pieces of size n=4 \t n=4, and the\ndivide and combine steps together will take ‚.n2/ time. He needs to determine\nhow many subproblems his algorithm has to create in order to beat Strassen’s algo-\nrithm. If his algorithm creates a subproblems, then the recurrence for the running\ntime T .n/ becomes T .n/ D aT .n=4/ C ‚.n2/. What is the largest integer value\nof a for which Professor Caesar’s algorithm would be asymptotically faster than\nStrassen’s algorithm?\n4.5-3\nUse the master method to show that the solution to the binary-search recurrence\nT .n/ D T .n=2/ C ‚.1/ is T .n/ D ‚.lg n/. (See Exercise 2.3-5 for a description\nof binary search.)\n4.5-4\nCan the master method be applied to the recurrence T .n/ D 4T .n=2/ C n2 lg n?\nWhy or why not? Give an asymptotic upper bound for this recurrence.\n4.5-5\n?\nConsider the regularity condition af .n=b/ \u0002 cf .n/ for some constant c < 1,",
    "parent_1444d5d7-a311-4279-bb2c-1d3539c63a4a": "of binary search.)\n4.5-4\nCan the master method be applied to the recurrence T .n/ D 4T .n=2/ C n2 lg n?\nWhy or why not? Give an asymptotic upper bound for this recurrence.\n4.5-5\n?\nConsider the regularity condition af .n=b/ \u0002 cf .n/ for some constant c < 1,\nwhich is part of case 3 of the master theorem. Give an example of constants a \u0006 1\nand b > 1 and a function f .n/ that satisﬁes all the conditions in case 3 of the\nmaster theorem except the regularity condition.\n?\n4.6\nProof of the master theorem\nThis section contains a proof of the master theorem (Theorem 4.1). You do not\nneed to understand the proof in order to apply the master theorem.\nThe proof appears in two parts.\nThe ﬁrst part analyzes the master recur-\nrence (4.20), under the simplifying assumption that T .n/ is deﬁned only on ex-\nact powers of b > 1, that is, for n D 1; b; b2; : : :. This part gives all the intuition\nneeded to understand why the master theorem is true. The second part shows how\nto extend the analysis to all positive integers n; it applies mathematical technique\nto the problem of handling ﬂoors and ceilings.\nIn this section, we shall sometimes abuse our asymptotic notation slightly by\nusing it to describe the behavior of functions that are deﬁned only over exact\npowers of b.\nRecall that the deﬁnitions of asymptotic notations require that\n98\nChapter 4\nDivide-and-Conquer\nbounds be proved for all sufﬁciently large numbers, not just those that are pow-\ners of b. Since we could make new asymptotic notations that apply only to the set\nfbi W i D 0; 1; 2; : : :g, instead of to the nonnegative numbers, this abuse is minor.\nNevertheless, we must always be on guard when we use asymptotic notation over\na limited domain lest we draw improper conclusions. For example, proving that\nT .n/ D O.n/ when n is an exact power of 2 does not guarantee that T .n/ D O.n/.\nThe function T .n/ could be deﬁned as\nT .n/ D\n(\nn\nif n D 1; 2; 4; 8; : : : ;\nn2\notherwise ;",
    "parent_42d356cd-c5b6-4894-9821-c1ea86a0d781": "a limited domain lest we draw improper conclusions. For example, proving that\nT .n/ D O.n/ when n is an exact power of 2 does not guarantee that T .n/ D O.n/.\nThe function T .n/ could be deﬁned as\nT .n/ D\n(\nn\nif n D 1; 2; 4; 8; : : : ;\nn2\notherwise ;\nin which case the best upper bound that applies to all values of n is T .n/ D O.n2/.\nBecause of this sort of drastic consequence, we shall never use asymptotic notation\nover a limited domain without making it absolutely clear from the context that we\nare doing so.\n4.6.1\nThe proof for exact powers\nThe ﬁrst part of the proof of the master theorem analyzes the recurrence (4.20)\nT .n/ D aT .n=b/ C f .n/ ;\nfor the master method, under the assumption that n is an exact power of b > 1,\nwhere b need not be an integer. We break the analysis into three lemmas. The ﬁrst\nreduces the problem of solving the master recurrence to the problem of evaluating\nan expression that contains a summation. The second determines bounds on this\nsummation. The third lemma puts the ﬁrst two together to prove a version of the\nmaster theorem for the case in which n is an exact power of b.\nLemma 4.2\nLet a \u0006 1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned\non exact powers of b. Deﬁne T .n/ on exact powers of b by the recurrence\nT .n/ D\n(\n‚.1/\nif n D 1 ;\naT .n=b/ C f .n/\nif n D bi ;\nwhere i is a positive integer. Then\nT .n/ D ‚.nlogb a/ C\nlogb n\u00031\nX\njD0\najf .n=bj/ :\n(4.21)\nProof\nWe use the recursion tree in Figure 4.7. The root of the tree has cost f .n/,\nand it has a children, each with cost f .n=b/. (It is convenient to think of a as being\n4.6\nProof of the master theorem\n99\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\nf .n/\nf .n/\na\na\na\na\na\na\na\na\na\na\na\na\na\nf .n=b/\nf .n=b/\nf .n=b/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\naf .n=b/\na2f .n=b2/\nlogb n\nnlogb a\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.nlogb a/\nTotal: ‚.nlogb a/ C\nlogb n\u00031\nX\njD0\najf .n=bj/\nFigure 4.7",
    "parent_52c7b60a-a50d-4e4b-8460-f542120a607e": "a\na\na\na\na\na\na\na\na\na\na\na\na\nf .n=b/\nf .n=b/\nf .n=b/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\nf .n=b2/\naf .n=b/\na2f .n=b2/\nlogb n\nnlogb a\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.nlogb a/\nTotal: ‚.nlogb a/ C\nlogb n\u00031\nX\njD0\najf .n=bj/\nFigure 4.7\nThe recursion tree generated by T .n/ D aT .n=b/ Cf .n/. The tree is a complete a-ary\ntree with nlogb a leaves and height logb n. The cost of the nodes at each depth is shown at the right,\nand their sum is given in equation (4.21).\nan integer, especially when visualizing the recursion tree, but the mathematics does\nnot require it.) Each of these children has a children, making a2 nodes at depth 2,\nand each of the a children has cost f .n=b2/. In general, there are aj nodes at\ndepth j , and each has cost f .n=bj/. The cost of each leaf is T .1/ D ‚.1/, and\neach leaf is at depth logb n, since n=blogb n D 1. There are alogb n D nlogb a leaves\nin the tree.\nWe can obtain equation (4.21) by summing the costs of the nodes at each depth\nin the tree, as shown in the ﬁgure. The cost for all internal nodes at depth j is\najf .n=bj/, and so the total cost of all internal nodes is\nlogb n\u00031\nX\njD0\najf .n=bj/ :\nIn the underlying divide-and-conquer algorithm, this sum represents the costs of\ndividing problems into subproblems and then recombining the subproblems. The\n100\nChapter 4\nDivide-and-Conquer\ncost of all the leaves, which is the cost of doing all nlogb a subproblems of size 1,\nis ‚.nlogb a/.\nIn terms of the recursion tree, the three cases of the master theorem correspond\nto cases in which the total cost of the tree is (1) dominated by the costs in the\nleaves, (2) evenly distributed among the levels of the tree, or (3) dominated by the\ncost of the root.\nThe summation in equation (4.21) describes the cost of the dividing and com-\nbining steps in the underlying divide-and-conquer algorithm. The next lemma pro-\nvides asymptotic bounds on the summation’s growth.\nLemma 4.3",
    "parent_767f5862-289a-4f35-9806-31b7e71d1f99": "cost of the root.\nThe summation in equation (4.21) describes the cost of the dividing and com-\nbining steps in the underlying divide-and-conquer algorithm. The next lemma pro-\nvides asymptotic bounds on the summation’s growth.\nLemma 4.3\nLet a \u0006 1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned\non exact powers of b. A function g.n/ deﬁned over exact powers of b by\ng.n/ D\nlogb n\u00031\nX\njD0\najf .n=bj/\n(4.22)\nhas the following asymptotic bounds for exact powers of b:\n1. If f .n/ D O.nlogb a\u0003\u0002/ for some constant \b > 0, then g.n/ D O.nlogb a/.\n2. If f .n/ D ‚.nlogb a/, then g.n/ D ‚.nlogb a lg n/.\n3. If af .n=b/ \u0002 cf .n/ for some constant c < 1 and for all sufﬁciently large n,\nthen g.n/ D ‚.f .n//.\nProof\nFor case 1, we have f .n/ D O.nlogb a\u0003\u0002/, which implies that f .n=bj/ D\nO..n=bj /logb a\u0003\u0002/. Substituting into equation (4.22) yields\ng.n/ D O\n logb n\u00031\nX\njD0\naj \u0004 n\nbj\n\u0005logb a\u0003\u0002!\n:\n(4.23)\nWe bound the summation within the O-notation by factoring out terms and simpli-\nfying, which leaves an increasing geometric series:\nlogb n\u00031\nX\njD0\naj \u0004 n\nbj\n\u0005logb a\u0003\u0002\nD\nnlogb a\u0003\u0002\nlogb n\u00031\nX\njD0\n\u0002 ab\u0002\nblogb a\n\u0003j\nD\nnlogb a\u0003\u0002\nlogb n\u00031\nX\njD0\n.b\u0002/j\nD\nnlogb a\u0003\u0002\n\u0002b\u0002 logb n \u0005 1\nb\u0002 \u0005 1\n\u0003\n4.6\nProof of the master theorem\n101\nD\nnlogb a\u0003\u0002\n\u0002n\u0002 \u0005 1\nb\u0002 \u0005 1\n\u0003\n:\nSince b and \b are constants, we can rewrite the last expression as nlogb a\u0003\u0002O.n\u0002/ D\nO.nlogb a/. Substituting this expression for the summation in equation (4.23) yields\ng.n/ D O.nlogb a/ ;\nthereby proving case 1.\nBecause case 2 assumes that f .n/ D ‚.nlogb a/, we have that f .n=bj/ D\n‚..n=bj/logb a/. Substituting into equation (4.22) yields\ng.n/ D ‚\n logb n\u00031\nX\njD0\naj \u0004 n\nbj\n\u0005logb a!\n:\n(4.24)\nWe bound the summation within the ‚-notation as in case 1, but this time we do not\nobtain a geometric series. Instead, we discover that every term of the summation\nis the same:\nlogb n\u00031\nX\njD0\naj \u0004 n\nbj\n\u0005logb a\nD\nnlogb a\nlogb n\u00031\nX\njD0\n\u0004\na\nblogb a\n\u0005j\nD\nnlogb a\nlogb n\u00031\nX\njD0\n1\nD\nnlogb a logb n :",
    "parent_27a9aebf-c104-4490-8074-c997f89db5f9": "We bound the summation within the ‚-notation as in case 1, but this time we do not\nobtain a geometric series. Instead, we discover that every term of the summation\nis the same:\nlogb n\u00031\nX\njD0\naj \u0004 n\nbj\n\u0005logb a\nD\nnlogb a\nlogb n\u00031\nX\njD0\n\u0004\na\nblogb a\n\u0005j\nD\nnlogb a\nlogb n\u00031\nX\njD0\n1\nD\nnlogb a logb n :\nSubstituting this expression for the summation in equation (4.24) yields\ng.n/\nD\n‚.nlogb a logb n/\nD\n‚.nlogb a lg n/ ;\nproving case 2.\nWe prove case 3 similarly. Since f .n/ appears in the deﬁnition (4.22) of g.n/\nand all terms of g.n/ are nonnegative, we can conclude that g.n/ D \u0004.f .n// for\nexact powers of b. We assume in the statement of the lemma that af .n=b/ \u0002 cf .n/\nfor some constant c < 1 and all sufﬁciently large n. We rewrite this assumption\nas f .n=b/ \u0002 .c=a/f .n/ and iterate j times, yielding f .n=bj/ \u0002 .c=a/jf .n/ or,\nequivalently, ajf .n=bj/ \u0002 cjf .n/, where we assume that the values we iterate\non are sufﬁciently large. Since the last, and smallest, such value is n=bj\u00031, it is\nenough to assume that n=bj\u00031 is sufﬁciently large.\nSubstituting into equation (4.22) and simplifying yields a geometric series, but\nunlike the series in case 1, this one has decreasing terms. We use an O.1/ term to\n102\nChapter 4\nDivide-and-Conquer\ncapture the terms that are not covered by our assumption that n is sufﬁciently large:\ng.n/\nD\nlogb n\u00031\nX\njD0\najf .n=bj/\n\u0002\nlogb n\u00031\nX\njD0\ncjf .n/ C O.1/\n\u0002\nf .n/\n1\nX\njD0\ncj C O.1/\nD\nf .n/\n\u0002\n1\n1 \u0005 c\n\u0003\nC O.1/\nD\nO.f .n// ;\nsince c is a constant. Thus, we can conclude that g.n/ D ‚.f .n// for exact powers\nof b. With case 3 proved, the proof of the lemma is complete.\nWe can now prove a version of the master theorem for the case in which n is an\nexact power of b.\nLemma 4.4\nLet a \u0006 1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned\non exact powers of b. Deﬁne T .n/ on exact powers of b by the recurrence\nT .n/ D\n(\n‚.1/\nif n D 1 ;\naT .n=b/ C f .n/\nif n D bi ;",
    "parent_58b1e85d-906f-412b-b54f-630f1a37d5e2": "exact power of b.\nLemma 4.4\nLet a \u0006 1 and b > 1 be constants, and let f .n/ be a nonnegative function deﬁned\non exact powers of b. Deﬁne T .n/ on exact powers of b by the recurrence\nT .n/ D\n(\n‚.1/\nif n D 1 ;\naT .n=b/ C f .n/\nif n D bi ;\nwhere i is a positive integer. Then T .n/ has the following asymptotic bounds for\nexact powers of b:\n1. If f .n/ D O.nlogb a\u0003\u0002/ for some constant \b > 0, then T .n/ D ‚.nlogb a/.\n2. If f .n/ D ‚.nlogb a/, then T .n/ D ‚.nlogb a lg n/.\n3. If f .n/ D \u0004.nlogb aC\u0002/ for some constant \b > 0, and if af .n=b/ \u0002 cf .n/ for\nsome constant c < 1 and all sufﬁciently large n, then T .n/ D ‚.f .n//.\nProof\nWe use the bounds in Lemma 4.3 to evaluate the summation (4.21) from\nLemma 4.2. For case 1, we have\nT .n/\nD\n‚.nlogb a/ C O.nlogb a/\nD\n‚.nlogb a/ ;\n4.6\nProof of the master theorem\n103\nand for case 2,\nT .n/\nD\n‚.nlogb a/ C ‚.nlogb a lg n/\nD\n‚.nlogb a lg n/ :\nFor case 3,\nT .n/\nD\n‚.nlogb a/ C ‚.f .n//\nD\n‚.f .n// ;\nbecause f .n/ D \u0004.nlogb aC\u0002/.\n4.6.2\nFloors and ceilings\nTo complete the proof of the master theorem, we must now extend our analysis to\nthe situation in which ﬂoors and ceilings appear in the master recurrence, so that\nthe recurrence is deﬁned for all integers, not for just exact powers of b. Obtaining\na lower bound on\nT .n/ D aT .dn=be/ C f .n/\n(4.25)\nand an upper bound on\nT .n/ D aT .bn=bc/ C f .n/\n(4.26)\nis routine, since we can push through the bound dn=be \u0006 n=b in the ﬁrst case to\nyield the desired result, and we can push through the bound bn=bc \u0002 n=b in the\nsecond case. We use much the same technique to lower-bound the recurrence (4.26)\nas to upper-bound the recurrence (4.25), and so we shall present only this latter\nbound.\nWe modify the recursion tree of Figure 4.7 to produce the recursion tree in Fig-\nure 4.8. As we go down in the recursion tree, we obtain a sequence of recursive\ninvocations on the arguments\nn ;\ndn=be ;\nddn=be =be ;\ndddn=be =be =be ;\n:::\nLet us denote the j th element in the sequence by nj, where\nnj D\n(\nn\nif j D 0 ;",
    "parent_1e10934d-2362-4f3b-a096-42cb968fef5d": "ure 4.8. As we go down in the recursion tree, we obtain a sequence of recursive\ninvocations on the arguments\nn ;\ndn=be ;\nddn=be =be ;\ndddn=be =be =be ;\n:::\nLet us denote the j th element in the sequence by nj, where\nnj D\n(\nn\nif j D 0 ;\ndnj\u00031=be\nif j > 0 :\n(4.27)\n104\nChapter 4\nDivide-and-Conquer\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\n…\nf .n/\nf .n/\na\na\na\na\na\na\na\na\na\na\na\na\na\nf .n1/\nf .n1/\nf .n1/\nf .n2/\nf .n2/\nf .n2/\nf .n2/\nf .n2/\nf .n2/\nf .n2/\nf .n2/\nf .n2/\naf .n1/\na2f .n2/\nblogb nc\n‚.nlogb a/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.1/\n‚.nlogb a/\nTotal: ‚.nlogb a/ C\nblogb nc\u00031\nX\nj D0\najf .nj/\nFigure 4.8\nThe recursion tree generated by T .n/ D aT .dn=be/Cf .n/. The recursive argument nj\nis given by equation (4.27).\nOur ﬁrst goal is to determine the depth k such that nk is a constant. Using the\ninequality dxe \u0002 x C 1, we obtain\nn0\n\u0002\nn ;\nn1\n\u0002\nn\nb C 1 ;\nn2\n\u0002\nn\nb2 C 1\nb C 1 ;\nn3\n\u0002\nn\nb3 C 1\nb2 C 1\nb C 1 ;\n:::\nIn general, we have\n4.6\nProof of the master theorem\n105\nnj\n\u0002\nn\nbj C\nj\u00031\nX\niD0\n1\nbi\n<\nn\nbj C\n1\nX\niD0\n1\nbi\nD\nn\nbj C\nb\nb \u0005 1 :\nLetting j D blogb nc, we obtain\nnblogb nc\n<\nn\nbblogb nc C\nb\nb \u0005 1\n<\nn\nblogb n\u00031 C\nb\nb \u0005 1\nD\nn\nn=b C\nb\nb \u0005 1\nD\nb C\nb\nb \u0005 1\nD\nO.1/ ;\nand thus we see that at depth blogb nc, the problem size is at most a constant.\nFrom Figure 4.8, we see that\nT .n/ D ‚.nlogb a/ C\nblogb nc\u00031\nX\njD0\najf .nj/ ;\n(4.28)\nwhich is much the same as equation (4.21), except that n is an arbitrary integer and\nnot restricted to be an exact power of b.\nWe can now evaluate the summation\ng.n/ D\nblogb nc\u00031\nX\njD0\najf .nj/\n(4.29)\nfrom equation (4.28) in a manner analogous to the proof of Lemma 4.3. Beginning\nwith case 3, if af .dn=be/ \u0002 cf .n/ for n > bCb=.b\u00051/, where c < 1 is a constant,\nthen it follows that ajf .nj/ \u0002 cjf .n/. Therefore, we can evaluate the sum in\nequation (4.29) just as in Lemma 4.3. For case 2, we have f .n/ D ‚.nlogb a/. If we\ncan show that f .nj/ D O.nlogb a=aj/ D O..n=bj /logb a/, then the proof for case 2",
    "parent_530b46df-8269-4f78-9ae6-a488a430a439": "then it follows that ajf .nj/ \u0002 cjf .n/. Therefore, we can evaluate the sum in\nequation (4.29) just as in Lemma 4.3. For case 2, we have f .n/ D ‚.nlogb a/. If we\ncan show that f .nj/ D O.nlogb a=aj/ D O..n=bj /logb a/, then the proof for case 2\nof Lemma 4.3 will go through. Observe that j \u0002 blogb nc implies bj=n \u0002 1. The\nbound f .n/ D O.nlogb a/ implies that there exists a constant c > 0 such that for all\nsufﬁciently large nj,\n106\nChapter 4\nDivide-and-Conquer\nf .nj/\n\u0002\nc\n\u0002 n\nbj C\nb\nb \u0005 1\n\u0003logb a\nD\nc\n\u0002 n\nbj\n\u0002\n1 C bj\nn \u0003\nb\nb \u0005 1\n\u0003\u0003logb a\nD\nc\n\u0002nlogb a\naj\n\u0003 \u0002\n1 C\n\u0002bj\nn \u0003\nb\nb \u0005 1\n\u0003\u0003logb a\n\u0002\nc\n\u0002nlogb a\naj\n\u0003 \u0002\n1 C\nb\nb \u0005 1\n\u0003logb a\nD\nO\n\u0002nlogb a\naj\n\u0003\n;\nsince c.1 C b=.b \u0005 1//logb a is a constant. Thus, we have proved case 2. The proof\nof case 1 is almost identical. The key is to prove the bound f .nj/ D O.nlogb a\u0003\u0002/,\nwhich is similar to the corresponding proof of case 2, though the algebra is more\nintricate.\nWe have now proved the upper bounds in the master theorem for all integers n.\nThe proof of the lower bounds is similar.\nExercises\n4.6-1\n?\nGive a simple and exact expression for nj in equation (4.27) for the case in which b\nis a positive integer instead of an arbitrary real number.\n4.6-2\n?\nShow that if f .n/ D ‚.nlogb a lgk n/, where k \u0006 0, then the master recurrence has\nsolution T .n/ D ‚.nlogb a lgkC1 n/. For simplicity, conﬁne your analysis to exact\npowers of b.\n4.6-3\n?\nShow that case 3 of the master theorem is overstated, in the sense that the regularity\ncondition af .n=b/ \u0002 cf .n/ for some constant c < 1 implies that there exists a\nconstant \b > 0 such that f .n/ D \u0004.nlogb aC\u0002/.\nProblems for Chapter 4\n107\nProblems\n4-1\nRecurrence examples\nGive asymptotic upper and lower bounds for T .n/ in each of the following recur-\nrences. Assume that T .n/ is constant for n \u0002 2. Make your bounds as tight as\npossible, and justify your answers.\na. T .n/ D 2T .n=2/ C n4.\nb. T .n/ D T .7n=10/ C n.\nc. T .n/ D 16T .n=4/ C n2.\nd. T .n/ D 7T .n=3/ C n2.\ne. T .n/ D 7T .n=2/ C n2.",
    "parent_66ba097c-bc11-44e1-be16-c4010227a2ea": "rences. Assume that T .n/ is constant for n \u0002 2. Make your bounds as tight as\npossible, and justify your answers.\na. T .n/ D 2T .n=2/ C n4.\nb. T .n/ D T .7n=10/ C n.\nc. T .n/ D 16T .n=4/ C n2.\nd. T .n/ D 7T .n=3/ C n2.\ne. T .n/ D 7T .n=2/ C n2.\nf. T .n/ D 2T .n=4/ C pn.\ng. T .n/ D T .n \u0005 2/ C n2.\n4-2\nParameter-passing costs\nThroughout this book, we assume that parameter passing during procedure calls\ntakes constant time, even if an N -element array is being passed. This assumption\nis valid in most systems because a pointer to the array is passed, not the array itself.\nThis problem examines the implications of three parameter-passing strategies:\n1. An array is passed by pointer. Time D ‚.1/.\n2. An array is passed by copying. Time D ‚.N /, where N is the size of the array.\n3. An array is passed by copying only the subrange that might be accessed by the\ncalled procedure. Time D ‚.q \u0005 p C 1/ if the subarray AŒp : : q\u0002 is passed.\na. Consider the recursive binary search algorithm for ﬁnding a number in a sorted\narray (see Exercise 2.3-5). Give recurrences for the worst-case running times\nof binary search when arrays are passed using each of the three methods above,\nand give good upper bounds on the solutions of the recurrences. Let N be the\nsize of the original problem and n be the size of a subproblem.\nb. Redo part (a) for the MERGE-SORT algorithm from Section 2.3.1.\n108\nChapter 4\nDivide-and-Conquer\n4-3\nMore recurrence examples\nGive asymptotic upper and lower bounds for T .n/ in each of the following recur-\nrences. Assume that T .n/ is constant for sufﬁciently small n. Make your bounds\nas tight as possible, and justify your answers.\na. T .n/ D 4T .n=3/ C n lg n.\nb. T .n/ D 3T .n=3/ C n= lg n.\nc. T .n/ D 4T .n=2/ C n2pn.\nd. T .n/ D 3T .n=3 \u0005 2/ C n=2.\ne. T .n/ D 2T .n=2/ C n= lg n.\nf.\nT .n/ D T .n=2/ C T .n=4/ C T .n=8/ C n.\ng. T .n/ D T .n \u0005 1/ C 1=n.\nh. T .n/ D T .n \u0005 1/ C lg n.\ni.\nT .n/ D T .n \u0005 2/ C 1= lg n.\nj.\nT .n/ D pnT .pn/ C n.\n4-4\nFibonacci numbers",
    "parent_55994f75-a773-4cad-b301-d756685c6cd3": "c. T .n/ D 4T .n=2/ C n2pn.\nd. T .n/ D 3T .n=3 \u0005 2/ C n=2.\ne. T .n/ D 2T .n=2/ C n= lg n.\nf.\nT .n/ D T .n=2/ C T .n=4/ C T .n=8/ C n.\ng. T .n/ D T .n \u0005 1/ C 1=n.\nh. T .n/ D T .n \u0005 1/ C lg n.\ni.\nT .n/ D T .n \u0005 2/ C 1= lg n.\nj.\nT .n/ D pnT .pn/ C n.\n4-4\nFibonacci numbers\nThis problem develops properties of the Fibonacci numbers, which are deﬁned\nby recurrence (3.22). We shall use the technique of generating functions to solve\nthe Fibonacci recurrence. Deﬁne the generating function (or formal power se-\nries) F as\nF .´/\nD\n1\nX\niD0\nFi´i\nD\n0 C ´ C ´2 C 2´3 C 3´4 C 5´5 C 8´6 C 13´7 C 21´8 C \u0003 \u0003 \u0003 ;\nwhere Fi is the ith Fibonacci number.\na. Show that F .´/ D ´ C ´F .´/ C ´2F .´/.\nProblems for Chapter 4\n109\nb. Show that\nF .´/\nD\n´\n1 \u0005 ´ \u0005 ´2\nD\n´\n.1 \u0005 \u0007´/.1 \u0005 y\u0007´/\nD\n1\np\n5\n\u0002\n1\n1 \u0005 \u0007´ \u0005\n1\n1 \u0005 y\u0007´\n\u0003\n;\nwhere\n\u0007 D 1 C\np\n5\n2\nD 1:61803 : : :\nand\ny\u0007 D 1 \u0005\np\n5\n2\nD \u00050:61803 : : : :\nc. Show that\nF .´/ D\n1\nX\niD0\n1\np\n5\n.\u0007i \u0005 y\u0007i/´i :\nd. Use part (c) to prove that Fi D \u0007i=\np\n5 for i > 0, rounded to the nearest integer.\n(Hint: Observe that\nˇˇy\u0007\nˇˇ < 1.)\n4-5\nChip testing\nProfessor Diogenes has n supposedly identical integrated-circuit chips that in prin-\nciple are capable of testing each other. The professor’s test jig accommodates two\nchips at a time. When the jig is loaded, each chip tests the other and reports whether\nit is good or bad. A good chip always reports accurately whether the other chip is\ngood or bad, but the professor cannot trust the answer of a bad chip. Thus, the four\npossible outcomes of a test are as follows:\nChip A says\nChip B says\nConclusion\nB is good\nA is good\nboth are good, or both are bad\nB is good\nA is bad\nat least one is bad\nB is bad\nA is good\nat least one is bad\nB is bad\nA is bad\nat least one is bad\na. Show that if more than n=2 chips are bad, the professor cannot necessarily de-\ntermine which chips are good using any strategy based on this kind of pairwise\ntest. Assume that the bad chips can conspire to fool the professor.\n110\nChapter 4\nDivide-and-Conquer",
    "parent_520ced32-e3bd-48ea-83de-ffa9eed86ea4": "B is bad\nA is bad\nat least one is bad\na. Show that if more than n=2 chips are bad, the professor cannot necessarily de-\ntermine which chips are good using any strategy based on this kind of pairwise\ntest. Assume that the bad chips can conspire to fool the professor.\n110\nChapter 4\nDivide-and-Conquer\nb. Consider the problem of ﬁnding a single good chip from among n chips, as-\nsuming that more than n=2 of the chips are good. Show that bn=2c pairwise\ntests are sufﬁcient to reduce the problem to one of nearly half the size.\nc. Show that the good chips can be identiﬁed with ‚.n/ pairwise tests, assuming\nthat more than n=2 of the chips are good. Give and solve the recurrence that\ndescribes the number of tests.\n4-6\nMonge arrays\nAn m \t n array A of real numbers is a Monge array if for all i, j , k, and l such\nthat 1 \u0002 i < k \u0002 m and 1 \u0002 j < l \u0002 n, we have\nAŒi; j \u0002 C AŒk; l\u0002 \u0002 AŒi; l\u0002 C AŒk; j \u0002 :\nIn other words, whenever we pick two rows and two columns of a Monge array and\nconsider the four elements at the intersections of the rows and the columns, the sum\nof the upper-left and lower-right elements is less than or equal to the sum of the\nlower-left and upper-right elements. For example, the following array is Monge:\n10\n17\n13\n28\n23\n17\n22\n16\n29\n23\n24\n28\n22\n34\n24\n11\n13\n6\n17\n7\n45\n44\n32\n37\n23\n36\n33\n19\n21\n6\n75\n66\n51\n53\n34\na. Prove that an array is Monge if and only if for all i D 1; 2; :::; m \u0005 1 and\nj D 1; 2; :::; n \u0005 1, we have\nAŒi; j \u0002 C AŒi C 1; j C 1\u0002 \u0002 AŒi; j C 1\u0002 C AŒi C 1; j \u0002 :\n(Hint: For the “if” part, use induction separately on rows and columns.)\nb. The following array is not Monge. Change one element in order to make it\nMonge. (Hint: Use part (a).)\n37\n23\n22\n32\n21\n6\n7\n10\n53\n34\n30\n31\n32\n13\n9\n6\n43\n21\n15\n8\nNotes for Chapter 4\n111\nc. Let f .i/ be the index of the column containing the leftmost minimum element\nof row i. Prove that f .1/ \u0002 f .2/ \u0002 \u0003 \u0003 \u0003 \u0002 f .m/ for any m \t n Monge array.\nd. Here is a description of a divide-and-conquer algorithm that computes the left-",
    "parent_27ee98a2-b4e8-491c-919b-d8dd9992d718": "53\n34\n30\n31\n32\n13\n9\n6\n43\n21\n15\n8\nNotes for Chapter 4\n111\nc. Let f .i/ be the index of the column containing the leftmost minimum element\nof row i. Prove that f .1/ \u0002 f .2/ \u0002 \u0003 \u0003 \u0003 \u0002 f .m/ for any m \t n Monge array.\nd. Here is a description of a divide-and-conquer algorithm that computes the left-\nmost minimum element in each row of an m \t n Monge array A:\nConstruct a submatrix A0 of A consisting of the even-numbered rows of A.\nRecursively determine the leftmost minimum for each row of A0. Then\ncompute the leftmost minimum in the odd-numbered rows of A.\nExplain how to compute the leftmost minimum in the odd-numbered rows of A\n(given that the leftmost minimum of the even-numbered rows is known) in\nO.m C n/ time.\ne. Write the recurrence describing the running time of the algorithm described in\npart (d). Show that its solution is O.m C n log m/.\nChapter notes\nDivide-and-conquer as a technique for designing algorithms dates back to at least\n1962 in an article by Karatsuba and Ofman [194]. It might have been used well be-\nfore then, however; according to Heideman, Johnson, and Burrus [163], C. F. Gauss\ndevised the ﬁrst fast Fourier transform algorithm in 1805, and Gauss’s formulation\nbreaks the problem into smaller subproblems whose solutions are combined.\nThe maximum-subarray problem in Section 4.1 is a minor variation on a problem\nstudied by Bentley [43, Chapter 7].\nStrassen’s algorithm [325] caused much excitement when it was published\nin 1969. Before then, few imagined the possibility of an algorithm asymptotically\nfaster than the basic SQUARE-MATRIX-MULTIPLY procedure. The asymptotic\nupper bound for matrix multiplication has been improved since then. The most\nasymptotically efﬁcient algorithm for multiplying n \t n matrices to date, due to\nCoppersmith and Winograd [78], has a running time of O.n2:376/. The best lower\nbound known is just the obvious \u0004.n2/ bound (obvious because we must ﬁll in n2\nelements of the product matrix).",
    "parent_c4da30f9-d6fc-4c0c-96a8-160bb648d1b1": "asymptotically efﬁcient algorithm for multiplying n \t n matrices to date, due to\nCoppersmith and Winograd [78], has a running time of O.n2:376/. The best lower\nbound known is just the obvious \u0004.n2/ bound (obvious because we must ﬁll in n2\nelements of the product matrix).\nFrom a practical point of view, Strassen’s algorithm is often not the method of\nchoice for matrix multiplication, for four reasons:\n1. The constant factor hidden in the ‚.nlg 7/ running time of Strassen’s algo-\nrithm is larger than the constant factor in the ‚.n3/-time SQUARE-MATRIX-\nMULTIPLY procedure.\n2. When the matrices are sparse, methods tailored for sparse matrices are faster.\n112\nChapter 4\nDivide-and-Conquer\n3. Strassen’s algorithm is not quite as numerically stable as SQUARE-MATRIX-\nMULTIPLY. In other words, because of the limited precision of computer arith-\nmetic on noninteger values, larger errors accumulate in Strassen’s algorithm\nthan in SQUARE-MATRIX-MULTIPLY.\n4. The submatrices formed at the levels of recursion consume space.\nThe latter two reasons were mitigated around 1990. Higham [167] demonstrated\nthat the difference in numerical stability had been overemphasized; although\nStrassen’s algorithm is too numerically unstable for some applications, it is within\nacceptable limits for others. Bailey, Lee, and Simon [32] discuss techniques for\nreducing the memory requirements for Strassen’s algorithm.\nIn practice, fast matrix-multiplication implementations for dense matrices use\nStrassen’s algorithm for matrix sizes above a “crossover point,” and they switch\nto a simpler method once the subproblem size reduces to below the crossover\npoint. The exact value of the crossover point is highly system dependent. Analyses\nthat count operations but ignore effects from caches and pipelining have produced\ncrossover points as low as n D 8 (by Higham [167]) or n D 12 (by Huss-Lederman\net al. [186]). D’Alberto and Nicolau [81] developed an adaptive scheme, which",
    "parent_84e405b2-278c-4763-9363-146e9de00e82": "that count operations but ignore effects from caches and pipelining have produced\ncrossover points as low as n D 8 (by Higham [167]) or n D 12 (by Huss-Lederman\net al. [186]). D’Alberto and Nicolau [81] developed an adaptive scheme, which\ndetermines the crossover point by benchmarking when their software package is\ninstalled. They found crossover points on various systems ranging from n D 400\nto n D 2150, and they could not ﬁnd a crossover point on a couple of systems.\nRecurrences were studied as early as 1202 by L. Fibonacci, for whom the Fi-\nbonacci numbers are named. A. De Moivre introduced the method of generating\nfunctions (see Problem 4-4) for solving recurrences. The master method is adapted\nfrom Bentley, Haken, and Saxe [44], which provides the extended method justiﬁed\nby Exercise 4.6-2. Knuth [209] and Liu [237] show how to solve linear recurrences\nusing the method of generating functions. Purdom and Brown [287] and Graham,\nKnuth, and Patashnik [152] contain extended discussions of recurrence solving.\nSeveral researchers, including Akra and Bazzi [13], Roura [299], Verma [346],\nand Yap [360], have given methods for solving more general divide-and-conquer\nrecurrences than are solved by the master method. We describe the result of Akra\nand Bazzi here, as modiﬁed by Leighton [228]. The Akra-Bazzi method works for\nrecurrences of the form\nT .x/ D\n(\n‚.1/\nif 1 \u0002 x \u0002 x0 ;\nPk\niD1 aiT .bix/ C f .x/\nif x > x0 ;\n(4.30)\nwhere\n\u0002\nx \u0006 1 is a real number,\n\u0002\nx0 is a constant such that x0 \u0006 1=bi and x0 \u0006 1=.1 \u0005 bi/ for i D 1; 2; : : : ; k,\n\u0002\nai is a positive constant for i D 1; 2; : : : ; k,\nNotes for Chapter 4\n113\n\u0002\nbi is a constant in the range 0 < bi < 1 for i D 1; 2; : : : ; k,\n\u0002\nk \u0006 1 is an integer constant, and\n\u0002\nf .x/ is a nonnegative function that satisﬁes the polynomial-growth condi-\ntion: there exist positive constants c1 and c2 such that for all x \u0006 1, for\ni D 1; 2; : : : ; k, and for all u such that bix \u0002 u \u0002 x, we have c1f .x/ \u0002",
    "parent_4cb7a87e-5386-48c3-aa67-4aad42207c6c": "\u0002\nk \u0006 1 is an integer constant, and\n\u0002\nf .x/ is a nonnegative function that satisﬁes the polynomial-growth condi-\ntion: there exist positive constants c1 and c2 such that for all x \u0006 1, for\ni D 1; 2; : : : ; k, and for all u such that bix \u0002 u \u0002 x, we have c1f .x/ \u0002\nf .u/ \u0002 c2f .x/. (If jf 0.x/j is upper-bounded by some polynomial in x, then\nf .x/ satisﬁes the polynomial-growth condition. For example, f .x/ D x˛ lgˇ x\nsatisﬁes this condition for any real constants ˛ and ˇ.)\nAlthough the master method does not apply to a recurrence such as T .n/ D\nT .bn=3c/ C T .b2n=3c/ C O.n/, the Akra-Bazzi method does. To solve the re-\ncurrence (4.30), we ﬁrst ﬁnd the unique real number p such that Pk\niD1 aibp\ni D 1.\n(Such a p always exists.) The solution to the recurrence is then\nT .n/ D ‚\n\u0002\nxp\n\u0002\n1 C\nZ x\n1\nf .u/\nupC1 du\n\u0003\u0003\n:\nThe Akra-Bazzi method can be somewhat difﬁcult to use, but it serves in solving\nrecurrences that model division of the problem into substantially unequally sized\nsubproblems. The master method is simpler to use, but it applies only when sub-\nproblem sizes are equal.\n5\nProbabilistic Analysis and Randomized\nAlgorithms\nThis chapter introduces probabilistic analysis and randomized algorithms. If you\nare unfamiliar with the basics of probability theory, you should read Appendix C,\nwhich reviews this material. We shall revisit probabilistic analysis and randomized\nalgorithms several times throughout this book.\n5.1\nThe hiring problem\nSuppose that you need to hire a new ofﬁce assistant. Your previous attempts at\nhiring have been unsuccessful, and you decide to use an employment agency. The\nemployment agency sends you one candidate each day. You interview that person\nand then decide either to hire that person or not. You must pay the employment\nagency a small fee to interview an applicant. To actually hire an applicant is more\ncostly, however, since you must ﬁre your current ofﬁce assistant and pay a substan-",
    "parent_61c32e95-0e2b-4775-997b-a230eeb2b876": "and then decide either to hire that person or not. You must pay the employment\nagency a small fee to interview an applicant. To actually hire an applicant is more\ncostly, however, since you must ﬁre your current ofﬁce assistant and pay a substan-\ntial hiring fee to the employment agency. You are committed to having, at all times,\nthe best possible person for the job. Therefore, you decide that, after interviewing\neach applicant, if that applicant is better qualiﬁed than the current ofﬁce assistant,\nyou will ﬁre the current ofﬁce assistant and hire the new applicant. You are willing\nto pay the resulting price of this strategy, but you wish to estimate what that price\nwill be.\nThe procedure HIRE-ASSISTANT, given below, expresses this strategy for hiring\nin pseudocode. It assumes that the candidates for the ofﬁce assistant job are num-\nbered 1 through n. The procedure assumes that you are able to, after interviewing\ncandidate i, determine whether candidate i is the best candidate you have seen so\nfar. To initialize, the procedure creates a dummy candidate, numbered 0, who is\nless qualiﬁed than each of the other candidates.\n5.1\nThe hiring problem\n115\nHIRE-ASSISTANT.n/\n1\nbest D 0\n// candidate 0 is a least-qualiﬁed dummy candidate\n2\nfor i D 1 to n\n3\ninterview candidate i\n4\nif candidate i is better than candidate best\n5\nbest D i\n6\nhire candidate i\nThe cost model for this problem differs from the model described in Chapter 2.\nWe focus not on the running time of HIRE-ASSISTANT, but instead on the costs\nincurred by interviewing and hiring. On the surface, analyzing the cost of this algo-\nrithm may seem very different from analyzing the running time of, say, merge sort.\nThe analytical techniques used, however, are identical whether we are analyzing\ncost or running time. In either case, we are counting the number of times certain\nbasic operations are executed.\nInterviewing has a low cost, say ci, whereas hiring is expensive, costing ch. Let-",
    "parent_eb4c15ac-9c74-4890-94da-f1ff81c5772e": "The analytical techniques used, however, are identical whether we are analyzing\ncost or running time. In either case, we are counting the number of times certain\nbasic operations are executed.\nInterviewing has a low cost, say ci, whereas hiring is expensive, costing ch. Let-\nting m be the number of people hired, the total cost associated with this algorithm\nis O.cin C chm/. No matter how many people we hire, we always interview n\ncandidates and thus always incur the cost cin associated with interviewing. We\ntherefore concentrate on analyzing chm, the hiring cost. This quantity varies with\neach run of the algorithm.\nThis scenario serves as a model for a common computational paradigm. We of-\nten need to ﬁnd the maximum or minimum value in a sequence by examining each\nelement of the sequence and maintaining a current “winner.” The hiring problem\nmodels how often we update our notion of which element is currently winning.\nWorst-case analysis\nIn the worst case, we actually hire every candidate that we interview. This situation\noccurs if the candidates come in strictly increasing order of quality, in which case\nwe hire n times, for a total hiring cost of O.chn/.\nOf course, the candidates do not always come in increasing order of quality. In\nfact, we have no idea about the order in which they arrive, nor do we have any\ncontrol over this order. Therefore, it is natural to ask what we expect to happen in\na typical or average case.\nProbabilistic analysis\nProbabilistic analysis is the use of probability in the analysis of problems. Most\ncommonly, we use probabilistic analysis to analyze the running time of an algo-\nrithm. Sometimes we use it to analyze other quantities, such as the hiring cost\n116\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nin procedure HIRE-ASSISTANT. In order to perform a probabilistic analysis, we\nmust use knowledge of, or make assumptions about, the distribution of the inputs.",
    "parent_eb5a8dc5-183a-4cf0-86a5-db883ed065e9": "116\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nin procedure HIRE-ASSISTANT. In order to perform a probabilistic analysis, we\nmust use knowledge of, or make assumptions about, the distribution of the inputs.\nThen we analyze our algorithm, computing an average-case running time, where\nwe take the average over the distribution of the possible inputs. Thus we are, in\neffect, averaging the running time over all possible inputs. When reporting such a\nrunning time, we will refer to it as the average-case running time.\nWe must be very careful in deciding on the distribution of inputs. For some\nproblems, we may reasonably assume something about the set of all possible in-\nputs, and then we can use probabilistic analysis as a technique for designing an\nefﬁcient algorithm and as a means for gaining insight into a problem. For other\nproblems, we cannot describe a reasonable input distribution, and in these cases\nwe cannot use probabilistic analysis.\nFor the hiring problem, we can assume that the applicants come in a random\norder. What does that mean for this problem? We assume that we can compare\nany two candidates and decide which one is better qualiﬁed; that is, there is a\ntotal order on the candidates. (See Appendix B for the deﬁnition of a total or-\nder.) Thus, we can rank each candidate with a unique number from 1 through n,\nusing rank.i/ to denote the rank of applicant i, and adopt the convention that a\nhigher rank corresponds to a better qualiﬁed applicant. The ordered list hrank.1/;\nrank.2/; : : : ; rank.n/i is a permutation of the list h1; 2; : : : ; ni. Saying that the\napplicants come in a random order is equivalent to saying that this list of ranks is\nequally likely to be any one of the nŠ permutations of the numbers 1 through n.\nAlternatively, we say that the ranks form a uniform random permutation; that is,\neach of the possible nŠ permutations appears with equal probability.\nSection 5.2 contains a probabilistic analysis of the hiring problem.",
    "parent_db58e184-e787-4660-9fdd-af56353aa28c": "equally likely to be any one of the nŠ permutations of the numbers 1 through n.\nAlternatively, we say that the ranks form a uniform random permutation; that is,\neach of the possible nŠ permutations appears with equal probability.\nSection 5.2 contains a probabilistic analysis of the hiring problem.\nRandomized algorithms\nIn order to use probabilistic analysis, we need to know something about the distri-\nbution of the inputs. In many cases, we know very little about the input distribution.\nEven if we do know something about the distribution, we may not be able to model\nthis knowledge computationally. Yet we often can use probability and randomness\nas a tool for algorithm design and analysis, by making the behavior of part of the\nalgorithm random.\nIn the hiring problem, it may seem as if the candidates are being presented to us\nin a random order, but we have no way of knowing whether or not they really are.\nThus, in order to develop a randomized algorithm for the hiring problem, we must\nhave greater control over the order in which we interview the candidates. We will,\ntherefore, change the model slightly. We say that the employment agency has n\ncandidates, and they send us a list of the candidates in advance. On each day, we\nchoose, randomly, which candidate to interview. Although we know nothing about\n5.1\nThe hiring problem\n117\nthe candidates (besides their names), we have made a signiﬁcant change. Instead\nof relying on a guess that the candidates come to us in a random order, we have\ninstead gained control of the process and enforced a random order.\nMore generally, we call an algorithm randomized if its behavior is determined\nnot only by its input but also by values produced by a random-number gener-\nator. We shall assume that we have at our disposal a random-number generator\nRANDOM. A call to RANDOM.a; b/ returns an integer between a and b, inclu-\nsive, with each such integer being equally likely. For example, RANDOM.0; 1/",
    "parent_d19d78c4-7099-465c-ae5b-35eff37a5ea7": "ator. We shall assume that we have at our disposal a random-number generator\nRANDOM. A call to RANDOM.a; b/ returns an integer between a and b, inclu-\nsive, with each such integer being equally likely. For example, RANDOM.0; 1/\nproduces 0 with probability 1=2, and it produces 1 with probability 1=2. A call to\nRANDOM.3; 7/ returns either 3, 4, 5, 6, or 7, each with probability 1=5. Each inte-\nger returned by RANDOM is independent of the integers returned on previous calls.\nYou may imagine RANDOM as rolling a .b \u0005 a C 1/-sided die to obtain its out-\nput. (In practice, most programming environments offer a pseudorandom-number\ngenerator: a deterministic algorithm returning numbers that “look” statistically\nrandom.)\nWhen analyzing the running time of a randomized algorithm, we take the expec-\ntation of the running time over the distribution of values returned by the random\nnumber generator. We distinguish these algorithms from those in which the input\nis random by referring to the running time of a randomized algorithm as an ex-\npected running time. In general, we discuss the average-case running time when\nthe probability distribution is over the inputs to the algorithm, and we discuss the\nexpected running time when the algorithm itself makes random choices.\nExercises\n5.1-1\nShow that the assumption that we are always able to determine which candidate is\nbest, in line 4 of procedure HIRE-ASSISTANT, implies that we know a total order\non the ranks of the candidates.\n5.1-2\n?\nDescribe an implementation of the procedure RANDOM.a; b/ that only makes calls\nto RANDOM.0; 1/. What is the expected running time of your procedure, as a\nfunction of a and b?\n5.1-3\n?\nSuppose that you want to output 0 with probability 1=2 and 1 with probability 1=2.\nAt your disposal is a procedure BIASED-RANDOM, that outputs either 0 or 1. It\noutputs 1 with some probability p and 0 with probability 1 \u0005 p, where 0 < p < 1,\nbut you do not know what p is. Give an algorithm that uses BIASED-RANDOM",
    "parent_242762ed-81fc-4bc0-887c-1a2b3fe6673a": "At your disposal is a procedure BIASED-RANDOM, that outputs either 0 or 1. It\noutputs 1 with some probability p and 0 with probability 1 \u0005 p, where 0 < p < 1,\nbut you do not know what p is. Give an algorithm that uses BIASED-RANDOM\nas a subroutine, and returns an unbiased answer, returning 0 with probability 1=2\n118\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nand 1 with probability 1=2. What is the expected running time of your algorithm\nas a function of p?\n5.2\nIndicator random variables\nIn order to analyze many algorithms, including the hiring problem, we use indicator\nrandom variables. Indicator random variables provide a convenient method for\nconverting between probabilities and expectations. Suppose we are given a sample\nspace S and an event A. Then the indicator random variable I fAg associated with\nevent A is deﬁned as\nI fAg D\n(\n1\nif A occurs ;\n0\nif A does not occur :\n(5.1)\nAs a simple example, let us determine the expected number of heads that we\nobtain when ﬂipping a fair coin. Our sample space is S D fH; T g, with Pr fHg D\nPr fT g D 1=2. We can then deﬁne an indicator random variable XH, associated\nwith the coin coming up heads, which is the event H. This variable counts the\nnumber of heads obtained in this ﬂip, and it is 1 if the coin comes up heads and 0\notherwise. We write\nXH\nD\nI fHg\nD\n(\n1\nif H occurs ;\n0\nif T occurs :\nThe expected number of heads obtained in one ﬂip of the coin is simply the ex-\npected value of our indicator variable XH:\nE ŒXH\u0002\nD\nE ŒI fHg\u0002\nD\n1 \u0003 Pr fHg C 0 \u0003 Pr fT g\nD\n1 \u0003 .1=2/ C 0 \u0003 .1=2/\nD\n1=2 :\nThus the expected number of heads obtained by one ﬂip of a fair coin is 1=2. As\nthe following lemma shows, the expected value of an indicator random variable\nassociated with an event A is equal to the probability that A occurs.\nLemma 5.1\nGiven a sample space S and an event A in the sample space S, let XA D I fAg.\nThen E ŒXA\u0002 D Pr fAg.\n5.2\nIndicator random variables\n119\nProof",
    "parent_15c64c5f-c596-4915-b9cb-e576daaff8fb": "the following lemma shows, the expected value of an indicator random variable\nassociated with an event A is equal to the probability that A occurs.\nLemma 5.1\nGiven a sample space S and an event A in the sample space S, let XA D I fAg.\nThen E ŒXA\u0002 D Pr fAg.\n5.2\nIndicator random variables\n119\nProof\nBy the deﬁnition of an indicator random variable from equation (5.1) and\nthe deﬁnition of expected value, we have\nE ŒXA\u0002\nD\nE ŒI fAg\u0002\nD\n1 \u0003 Pr fAg C 0 \u0003 Pr\n˚\nA",
    "parent_f4272bb6-47ab-46d2-8116-46a66c414368": "D\nPr fAg ;\nwhere A denotes S \u0005 A, the complement of A.\nAlthough indicator random variables may seem cumbersome for an application\nsuch as counting the expected number of heads on a ﬂip of a single coin, they are\nuseful for analyzing situations in which we perform repeated random trials. For\nexample, indicator random variables give us a simple way to arrive at the result\nof equation (C.37). In this equation, we compute the number of heads in n coin\nﬂips by considering separately the probability of obtaining 0 heads, 1 head, 2 heads,\netc. The simpler method proposed in equation (C.38) instead uses indicator random\nvariables implicitly. Making this argument more explicit, we let Xi be the indicator\nrandom variable associated with the event in which the ith ﬂip comes up heads:\nXi D I fthe ith ﬂip results in the event Hg. Let X be the random variable denoting\nthe total number of heads in the n coin ﬂips, so that\nX D\nn\nX\niD1\nXi :\nWe wish to compute the expected number of heads, and so we take the expectation\nof both sides of the above equation to obtain\nE ŒX\u0002 D E\n\" n\nX\niD1\nXi\n#\n:\nThe above equation gives the expectation of the sum of n indicator random vari-\nables. By Lemma 5.1, we can easily compute the expectation of each of the random\nvariables. By equation (C.21)—linearity of expectation—it is easy to compute the\nexpectation of the sum: it equals the sum of the expectations of the n random\nvariables. Linearity of expectation makes the use of indicator random variables a\npowerful analytical technique; it applies even when there is dependence among the\nrandom variables. We now can easily compute the expected number of heads:\n120\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nE ŒX\u0002\nD\nE\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nE ŒXi\u0002\nD\nn\nX\niD1\n1=2\nD\nn=2 :\nThus, compared to the method used in equation (C.37), indicator random variables\ngreatly simplify the calculation. We shall use indicator random variables through-\nout this book.",
    "parent_b062f2e5-942b-4884-a0f6-b6ed8e6effa5": "Probabilistic Analysis and Randomized Algorithms\nE ŒX\u0002\nD\nE\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nE ŒXi\u0002\nD\nn\nX\niD1\n1=2\nD\nn=2 :\nThus, compared to the method used in equation (C.37), indicator random variables\ngreatly simplify the calculation. We shall use indicator random variables through-\nout this book.\nAnalysis of the hiring problem using indicator random variables\nReturning to the hiring problem, we now wish to compute the expected number of\ntimes that we hire a new ofﬁce assistant. In order to use a probabilistic analysis, we\nassume that the candidates arrive in a random order, as discussed in the previous\nsection. (We shall see in Section 5.3 how to remove this assumption.) Let X be the\nrandom variable whose value equals the number of times we hire a new ofﬁce as-\nsistant. We could then apply the deﬁnition of expected value from equation (C.20)\nto obtain\nE ŒX\u0002 D\nn\nX\nxD1\nx Pr fX D xg ;\nbut this calculation would be cumbersome. We shall instead use indicator random\nvariables to greatly simplify the calculation.\nTo use indicator random variables, instead of computing E ŒX\u0002 by deﬁning one\nvariable associated with the number of times we hire a new ofﬁce assistant, we\ndeﬁne n variables related to whether or not each particular candidate is hired. In\nparticular, we let Xi be the indicator random variable associated with the event in\nwhich the ith candidate is hired. Thus,\nXi\nD\nI fcandidate i is hiredg\nD\n(\n1\nif candidate i is hired ;\n0\nif candidate i is not hired ;\nand\nX D X1 C X2 C \u0003 \u0003 \u0003 C Xn :\n(5.2)\n5.2\nIndicator random variables\n121\nBy Lemma 5.1, we have that\nE ŒXi\u0002 D Pr fcandidate i is hiredg ;\nand we must therefore compute the probability that lines 5–6 of HIRE-ASSISTANT\nare executed.\nCandidate i is hired, in line 6, exactly when candidate i is better than each of\ncandidates 1 through i \u0005 1. Because we have assumed that the candidates arrive in\na random order, the ﬁrst i candidates have appeared in a random order. Any one of",
    "parent_4a8ab35f-9e1b-41b6-bee0-38dceb428812": "are executed.\nCandidate i is hired, in line 6, exactly when candidate i is better than each of\ncandidates 1 through i \u0005 1. Because we have assumed that the candidates arrive in\na random order, the ﬁrst i candidates have appeared in a random order. Any one of\nthese ﬁrst i candidates is equally likely to be the best-qualiﬁed so far. Candidate i\nhas a probability of 1=i of being better qualiﬁed than candidates 1 through i \u0005 1\nand thus a probability of 1=i of being hired. By Lemma 5.1, we conclude that\nE ŒXi\u0002 D 1=i :\n(5.3)\nNow we can compute E ŒX\u0002:\nE ŒX\u0002\nD\nE\n\" n\nX\niD1\nXi\n#\n(by equation (5.2))\n(5.4)\nD\nn\nX\niD1\nE ŒXi\u0002\n(by linearity of expectation)\nD\nn\nX\niD1\n1=i\n(by equation (5.3))\nD\nln n C O.1/\n(by equation (A.7)) .\n(5.5)\nEven though we interview n people, we actually hire only approximately ln n of\nthem, on average. We summarize this result in the following lemma.\nLemma 5.2\nAssuming that the candidates are presented in a random order, algorithm HIRE-\nASSISTANT has an average-case total hiring cost of O.ch ln n/.\nProof\nThe bound follows immediately from our deﬁnition of the hiring cost\nand equation (5.5), which shows that the expected number of hires is approxi-\nmately ln n.\nThe average-case hiring cost is a signiﬁcant improvement over the worst-case\nhiring cost of O.chn/.\n122\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nExercises\n5.2-1\nIn HIRE-ASSISTANT, assuming that the candidates are presented in a random or-\nder, what is the probability that you hire exactly one time? What is the probability\nthat you hire exactly n times?\n5.2-2\nIn HIRE-ASSISTANT, assuming that the candidates are presented in a random or-\nder, what is the probability that you hire exactly twice?\n5.2-3\nUse indicator random variables to compute the expected value of the sum of n dice.\n5.2-4\nUse indicator random variables to solve the following problem, which is known as\nthe hat-check problem. Each of n customers gives a hat to a hat-check person at a",
    "parent_43be2ac7-d42d-4afa-a10b-1ca476c9eba3": "5.2-3\nUse indicator random variables to compute the expected value of the sum of n dice.\n5.2-4\nUse indicator random variables to solve the following problem, which is known as\nthe hat-check problem. Each of n customers gives a hat to a hat-check person at a\nrestaurant. The hat-check person gives the hats back to the customers in a random\norder. What is the expected number of customers who get back their own hat?\n5.2-5\nLet AŒ1 : : n\u0002 be an array of n distinct numbers. If i < j and AŒi\u0002 > AŒj \u0002, then\nthe pair .i; j / is called an inversion of A. (See Problem 2-4 for more on inver-\nsions.) Suppose that the elements of A form a uniform random permutation of\nh1; 2; : : : ; ni. Use indicator random variables to compute the expected number of\ninversions.\n5.3\nRandomized algorithms\nIn the previous section, we showed how knowing a distribution on the inputs can\nhelp us to analyze the average-case behavior of an algorithm. Many times, we do\nnot have such knowledge, thus precluding an average-case analysis. As mentioned\nin Section 5.1, we may be able to use a randomized algorithm.\nFor a problem such as the hiring problem, in which it is helpful to assume that\nall permutations of the input are equally likely, a probabilistic analysis can guide\nthe development of a randomized algorithm. Instead of assuming a distribution\nof inputs, we impose a distribution. In particular, before running the algorithm,\nwe randomly permute the candidates in order to enforce the property that every\npermutation is equally likely. Although we have modiﬁed the algorithm, we still\nexpect to hire a new ofﬁce assistant approximately ln n times. But now we expect\n5.3\nRandomized algorithms\n123\nthis to be the case for any input, rather than for inputs drawn from a particular\ndistribution.\nLet us further explore the distinction between probabilistic analysis and random-\nized algorithms. In Section 5.2, we claimed that, assuming that the candidates ar-",
    "parent_511b0ff7-3548-4cfd-9a7f-55605a24a649": "5.3\nRandomized algorithms\n123\nthis to be the case for any input, rather than for inputs drawn from a particular\ndistribution.\nLet us further explore the distinction between probabilistic analysis and random-\nized algorithms. In Section 5.2, we claimed that, assuming that the candidates ar-\nrive in a random order, the expected number of times we hire a new ofﬁce assistant\nis about ln n. Note that the algorithm here is deterministic; for any particular input,\nthe number of times a new ofﬁce assistant is hired is always the same. Furthermore,\nthe number of times we hire a new ofﬁce assistant differs for different inputs, and it\ndepends on the ranks of the various candidates. Since this number depends only on\nthe ranks of the candidates, we can represent a particular input by listing, in order,\nthe ranks of the candidates, i.e., hrank.1/; rank.2/; : : : ; rank.n/i. Given the rank\nlist A1 D h1;2;3;4;5;6;7;8;9;10i, a new ofﬁce assistant is always hired 10 times,\nsince each successive candidate is better than the previous one, and lines 5–6 are\nexecuted in each iteration. Given the list of ranks A2 D h10; 9; 8; 7; 6; 5; 4; 3; 2; 1i,\na new ofﬁce assistant is hired only once, in the ﬁrst iteration. Given a list of ranks\nA3 D h5; 2; 1; 8; 4; 7; 10; 9; 3; 6i, a new ofﬁce assistant is hired three times,\nupon interviewing the candidates with ranks 5, 8, and 10. Recalling that the cost\nof our algorithm depends on how many times we hire a new ofﬁce assistant, we\nsee that there are expensive inputs such as A1, inexpensive inputs such as A2, and\nmoderately expensive inputs such as A3.\nConsider, on the other hand, the randomized algorithm that ﬁrst permutes the\ncandidates and then determines the best candidate. In this case, we randomize in\nthe algorithm, not in the input distribution. Given a particular input, say A3 above,\nwe cannot say how many times the maximum is updated, because this quantity\ndiffers with each run of the algorithm. The ﬁrst time we run the algorithm on A3,",
    "parent_d16077f3-4692-420b-a5b9-0a6c515c9efd": "the algorithm, not in the input distribution. Given a particular input, say A3 above,\nwe cannot say how many times the maximum is updated, because this quantity\ndiffers with each run of the algorithm. The ﬁrst time we run the algorithm on A3,\nit may produce the permutation A1 and perform 10 updates; but the second time\nwe run the algorithm, we may produce the permutation A2 and perform only one\nupdate. The third time we run it, we may perform some other number of updates.\nEach time we run the algorithm, the execution depends on the random choices\nmade and is likely to differ from the previous execution of the algorithm. For this\nalgorithm and many other randomized algorithms, no particular input elicits its\nworst-case behavior. Even your worst enemy cannot produce a bad input array,\nsince the random permutation makes the input order irrelevant. The randomized\nalgorithm performs badly only if the random-number generator produces an “un-\nlucky” permutation.\nFor the hiring problem, the only change needed in the code is to randomly per-\nmute the array.\n124\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nRANDOMIZED-HIRE-ASSISTANT.n/\n1\nrandomly permute the list of candidates\n2\nbest D 0\n// candidate 0 is a least-qualiﬁed dummy candidate\n3\nfor i D 1 to n\n4\ninterview candidate i\n5\nif candidate i is better than candidate best\n6\nbest D i\n7\nhire candidate i\nWith this simple change, we have created a randomized algorithm whose perfor-\nmance matches that obtained by assuming that the candidates were presented in a\nrandom order.\nLemma 5.3\nThe expected hiring cost of the procedure RANDOMIZED-HIRE-ASSISTANT is\nO.ch ln n/.\nProof\nAfter permuting the input array, we have achieved a situation identical to\nthat of the probabilistic analysis of HIRE-ASSISTANT.\nComparing Lemmas 5.2 and 5.3 highlights the difference between probabilistic\nanalysis and randomized algorithms. In Lemma 5.2, we make an assumption about",
    "parent_5072e32f-dcdb-4827-a96c-b0be781b8cc1": "Proof\nAfter permuting the input array, we have achieved a situation identical to\nthat of the probabilistic analysis of HIRE-ASSISTANT.\nComparing Lemmas 5.2 and 5.3 highlights the difference between probabilistic\nanalysis and randomized algorithms. In Lemma 5.2, we make an assumption about\nthe input. In Lemma 5.3, we make no such assumption, although randomizing the\ninput takes some additional time. To remain consistent with our terminology, we\ncouched Lemma 5.2 in terms of the average-case hiring cost and Lemma 5.3 in\nterms of the expected hiring cost. In the remainder of this section, we discuss some\nissues involved in randomly permuting inputs.\nRandomly permuting arrays\nMany randomized algorithms randomize the input by permuting the given input\narray. (There are other ways to use randomization.) Here, we shall discuss two\nmethods for doing so. We assume that we are given an array A which, without loss\nof generality, contains the elements 1 through n. Our goal is to produce a random\npermutation of the array.\nOne common method is to assign each element AŒi\u0002 of the array a random pri-\nority P Œi\u0002, and then sort the elements of A according to these priorities. For ex-\nample, if our initial array is A D h1; 2; 3; 4i and we choose random priorities\nP D h36; 3; 62; 19i, we would produce an array B D h2; 4; 1; 3i, since the second\npriority is the smallest, followed by the fourth, then the ﬁrst, and ﬁnally the third.\nWe call this procedure PERMUTE-BY-SORTING:\n5.3\nRandomized algorithms\n125\nPERMUTE-BY-SORTING.A/\n1\nn D A:length\n2\nlet P Œ1 : : n\u0002 be a new array\n3\nfor i D 1 to n\n4\nP Œi\u0002 D RANDOM.1; n3/\n5\nsort A, using P as sort keys\nLine 4 chooses a random number between 1 and n3. We use a range of 1 to n3\nto make it likely that all the priorities in P are unique. (Exercise 5.3-5 asks you\nto prove that the probability that all entries are unique is at least 1 \u0005 1=n, and\nExercise 5.3-6 asks how to implement the algorithm even if two or more priorities",
    "parent_76588a52-1cea-4470-a0a5-5de3357061a9": "to make it likely that all the priorities in P are unique. (Exercise 5.3-5 asks you\nto prove that the probability that all entries are unique is at least 1 \u0005 1=n, and\nExercise 5.3-6 asks how to implement the algorithm even if two or more priorities\nare identical.) Let us assume that all the priorities are unique.\nThe time-consuming step in this procedure is the sorting in line 5. As we shall\nsee in Chapter 8, if we use a comparison sort, sorting takes \u0004.n lg n/ time. We\ncan achieve this lower bound, since we have seen that merge sort takes ‚.n lg n/\ntime. (We shall see other comparison sorts that take ‚.n lg n/ time in Part II.\nExercise 8.3-4 asks you to solve the very similar problem of sorting numbers in the\nrange 0 to n3 \u0005 1 in O.n/ time.) After sorting, if P Œi\u0002 is the j th smallest priority,\nthen AŒi\u0002 lies in position j of the output. In this manner we obtain a permutation. It\nremains to prove that the procedure produces a uniform random permutation, that\nis, that the procedure is equally likely to produce every permutation of the numbers\n1 through n.\nLemma 5.4\nProcedure PERMUTE-BY-SORTING produces a uniform random permutation of the\ninput, assuming that all priorities are distinct.\nProof\nWe start by considering the particular permutation in which each ele-\nment AŒi\u0002 receives the ith smallest priority. We shall show that this permutation\noccurs with probability exactly 1=nŠ. For i D 1; 2; : : : ; n, let Ei be the event\nthat element AŒi\u0002 receives the ith smallest priority. Then we wish to compute the\nprobability that for all i, event Ei occurs, which is\nPr fE1 \\ E2 \\ E3 \\ \u0003 \u0003 \u0003 \\ En\u00031 \\ Eng :\nUsing Exercise C.2-5, this probability is equal to\nPr fE1g \u0003 Pr fE2 j E1g \u0003 Pr fE3 j E2 \\ E1g \u0003 Pr fE4 j E3 \\ E2 \\ E1g\n\u0003 \u0003 \u0003 Pr fEi j Ei\u00031 \\ Ei\u00032 \\ \u0003 \u0003 \u0003 \\ E1g \u0003 \u0003 \u0003 Pr fEn j En\u00031 \\ \u0003 \u0003 \u0003 \\ E1g :\nWe have that Pr fE1g D 1=n because it is the probability that one priority\nchosen randomly out of a set of n is the smallest priority.\nNext, we observe\n126\nChapter 5",
    "parent_ad0a539a-0a88-4fbe-aa98-dfe7a25faf48": "\u0003 \u0003 \u0003 Pr fEi j Ei\u00031 \\ Ei\u00032 \\ \u0003 \u0003 \u0003 \\ E1g \u0003 \u0003 \u0003 Pr fEn j En\u00031 \\ \u0003 \u0003 \u0003 \\ E1g :\nWe have that Pr fE1g D 1=n because it is the probability that one priority\nchosen randomly out of a set of n is the smallest priority.\nNext, we observe\n126\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nthat Pr fE2 j E1g D 1=.n \u0005 1/ because given that element AŒ1\u0002 has the small-\nest priority, each of the remaining n \u0005 1 elements has an equal chance of hav-\ning the second smallest priority. In general, for i D 2; 3; : : : ; n, we have that\nPr fEi j Ei\u00031 \\ Ei\u00032 \\ \u0003 \u0003 \u0003 \\ E1g D 1=.n\u0005i C1/, since, given that elements AŒ1\u0002\nthrough AŒi \u0005 1\u0002 have the i \u0005 1 smallest priorities (in order), each of the remaining\nn \u0005 .i \u0005 1/ elements has an equal chance of having the ith smallest priority. Thus,\nwe have\nPr fE1 \\ E2 \\ E3 \\ \u0003 \u0003 \u0003 \\ En\u00031 \\ Eng\nD\n\u00021\nn\n\u0003 \u0002\n1\nn \u0005 1\n\u0003\n\u0003 \u0003 \u0003\n\u00021\n2\n\u0003 \u00021\n1\n\u0003\nD\n1\nnŠ ;\nand we have shown that the probability of obtaining the identity permutation\nis 1=nŠ.\nWe can extend this proof to work for any permutation of priorities. Consider\nany ﬁxed permutation \t D h\t.1/; \t.2/; : : : ; \t.n/i of the set f1; 2; : : : ; ng. Let us\ndenote by ri the rank of the priority assigned to element AŒi\u0002, where the element\nwith the j th smallest priority has rank j . If we deﬁne Ei as the event in which\nelement AŒi\u0002 receives the \t.i/th smallest priority, or ri D \t.i/, the same proof\nstill applies. Therefore, if we calculate the probability of obtaining any particular\npermutation, the calculation is identical to the one above, so that the probability of\nobtaining this permutation is also 1=nŠ.\nYou might think that to prove that a permutation is a uniform random permuta-\ntion, it sufﬁces to show that, for each element AŒi\u0002, the probability that the element\nwinds up in position j is 1=n. Exercise 5.3-4 shows that this weaker condition is,\nin fact, insufﬁcient.\nA better method for generating a random permutation is to permute the given",
    "parent_d767a7e0-187d-4ce4-b845-9e0296202fd6": "tion, it sufﬁces to show that, for each element AŒi\u0002, the probability that the element\nwinds up in position j is 1=n. Exercise 5.3-4 shows that this weaker condition is,\nin fact, insufﬁcient.\nA better method for generating a random permutation is to permute the given\narray in place. The procedure RANDOMIZE-IN-PLACE does so in O.n/ time. In\nits ith iteration, it chooses the element AŒi\u0002 randomly from among elements AŒi\u0002\nthrough AŒn\u0002. Subsequent to the ith iteration, AŒi\u0002 is never altered.\nRANDOMIZE-IN-PLACE.A/\n1\nn D A:length\n2\nfor i D 1 to n\n3\nswap AŒi\u0002 with AŒRANDOM.i; n/\u0002\nWe shall use a loop invariant to show that procedure RANDOMIZE-IN-PLACE\nproduces a uniform random permutation.\nA k-permutation on a set of n ele-\nments is a sequence containing k of the n elements, with no repetitions. (See\nAppendix C.) There are nŠ=.n \u0005 k/Š such possible k-permutations.\n5.3\nRandomized algorithms\n127\nLemma 5.5\nProcedure RANDOMIZE-IN-PLACE computes a uniform random permutation.\nProof\nWe use the following loop invariant:\nJust prior to the ith iteration of the for loop of lines 2–3, for each possible\n.i \u0005 1/-permutation of the n elements, the subarray AŒ1 : : i \u0005 1\u0002 contains\nthis .i \u0005 1/-permutation with probability .n \u0005 i C 1/Š=nŠ.\nWe need to show that this invariant is true prior to the ﬁrst loop iteration, that each\niteration of the loop maintains the invariant, and that the invariant provides a useful\nproperty to show correctness when the loop terminates.\nInitialization: Consider the situation just before the ﬁrst loop iteration, so that\ni D 1. The loop invariant says that for each possible 0-permutation, the sub-\narray AŒ1 : : 0\u0002 contains this 0-permutation with probability .n \u0005 i C 1/Š=nŠ D\nnŠ=nŠ D 1. The subarray AŒ1 : : 0\u0002 is an empty subarray, and a 0-permutation\nhas no elements. Thus, AŒ1 : : 0\u0002 contains any 0-permutation with probability 1,\nand the loop invariant holds prior to the ﬁrst iteration.\nMaintenance: We assume that just before the ith iteration, each possible",
    "parent_49404480-2787-4bd6-b0f1-36a93550aa59": "nŠ=nŠ D 1. The subarray AŒ1 : : 0\u0002 is an empty subarray, and a 0-permutation\nhas no elements. Thus, AŒ1 : : 0\u0002 contains any 0-permutation with probability 1,\nand the loop invariant holds prior to the ﬁrst iteration.\nMaintenance: We assume that just before the ith iteration, each possible\n.i \u0005 1/-permutation appears in the subarray AŒ1 : : i \u0005 1\u0002 with probability\n.n \u0005 i C 1/Š=nŠ, and we shall show that after the ith iteration, each possible\ni-permutation appears in the subarray AŒ1 : : i\u0002 with probability .n \u0005 i/Š=nŠ.\nIncrementing i for the next iteration then maintains the loop invariant.\nLet us examine the ith iteration. Consider a particular i-permutation, and de-\nnote the elements in it by hx1; x2; : : : ; xii. This permutation consists of an\n.i \u0005 1/-permutation hx1; : : : ; xi\u00031i followed by the value xi that the algorithm\nplaces in AŒi\u0002. Let E1 denote the event in which the ﬁrst i \u0005 1 iterations have\ncreated the particular .i \u00051/-permutation hx1;: : : ;xi\u00031i in AŒ1 : : i \u00051\u0002. By the\nloop invariant, Pr fE1g D .n \u0005 i C 1/Š=nŠ. Let E2 be the event that ith iteration\nputs xi in position AŒi\u0002. The i-permutation hx1;: : : ;xii appears in AŒ1 : : i\u0002 pre-\ncisely when both E1 and E2 occur, and so we wish to compute Pr fE2 \\ E1g.\nUsing equation (C.14), we have\nPr fE2 \\ E1g D Pr fE2 j E1g Pr fE1g :\nThe probability Pr fE2 j E1g equals 1=.n\u0005iC1/ because in line 3 the algorithm\nchooses xi randomly from the n \u0005 i C 1 values in positions AŒi : : n\u0002. Thus, we\nhave\n128\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nPr fE2 \\ E1g\nD\nPr fE2 j E1g Pr fE1g\nD\n1\nn \u0005 i C 1 \u0003 .n \u0005 i C 1/Š\nnŠ\nD\n.n \u0005 i/Š\nnŠ\n:\nTermination: At termination, i D n C 1, and we have that the subarray AŒ1 : : n\u0002\nis a given n-permutation with probability .n\u0005.nC1/C1/=nŠ D 0Š=nŠ D 1=nŠ.\nThus, RANDOMIZE-IN-PLACE produces a uniform random permutation.\nA randomized algorithm is often the simplest and most efﬁcient way to solve a\nproblem. We shall use randomized algorithms occasionally throughout this book.",
    "parent_3ddc1ec0-c86d-4c47-908d-62ca475022db": "is a given n-permutation with probability .n\u0005.nC1/C1/=nŠ D 0Š=nŠ D 1=nŠ.\nThus, RANDOMIZE-IN-PLACE produces a uniform random permutation.\nA randomized algorithm is often the simplest and most efﬁcient way to solve a\nproblem. We shall use randomized algorithms occasionally throughout this book.\nExercises\n5.3-1\nProfessor Marceau objects to the loop invariant used in the proof of Lemma 5.5. He\nquestions whether it is true prior to the ﬁrst iteration. He reasons that we could just\nas easily declare that an empty subarray contains no 0-permutations. Therefore,\nthe probability that an empty subarray contains a 0-permutation should be 0, thus\ninvalidating the loop invariant prior to the ﬁrst iteration. Rewrite the procedure\nRANDOMIZE-IN-PLACE so that its associated loop invariant applies to a nonempty\nsubarray prior to the ﬁrst iteration, and modify the proof of Lemma 5.5 for your\nprocedure.\n5.3-2\nProfessor Kelp decides to write a procedure that produces at random any permuta-\ntion besides the identity permutation. He proposes the following procedure:\nPERMUTE-WITHOUT-IDENTITY.A/\n1\nn D A:length\n2\nfor i D 1 to n \u0005 1\n3\nswap AŒi\u0002 with AŒRANDOM.i C 1; n/\u0002\nDoes this code do what Professor Kelp intends?\n5.3-3\nSuppose that instead of swapping element AŒi\u0002 with a random element from the\nsubarray AŒi : : n\u0002, we swapped it with a random element from anywhere in the\narray:\n5.3\nRandomized algorithms\n129\nPERMUTE-WITH-ALL.A/\n1\nn D A:length\n2\nfor i D 1 to n\n3\nswap AŒi\u0002 with AŒRANDOM.1; n/\u0002\nDoes this code produce a uniform random permutation? Why or why not?\n5.3-4\nProfessor Armstrong suggests the following procedure for generating a uniform\nrandom permutation:\nPERMUTE-BY-CYCLIC.A/\n1\nn D A:length\n2\nlet BŒ1 : : n\u0002 be a new array\n3\noffset D RANDOM.1; n/\n4\nfor i D 1 to n\n5\ndest D i C offset\n6\nif dest > n\n7\ndest D dest \u0005 n\n8\nBŒdest\u0002 D AŒi\u0002\n9\nreturn B\nShow that each element AŒi\u0002 has a 1=n probability of winding up in any particular",
    "parent_4c04b1aa-5cbd-45fc-af6e-6a7ad73d934f": "random permutation:\nPERMUTE-BY-CYCLIC.A/\n1\nn D A:length\n2\nlet BŒ1 : : n\u0002 be a new array\n3\noffset D RANDOM.1; n/\n4\nfor i D 1 to n\n5\ndest D i C offset\n6\nif dest > n\n7\ndest D dest \u0005 n\n8\nBŒdest\u0002 D AŒi\u0002\n9\nreturn B\nShow that each element AŒi\u0002 has a 1=n probability of winding up in any particular\nposition in B. Then show that Professor Armstrong is mistaken by showing that\nthe resulting permutation is not uniformly random.\n5.3-5\n?\nProve that in the array P in procedure PERMUTE-BY-SORTING, the probability\nthat all elements are unique is at least 1 \u0005 1=n.\n5.3-6\nExplain how to implement the algorithm PERMUTE-BY-SORTING to handle the\ncase in which two or more priorities are identical. That is, your algorithm should\nproduce a uniform random permutation, even if two or more priorities are identical.\n5.3-7\nSuppose we want to create a random sample of the set f1; 2; 3; : : : ; ng, that is,\nan m-element subset S, where 0 \u0002 m \u0002 n, such that each m-subset is equally\nlikely to be created. One way would be to set AŒi\u0002 D i for i D 1; 2; 3; : : : ; n,\ncall RANDOMIZE-IN-PLACE.A/, and then take just the ﬁrst m array elements.\nThis method would make n calls to the RANDOM procedure. If n is much larger\nthan m, we can create a random sample with fewer calls to RANDOM. Show that\n130\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nthe following recursive procedure returns a random m-subset S of f1; 2; 3; : : : ; ng,\nin which each m-subset is equally likely, while making only m calls to RANDOM:\nRANDOM-SAMPLE.m; n/\n1\nif m == 0\n2\nreturn ;\n3\nelse S D RANDOM-SAMPLE.m \u0005 1; n \u0005 1/\n4\ni D RANDOM.1; n/\n5\nif i 2 S\n6\nS D S [ fng\n7\nelse S D S [ fig\n8\nreturn S\n?\n5.4\nProbabilistic analysis and further uses of indicator random variables\nThis advanced section further illustrates probabilistic analysis by way of four ex-\namples. The ﬁrst determines the probability that in a room of k people, two of\nthem share the same birthday. The second example examines what happens when",
    "parent_bfd372ba-62f3-4959-acb9-c602bec5f3fb": "This advanced section further illustrates probabilistic analysis by way of four ex-\namples. The ﬁrst determines the probability that in a room of k people, two of\nthem share the same birthday. The second example examines what happens when\nwe randomly toss balls into bins. The third investigates “streaks” of consecutive\nheads when we ﬂip coins. The ﬁnal example analyzes a variant of the hiring prob-\nlem in which you have to make decisions without actually interviewing all the\ncandidates.\n5.4.1\nThe birthday paradox\nOur ﬁrst example is the birthday paradox. How many people must there be in a\nroom before there is a 50% chance that two of them were born on the same day of\nthe year? The answer is surprisingly few. The paradox is that it is in fact far fewer\nthan the number of days in a year, or even half the number of days in a year, as we\nshall see.\nTo answer this question, we index the people in the room with the integers\n1; 2; : : : ; k, where k is the number of people in the room. We ignore the issue\nof leap years and assume that all years have n D 365 days. For i D 1; 2; : : : ; k,\nlet bi be the day of the year on which person i’s birthday falls, where 1 \u0002 bi \u0002 n.\nWe also assume that birthdays are uniformly distributed across the n days of the\nyear, so that Pr fbi D rg D 1=n for i D 1; 2; : : : ; k and r D 1; 2; : : : ; n.\nThe probability that two given people, say i and j , have matching birthdays\ndepends on whether the random selection of birthdays is independent. We assume\nfrom now on that birthdays are independent, so that the probability that i’s birthday\n5.4\nProbabilistic analysis and further uses of indicator random variables\n131\nand j ’s birthday both fall on day r is\nPr fbi D r and bj D rg\nD\nPr fbi D rg Pr fbj D rg\nD\n1=n2 :\nThus, the probability that they both fall on the same day is\nPr fbi D bjg\nD\nn\nX\nrD1\nPr fbi D r and bj D rg\nD\nn\nX\nrD1\n.1=n2/\nD\n1=n :\n(5.6)\nMore intuitively, once bi is chosen, the probability that bj is chosen to be the same",
    "parent_e1ea5f31-7912-455d-b95e-bd9a35938835": "Pr fbi D r and bj D rg\nD\nPr fbi D rg Pr fbj D rg\nD\n1=n2 :\nThus, the probability that they both fall on the same day is\nPr fbi D bjg\nD\nn\nX\nrD1\nPr fbi D r and bj D rg\nD\nn\nX\nrD1\n.1=n2/\nD\n1=n :\n(5.6)\nMore intuitively, once bi is chosen, the probability that bj is chosen to be the same\nday is 1=n. Thus, the probability that i and j have the same birthday is the same\nas the probability that the birthday of one of them falls on a given day. Notice,\nhowever, that this coincidence depends on the assumption that the birthdays are\nindependent.\nWe can analyze the probability of at least 2 out of k people having matching\nbirthdays by looking at the complementary event. The probability that at least two\nof the birthdays match is 1 minus the probability that all the birthdays are different.\nThe event that k people have distinct birthdays is\nBk D\nk\\\niD1\nAi ;\nwhere Ai is the event that person i’s birthday is different from person j ’s for\nall j < i. Since we can write Bk D Ak \\ Bk\u00031, we obtain from equation (C.16)\nthe recurrence\nPr fBkg D Pr fBk\u00031g Pr fAk j Bk\u00031g ;\n(5.7)\nwhere we take Pr fB1g D Pr fA1g D 1 as an initial condition. In other words,\nthe probability that b1; b2; : : : ; bk are distinct birthdays is the probability that\nb1; b2; : : : ; bk\u00031 are distinct birthdays times the probability that bk ¤ bi for\ni D 1; 2; : : : ; k \u0005 1, given that b1; b2; : : : ; bk\u00031 are distinct.\nIf b1; b2; : : : ; bk\u00031 are distinct, the conditional probability that bk ¤ bi for\ni D 1; 2; : : : ; k \u0005 1 is Pr fAk j Bk\u00031g D .n \u0005 k C 1/=n, since out of the n days,\nn \u0005 .k \u0005 1/ days are not taken. We iteratively apply the recurrence (5.7) to obtain\n132\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nPr fBkg\nD\nPr fBk\u00031g Pr fAk j Bk\u00031g\nD\nPr fBk\u00032g Pr fAk\u00031 j Bk\u00032g Pr fAk j Bk\u00031g\n:::\nD\nPr fB1g Pr fA2 j B1g Pr fA3 j B2g \u0003 \u0003 \u0003 Pr fAk j Bk\u00031g\nD\n1 \u0003\n\u0002n \u0005 1\nn\n\u0003 \u0002n \u0005 2\nn\n\u0003\n\u0003 \u0003 \u0003\n\u0002n \u0005 k C 1\nn\n\u0003\nD\n1 \u0003\n\u0002\n1 \u0005 1\nn\n\u0003 \u0002\n1 \u0005 2\nn\n\u0003\n\u0003 \u0003 \u0003\n\u0002\n1 \u0005 k \u0005 1\nn\n\u0003\n:\nInequality (3.12), 1 C x \u0002 ex, gives us\nPr fBkg\n\u0002",
    "parent_e332b407-be66-45e9-aa36-6037db807cc4": "Pr fBkg\nD\nPr fBk\u00031g Pr fAk j Bk\u00031g\nD\nPr fBk\u00032g Pr fAk\u00031 j Bk\u00032g Pr fAk j Bk\u00031g\n:::\nD\nPr fB1g Pr fA2 j B1g Pr fA3 j B2g \u0003 \u0003 \u0003 Pr fAk j Bk\u00031g\nD\n1 \u0003\n\u0002n \u0005 1\nn\n\u0003 \u0002n \u0005 2\nn\n\u0003\n\u0003 \u0003 \u0003\n\u0002n \u0005 k C 1\nn\n\u0003\nD\n1 \u0003\n\u0002\n1 \u0005 1\nn\n\u0003 \u0002\n1 \u0005 2\nn\n\u0003\n\u0003 \u0003 \u0003\n\u0002\n1 \u0005 k \u0005 1\nn\n\u0003\n:\nInequality (3.12), 1 C x \u0002 ex, gives us\nPr fBkg\n\u0002\ne\u00031=ne\u00032=n \u0003 \u0003 \u0003 e\u0003.k\u00031/=n\nD\ne\u0003 Pk\u00041\niD1 i=n\nD\ne\u0003k.k\u00031/=2n\n\u0002\n1=2\nwhen \u0005k.k \u0005 1/=2n \u0002 ln.1=2/. The probability that all k birthdays are distinct\nis at most 1=2 when k.k \u0005 1/ \u0006 2n ln 2 or, solving the quadratic equation, when\nk \u0006 .1 C\np\n1 C .8 ln 2/n/=2. For n D 365, we must have k \u0006 23. Thus, if at\nleast 23 people are in a room, the probability is at least 1=2 that at least two people\nhave the same birthday. On Mars, a year is 669 Martian days long; it therefore\ntakes 31 Martians to get the same effect.\nAn analysis using indicator random variables\nWe can use indicator random variables to provide a simpler but approximate anal-\nysis of the birthday paradox. For each pair .i; j / of the k people in the room, we\ndeﬁne the indicator random variable Xij, for 1 \u0002 i < j \u0002 k, by\nXij\nD\nI fperson i and person j have the same birthdayg\nD\n(\n1\nif person i and person j have the same birthday ;\n0\notherwise :\nBy equation (5.6), the probability that two people have matching birthdays is 1=n,\nand thus by Lemma 5.1, we have\nE ŒXij\u0002\nD\nPr fperson i and person j have the same birthdayg\nD\n1=n :\nLetting X be the random variable that counts the number of pairs of individuals\nhaving the same birthday, we have\n5.4\nProbabilistic analysis and further uses of indicator random variables\n133\nX D\nk\nX\niD1\nk\nX\njDiC1\nXij :\nTaking expectations of both sides and applying linearity of expectation, we obtain\nE ŒX\u0002\nD\nE\n\" k\nX\niD1\nk\nX\njDiC1\nXij\n#\nD\nk\nX\niD1\nk\nX\njDiC1\nE ŒXij\u0002\nD\n \nk\n2\n!\n1\nn\nD\nk.k \u0005 1/\n2n\n:\nWhen k.k \u0005 1/ \u0006 2n, therefore, the expected number of pairs of people with the\nsame birthday is at least 1. Thus, if we have at least\np\n2nC1 individuals in a room,",
    "parent_a4966549-0344-4296-abc3-31d45ba4ab54": "E ŒX\u0002\nD\nE\n\" k\nX\niD1\nk\nX\njDiC1\nXij\n#\nD\nk\nX\niD1\nk\nX\njDiC1\nE ŒXij\u0002\nD\n \nk\n2\n!\n1\nn\nD\nk.k \u0005 1/\n2n\n:\nWhen k.k \u0005 1/ \u0006 2n, therefore, the expected number of pairs of people with the\nsame birthday is at least 1. Thus, if we have at least\np\n2nC1 individuals in a room,\nwe can expect at least two to have the same birthday. For n D 365, if k D 28, the\nexpected number of pairs with the same birthday is .28 \u0003 27/=.2 \u0003 365/ \u0004 1:0356.\nThus, with at least 28 people, we expect to ﬁnd at least one matching pair of birth-\ndays. On Mars, where a year is 669 Martian days long, we need at least 38 Mar-\ntians.\nThe ﬁrst analysis, which used only probabilities, determined the number of peo-\nple required for the probability to exceed 1=2 that a matching pair of birthdays\nexists, and the second analysis, which used indicator random variables, determined\nthe number such that the expected number of matching birthdays is 1. Although\nthe exact numbers of people differ for the two situations, they are the same asymp-\ntotically: ‚.pn/.\n5.4.2\nBalls and bins\nConsider a process in which we randomly toss identical balls into b bins, numbered\n1; 2; : : : ; b. The tosses are independent, and on each toss the ball is equally likely\nto end up in any bin. The probability that a tossed ball lands in any given bin is 1=b.\nThus, the ball-tossing process is a sequence of Bernoulli trials (see Appendix C.4)\nwith a probability 1=b of success, where success means that the ball falls in the\ngiven bin. This model is particularly useful for analyzing hashing (see Chapter 11),\nand we can answer a variety of interesting questions about the ball-tossing process.\n(Problem C-1 asks additional questions about balls and bins.)\n134\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nHow many balls fall in a given bin? The number of balls that fall in a given bin\nfollows the binomial distribution b.kI n; 1=b/. If we toss n balls, equation (C.37)",
    "parent_f39d92bf-0a40-4adb-a46d-d9c07de1b69e": "(Problem C-1 asks additional questions about balls and bins.)\n134\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nHow many balls fall in a given bin? The number of balls that fall in a given bin\nfollows the binomial distribution b.kI n; 1=b/. If we toss n balls, equation (C.37)\ntells us that the expected number of balls that fall in the given bin is n=b.\nHow many balls must we toss, on the average, until a given bin contains a ball?\nThe number of tosses until the given bin receives a ball follows the geometric\ndistribution with probability 1=b and, by equation (C.32), the expected number of\ntosses until success is 1=.1=b/ D b.\nHow many balls must we toss until every bin contains at least one ball? Let us\ncall a toss in which a ball falls into an empty bin a “hit.” We want to know the\nexpected number n of tosses required to get b hits.\nUsing the hits, we can partition the n tosses into stages. The ith stage consists of\nthe tosses after the .i \u0005 1/st hit until the ith hit. The ﬁrst stage consists of the ﬁrst\ntoss, since we are guaranteed to have a hit when all bins are empty. For each toss\nduring the ith stage, i \u0005 1 bins contain balls and b \u0005 i C 1 bins are empty. Thus,\nfor each toss in the ith stage, the probability of obtaining a hit is .b \u0005 i C 1/=b.\nLet ni denote the number of tosses in the ith stage. Thus, the number of tosses\nrequired to get b hits is n D Pb\niD1 ni. Each random variable ni has a geometric\ndistribution with probability of success .b \u0005i C1/=b and thus, by equation (C.32),\nwe have\nE Œni\u0002 D\nb\nb \u0005 i C 1 :\nBy linearity of expectation, we have\nE Œn\u0002\nD\nE\n\"\nb\nX\niD1\nni\n#\nD\nb\nX\niD1\nE Œni\u0002\nD\nb\nX\niD1\nb\nb \u0005 i C 1\nD\nb\nb\nX\niD1\n1\ni\nD\nb.ln b C O.1//\n(by equation (A.7)) .\nIt therefore takes approximately b ln b tosses before we can expect that every bin\nhas a ball. This problem is also known as the coupon collector’s problem, which\nsays that a person trying to collect each of b different coupons expects to acquire",
    "parent_e385254a-07c9-4f1f-b814-32cd499fe1b6": "b\nb\nX\niD1\n1\ni\nD\nb.ln b C O.1//\n(by equation (A.7)) .\nIt therefore takes approximately b ln b tosses before we can expect that every bin\nhas a ball. This problem is also known as the coupon collector’s problem, which\nsays that a person trying to collect each of b different coupons expects to acquire\napproximately b ln b randomly obtained coupons in order to succeed.\n5.4\nProbabilistic analysis and further uses of indicator random variables\n135\n5.4.3\nStreaks\nSuppose you ﬂip a fair coin n times. What is the longest streak of consecutive\nheads that you expect to see? The answer is ‚.lg n/, as the following analysis\nshows.\nWe ﬁrst prove that the expected length of the longest streak of heads is O.lg n/.\nThe probability that each coin ﬂip is a head is 1=2. Let Aik be the event that a\nstreak of heads of length at least k begins with the ith coin ﬂip or, more precisely,\nthe event that the k consecutive coin ﬂips i; i C 1; : : : ; i C k \u0005 1 yield only heads,\nwhere 1 \u0002 k \u0002 n and 1 \u0002 i \u0002 n\u0005kC1. Since coin ﬂips are mutually independent,\nfor any given event Aik, the probability that all k ﬂips are heads is\nPr fAikg D 1=2k :\n(5.8)\nFor k D 2 dlg ne,\nPr fAi;2dlg neg\nD\n1=22dlg ne\n\u0002\n1=22 lg n\nD\n1=n2 ;\nand thus the probability that a streak of heads of length at least 2 dlg ne begins in\nposition i is quite small. There are at most n \u0005 2 dlg ne C 1 positions where such\na streak can begin. The probability that a streak of heads of length at least 2 dlg ne\nbegins anywhere is therefore\nPr\n(n\u00032dlg neC1\n[\niD1\nAi;2dlg ne\n)\n\u0002\nn\u00032dlg neC1\nX\niD1\n1=n2\n<\nn\nX\niD1\n1=n2\nD\n1=n ;\n(5.9)\nsince by Boole’s inequality (C.19), the probability of a union of events is at most\nthe sum of the probabilities of the individual events. (Note that Boole’s inequality\nholds even for events such as these that are not independent.)\nWe now use inequality (5.9) to bound the length of the longest streak.\nFor\nj D 0; 1; 2; : : : ; n, let Lj be the event that the longest streak of heads has length ex-",
    "parent_f5b48e70-da92-4e12-b129-6a53114dabe0": "holds even for events such as these that are not independent.)\nWe now use inequality (5.9) to bound the length of the longest streak.\nFor\nj D 0; 1; 2; : : : ; n, let Lj be the event that the longest streak of heads has length ex-\nactly j , and let L be the length of the longest streak. By the deﬁnition of expected\nvalue, we have\nE ŒL\u0002 D\nn\nX\njD0\nj Pr fLjg :\n(5.10)\n136\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nWe could try to evaluate this sum using upper bounds on each Pr fLjg similar to\nthose computed in inequality (5.9). Unfortunately, this method would yield weak\nbounds. We can use some intuition gained by the above analysis to obtain a good\nbound, however. Informally, we observe that for no individual term in the sum-\nmation in equation (5.10) are both the factors j and Pr fLjg large. Why? When\nj \u0006 2 dlg ne, then Pr fLjg is very small, and when j < 2 dlg ne, then j is fairly\nsmall. More formally, we note that the events Lj for j D 0; 1; : : : ; n are disjoint,\nand so the probability that a streak of heads of length at least 2 dlg ne begins any-\nwhere is Pn\njD2dlg ne Pr fLjg. By inequality (5.9), we have Pn\njD2dlg ne Pr fLjg < 1=n.\nAlso, noting that Pn\njD0 Pr fLjg D 1, we have that P2dlg ne\u00031\njD0\nPr fLjg \u0002 1. Thus,\nwe obtain\nE ŒL\u0002\nD\nn\nX\njD0\nj Pr fLjg\nD\n2dlg ne\u00031\nX\njD0\nj Pr fLjg C\nn\nX\njD2dlg ne\nj Pr fLjg\n<\n2dlg ne\u00031\nX\njD0\n.2 dlg ne/ Pr fLjg C\nn\nX\njD2dlg ne\nn Pr fLjg\nD\n2 dlg ne\n2dlg ne\u00031\nX\njD0\nPr fLjg C n\nn\nX\njD2dlg ne\nPr fLjg\n<\n2 dlg ne \u0003 1 C n \u0003 .1=n/\nD\nO.lg n/ :\nThe probability that a streak of heads exceeds r dlg ne ﬂips diminishes quickly\nwith r. For r \u0006 1, the probability that a streak of at least r dlg ne heads starts in\nposition i is\nPr fAi;rdlg neg\nD\n1=2rdlg ne\n\u0002\n1=nr :\nThus, the probability is at most n=nr D 1=nr\u00031 that the longest streak is at\nleast r dlg ne, or equivalently, the probability is at least 1 \u0005 1=nr\u00031 that the longest\nstreak has length less than r dlg ne.",
    "parent_b93cbcb9-78bb-4338-910a-6371ae59f0f3": "position i is\nPr fAi;rdlg neg\nD\n1=2rdlg ne\n\u0002\n1=nr :\nThus, the probability is at most n=nr D 1=nr\u00031 that the longest streak is at\nleast r dlg ne, or equivalently, the probability is at least 1 \u0005 1=nr\u00031 that the longest\nstreak has length less than r dlg ne.\nAs an example, for n D 1000 coin ﬂips, the probability of having a streak of at\nleast 2 dlg ne D 20 heads is at most 1=n D 1=1000. The chance of having a streak\nlonger than 3 dlg ne D 30 heads is at most 1=n2 D 1=1,000,000.\nWe now prove a complementary lower bound: the expected length of the longest\nstreak of heads in n coin ﬂips is \u0004.lg n/. To prove this bound, we look for streaks\n5.4\nProbabilistic analysis and further uses of indicator random variables\n137\nof length s by partitioning the n ﬂips into approximately n=s groups of s ﬂips\neach. If we choose s D b.lg n/=2c, we can show that it is likely that at least one\nof these groups comes up all heads, and hence it is likely that the longest streak\nhas length at least s D \u0004.lg n/. We then show that the longest streak has expected\nlength \u0004.lg n/.\nWe partition the n coin ﬂips into at least bn= b.lg n/=2cc groups of b.lg n/=2c\nconsecutive ﬂips, and we bound the probability that no group comes up all heads.\nBy equation (5.8), the probability that the group starting in position i comes up all\nheads is\nPr fAi;b.lg n/=2cg\nD\n1=2b.lg n/=2c\n\u0006\n1=pn :\nThe probability that a streak of heads of length at least b.lg n/=2c does not begin\nin position i is therefore at most 1 \u0005 1=pn. Since the bn= b.lg n/=2cc groups are\nformed from mutually exclusive, independent coin ﬂips, the probability that every\none of these groups fails to be a streak of length b.lg n/=2c is at most\n\u000b\n1 \u0005 1=pn\n\fbn=b.lg n/=2cc\n\u0002\n\u000b\n1 \u0005 1=pn\n\fn=b.lg n/=2c\u00031\n\u0002\n\u000b\n1 \u0005 1=pn\n\f2n= lg n\u00031\n\u0002\ne\u0003.2n= lg n\u00031/=pn\nD\nO.e\u0003 lg n/\nD\nO.1=n/ :\nFor this argument, we used inequality (3.12), 1 C x \u0002 ex, and the fact, which you\nmight want to verify, that .2n= lg n \u0005 1/=pn \u0006 lg n for sufﬁciently large n.",
    "parent_81592fc5-c82b-4840-83d2-ac6b96e7c188": "1 \u0005 1=pn\n\fbn=b.lg n/=2cc\n\u0002\n\u000b\n1 \u0005 1=pn\n\fn=b.lg n/=2c\u00031\n\u0002\n\u000b\n1 \u0005 1=pn\n\f2n= lg n\u00031\n\u0002\ne\u0003.2n= lg n\u00031/=pn\nD\nO.e\u0003 lg n/\nD\nO.1=n/ :\nFor this argument, we used inequality (3.12), 1 C x \u0002 ex, and the fact, which you\nmight want to verify, that .2n= lg n \u0005 1/=pn \u0006 lg n for sufﬁciently large n.\nThus, the probability that the longest streak exceeds b.lg n/=2c is\nn\nX\njDb.lg n/=2cC1\nPr fLjg \u0006 1 \u0005 O.1=n/ :\n(5.11)\nWe can now calculate a lower bound on the expected length of the longest streak,\nbeginning with equation (5.10) and proceeding in a manner similar to our analysis\nof the upper bound:\n138\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nE ŒL\u0002\nD\nn\nX\njD0\nj Pr fLjg\nD\nb.lg n/=2c\nX\njD0\nj Pr fLjg C\nn\nX\njDb.lg n/=2cC1\nj Pr fLjg\n\u0006\nb.lg n/=2c\nX\njD0\n0 \u0003 Pr fLjg C\nn\nX\njDb.lg n/=2cC1\nb.lg n/=2c Pr fLjg\nD\n0 \u0003\nb.lg n/=2c\nX\njD0\nPr fLjg C b.lg n/=2c\nn\nX\njDb.lg n/=2cC1\nPr fLjg\n\u0006\n0 C b.lg n/=2c .1 \u0005 O.1=n//\n(by inequality (5.11))\nD\n\u0004.lg n/ :\nAs with the birthday paradox, we can obtain a simpler but approximate analysis\nusing indicator random variables. We let Xik D I fAikg be the indicator random\nvariable associated with a streak of heads of length at least k beginning with the\nith coin ﬂip. To count the total number of such streaks, we deﬁne\nX D\nn\u0003kC1\nX\niD1\nXik :\nTaking expectations and using linearity of expectation, we have\nE ŒX\u0002\nD\nE\n\"n\u0003kC1\nX\niD1\nXik\n#\nD\nn\u0003kC1\nX\niD1\nE ŒXik\u0002\nD\nn\u0003kC1\nX\niD1\nPr fAikg\nD\nn\u0003kC1\nX\niD1\n1=2k\nD\nn \u0005 k C 1\n2k\n:\nBy plugging in various values for k, we can calculate the expected number of\nstreaks of length k. If this number is large (much greater than 1), then we expect\nmany streaks of length k to occur and the probability that one occurs is high. If\n5.4\nProbabilistic analysis and further uses of indicator random variables\n139\nthis number is small (much less than 1), then we expect few streaks of length k to\noccur and the probability that one occurs is low. If k D c lg n, for some positive\nconstant c, we obtain\nE ŒX\u0002\nD\nn \u0005 c lg n C 1\n2c lg n\nD\nn \u0005 c lg n C 1",
    "parent_751b3ff9-e87a-4c96-820e-efa8bc35575f": "139\nthis number is small (much less than 1), then we expect few streaks of length k to\noccur and the probability that one occurs is low. If k D c lg n, for some positive\nconstant c, we obtain\nE ŒX\u0002\nD\nn \u0005 c lg n C 1\n2c lg n\nD\nn \u0005 c lg n C 1\nnc\nD\n1\nnc\u00031 \u0005 .c lg n \u0005 1/=n\nnc\u00031\nD\n‚.1=nc\u00031/ :\nIf c is large, the expected number of streaks of length c lg n is small, and we con-\nclude that they are unlikely to occur. On the other hand, if c D 1=2, then we obtain\nE ŒX\u0002 D ‚.1=n1=2\u00031/ D ‚.n1=2/, and we expect that there are a large number\nof streaks of length .1=2/ lg n. Therefore, one streak of such a length is likely to\noccur. From these rough estimates alone, we can conclude that the expected length\nof the longest streak is ‚.lg n/.\n5.4.4\nThe on-line hiring problem\nAs a ﬁnal example, we consider a variant of the hiring problem. Suppose now that\nwe do not wish to interview all the candidates in order to ﬁnd the best one. We\nalso do not wish to hire and ﬁre as we ﬁnd better and better applicants. Instead, we\nare willing to settle for a candidate who is close to the best, in exchange for hiring\nexactly once. We must obey one company requirement: after each interview we\nmust either immediately offer the position to the applicant or immediately reject the\napplicant. What is the trade-off between minimizing the amount of interviewing\nand maximizing the quality of the candidate hired?\nWe can model this problem in the following way. After meeting an applicant,\nwe are able to give each one a score; let score.i/ denote the score we give to the ith\napplicant, and assume that no two applicants receive the same score. After we have\nseen j applicants, we know which of the j has the highest score, but we do not\nknow whether any of the remaining n\u0005j applicants will receive a higher score. We\ndecide to adopt the strategy of selecting a positive integer k < n, interviewing and\nthen rejecting the ﬁrst k applicants, and hiring the ﬁrst applicant thereafter who has",
    "parent_c6c569f6-9ada-4c73-a264-4f8eb99e7320": "know whether any of the remaining n\u0005j applicants will receive a higher score. We\ndecide to adopt the strategy of selecting a positive integer k < n, interviewing and\nthen rejecting the ﬁrst k applicants, and hiring the ﬁrst applicant thereafter who has\na higher score than all preceding applicants. If it turns out that the best-qualiﬁed\napplicant was among the ﬁrst k interviewed, then we hire the nth applicant. We\nformalize this strategy in the procedure ON-LINE-MAXIMUM.k; n/, which returns\nthe index of the candidate we wish to hire.\n140\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nON-LINE-MAXIMUM.k; n/\n1\nbestscore D \u00051\n2\nfor i D 1 to k\n3\nif score.i/ > bestscore\n4\nbestscore D score.i/\n5\nfor i D k C 1 to n\n6\nif score.i/ > bestscore\n7\nreturn i\n8\nreturn n\nWe wish to determine, for each possible value of k, the probability that we\nhire the most qualiﬁed applicant.\nWe then choose the best possible k, and\nimplement the strategy with that value.\nFor the moment, assume that k is\nﬁxed. Let M.j / D max1\u0005i\u0005j fscore.i/g denote the maximum score among ap-\nplicants 1 through j . Let S be the event that we succeed in choosing the best-\nqualiﬁed applicant, and let Si be the event that we succeed when the best-qualiﬁed\napplicant is the ith one interviewed. Since the various Si are disjoint, we have\nthat Pr fSg D Pn\niD1 Pr fSig. Noting that we never succeed when the best-qualiﬁed\napplicant is one of the ﬁrst k, we have that Pr fSig D 0 for i D 1; 2; : : : ; k. Thus,\nwe obtain\nPr fSg D\nn\nX\niDkC1\nPr fSig :\n(5.12)\nWe now compute Pr fSig. In order to succeed when the best-qualiﬁed applicant\nis the ith one, two things must happen. First, the best-qualiﬁed applicant must be\nin position i, an event which we denote by Bi. Second, the algorithm must not\nselect any of the applicants in positions k C1 through i \u00051, which happens only if,\nfor each j such that k C1 \u0002 j \u0002 i \u00051, we ﬁnd that score.j / < bestscore in line 6.",
    "parent_e65ca7ef-c6a5-4d8d-b6bc-834dec134652": "in position i, an event which we denote by Bi. Second, the algorithm must not\nselect any of the applicants in positions k C1 through i \u00051, which happens only if,\nfor each j such that k C1 \u0002 j \u0002 i \u00051, we ﬁnd that score.j / < bestscore in line 6.\n(Because scores are unique, we can ignore the possibility of score.j / D bestscore.)\nIn other words, all of the values score.k C 1/ through score.i \u0005 1/ must be less\nthan M.k/; if any are greater than M.k/, we instead return the index of the ﬁrst\none that is greater. We use Oi to denote the event that none of the applicants in\nposition k C 1 through i \u0005 1 are chosen. Fortunately, the two events Bi and Oi\nare independent. The event Oi depends only on the relative ordering of the values\nin positions 1 through i \u0005 1, whereas Bi depends only on whether the value in\nposition i is greater than the values in all other positions. The ordering of the\nvalues in positions 1 through i \u0005 1 does not affect whether the value in position i\nis greater than all of them, and the value in position i does not affect the ordering\nof the values in positions 1 through i \u0005 1. Thus we can apply equation (C.15) to\nobtain\n5.4\nProbabilistic analysis and further uses of indicator random variables\n141\nPr fSig D Pr fBi \\ Oig D Pr fBig Pr fOig :\nThe probability Pr fBig is clearly 1=n, since the maximum is equally likely to\nbe in any one of the n positions. For event Oi to occur, the maximum value in\npositions 1 through i\u00051, which is equally likely to be in any of these i\u00051 positions,\nmust be in one of the ﬁrst k positions. Consequently, Pr fOig D k=.i \u0005 1/ and\nPr fSig D k=.n.i \u0005 1//. Using equation (5.12), we have\nPr fSg\nD\nn\nX\niDkC1\nPr fSig\nD\nn\nX\niDkC1\nk\nn.i \u0005 1/\nD\nk\nn\nn\nX\niDkC1\n1\ni \u0005 1\nD\nk\nn\nn\u00031\nX\niDk\n1\ni :\nWe approximate by integrals to bound this summation from above and below. By\nthe inequalities (A.12), we have\nZ n\nk\n1\nx dx \u0002\nn\u00031\nX\niDk\n1\ni \u0002\nZ n\u00031\nk\u00031\n1\nx dx :\nEvaluating these deﬁnite integrals gives us the bounds\nk\nn.ln n \u0005 ln k/ \u0002 Pr fSg \u0002 k",
    "parent_bdcdc76f-5f83-4c3a-ae19-2cd864521535": "n.i \u0005 1/\nD\nk\nn\nn\nX\niDkC1\n1\ni \u0005 1\nD\nk\nn\nn\u00031\nX\niDk\n1\ni :\nWe approximate by integrals to bound this summation from above and below. By\nthe inequalities (A.12), we have\nZ n\nk\n1\nx dx \u0002\nn\u00031\nX\niDk\n1\ni \u0002\nZ n\u00031\nk\u00031\n1\nx dx :\nEvaluating these deﬁnite integrals gives us the bounds\nk\nn.ln n \u0005 ln k/ \u0002 Pr fSg \u0002 k\nn.ln.n \u0005 1/ \u0005 ln.k \u0005 1// ;\nwhich provide a rather tight bound for Pr fSg. Because we wish to maximize our\nprobability of success, let us focus on choosing the value of k that maximizes the\nlower bound on Pr fSg. (Besides, the lower-bound expression is easier to maximize\nthan the upper-bound expression.) Differentiating the expression .k=n/.ln n\u0005ln k/\nwith respect to k, we obtain\n1\nn.ln n \u0005 ln k \u0005 1/ :\nSetting this derivative equal to 0, we see that we maximize the lower bound on the\nprobability when ln k D ln n\u00051 D ln.n=e/ or, equivalently, when k D n=e. Thus,\nif we implement our strategy with k D n=e, we succeed in hiring our best-qualiﬁed\napplicant with probability at least 1=e.\n142\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nExercises\n5.4-1\nHow many people must there be in a room before the probability that someone\nhas the same birthday as you do is at least 1=2? How many people must there be\nbefore the probability that at least two people have a birthday on July 4 is greater\nthan 1=2?\n5.4-2\nSuppose that we toss balls into b bins until some bin contains two balls. Each toss\nis independent, and each ball is equally likely to end up in any bin. What is the\nexpected number of ball tosses?\n5.4-3\n?\nFor the analysis of the birthday paradox, is it important that the birthdays be mutu-\nally independent, or is pairwise independence sufﬁcient? Justify your answer.\n5.4-4\n?\nHow many people should be invited to a party in order to make it likely that there\nare three people with the same birthday?\n5.4-5\n?\nWhat is the probability that a k-string over a set of size n forms a k-permutation?\nHow does this question relate to the birthday paradox?\n5.4-6\n?",
    "parent_beb3cfb3-2442-47fd-9515-7ef27fad5bdd": "5.4-4\n?\nHow many people should be invited to a party in order to make it likely that there\nare three people with the same birthday?\n5.4-5\n?\nWhat is the probability that a k-string over a set of size n forms a k-permutation?\nHow does this question relate to the birthday paradox?\n5.4-6\n?\nSuppose that n balls are tossed into n bins, where each toss is independent and the\nball is equally likely to end up in any bin. What is the expected number of empty\nbins? What is the expected number of bins with exactly one ball?\n5.4-7\n?\nSharpen the lower bound on streak length by showing that in n ﬂips of a fair coin,\nthe probability is less than 1=n that no streak longer than lg n\u00052 lg lg n consecutive\nheads occurs.\nProblems for Chapter 5\n143\nProblems\n5-1\nProbabilistic counting\nWith a b-bit counter, we can ordinarily only count up to 2b \u0005 1. With R. Morris’s\nprobabilistic counting, we can count up to a much larger value at the expense of\nsome loss of precision.\nWe let a counter value of i represent a count of ni for i D 0; 1; : : : ; 2b \u00051, where\nthe ni form an increasing sequence of nonnegative values. We assume that the ini-\ntial value of the counter is 0, representing a count of n0 D 0. The INCREMENT\noperation works on a counter containing the value i in a probabilistic manner. If\ni D 2b \u0005 1, then the operation reports an overﬂow error. Otherwise, the INCRE-\nMENT operation increases the counter by 1 with probability 1=.niC1 \u0005 ni/, and it\nleaves the counter unchanged with probability 1 \u0005 1=.niC1 \u0005 ni/.\nIf we select ni D i for all i \u0006 0, then the counter is an ordinary one. More\ninteresting situations arise if we select, say, ni D 2i\u00031 for i > 0 or ni D Fi (the\nith Fibonacci number—see Section 3.2).\nFor this problem, assume that n2b\u00031 is large enough that the probability of an\noverﬂow error is negligible.\na. Show that the expected value represented by the counter after n INCREMENT\noperations have been performed is exactly n.",
    "parent_c7ad73d4-340c-4e36-8a3d-4899bdb9fa51": "ith Fibonacci number—see Section 3.2).\nFor this problem, assume that n2b\u00031 is large enough that the probability of an\noverﬂow error is negligible.\na. Show that the expected value represented by the counter after n INCREMENT\noperations have been performed is exactly n.\nb. The analysis of the variance of the count represented by the counter depends\non the sequence of the ni. Let us consider a simple case: ni D 100i for\nall i \u0006 0. Estimate the variance in the value represented by the register after n\nINCREMENT operations have been performed.\n5-2\nSearching an unsorted array\nThis problem examines three algorithms for searching for a value x in an unsorted\narray A consisting of n elements.\nConsider the following randomized strategy: pick a random index i into A. If\nAŒi\u0002 D x, then we terminate; otherwise, we continue the search by picking a new\nrandom index into A. We continue picking random indices into A until we ﬁnd an\nindex j such that AŒj \u0002 D x or until we have checked every element of A. Note\nthat we pick from the whole set of indices each time, so that we may examine a\ngiven element more than once.\na. Write pseudocode for a procedure RANDOM-SEARCH to implement the strat-\negy above. Be sure that your algorithm terminates when all indices into A have\nbeen picked.\n144\nChapter 5\nProbabilistic Analysis and Randomized Algorithms\nb. Suppose that there is exactly one index i such that AŒi\u0002 D x. What is the\nexpected number of indices into A that we must pick before we ﬁnd x and\nRANDOM-SEARCH terminates?\nc. Generalizing your solution to part (b), suppose that there are k \u0006 1 indices i\nsuch that AŒi\u0002 D x. What is the expected number of indices into A that we\nmust pick before we ﬁnd x and RANDOM-SEARCH terminates? Your answer\nshould be a function of n and k.\nd. Suppose that there are no indices i such that AŒi\u0002 D x. What is the expected\nnumber of indices into A that we must pick before we have checked all elements\nof A and RANDOM-SEARCH terminates?",
    "parent_c628dc75-5bc7-48c7-971d-0894d4b4e5bd": "must pick before we ﬁnd x and RANDOM-SEARCH terminates? Your answer\nshould be a function of n and k.\nd. Suppose that there are no indices i such that AŒi\u0002 D x. What is the expected\nnumber of indices into A that we must pick before we have checked all elements\nof A and RANDOM-SEARCH terminates?\nNow consider a deterministic linear search algorithm, which we refer to as\nDETERMINISTIC-SEARCH. Speciﬁcally, the algorithm searches A for x in order,\nconsidering AŒ1\u0002; AŒ2\u0002; AŒ3\u0002; : : : ; AŒn\u0002 until either it ﬁnds AŒi\u0002 D x or it reaches\nthe end of the array. Assume that all possible permutations of the input array are\nequally likely.\ne. Suppose that there is exactly one index i such that AŒi\u0002 D x. What is the\naverage-case running time of DETERMINISTIC-SEARCH? What is the worst-\ncase running time of DETERMINISTIC-SEARCH?\nf.\nGeneralizing your solution to part (e), suppose that there are k \u0006 1 indices i\nsuch that AŒi\u0002 D x. What is the average-case running time of DETERMINISTIC-\nSEARCH? What is the worst-case running time of DETERMINISTIC-SEARCH?\nYour answer should be a function of n and k.\ng. Suppose that there are no indices i such that AŒi\u0002 D x. What is the average-case\nrunning time of DETERMINISTIC-SEARCH? What is the worst-case running\ntime of DETERMINISTIC-SEARCH?\nFinally, consider a randomized algorithm SCRAMBLE-SEARCH that works by\nﬁrst randomly permuting the input array and then running the deterministic lin-\near search given above on the resulting permuted array.\nh. Letting k be the number of indices i such that AŒi\u0002 D x, give the worst-case and\nexpected running times of SCRAMBLE-SEARCH for the cases in which k D 0\nand k D 1. Generalize your solution to handle the case in which k \u0006 1.\ni.\nWhich of the three searching algorithms would you use? Explain your answer.\nNotes for Chapter 5\n145\nChapter notes\nBollob´as [53], Hofri [174], and Spencer [321] contain a wealth of advanced prob-\nabilistic techniques. The advantages of randomized algorithms are discussed and",
    "parent_0c6b4442-0bf4-46a4-bd19-0a1d318cf464": "i.\nWhich of the three searching algorithms would you use? Explain your answer.\nNotes for Chapter 5\n145\nChapter notes\nBollob´as [53], Hofri [174], and Spencer [321] contain a wealth of advanced prob-\nabilistic techniques. The advantages of randomized algorithms are discussed and\nsurveyed by Karp [200] and Rabin [288]. The textbook by Motwani and Raghavan\n[262] gives an extensive treatment of randomized algorithms.\nSeveral variants of the hiring problem have been widely studied. These problems\nare more commonly referred to as “secretary problems.” An example of work in\nthis area is the paper by Ajtai, Meggido, and Waarts [11].\nII\nSorting and Order Statistics\nIntroduction\nThis part presents several algorithms that solve the following sorting problem:\nInput: A sequence of n numbers ha1; a2; : : : ; ani.\nOutput: A permutation (reordering) ha0\n1; a0\n2; : : : ; a0\nni of the input sequence such\nthat a0\n1 \u0002 a0\n2 \u0002 \u0003 \u0003 \u0003 \u0002 a0\nn.\nThe input sequence is usually an n-element array, although it may be represented\nin some other fashion, such as a linked list.\nThe structure of the data\nIn practice, the numbers to be sorted are rarely isolated values. Each is usually part\nof a collection of data called a record. Each record contains a key, which is the\nvalue to be sorted. The remainder of the record consists of satellite data, which are\nusually carried around with the key. In practice, when a sorting algorithm permutes\nthe keys, it must permute the satellite data as well. If each record includes a large\namount of satellite data, we often permute an array of pointers to the records rather\nthan the records themselves in order to minimize data movement.\nIn a sense, it is these implementation details that distinguish an algorithm from\na full-blown program. A sorting algorithm describes the method by which we\ndetermine the sorted order, regardless of whether we are sorting individual numbers\nor large records containing many bytes of satellite data. Thus, when focusing on the",
    "parent_2a92d36e-bd6a-4e90-9a39-510bb8d9ad58": "a full-blown program. A sorting algorithm describes the method by which we\ndetermine the sorted order, regardless of whether we are sorting individual numbers\nor large records containing many bytes of satellite data. Thus, when focusing on the\nproblem of sorting, we typically assume that the input consists only of numbers.\nTranslating an algorithm for sorting numbers into a program for sorting records\n148\nPart II\nSorting and Order Statistics\nis conceptually straightforward, although in a given engineering situation other\nsubtleties may make the actual programming task a challenge.\nWhy sorting?\nMany computer scientists consider sorting to be the most fundamental problem in\nthe study of algorithms. There are several reasons:\n\u0002\nSometimes an application inherently needs to sort information. For example,\nin order to prepare customer statements, banks need to sort checks by check\nnumber.\n\u0002\nAlgorithms often use sorting as a key subroutine. For example, a program that\nrenders graphical objects which are layered on top of each other might have\nto sort the objects according to an “above” relation so that it can draw these\nobjects from bottom to top. We shall see numerous algorithms in this text that\nuse sorting as a subroutine.\n\u0002\nWe can draw from among a wide variety of sorting algorithms, and they em-\nploy a rich set of techniques. In fact, many important techniques used through-\nout algorithm design appear in the body of sorting algorithms that have been\ndeveloped over the years. In this way, sorting is also a problem of historical\ninterest.\n\u0002\nWe can prove a nontrivial lower bound for sorting (as we shall do in Chapter 8).\nOur best upper bounds match the lower bound asymptotically, and so we know\nthat our sorting algorithms are asymptotically optimal. Moreover, we can use\nthe lower bound for sorting to prove lower bounds for certain other problems.\n\u0002\nMany engineering issues come to the fore when implementing sorting algo-",
    "parent_064aa034-9073-4375-a2cd-0e3c487c3295": "that our sorting algorithms are asymptotically optimal. Moreover, we can use\nthe lower bound for sorting to prove lower bounds for certain other problems.\n\u0002\nMany engineering issues come to the fore when implementing sorting algo-\nrithms. The fastest sorting program for a particular situation may depend on\nmany factors, such as prior knowledge about the keys and satellite data, the\nmemory hierarchy (caches and virtual memory) of the host computer, and the\nsoftware environment. Many of these issues are best dealt with at the algorith-\nmic level, rather than by “tweaking” the code.\nSorting algorithms\nWe introduced two algorithms that sort n real numbers in Chapter 2. Insertion sort\ntakes ‚.n2/ time in the worst case. Because its inner loops are tight, however,\nit is a fast in-place sorting algorithm for small input sizes. (Recall that a sorting\nalgorithm sorts in place if only a constant number of elements of the input ar-\nray are ever stored outside the array.) Merge sort has a better asymptotic running\ntime, ‚.n lg n/, but the MERGE procedure it uses does not operate in place.\nPart II\nSorting and Order Statistics\n149\nIn this part, we shall introduce two more algorithms that sort arbitrary real num-\nbers. Heapsort, presented in Chapter 6, sorts n numbers in place in O.n lg n/ time.\nIt uses an important data structure, called a heap, with which we can also imple-\nment a priority queue.\nQuicksort, in Chapter 7, also sorts n numbers in place, but its worst-case running\ntime is ‚.n2/. Its expected running time is ‚.n lg n/, however, and it generally\noutperforms heapsort in practice. Like insertion sort, quicksort has tight code, and\nso the hidden constant factor in its running time is small. It is a popular algorithm\nfor sorting large input arrays.\nInsertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they\ndetermine the sorted order of an input array by comparing elements. Chapter 8 be-",
    "parent_4400b4e3-f217-4fc4-9c37-677c7eecad4c": "so the hidden constant factor in its running time is small. It is a popular algorithm\nfor sorting large input arrays.\nInsertion sort, merge sort, heapsort, and quicksort are all comparison sorts: they\ndetermine the sorted order of an input array by comparing elements. Chapter 8 be-\ngins by introducing the decision-tree model in order to study the performance limi-\ntations of comparison sorts. Using this model, we prove a lower bound of \u0004.n lg n/\non the worst-case running time of any comparison sort on n inputs, thus showing\nthat heapsort and merge sort are asymptotically optimal comparison sorts.\nChapter 8 then goes on to show that we can beat this lower bound of \u0004.n lg n/\nif we can gather information about the sorted order of the input by means other\nthan comparing elements. The counting sort algorithm, for example, assumes that\nthe input numbers are in the set f0; 1; : : : ; kg. By using array indexing as a tool\nfor determining relative order, counting sort can sort n numbers in ‚.k C n/ time.\nThus, when k D O.n/, counting sort runs in time that is linear in the size of the\ninput array. A related algorithm, radix sort, can be used to extend the range of\ncounting sort. If there are n integers to sort, each integer has d digits, and each\ndigit can take on up to k possible values, then radix sort can sort the numbers\nin ‚.d.n C k// time. When d is a constant and k is O.n/, radix sort runs in\nlinear time. A third algorithm, bucket sort, requires knowledge of the probabilistic\ndistribution of numbers in the input array. It can sort n real numbers uniformly\ndistributed in the half-open interval Œ0; 1/ in average-case O.n/ time.\nThe following table summarizes the running times of the sorting algorithms from\nChapters 2 and 6–8. As usual, n denotes the number of items to sort. For counting\nsort, the items to sort are integers in the set f0; 1; : : : ; kg. For radix sort, each item\nis a d-digit number, where each digit takes on k possible values. For bucket sort,",
    "parent_b3a302b4-4de1-4ec6-b23a-8ffcd79a698f": "Chapters 2 and 6–8. As usual, n denotes the number of items to sort. For counting\nsort, the items to sort are integers in the set f0; 1; : : : ; kg. For radix sort, each item\nis a d-digit number, where each digit takes on k possible values. For bucket sort,\nwe assume that the keys are real numbers uniformly distributed in the half-open\ninterval Œ0; 1/. The rightmost column gives the average-case or expected running\ntime, indicating which it gives when it differs from the worst-case running time.\nWe omit the average-case running time of heapsort because we do not analyze it in\nthis book.\n150\nPart II\nSorting and Order Statistics\nWorst-case\nAverage-case/expected\nAlgorithm\nrunning time\nrunning time\nInsertion sort\n‚.n2/\n‚.n2/\nMerge sort\n‚.n lg n/\n‚.n lg n/\nHeapsort\nO.n lg n/\n—\nQuicksort\n‚.n2/\n‚.n lg n/\n(expected)\nCounting sort\n‚.k C n/\n‚.k C n/\nRadix sort\n‚.d.n C k//\n‚.d.n C k//\nBucket sort\n‚.n2/\n‚.n/\n(average-case)\nOrder statistics\nThe ith order statistic of a set of n numbers is the ith smallest number in the set.\nWe can, of course, select the ith order statistic by sorting the input and indexing\nthe ith element of the output. With no assumptions about the input distribution,\nthis method runs in \u0004.n lg n/ time, as the lower bound proved in Chapter 8 shows.\nIn Chapter 9, we show that we can ﬁnd the ith smallest element in O.n/ time,\neven when the elements are arbitrary real numbers. We present a randomized algo-\nrithm with tight pseudocode that runs in ‚.n2/ time in the worst case, but whose\nexpected running time is O.n/. We also give a more complicated algorithm that\nruns in O.n/ worst-case time.\nBackground\nAlthough most of this part does not rely on difﬁcult mathematics, some sections\ndo require mathematical sophistication. In particular, analyses of quicksort, bucket\nsort, and the order-statistic algorithm use probability, which is reviewed in Ap-\npendix C, and the material on probabilistic analysis and randomized algorithms in",
    "parent_03899f17-dcb4-462c-9f86-a0aa73791886": "do require mathematical sophistication. In particular, analyses of quicksort, bucket\nsort, and the order-statistic algorithm use probability, which is reviewed in Ap-\npendix C, and the material on probabilistic analysis and randomized algorithms in\nChapter 5. The analysis of the worst-case linear-time algorithm for order statis-\ntics involves somewhat more sophisticated mathematics than the other worst-case\nanalyses in this part.\n6\nHeapsort\nIn this chapter, we introduce another sorting algorithm: heapsort. Like merge sort,\nbut unlike insertion sort, heapsort’s running time is O.n lg n/. Like insertion sort,\nbut unlike merge sort, heapsort sorts in place: only a constant number of array\nelements are stored outside the input array at any time. Thus, heapsort combines\nthe better attributes of the two sorting algorithms we have already discussed.\nHeapsort also introduces another algorithm design technique: using a data struc-\nture, in this case one we call a “heap,” to manage information. Not only is the heap\ndata structure useful for heapsort, but it also makes an efﬁcient priority queue. The\nheap data structure will reappear in algorithms in later chapters.\nThe term “heap” was originally coined in the context of heapsort, but it has since\ncome to refer to “garbage-collected storage,” such as the programming languages\nJava and Lisp provide. Our heap data structure is not garbage-collected storage,\nand whenever we refer to heaps in this book, we shall mean a data structure rather\nthan an aspect of garbage collection.\n6.1\nHeaps\nThe (binary) heap data structure is an array object that we can view as a\nnearly complete binary tree (see Section B.5.3), as shown in Figure 6.1. Each\nnode of the tree corresponds to an element of the array.\nThe tree is com-\npletely ﬁlled on all levels except possibly the lowest, which is ﬁlled from the\nleft up to a point. An array A that represents a heap is an object with two at-",
    "parent_c140ffc3-ffb6-4d76-91dc-9a944098b711": "node of the tree corresponds to an element of the array.\nThe tree is com-\npletely ﬁlled on all levels except possibly the lowest, which is ﬁlled from the\nleft up to a point. An array A that represents a heap is an object with two at-\ntributes: A:length, which (as usual) gives the number of elements in the array, and\nA:heap-size, which represents how many elements in the heap are stored within\narray A. That is, although AŒ1 : : A:length\u0002 may contain numbers, only the ele-\nments in AŒ1 : : A:heap-size\u0002, where 0 \u0002 A:heap-size \u0002 A:length, are valid ele-\nments of the heap. The root of the tree is AŒ1\u0002, and given the index i of a node, we\ncan easily compute the indices of its parent, left child, and right child:\n152\nChapter 6\nHeapsort\n(a)\n16 14 10 8\n7\n9\n3\n2\n4\n1\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n(b)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n16\n14\n10\n8\n7\n9\n3\n2\n4\n1\nFigure 6.1\nA max-heap viewed as (a) a binary tree and (b) an array. The number within the circle\nat each node in the tree is the value stored at that node. The number above a node is the corresponding\nindex in the array. Above and below the array are lines showing parent-child relationships; parents\nare always to the left of their children. The tree has height three; the node at index 4 (with value 8)\nhas height one.\nPARENT.i/\n1\nreturn bi=2c\nLEFT.i/\n1\nreturn 2i\nRIGHT.i/\n1\nreturn 2i C 1\nOn most computers, the LEFT procedure can compute 2i in one instruction by\nsimply shifting the binary representation of i left by one bit position. Similarly, the\nRIGHT procedure can quickly compute 2i C1 by shifting the binary representation\nof i left by one bit position and then adding in a 1 as the low-order bit. The\nPARENT procedure can compute bi=2c by shifting i right one bit position. Good\nimplementations of heapsort often implement these procedures as “macros” or “in-\nline” procedures.\nThere are two kinds of binary heaps: max-heaps and min-heaps. In both kinds,\nthe values in the nodes satisfy a heap property, the speciﬁcs of which depend on",
    "parent_e299e1cb-fffe-4219-87be-fc1d12e8397c": "implementations of heapsort often implement these procedures as “macros” or “in-\nline” procedures.\nThere are two kinds of binary heaps: max-heaps and min-heaps. In both kinds,\nthe values in the nodes satisfy a heap property, the speciﬁcs of which depend on\nthe kind of heap. In a max-heap, the max-heap property is that for every node i\nother than the root,\nAŒPARENT.i/\u0002 \u0006 AŒi\u0002 ;\nthat is, the value of a node is at most the value of its parent. Thus, the largest\nelement in a max-heap is stored at the root, and the subtree rooted at a node contains\n6.1\nHeaps\n153\nvalues no larger than that contained at the node itself. A min-heap is organized in\nthe opposite way; the min-heap property is that for every node i other than the\nroot,\nAŒPARENT.i/\u0002 \u0002 AŒi\u0002 :\nThe smallest element in a min-heap is at the root.\nFor the heapsort algorithm, we use max-heaps. Min-heaps commonly imple-\nment priority queues, which we discuss in Section 6.5. We shall be precise in\nspecifying whether we need a max-heap or a min-heap for any particular applica-\ntion, and when properties apply to either max-heaps or min-heaps, we just use the\nterm “heap.”\nViewing a heap as a tree, we deﬁne the height of a node in a heap to be the\nnumber of edges on the longest simple downward path from the node to a leaf, and\nwe deﬁne the height of the heap to be the height of its root. Since a heap of n ele-\nments is based on a complete binary tree, its height is ‚.lg n/ (see Exercise 6.1-2).\nWe shall see that the basic operations on heaps run in time at most proportional\nto the height of the tree and thus take O.lg n/ time. The remainder of this chapter\npresents some basic procedures and shows how they are used in a sorting algorithm\nand a priority-queue data structure.\n\u0002\nThe MAX-HEAPIFY procedure, which runs in O.lg n/ time, is the key to main-\ntaining the max-heap property.\n\u0002\nThe BUILD-MAX-HEAP procedure, which runs in linear time, produces a max-\nheap from an unordered input array.\n\u0002",
    "parent_ff33913e-ea9e-4bbf-96d5-32521a0e2346": "and a priority-queue data structure.\n\u0002\nThe MAX-HEAPIFY procedure, which runs in O.lg n/ time, is the key to main-\ntaining the max-heap property.\n\u0002\nThe BUILD-MAX-HEAP procedure, which runs in linear time, produces a max-\nheap from an unordered input array.\n\u0002\nThe HEAPSORT procedure, which runs in O.n lg n/ time, sorts an array in\nplace.\n\u0002\nThe MAX-HEAP-INSERT, HEAP-EXTRACT-MAX, HEAP-INCREASE-KEY,\nand HEAP-MAXIMUM procedures, which run in O.lg n/ time, allow the heap\ndata structure to implement a priority queue.\nExercises\n6.1-1\nWhat are the minimum and maximum numbers of elements in a heap of height h?\n6.1-2\nShow that an n-element heap has height blg nc.\n6.1-3\nShow that in any subtree of a max-heap, the root of the subtree contains the largest\nvalue occurring anywhere in that subtree.\n154\nChapter 6\nHeapsort\n6.1-4\nWhere in a max-heap might the smallest element reside, assuming that all elements\nare distinct?\n6.1-5\nIs an array that is in sorted order a min-heap?\n6.1-6\nIs the array with values h23; 17; 14; 6; 13; 10; 1; 5; 7; 12i a max-heap?\n6.1-7\nShow that, with the array representation for storing an n-element heap, the leaves\nare the nodes indexed by bn=2c C 1; bn=2c C 2; : : : ; n.\n6.2\nMaintaining the heap property\nIn order to maintain the max-heap property, we call the procedure MAX-HEAPIFY.\nIts inputs are an array A and an index i into the array. When it is called, MAX-\nHEAPIFY assumes that the binary trees rooted at LEFT.i/ and RIGHT.i/ are max-\nheaps, but that AŒi\u0002 might be smaller than its children, thus violating the max-heap\nproperty. MAX-HEAPIFY lets the value at AŒi\u0002 “ﬂoat down” in the max-heap so\nthat the subtree rooted at index i obeys the max-heap property.\nMAX-HEAPIFY.A; i/\n1\nl D LEFT.i/\n2\nr D RIGHT.i/\n3\nif l \u0002 A:heap-size and AŒl\u0002 > AŒi\u0002\n4\nlargest D l\n5\nelse largest D i\n6\nif r \u0002 A:heap-size and AŒr\u0002 > AŒlargest\u0002\n7\nlargest D r\n8\nif largest ¤ i\n9\nexchange AŒi\u0002 with AŒlargest\u0002\n10\nMAX-HEAPIFY.A; largest/",
    "parent_f28fffd5-fcb6-478d-b204-6894d81783d3": "MAX-HEAPIFY.A; i/\n1\nl D LEFT.i/\n2\nr D RIGHT.i/\n3\nif l \u0002 A:heap-size and AŒl\u0002 > AŒi\u0002\n4\nlargest D l\n5\nelse largest D i\n6\nif r \u0002 A:heap-size and AŒr\u0002 > AŒlargest\u0002\n7\nlargest D r\n8\nif largest ¤ i\n9\nexchange AŒi\u0002 with AŒlargest\u0002\n10\nMAX-HEAPIFY.A; largest/\nFigure 6.2 illustrates the action of MAX-HEAPIFY. At each step, the largest of\nthe elements AŒi\u0002, AŒLEFT.i/\u0002, and AŒRIGHT.i/\u0002 is determined, and its index is\nstored in largest. If AŒi\u0002 is largest, then the subtree rooted at node i is already a\nmax-heap and the procedure terminates. Otherwise, one of the two children has the\nlargest element, and AŒi\u0002 is swapped with AŒlargest\u0002, which causes node i and its\n6.2\nMaintaining the heap property\n155\n16\n4\n10\n14\n7\n9\n2\n8\n1\n(a)\n16\n14\n10\n4\n7\n9\n3\n2\n8\n1\n(b)\n16\n14\n10\n8\n7\n9\n3\n2\n4\n1\n(c)\n3\n1\n3\n4\n5\n6\n7\n9\n10\n2\n8\n1\n3\n4\n5\n6\n7\n9\n10\n2\n8\n1\n3\n4\n5\n6\n7\n9\n10\n2\n8\ni\ni\ni\nFigure 6.2\nThe action of MAX-HEAPIFY.A; 2/, where A:heap-size D 10. (a) The initial con-\nﬁguration, with AŒ2\u0002 at node i D 2 violating the max-heap property since it is not larger than\nboth children. The max-heap property is restored for node 2 in (b) by exchanging AŒ2\u0002 with AŒ4\u0002,\nwhich destroys the max-heap property for node 4. The recursive call MAX-HEAPIFY.A; 4/ now\nhas i D 4. After swapping AŒ4\u0002 with AŒ9\u0002, as shown in (c), node 4 is ﬁxed up, and the recursive call\nMAX-HEAPIFY.A; 9/ yields no further change to the data structure.\nchildren to satisfy the max-heap property. The node indexed by largest, however,\nnow has the original value AŒi\u0002, and thus the subtree rooted at largest might violate\nthe max-heap property. Consequently, we call MAX-HEAPIFY recursively on that\nsubtree.\nThe running time of MAX-HEAPIFY on a subtree of size n rooted at a given\nnode i is the ‚.1/ time to ﬁx up the relationships among the elements AŒi\u0002,\nAŒLEFT.i/\u0002, and AŒRIGHT.i/\u0002, plus the time to run MAX-HEAPIFY on a subtree\nrooted at one of the children of node i (assuming that the recursive call occurs).",
    "parent_b778c4cf-a014-49e4-a0e0-228bc4752537": "node i is the ‚.1/ time to ﬁx up the relationships among the elements AŒi\u0002,\nAŒLEFT.i/\u0002, and AŒRIGHT.i/\u0002, plus the time to run MAX-HEAPIFY on a subtree\nrooted at one of the children of node i (assuming that the recursive call occurs).\nThe children’s subtrees each have size at most 2n=3—the worst case occurs when\nthe bottom level of the tree is exactly half full—and therefore we can describe the\nrunning time of MAX-HEAPIFY by the recurrence\nT .n/ \u0002 T .2n=3/ C ‚.1/ :\n156\nChapter 6\nHeapsort\nThe solution to this recurrence, by case 2 of the master theorem (Theorem 4.1),\nis T .n/ D O.lg n/. Alternatively, we can characterize the running time of MAX-\nHEAPIFY on a node of height h as O.h/.\nExercises\n6.2-1\nUsing Figure 6.2 as a model, illustrate the operation of MAX-HEAPIFY.A; 3/ on\nthe array A D h27; 17; 3; 16; 13; 10; 1; 5; 7; 12; 4; 8; 9; 0i.\n6.2-2\nStarting with the procedure MAX-HEAPIFY, write pseudocode for the procedure\nMIN-HEAPIFY.A; i/, which performs the corresponding manipulation on a min-\nheap. How does the running time of MIN-HEAPIFY compare to that of MAX-\nHEAPIFY?\n6.2-3\nWhat is the effect of calling MAX-HEAPIFY.A; i/ when the element AŒi\u0002 is larger\nthan its children?\n6.2-4\nWhat is the effect of calling MAX-HEAPIFY.A; i/ for i > A:heap-size=2?\n6.2-5\nThe code for MAX-HEAPIFY is quite efﬁcient in terms of constant factors, except\npossibly for the recursive call in line 10, which might cause some compilers to\nproduce inefﬁcient code. Write an efﬁcient MAX-HEAPIFY that uses an iterative\ncontrol construct (a loop) instead of recursion.\n6.2-6\nShow that the worst-case running time of MAX-HEAPIFY on a heap of size n\nis \u0004.lg n/. (Hint: For a heap with n nodes, give node values that cause MAX-\nHEAPIFY to be called recursively at every node on a simple path from the root\ndown to a leaf.)\n6.3\nBuilding a heap\nWe can use the procedure MAX-HEAPIFY in a bottom-up manner to convert an\narray AŒ1 : : n\u0002, where n D A:length, into a max-heap. By Exercise 6.1-7, the",
    "parent_52986d81-b941-4d4d-bb1e-359fcfbd1e46": "HEAPIFY to be called recursively at every node on a simple path from the root\ndown to a leaf.)\n6.3\nBuilding a heap\nWe can use the procedure MAX-HEAPIFY in a bottom-up manner to convert an\narray AŒ1 : : n\u0002, where n D A:length, into a max-heap. By Exercise 6.1-7, the\nelements in the subarray AŒ.bn=2cC1/ : : n\u0002 are all leaves of the tree, and so each is\n6.3\nBuilding a heap\n157\na 1-element heap to begin with. The procedure BUILD-MAX-HEAP goes through\nthe remaining nodes of the tree and runs MAX-HEAPIFY on each one.\nBUILD-MAX-HEAP.A/\n1\nA:heap-size D A:length\n2\nfor i D bA:length=2c downto 1\n3\nMAX-HEAPIFY.A; i/\nFigure 6.3 shows an example of the action of BUILD-MAX-HEAP.\nTo show why BUILD-MAX-HEAP works correctly, we use the following loop\ninvariant:\nAt the start of each iteration of the for loop of lines 2–3, each node i C 1;\ni C 2; : : : ; n is the root of a max-heap.\nWe need to show that this invariant is true prior to the ﬁrst loop iteration, that each\niteration of the loop maintains the invariant, and that the invariant provides a useful\nproperty to show correctness when the loop terminates.\nInitialization: Prior to the ﬁrst iteration of the loop, i D bn=2c. Each node\nbn=2c C 1; bn=2c C 2; : : : ; n is a leaf and is thus the root of a trivial max-heap.\nMaintenance: To see that each iteration maintains the loop invariant, observe that\nthe children of node i are numbered higher than i. By the loop invariant, there-\nfore, they are both roots of max-heaps. This is precisely the condition required\nfor the call MAX-HEAPIFY.A; i/ to make node i a max-heap root. Moreover,\nthe MAX-HEAPIFY call preserves the property that nodes i C 1; i C 2; : : : ; n\nare all roots of max-heaps. Decrementing i in the for loop update reestablishes\nthe loop invariant for the next iteration.\nTermination: At termination, i D 0. By the loop invariant, each node 1; 2; : : : ; n\nis the root of a max-heap. In particular, node 1 is.\nWe can compute a simple upper bound on the running time of BUILD-MAX-",
    "parent_1e9b6925-8d7c-4dea-b32b-5459ced29bff": "the loop invariant for the next iteration.\nTermination: At termination, i D 0. By the loop invariant, each node 1; 2; : : : ; n\nis the root of a max-heap. In particular, node 1 is.\nWe can compute a simple upper bound on the running time of BUILD-MAX-\nHEAP as follows. Each call to MAX-HEAPIFY costs O.lg n/ time, and BUILD-\nMAX-HEAP makes O.n/ such calls. Thus, the running time is O.n lg n/. This\nupper bound, though correct, is not asymptotically tight.\nWe can derive a tighter bound by observing that the time for MAX-HEAPIFY to\nrun at a node varies with the height of the node in the tree, and the heights of most\nnodes are small. Our tighter analysis relies on the properties that an n-element heap\nhas height blg nc (see Exercise 6.1-2) and at most\n˙\nn=2hC1\u000e\nnodes of any height h\n(see Exercise 6.3-3).\nThe time required by MAX-HEAPIFY when called on a node of height h is O.h/,\nand so we can express the total cost of BUILD-MAX-HEAP as being bounded from\nabove by\n158\nChapter 6\nHeapsort\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n4\n1\n3\n2\n9\n10\n14\n8\n7\n(a)\n16\n4\n1\n2\n3\n16 9 10 14 8\n7\n4\n1\n3\n2\n9\n10\n14\n8\n7\n(b)\n16\n4\n1\n3\n14\n9\n10\n2\n8\n7\n(c)\n16\n4\n1\n10\n14\n9\n3\n2\n8\n7\n(d)\n16\n4\n16\n10\n14\n9\n3\n2\n8\n1\n(e)\n7\n16\n14\n10\n8\n9\n3\n2\n4\n1\n(f)\n7\nA\ni\ni\ni\ni\ni\nFigure 6.3\nThe operation of BUILD-MAX-HEAP, showing the data structure before the call to\nMAX-HEAPIFY in line 3 of BUILD-MAX-HEAP.\n(a) A 10-element input array A and the bi-\nnary tree it represents. The ﬁgure shows that the loop index i refers to node 5 before the call\nMAX-HEAPIFY.A; i/. (b) The data structure that results. The loop index i for the next iteration\nrefers to node 4. (c)–(e) Subsequent iterations of the for loop in BUILD-MAX-HEAP. Observe that\nwhenever MAX-HEAPIFY is called on a node, the two subtrees of that node are both max-heaps.\n(f) The max-heap after BUILD-MAX-HEAP ﬁnishes.\n6.4\nThe heapsort algorithm\n159\nblg nc\nX\nhD0\nl n\n2hC1\nm\nO.h/ D O\n \nn\nblg nc\nX\nhD0",
    "parent_fe124837-8e4e-4a5e-b6d2-7cd849f82519": "whenever MAX-HEAPIFY is called on a node, the two subtrees of that node are both max-heaps.\n(f) The max-heap after BUILD-MAX-HEAP ﬁnishes.\n6.4\nThe heapsort algorithm\n159\nblg nc\nX\nhD0\nl n\n2hC1\nm\nO.h/ D O\n \nn\nblg nc\nX\nhD0\nh\n2h\n!\n:\nWe evalaute the last summation by substituting x D 1=2 in the formula (A.8),\nyielding\n1\nX\nhD0\nh\n2h\nD\n1=2\n.1 \u0005 1=2/2\nD\n2 :\nThus, we can bound the running time of BUILD-MAX-HEAP as\nO\n \nn\nblg nc\nX\nhD0\nh\n2h\n!\nD\nO\n \nn\n1\nX\nhD0\nh\n2h\n!\nD\nO.n/ :\nHence, we can build a max-heap from an unordered array in linear time.\nWe can build a min-heap by the procedure BUILD-MIN-HEAP, which is the\nsame as BUILD-MAX-HEAP but with the call to MAX-HEAPIFY in line 3 replaced\nby a call to MIN-HEAPIFY (see Exercise 6.2-2). BUILD-MIN-HEAP produces a\nmin-heap from an unordered linear array in linear time.\nExercises\n6.3-1\nUsing Figure 6.3 as a model, illustrate the operation of BUILD-MAX-HEAP on the\narray A D h5; 3; 17; 10; 84; 19; 6; 22; 9i.\n6.3-2\nWhy do we want the loop index i in line 2 of BUILD-MAX-HEAP to decrease from\nbA:length=2c to 1 rather than increase from 1 to bA:length=2c?\n6.3-3\nShow that there are at most\n˙\nn=2hC1\u000e\nnodes of height h in any n-element heap.\n6.4\nThe heapsort algorithm\nThe heapsort algorithm starts by using BUILD-MAX-HEAP to build a max-heap\non the input array AŒ1 : : n\u0002, where n D A:length. Since the maximum element\nof the array is stored at the root AŒ1\u0002, we can put it into its correct ﬁnal position\n160\nChapter 6\nHeapsort\nby exchanging it with AŒn\u0002. If we now discard node n from the heap—and we\ncan do so by simply decrementing A:heap-size—we observe that the children of\nthe root remain max-heaps, but the new root element might violate the max-heap\nproperty. All we need to do to restore the max-heap property, however, is call\nMAX-HEAPIFY.A; 1/, which leaves a max-heap in AŒ1 : : n \u0005 1\u0002. The heapsort\nalgorithm then repeats this process for the max-heap of size n \u0005 1 down to a heap\nof size 2. (See Exercise 6.4-2 for a precise loop invariant.)",
    "parent_744f715d-b800-45ef-bc5f-4445cf165a5b": "property. All we need to do to restore the max-heap property, however, is call\nMAX-HEAPIFY.A; 1/, which leaves a max-heap in AŒ1 : : n \u0005 1\u0002. The heapsort\nalgorithm then repeats this process for the max-heap of size n \u0005 1 down to a heap\nof size 2. (See Exercise 6.4-2 for a precise loop invariant.)\nHEAPSORT.A/\n1\nBUILD-MAX-HEAP.A/\n2\nfor i D A:length downto 2\n3\nexchange AŒ1\u0002 with AŒi\u0002\n4\nA:heap-size D A:heap-size \u0005 1\n5\nMAX-HEAPIFY.A; 1/\nFigure 6.4 shows an example of the operation of HEAPSORT after line 1 has built\nthe initial max-heap. The ﬁgure shows the max-heap before the ﬁrst iteration of\nthe for loop of lines 2–5 and after each iteration.\nThe HEAPSORT procedure takes time O.n lg n/, since the call to BUILD-MAX-\nHEAP takes time O.n/ and each of the n \u0005 1 calls to MAX-HEAPIFY takes\ntime O.lg n/.\nExercises\n6.4-1\nUsing Figure 6.4 as a model, illustrate the operation of HEAPSORT on the array\nA D h5; 13; 2; 25; 7; 17; 20; 8; 4i.\n6.4-2\nArgue the correctness of HEAPSORT using the following loop invariant:\nAt the start of each iteration of the for loop of lines 2–5, the subarray\nAŒ1 : : i\u0002 is a max-heap containing the i smallest elements of AŒ1 : : n\u0002, and\nthe subarray AŒi C 1 : : n\u0002 contains the n \u0005 i largest elements of AŒ1 : : n\u0002,\nsorted.\n6.4-3\nWhat is the running time of HEAPSORT on an array A of length n that is already\nsorted in increasing order? What about decreasing order?\n6.4-4\nShow that the worst-case running time of HEAPSORT is \u0004.n lg n/.\n6.4\nThe heapsort algorithm\n161\n(a)\n(b)\n(c)\n(d)\n(e)\n(f)\n(g)\n(h)\n(i)\n(j)\n(k)\n1\n2\n3\n4\n7\n8\n9 10 14 16\n10\n2\n1\n3\n4\n7\n8\n9\n16\n14\n1\n2\n3\n4\n7\n8\n9\n16\n14\n10\n3\n2\n1\n9\n8\n7\n4\n10\n14\n16\n4\n2\n3\n9\n8\n7\n1\n10\n14\n16\n8\n3\n7\n4\n2\n1\n9\n16\n14\n10\n7\n4\n3\n9\n8\n2\n1\n10\n14\n16\n9\n8\n3\n2\n1\n7\n4\n16\n14\n10\n10\n8\n9\n3\n1\n7\n4\n16\n14\n2\n14\n8\n10\n3\n9\n7\n4\n16\n1\n2\n16\n14\n10\n3\n9\n7\n8\n1\n4\n2\nA\ni\ni\ni\ni\ni\ni\ni\ni\ni\nFigure 6.4\nThe operation of HEAPSORT. (a) The max-heap data structure just after BUILD-MAX-",
    "parent_5386427a-3a83-4bd0-925d-c4a82db28980": "10\n3\n2\n1\n9\n8\n7\n4\n10\n14\n16\n4\n2\n3\n9\n8\n7\n1\n10\n14\n16\n8\n3\n7\n4\n2\n1\n9\n16\n14\n10\n7\n4\n3\n9\n8\n2\n1\n10\n14\n16\n9\n8\n3\n2\n1\n7\n4\n16\n14\n10\n10\n8\n9\n3\n1\n7\n4\n16\n14\n2\n14\n8\n10\n3\n9\n7\n4\n16\n1\n2\n16\n14\n10\n3\n9\n7\n8\n1\n4\n2\nA\ni\ni\ni\ni\ni\ni\ni\ni\ni\nFigure 6.4\nThe operation of HEAPSORT. (a) The max-heap data structure just after BUILD-MAX-\nHEAP has built it in line 1. (b)–(j) The max-heap just after each call of MAX-HEAPIFY in line 5,\nshowing the value of i at that time. Only lightly shaded nodes remain in the heap. (k) The resulting\nsorted array A.\n162\nChapter 6\nHeapsort\n6.4-5\n?\nShow that when all elements are distinct, the best-case running time of HEAPSORT\nis \u0004.n lg n/.\n6.5\nPriority queues\nHeapsort is an excellent algorithm, but a good implementation of quicksort, pre-\nsented in Chapter 7, usually beats it in practice. Nevertheless, the heap data struc-\nture itself has many uses. In this section, we present one of the most popular ap-\nplications of a heap: as an efﬁcient priority queue. As with heaps, priority queues\ncome in two forms: max-priority queues and min-priority queues. We will focus\nhere on how to implement max-priority queues, which are in turn based on max-\nheaps; Exercise 6.5-3 asks you to write the procedures for min-priority queues.\nA priority queue is a data structure for maintaining a set S of elements, each\nwith an associated value called a key. A max-priority queue supports the following\noperations:\nINSERT.S; x/ inserts the element x into the set S, which is equivalent to the oper-\nation S D S [ fxg.\nMAXIMUM.S/ returns the element of S with the largest key.\nEXTRACT-MAX.S/ removes and returns the element of S with the largest key.\nINCREASE-KEY.S; x; k/ increases the value of element x’s key to the new value k,\nwhich is assumed to be at least as large as x’s current key value.\nAmong their other applications, we can use max-priority queues to schedule\njobs on a shared computer. The max-priority queue keeps track of the jobs to",
    "parent_87b65dc5-5430-44a2-b0f8-d4f1f1baed45": "INCREASE-KEY.S; x; k/ increases the value of element x’s key to the new value k,\nwhich is assumed to be at least as large as x’s current key value.\nAmong their other applications, we can use max-priority queues to schedule\njobs on a shared computer. The max-priority queue keeps track of the jobs to\nbe performed and their relative priorities. When a job is ﬁnished or interrupted,\nthe scheduler selects the highest-priority job from among those pending by calling\nEXTRACT-MAX. The scheduler can add a new job to the queue at any time by\ncalling INSERT.\nAlternatively, a min-priority queue supports the operations INSERT, MINIMUM,\nEXTRACT-MIN, and DECREASE-KEY. A min-priority queue can be used in an\nevent-driven simulator. The items in the queue are events to be simulated, each\nwith an associated time of occurrence that serves as its key. The events must be\nsimulated in order of their time of occurrence, because the simulation of an event\ncan cause other events to be simulated in the future. The simulation program calls\nEXTRACT-MIN at each step to choose the next event to simulate. As new events are\nproduced, the simulator inserts them into the min-priority queue by calling INSERT.\n6.5\nPriority queues\n163\nWe shall see other uses for min-priority queues, highlighting the DECREASE-KEY\noperation, in Chapters 23 and 24.\nNot surprisingly, we can use a heap to implement a priority queue. In a given ap-\nplication, such as job scheduling or event-driven simulation, elements of a priority\nqueue correspond to objects in the application. We often need to determine which\napplication object corresponds to a given priority-queue element, and vice versa.\nWhen we use a heap to implement a priority queue, therefore, we often need to\nstore a handle to the corresponding application object in each heap element. The\nexact makeup of the handle (such as a pointer or an integer) depends on the ap-\nplication. Similarly, we need to store a handle to the corresponding heap element",
    "parent_86e10c51-52e6-40e7-a49e-36b586d232a8": "store a handle to the corresponding application object in each heap element. The\nexact makeup of the handle (such as a pointer or an integer) depends on the ap-\nplication. Similarly, we need to store a handle to the corresponding heap element\nin each application object. Here, the handle would typically be an array index.\nBecause heap elements change locations within the array during heap operations,\nan actual implementation, upon relocating a heap element, would also have to up-\ndate the array index in the corresponding application object. Because the details\nof accessing application objects depend heavily on the application and its imple-\nmentation, we shall not pursue them here, other than noting that in practice, these\nhandles do need to be correctly maintained.\nNow we discuss how to implement the operations of a max-priority queue. The\nprocedure HEAP-MAXIMUM implements the MAXIMUM operation in ‚.1/ time.\nHEAP-MAXIMUM.A/\n1\nreturn AŒ1\u0002\nThe procedure HEAP-EXTRACT-MAX implements the EXTRACT-MAX opera-\ntion. It is similar to the for loop body (lines 3–5) of the HEAPSORT procedure.\nHEAP-EXTRACT-MAX.A/\n1\nif A:heap-size < 1\n2\nerror “heap underﬂow”\n3\nmax D AŒ1\u0002\n4\nAŒ1\u0002 D AŒA:heap-size\u0002\n5\nA:heap-size D A:heap-size \u0005 1\n6\nMAX-HEAPIFY.A; 1/\n7\nreturn max\nThe running time of HEAP-EXTRACT-MAX is O.lg n/, since it performs only a\nconstant amount of work on top of the O.lg n/ time for MAX-HEAPIFY.\nThe procedure HEAP-INCREASE-KEY implements the INCREASE-KEY opera-\ntion. An index i into the array identiﬁes the priority-queue element whose key we\nwish to increase. The procedure ﬁrst updates the key of element AŒi\u0002 to its new\nvalue. Because increasing the key of AŒi\u0002 might violate the max-heap property,\n164\nChapter 6\nHeapsort\nthe procedure then, in a manner reminiscent of the insertion loop (lines 5–7) of\nINSERTION-SORT from Section 2.1, traverses a simple path from this node toward\nthe root to ﬁnd a proper place for the newly increased key. As HEAP-INCREASE-",
    "parent_ceb84428-0654-48fe-813f-d9acf15e15fb": "164\nChapter 6\nHeapsort\nthe procedure then, in a manner reminiscent of the insertion loop (lines 5–7) of\nINSERTION-SORT from Section 2.1, traverses a simple path from this node toward\nthe root to ﬁnd a proper place for the newly increased key. As HEAP-INCREASE-\nKEY traverses this path, it repeatedly compares an element to its parent, exchang-\ning their keys and continuing if the element’s key is larger, and terminating if the el-\nement’s key is smaller, since the max-heap property now holds. (See Exercise 6.5-5\nfor a precise loop invariant.)\nHEAP-INCREASE-KEY.A; i; key/\n1\nif key < AŒi\u0002\n2\nerror “new key is smaller than current key”\n3\nAŒi\u0002 D key\n4\nwhile i > 1 and AŒPARENT.i/\u0002 < AŒi\u0002\n5\nexchange AŒi\u0002 with AŒPARENT.i/\u0002\n6\ni D PARENT.i/\nFigure 6.5 shows an example of a HEAP-INCREASE-KEY operation. The running\ntime of HEAP-INCREASE-KEY on an n-element heap is O.lg n/, since the path\ntraced from the node updated in line 3 to the root has length O.lg n/.\nThe procedure MAX-HEAP-INSERT implements the INSERT operation. It takes\nas an input the key of the new element to be inserted into max-heap A. The proce-\ndure ﬁrst expands the max-heap by adding to the tree a new leaf whose key is \u00051.\nThen it calls HEAP-INCREASE-KEY to set the key of this new node to its correct\nvalue and maintain the max-heap property.\nMAX-HEAP-INSERT.A; key/\n1\nA:heap-size D A:heap-size C 1\n2\nAŒA:heap-size\u0002 D \u00051\n3\nHEAP-INCREASE-KEY.A; A:heap-size; key/\nThe running time of MAX-HEAP-INSERT on an n-element heap is O.lg n/.\nIn summary, a heap can support any priority-queue operation on a set of size n\nin O.lg n/ time.\nExercises\n6.5-1\nIllustrate the operation of HEAP-EXTRACT-MAX on the heap A D h15; 13; 9; 5;\n12; 8; 7; 4; 0; 6; 2; 1i.\n6.5\nPriority queues\n165\n16\n14\n10\n8\n7\n9\n3\n2\n4\n1\n(a)\ni\n16\n14\n10\n8\n7\n9\n3\n2\n15\n1\n(b)\n16\n14\n10\n8\n7\n9\n3\n2\n15\n1\n(c)\ni\ni\n16\n14\n10\n8\n7\n9\n3\n2\n15\n1\n(d)\ni\nFigure 6.5\nThe operation of HEAP-INCREASE-KEY. (a) The max-heap of Figure 6.4(a) with a",
    "parent_67d5da92-8559-4001-a861-ff334ab5a00a": "12; 8; 7; 4; 0; 6; 2; 1i.\n6.5\nPriority queues\n165\n16\n14\n10\n8\n7\n9\n3\n2\n4\n1\n(a)\ni\n16\n14\n10\n8\n7\n9\n3\n2\n15\n1\n(b)\n16\n14\n10\n8\n7\n9\n3\n2\n15\n1\n(c)\ni\ni\n16\n14\n10\n8\n7\n9\n3\n2\n15\n1\n(d)\ni\nFigure 6.5\nThe operation of HEAP-INCREASE-KEY. (a) The max-heap of Figure 6.4(a) with a\nnode whose index is i heavily shaded. (b) This node has its key increased to 15. (c) After one\niteration of the while loop of lines 4–6, the node and its parent have exchanged keys, and the index i\nmoves up to the parent. (d) The max-heap after one more iteration of the while loop. At this point,\nAŒPARENT.i/\u0002 \u0006 AŒi\u0002. The max-heap property now holds and the procedure terminates.\n6.5-2\nIllustrate the operation of MAX-HEAP-INSERT.A; 10/ on the heap A D h15;13;9;\n5; 12; 8; 7; 4; 0; 6; 2; 1i.\n6.5-3\nWrite pseudocode for the procedures HEAP-MINIMUM, HEAP-EXTRACT-MIN,\nHEAP-DECREASE-KEY, and MIN-HEAP-INSERT that implement a min-priority\nqueue with a min-heap.\n6.5-4\nWhy do we bother setting the key of the inserted node to \u00051 in line 2 of MAX-\nHEAP-INSERT when the next thing we do is increase its key to the desired value?\n166\nChapter 6\nHeapsort\n6.5-5\nArgue the correctness of HEAP-INCREASE-KEY using the following loop invari-\nant:\nAt the start of each iteration of the while loop of lines 4–6, the subarray\nAŒ1 : : A:heap-size\u0002 satisﬁes the max-heap property, except that there may\nbe one violation: AŒi\u0002 may be larger than AŒPARENT.i/\u0002.\nYou may assume that the subarray AŒ1 : : A:heap-size\u0002 satisﬁes the max-heap prop-\nerty at the time HEAP-INCREASE-KEY is called.\n6.5-6\nEach exchange operation on line 5 of HEAP-INCREASE-KEY typically requires\nthree assignments. Show how to use the idea of the inner loop of INSERTION-\nSORT to reduce the three assignments down to just one assignment.\n6.5-7\nShow how to implement a ﬁrst-in, ﬁrst-out queue with a priority queue. Show\nhow to implement a stack with a priority queue. (Queues and stacks are deﬁned in\nSection 10.1.)\n6.5-8",
    "parent_dddeb97a-2f47-41ca-bcb6-d537c4cdf95c": "SORT to reduce the three assignments down to just one assignment.\n6.5-7\nShow how to implement a ﬁrst-in, ﬁrst-out queue with a priority queue. Show\nhow to implement a stack with a priority queue. (Queues and stacks are deﬁned in\nSection 10.1.)\n6.5-8\nThe operation HEAP-DELETE.A; i/ deletes the item in node i from heap A. Give\nan implementation of HEAP-DELETE that runs in O.lg n/ time for an n-element\nmax-heap.\n6.5-9\nGive an O.n lg k/-time algorithm to merge k sorted lists into one sorted list,\nwhere n is the total number of elements in all the input lists. (Hint: Use a min-\nheap for k-way merging.)\nProblems\n6-1\nBuilding a heap using insertion\nWe can build a heap by repeatedly calling MAX-HEAP-INSERT to insert the ele-\nments into the heap. Consider the following variation on the BUILD-MAX-HEAP\nprocedure:\nProblems for Chapter 6\n167\nBUILD-MAX-HEAP0.A/\n1\nA:heap-size D 1\n2\nfor i D 2 to A:length\n3\nMAX-HEAP-INSERT.A; AŒi\u0002/\na. Do the procedures BUILD-MAX-HEAP and BUILD-MAX-HEAP0 always create\nthe same heap when run on the same input array? Prove that they do, or provide\na counterexample.\nb. Show that in the worst case, BUILD-MAX-HEAP0 requires ‚.n lg n/ time to\nbuild an n-element heap.\n6-2\nAnalysis of d-ary heaps\nA d-ary heap is like a binary heap, but (with one possible exception) non-leaf\nnodes have d children instead of 2 children.\na. How would you represent a d-ary heap in an array?\nb. What is the height of a d-ary heap of n elements in terms of n and d?\nc. Give an efﬁcient implementation of EXTRACT-MAX in a d-ary max-heap. An-\nalyze its running time in terms of d and n.\nd. Give an efﬁcient implementation of INSERT in a d-ary max-heap. Analyze its\nrunning time in terms of d and n.\ne. Give an efﬁcient implementation of INCREASE-KEY.A; i; k/, which ﬂags an\nerror if k < AŒi\u0002, but otherwise sets AŒi\u0002 D k and then updates the d-ary max-\nheap structure appropriately. Analyze its running time in terms of d and n.\n6-3\nYoung tableaus",
    "parent_709537aa-cdc3-40fe-9fbf-34609f6106f8": "running time in terms of d and n.\ne. Give an efﬁcient implementation of INCREASE-KEY.A; i; k/, which ﬂags an\nerror if k < AŒi\u0002, but otherwise sets AŒi\u0002 D k and then updates the d-ary max-\nheap structure appropriately. Analyze its running time in terms of d and n.\n6-3\nYoung tableaus\nAn m \t n Young tableau is an m \t n matrix such that the entries of each row are\nin sorted order from left to right and the entries of each column are in sorted order\nfrom top to bottom. Some of the entries of a Young tableau may be 1, which we\ntreat as nonexistent elements. Thus, a Young tableau can be used to hold r \u0002 mn\nﬁnite numbers.\na. Draw a 4\t4 Young tableau containing the elements f9; 16; 3; 2; 4; 8; 5; 14; 12g.\nb. Argue that an m \t n Young tableau Y is empty if Y Œ1; 1\u0002 D 1. Argue that Y\nis full (contains mn elements) if Y Œm; n\u0002 < 1.\n168\nChapter 6\nHeapsort\nc. Give an algorithm to implement EXTRACT-MIN on a nonempty m \t n Young\ntableau that runs in O.m C n/ time.\nYour algorithm should use a recur-\nsive subroutine that solves an m \t n problem by recursively solving either\nan .m \u0005 1/ \t n or an m \t .n \u0005 1/ subproblem.\n(Hint: Think about MAX-\nHEAPIFY.) Deﬁne T .p/, where p D m C n, to be the maximum running time\nof EXTRACT-MIN on any m \t n Young tableau. Give and solve a recurrence\nfor T .p/ that yields the O.m C n/ time bound.\nd. Show how to insert a new element into a nonfull m \t n Young tableau in\nO.m C n/ time.\ne. Using no other sorting method as a subroutine, show how to use an n\tn Young\ntableau to sort n2 numbers in O.n3/ time.\nf.\nGive an O.m C n/-time algorithm to determine whether a given number is\nstored in a given m \t n Young tableau.\nChapter notes\nThe heapsort algorithm was invented by Williams [357], who also described how\nto implement a priority queue with a heap. The BUILD-MAX-HEAP procedure\nwas suggested by Floyd [106].\nWe use min-heaps to implement min-priority queues in Chapters 16, 23, and 24.",
    "parent_12f8b73c-9596-455f-a419-b6a3a9b9c30c": "Chapter notes\nThe heapsort algorithm was invented by Williams [357], who also described how\nto implement a priority queue with a heap. The BUILD-MAX-HEAP procedure\nwas suggested by Floyd [106].\nWe use min-heaps to implement min-priority queues in Chapters 16, 23, and 24.\nWe also give an implementation with improved time bounds for certain operations\nin Chapter 19 and, assuming that the keys are drawn from a bounded set of non-\nnegative integers, Chapter 20.\nIf the data are b-bit integers, and the computer memory consists of addressable\nb-bit words, Fredman and Willard [115] showed how to implement MINIMUM in\nO.1/ time and INSERT and EXTRACT-MIN in O.\np\nlg n/ time. Thorup [337] has\nimproved the O.\np\nlg n/ bound to O.lg lg n/ time. This bound uses an amount of\nspace unbounded in n, but it can be implemented in linear space by using random-\nized hashing.\nAn important special case of priority queues occurs when the sequence of\nEXTRACT-MIN operations is monotone, that is, the values returned by succes-\nsive EXTRACT-MIN operations are monotonically increasing over time. This case\narises in several important applications, such as Dijkstra’s single-source shortest-\npaths algorithm, which we discuss in Chapter 24, and in discrete-event simula-\ntion. For Dijkstra’s algorithm it is particularly important that the DECREASE-KEY\noperation be implemented efﬁciently. For the monotone case, if the data are in-\ntegers in the range 1; 2; : : : ; C, Ahuja, Mehlhorn, Orlin, and Tarjan [8] describe\nNotes for Chapter 6\n169\nhow to implement EXTRACT-MIN and INSERT in O.lg C/ amortized time (see\nChapter 17 for more on amortized analysis) and DECREASE-KEY in O.1/ time,\nusing a data structure called a radix heap. The O.lg C/ bound can be improved\nto O.\np\nlg C/ using Fibonacci heaps (see Chapter 19) in conjunction with radix\nheaps. Cherkassky, Goldberg, and Silverstein [65] further improved the bound to\nO.lg1=3C\u0002 C/ expected time by combining the multilevel bucketing structure of",
    "parent_ad20439c-febb-41ed-bbb9-27a1aee5fa12": "to O.\np\nlg C/ using Fibonacci heaps (see Chapter 19) in conjunction with radix\nheaps. Cherkassky, Goldberg, and Silverstein [65] further improved the bound to\nO.lg1=3C\u0002 C/ expected time by combining the multilevel bucketing structure of\nDenardo and Fox [85] with the heap of Thorup mentioned earlier. Raman [291]\nfurther improved these results to obtain a bound of O.min.lg1=4C\u0002 C; lg1=3C\u0002 n//,\nfor any ﬁxed \b > 0.\n7\nQuicksort\nThe quicksort algorithm has a worst-case running time of ‚.n2/ on an input array\nof n numbers. Despite this slow worst-case running time, quicksort is often the best\npractical choice for sorting because it is remarkably efﬁcient on the average: its\nexpected running time is ‚.n lg n/, and the constant factors hidden in the ‚.n lg n/\nnotation are quite small. It also has the advantage of sorting in place (see page 17),\nand it works well even in virtual-memory environments.\nSection 7.1 describes the algorithm and an important subroutine used by quick-\nsort for partitioning. Because the behavior of quicksort is complex, we start with\nan intuitive discussion of its performance in Section 7.2 and postpone its precise\nanalysis to the end of the chapter. Section 7.3 presents a version of quicksort that\nuses random sampling. This algorithm has a good expected running time, and no\nparticular input elicits its worst-case behavior. Section 7.4 analyzes the random-\nized algorithm, showing that it runs in ‚.n2/ time in the worst case and, assuming\ndistinct elements, in expected O.n lg n/ time.\n7.1\nDescription of quicksort\nQuicksort, like merge sort, applies the divide-and-conquer paradigm introduced\nin Section 2.3.1. Here is the three-step divide-and-conquer process for sorting a\ntypical subarray AŒp : : r\u0002:\nDivide: Partition (rearrange) the array AŒp : : r\u0002 into two (possibly empty) subar-\nrays AŒp : : q \u0005 1\u0002 and AŒq C 1 : : r\u0002 such that each element of AŒp : : q \u0005 1\u0002 is\nless than or equal to AŒq\u0002, which is, in turn, less than or equal to each element",
    "parent_3d9b7d01-cb71-4cd3-8826-6a03004eacdc": "typical subarray AŒp : : r\u0002:\nDivide: Partition (rearrange) the array AŒp : : r\u0002 into two (possibly empty) subar-\nrays AŒp : : q \u0005 1\u0002 and AŒq C 1 : : r\u0002 such that each element of AŒp : : q \u0005 1\u0002 is\nless than or equal to AŒq\u0002, which is, in turn, less than or equal to each element\nof AŒq C 1 : : r\u0002. Compute the index q as part of this partitioning procedure.\nConquer: Sort the two subarrays AŒp : : q \u00051\u0002 and AŒq C1 : : r\u0002 by recursive calls\nto quicksort.\n7.1\nDescription of quicksort\n171\nCombine: Because the subarrays are already sorted, no work is needed to combine\nthem: the entire array AŒp : : r\u0002 is now sorted.\nThe following procedure implements quicksort:\nQUICKSORT.A; p; r/\n1\nif p < r\n2\nq D PARTITION.A; p; r/\n3\nQUICKSORT.A; p; q \u0005 1/\n4\nQUICKSORT.A; q C 1; r/\nTo sort an entire array A, the initial call is QUICKSORT.A; 1; A:length/.\nPartitioning the array\nThe key to the algorithm is the PARTITION procedure, which rearranges the subar-\nray AŒp : : r\u0002 in place.\nPARTITION.A; p; r/\n1\nx D AŒr\u0002\n2\ni D p \u0005 1\n3\nfor j D p to r \u0005 1\n4\nif AŒj \u0002 \u0002 x\n5\ni D i C 1\n6\nexchange AŒi\u0002 with AŒj \u0002\n7\nexchange AŒi C 1\u0002 with AŒr\u0002\n8\nreturn i C 1\nFigure 7.1 shows how PARTITION works on an 8-element array. PARTITION\nalways selects an element x D AŒr\u0002 as a pivot element around which to partition the\nsubarray AŒp : : r\u0002. As the procedure runs, it partitions the array into four (possibly\nempty) regions. At the start of each iteration of the for loop in lines 3–6, the regions\nsatisfy certain properties, shown in Figure 7.2. We state these properties as a loop\ninvariant:\nAt the beginning of each iteration of the loop of lines 3–6, for any array\nindex k,\n1. If p \u0002 k \u0002 i, then AŒk\u0002 \u0002 x.\n2. If i C 1 \u0002 k \u0002 j \u0005 1, then AŒk\u0002 > x.\n3. If k D r, then AŒk\u0002 D x.\n172\nChapter 7\nQuicksort\n2\n8\n7\n1\n3\n5\n6\n4\np,j\nr\ni\n(a)\n2\n8\n7\n1\n3\n5\n6\n4\np,i\nr\nj\n(b)\n2\n8\n7\n1\n3\n5\n6\n4\np,i\nr\nj\n(c)\n2\n8\n7\n1\n3\n5\n6\n4\np,i\nr\nj\n(d)\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\nj\n(e)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\nj\n(f)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\nj\n(g)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\n(h)\ni\n2\n8\n7\n1\n3",
    "parent_6298078f-9c00-4eda-a51a-3f33f6df347c": "3. If k D r, then AŒk\u0002 D x.\n172\nChapter 7\nQuicksort\n2\n8\n7\n1\n3\n5\n6\n4\np,j\nr\ni\n(a)\n2\n8\n7\n1\n3\n5\n6\n4\np,i\nr\nj\n(b)\n2\n8\n7\n1\n3\n5\n6\n4\np,i\nr\nj\n(c)\n2\n8\n7\n1\n3\n5\n6\n4\np,i\nr\nj\n(d)\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\nj\n(e)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\nj\n(f)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\nj\n(g)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\n(h)\ni\n2\n8\n7\n1\n3\n5\n6\n4\np\nr\n(i)\ni\nFigure 7.1\nThe operation of PARTITION on a sample array. Array entry AŒr\u0002 becomes the pivot\nelement x. Lightly shaded array elements are all in the ﬁrst partition with values no greater than x.\nHeavily shaded elements are in the second partition with values greater than x. The unshaded el-\nements have not yet been put in one of the ﬁrst two partitions, and the ﬁnal white element is the\npivot x. (a) The initial array and variable settings. None of the elements have been placed in either\nof the ﬁrst two partitions. (b) The value 2 is “swapped with itself” and put in the partition of smaller\nvalues. (c)–(d) The values 8 and 7 are added to the partition of larger values. (e) The values 1 and 8\nare swapped, and the smaller partition grows. (f) The values 3 and 7 are swapped, and the smaller\npartition grows. (g)–(h) The larger partition grows to include 5 and 6, and the loop terminates. (i) In\nlines 7–8, the pivot element is swapped so that it lies between the two partitions.\nThe indices between j and r \u0005 1 are not covered by any of the three cases, and the\nvalues in these entries have no particular relationship to the pivot x.\nWe need to show that this loop invariant is true prior to the ﬁrst iteration, that\neach iteration of the loop maintains the invariant, and that the invariant provides a\nuseful property to show correctness when the loop terminates.\n7.1\nDescription of quicksort\n173\n≤x\n> x\nunrestricted\nx\np\ni\nj\nr\nFigure 7.2\nThe four regions maintained by the procedure PARTITION on a subarray AŒp : : r\u0002. The\nvalues in AŒp : : i\u0002 are all less than or equal to x, the values in AŒi C 1 : : j \u0005 1\u0002 are all greater than x,",
    "parent_ac04f820-ed52-4172-a44b-860b56067750": "7.1\nDescription of quicksort\n173\n≤x\n> x\nunrestricted\nx\np\ni\nj\nr\nFigure 7.2\nThe four regions maintained by the procedure PARTITION on a subarray AŒp : : r\u0002. The\nvalues in AŒp : : i\u0002 are all less than or equal to x, the values in AŒi C 1 : : j \u0005 1\u0002 are all greater than x,\nand AŒr\u0002 D x. The subarray AŒj : : r \u0005 1\u0002 can take on any values.\nInitialization: Prior to the ﬁrst iteration of the loop, i D p \u0005 1 and j D p. Be-\ncause no values lie between p and i and no values lie between i C 1 and j \u0005 1,\nthe ﬁrst two conditions of the loop invariant are trivially satisﬁed. The assign-\nment in line 1 satisﬁes the third condition.\nMaintenance: As Figure 7.3 shows, we consider two cases, depending on the\noutcome of the test in line 4. Figure 7.3(a) shows what happens when AŒj \u0002 > x;\nthe only action in the loop is to increment j . After j is incremented, condition 2\nholds for AŒj \u0005 1\u0002 and all other entries remain unchanged. Figure 7.3(b) shows\nwhat happens when AŒj \u0002 \u0002 x; the loop increments i, swaps AŒi\u0002 and AŒj \u0002,\nand then increments j . Because of the swap, we now have that AŒi\u0002 \u0002 x, and\ncondition 1 is satisﬁed. Similarly, we also have that AŒj \u0005 1\u0002 > x, since the\nitem that was swapped into AŒj \u0005 1\u0002 is, by the loop invariant, greater than x.\nTermination: At termination, j D r. Therefore, every entry in the array is in one\nof the three sets described by the invariant, and we have partitioned the values\nin the array into three sets: those less than or equal to x, those greater than x,\nand a singleton set containing x.\nThe ﬁnal two lines of PARTITION ﬁnish up by swapping the pivot element with\nthe leftmost element greater than x, thereby moving the pivot into its correct place\nin the partitioned array, and then returning the pivot’s new index. The output of\nPARTITION now satisﬁes the speciﬁcations given for the divide step. In fact, it\nsatisﬁes a slightly stronger condition: after line 2 of QUICKSORT, AŒq\u0002 is strictly\nless than every element of AŒq C 1 : : r\u0002.",
    "parent_e6c44c8e-3286-4723-b481-a12592e1220b": "in the partitioned array, and then returning the pivot’s new index. The output of\nPARTITION now satisﬁes the speciﬁcations given for the divide step. In fact, it\nsatisﬁes a slightly stronger condition: after line 2 of QUICKSORT, AŒq\u0002 is strictly\nless than every element of AŒq C 1 : : r\u0002.\nThe running time of PARTITION on the subarray AŒp : : r\u0002 is ‚.n/, where\nn D r \u0005 p C 1 (see Exercise 7.1-3).\nExercises\n7.1-1\nUsing Figure 7.1 as a model, illustrate the operation of PARTITION on the array\nA D h13; 19; 9; 5; 12; 8; 7; 4; 21; 2; 6; 11i.\n174\nChapter 7\nQuicksort\n≤x\n> x\nx\np\ni\nj\nr\n>x\n(a)\n≤x\n> x\nx\np\ni\nj\nr\n≤x\n> x\nx\np\ni\nj\nr\n≤x\n(b)\n≤x\n> x\nx\np\ni\nj\nr\nFigure 7.3\nThe two cases for one iteration of procedure PARTITION. (a) If AŒj\u0002 > x, the only\naction is to increment j, which maintains the loop invariant. (b) If AŒj\u0002 \u0002 x, index i is incremented,\nAŒi\u0002 and AŒj\u0002 are swapped, and then j is incremented. Again, the loop invariant is maintained.\n7.1-2\nWhat value of q does PARTITION return when all elements in the array AŒp : : r\u0002\nhave the same value? Modify PARTITION so that q D b.p C r/=2c when all\nelements in the array AŒp : : r\u0002 have the same value.\n7.1-3\nGive a brief argument that the running time of PARTITION on a subarray of size n\nis ‚.n/.\n7.1-4\nHow would you modify QUICKSORT to sort into nonincreasing order?\n7.2\nPerformance of quicksort\nThe running time of quicksort depends on whether the partitioning is balanced or\nunbalanced, which in turn depends on which elements are used for partitioning.\nIf the partitioning is balanced, the algorithm runs asymptotically as fast as merge\n7.2\nPerformance of quicksort\n175\nsort. If the partitioning is unbalanced, however, it can run asymptotically as slowly\nas insertion sort. In this section, we shall informally investigate how quicksort\nperforms under the assumptions of balanced versus unbalanced partitioning.\nWorst-case partitioning\nThe worst-case behavior for quicksort occurs when the partitioning routine pro-",
    "parent_eb020da6-55c5-4677-a8ba-c860fea36865": "as insertion sort. In this section, we shall informally investigate how quicksort\nperforms under the assumptions of balanced versus unbalanced partitioning.\nWorst-case partitioning\nThe worst-case behavior for quicksort occurs when the partitioning routine pro-\nduces one subproblem with n \u0005 1 elements and one with 0 elements. (We prove\nthis claim in Section 7.4.1.) Let us assume that this unbalanced partitioning arises\nin each recursive call. The partitioning costs ‚.n/ time. Since the recursive call\non an array of size 0 just returns, T .0/ D ‚.1/, and the recurrence for the running\ntime is\nT .n/\nD\nT .n \u0005 1/ C T .0/ C ‚.n/\nD\nT .n \u0005 1/ C ‚.n/ :\nIntuitively, if we sum the costs incurred at each level of the recursion, we get\nan arithmetic series (equation (A.2)), which evaluates to ‚.n2/.\nIndeed, it is\nstraightforward to use the substitution method to prove that the recurrence T .n/ D\nT .n \u0005 1/ C ‚.n/ has the solution T .n/ D ‚.n2/. (See Exercise 7.2-1.)\nThus, if the partitioning is maximally unbalanced at every recursive level of the\nalgorithm, the running time is ‚.n2/. Therefore the worst-case running time of\nquicksort is no better than that of insertion sort. Moreover, the ‚.n2/ running time\noccurs when the input array is already completely sorted—a common situation in\nwhich insertion sort runs in O.n/ time.\nBest-case partitioning\nIn the most even possible split, PARTITION produces two subproblems, each of\nsize no more than n=2, since one is of size bn=2c and one of size dn=2e\u00051. In this\ncase, quicksort runs much faster. The recurrence for the running time is then\nT .n/ D 2T .n=2/ C ‚.n/ ;\nwhere we tolerate the sloppiness from ignoring the ﬂoor and ceiling and from sub-\ntracting 1. By case 2 of the master theorem (Theorem 4.1), this recurrence has the\nsolution T .n/ D ‚.n lg n/. By equally balancing the two sides of the partition at\nevery level of the recursion, we get an asymptotically faster algorithm.\nBalanced partitioning",
    "parent_951a0a76-5142-47c5-9318-a0b640df7bed": "tracting 1. By case 2 of the master theorem (Theorem 4.1), this recurrence has the\nsolution T .n/ D ‚.n lg n/. By equally balancing the two sides of the partition at\nevery level of the recursion, we get an asymptotically faster algorithm.\nBalanced partitioning\nThe average-case running time of quicksort is much closer to the best case than to\nthe worst case, as the analyses in Section 7.4 will show. The key to understand-\n176\nChapter 7\nQuicksort\nn\ncn\ncn\ncn\ncn\n\u0002 cn\n\u0002 cn\n1\n1\nO.n lg n/\nlog10 n\nlog10=9 n\n1\n10 n\n9\n10 n\n1\n100 n\n9\n100 n\n9\n100 n\n81\n100 n\n81\n1000 n\n729\n1000 n\nFigure 7.4\nA recursion tree for QUICKSORT in which PARTITION always produces a 9-to-1 split,\nyielding a running time of O.n lg n/. Nodes show subproblem sizes, with per-level costs on the right.\nThe per-level costs include the constant c implicit in the ‚.n/ term.\ning why is to understand how the balance of the partitioning is reﬂected in the\nrecurrence that describes the running time.\nSuppose, for example, that the partitioning algorithm always produces a 9-to-1\nproportional split, which at ﬁrst blush seems quite unbalanced. We then obtain the\nrecurrence\nT .n/ D T .9n=10/ C T .n=10/ C cn ;\non the running time of quicksort, where we have explicitly included the constant c\nhidden in the ‚.n/ term. Figure 7.4 shows the recursion tree for this recurrence.\nNotice that every level of the tree has cost cn, until the recursion reaches a bound-\nary condition at depth log10 n D ‚.lg n/, and then the levels have cost at most cn.\nThe recursion terminates at depth log10=9 n D ‚.lg n/. The total cost of quick-\nsort is therefore O.n lg n/. Thus, with a 9-to-1 proportional split at every level of\nrecursion, which intuitively seems quite unbalanced, quicksort runs in O.n lg n/\ntime—asymptotically the same as if the split were right down the middle. Indeed,\neven a 99-to-1 split yields an O.n lg n/ running time. In fact, any split of constant",
    "parent_74005218-f658-4cc6-856a-ff60a65fcf2d": "recursion, which intuitively seems quite unbalanced, quicksort runs in O.n lg n/\ntime—asymptotically the same as if the split were right down the middle. Indeed,\neven a 99-to-1 split yields an O.n lg n/ running time. In fact, any split of constant\nproportionality yields a recursion tree of depth ‚.lg n/, where the cost at each level\nis O.n/. The running time is therefore O.n lg n/ whenever the split has constant\nproportionality.\n7.2\nPerformance of quicksort\n177\nn\n0\nn–1\n(n–1)/2 – 1\n(n–1)/2\nn\n(n–1)/2\n(a)\n(b)\n(n–1)/2\nΘ(n)\nΘ(n)\nFigure 7.5\n(a) Two levels of a recursion tree for quicksort. The partitioning at the root costs n\nand produces a “bad” split: two subarrays of sizes 0 and n \u0005 1. The partitioning of the subarray of\nsize n \u0005 1 costs n \u0005 1 and produces a “good” split: subarrays of size .n \u0005 1/=2 \u0005 1 and .n \u0005 1/=2.\n(b) A single level of a recursion tree that is very well balanced. In both parts, the partitioning cost for\nthe subproblems shown with elliptical shading is ‚.n/. Yet the subproblems remaining to be solved\nin (a), shown with square shading, are no larger than the corresponding subproblems remaining to be\nsolved in (b).\nIntuition for the average case\nTo develop a clear notion of the randomized behavior of quicksort, we must make\nan assumption about how frequently we expect to encounter the various inputs.\nThe behavior of quicksort depends on the relative ordering of the values in the\narray elements given as the input, and not by the particular values in the array. As\nin our probabilistic analysis of the hiring problem in Section 5.2, we will assume\nfor now that all permutations of the input numbers are equally likely.\nWhen we run quicksort on a random input array, the partitioning is highly un-\nlikely to happen in the same way at every level, as our informal analysis has as-\nsumed. We expect that some of the splits will be reasonably well balanced and\nthat some will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show",
    "parent_51dbb87e-be2d-4243-905a-31ae78b12637": "likely to happen in the same way at every level, as our informal analysis has as-\nsumed. We expect that some of the splits will be reasonably well balanced and\nthat some will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show\nthat about 80 percent of the time PARTITION produces a split that is more balanced\nthan 9 to 1, and about 20 percent of the time it produces a split that is less balanced\nthan 9 to 1.\nIn the average case, PARTITION produces a mix of “good” and “bad” splits. In a\nrecursion tree for an average-case execution of PARTITION, the good and bad splits\nare distributed randomly throughout the tree. Suppose, for the sake of intuition,\nthat the good and bad splits alternate levels in the tree, and that the good splits\nare best-case splits and the bad splits are worst-case splits. Figure 7.5(a) shows\nthe splits at two consecutive levels in the recursion tree. At the root of the tree,\nthe cost is n for partitioning, and the subarrays produced have sizes n \u0005 1 and 0:\nthe worst case. At the next level, the subarray of size n \u0005 1 undergoes best-case\npartitioning into subarrays of size .n \u0005 1/=2 \u0005 1 and .n \u0005 1/=2. Let’s assume that\nthe boundary-condition cost is 1 for the subarray of size 0.\n178\nChapter 7\nQuicksort\nThe combination of the bad split followed by the good split produces three sub-\narrays of sizes 0, .n \u0005 1/=2 \u0005 1, and .n \u0005 1/=2 at a combined partitioning cost\nof ‚.n/ C ‚.n \u0005 1/ D ‚.n/. Certainly, this situation is no worse than that in\nFigure 7.5(b), namely a single level of partitioning that produces two subarrays of\nsize .n \u0005 1/=2, at a cost of ‚.n/. Yet this latter situation is balanced! Intuitively,\nthe ‚.n \u0005 1/ cost of the bad split can be absorbed into the ‚.n/ cost of the good\nsplit, and the resulting split is good. Thus, the running time of quicksort, when lev-\nels alternate between good and bad splits, is like the running time for good splits",
    "parent_dc32b6e3-ad46-4109-b43e-cb09cc576665": "the ‚.n \u0005 1/ cost of the bad split can be absorbed into the ‚.n/ cost of the good\nsplit, and the resulting split is good. Thus, the running time of quicksort, when lev-\nels alternate between good and bad splits, is like the running time for good splits\nalone: still O.n lg n/, but with a slightly larger constant hidden by the O-notation.\nWe shall give a rigorous analysis of the expected running time of a randomized\nversion of quicksort in Section 7.4.2.\nExercises\n7.2-1\nUse the substitution method to prove that the recurrence T .n/ D T .n \u0005 1/ C ‚.n/\nhas the solution T .n/ D ‚.n2/, as claimed at the beginning of Section 7.2.\n7.2-2\nWhat is the running time of QUICKSORT when all elements of array A have the\nsame value?\n7.2-3\nShow that the running time of QUICKSORT is ‚.n2/ when the array A contains\ndistinct elements and is sorted in decreasing order.\n7.2-4\nBanks often record transactions on an account in order of the times of the transac-\ntions, but many people like to receive their bank statements with checks listed in\norder by check number. People usually write checks in order by check number, and\nmerchants usually cash them with reasonable dispatch. The problem of converting\ntime-of-transaction ordering to check-number ordering is therefore the problem of\nsorting almost-sorted input. Argue that the procedure INSERTION-SORT would\ntend to beat the procedure QUICKSORT on this problem.\n7.2-5\nSuppose that the splits at every level of quicksort are in the proportion 1 \u0005 ˛ to ˛,\nwhere 0 < ˛ \u0002 1=2 is a constant. Show that the minimum depth of a leaf in the re-\ncursion tree is approximately \u0005 lg n= lg ˛ and the maximum depth is approximately\n\u0005 lg n= lg.1 \u0005 ˛/. (Don’t worry about integer round-off.)\n7.3\nA randomized version of quicksort\n179\n7.2-6\n?\nArgue that for any constant 0 < ˛ \u0002 1=2, the probability is approximately 1 \u0005 2˛\nthat on a random input array, PARTITION produces a split more balanced than 1\u0005˛\nto ˛.\n7.3\nA randomized version of quicksort",
    "parent_855efa1e-935c-4df2-b620-108f3a71c1fc": "7.3\nA randomized version of quicksort\n179\n7.2-6\n?\nArgue that for any constant 0 < ˛ \u0002 1=2, the probability is approximately 1 \u0005 2˛\nthat on a random input array, PARTITION produces a split more balanced than 1\u0005˛\nto ˛.\n7.3\nA randomized version of quicksort\nIn exploring the average-case behavior of quicksort, we have made an assumption\nthat all permutations of the input numbers are equally likely. In an engineering\nsituation, however, we cannot always expect this assumption to hold. (See Exer-\ncise 7.2-4.) As we saw in Section 5.3, we can sometimes add randomization to an\nalgorithm in order to obtain good expected performance over all inputs. Many peo-\nple regard the resulting randomized version of quicksort as the sorting algorithm\nof choice for large enough inputs.\nIn Section 5.3, we randomized our algorithm by explicitly permuting the in-\nput. We could do so for quicksort also, but a different randomization technique,\ncalled random sampling, yields a simpler analysis. Instead of always using AŒr\u0002\nas the pivot, we will select a randomly chosen element from the subarray AŒp : : r\u0002.\nWe do so by ﬁrst exchanging element AŒr\u0002 with an element chosen at random\nfrom AŒp : : r\u0002. By randomly sampling the range p; : : : ; r, we ensure that the pivot\nelement x D AŒr\u0002 is equally likely to be any of the r \u0005 p C 1 elements in the\nsubarray. Because we randomly choose the pivot element, we expect the split of\nthe input array to be reasonably well balanced on average.\nThe changes to PARTITION and QUICKSORT are small. In the new partition\nprocedure, we simply implement the swap before actually partitioning:\nRANDOMIZED-PARTITION.A; p; r/\n1\ni D RANDOM.p; r/\n2\nexchange AŒr\u0002 with AŒi\u0002\n3\nreturn PARTITION.A; p; r/\nThe new quicksort calls RANDOMIZED-PARTITION in place of PARTITION:\nRANDOMIZED-QUICKSORT.A; p; r/\n1\nif p < r\n2\nq D RANDOMIZED-PARTITION.A; p; r/\n3\nRANDOMIZED-QUICKSORT.A; p; q \u0005 1/\n4\nRANDOMIZED-QUICKSORT.A; q C 1; r/\nWe analyze this algorithm in the next section.\n180\nChapter 7",
    "parent_96ec93cf-331e-4305-acad-97a8278fcd59": "The new quicksort calls RANDOMIZED-PARTITION in place of PARTITION:\nRANDOMIZED-QUICKSORT.A; p; r/\n1\nif p < r\n2\nq D RANDOMIZED-PARTITION.A; p; r/\n3\nRANDOMIZED-QUICKSORT.A; p; q \u0005 1/\n4\nRANDOMIZED-QUICKSORT.A; q C 1; r/\nWe analyze this algorithm in the next section.\n180\nChapter 7\nQuicksort\nExercises\n7.3-1\nWhy do we analyze the expected running time of a randomized algorithm and not\nits worst-case running time?\n7.3-2\nWhen RANDOMIZED-QUICKSORT runs, how many calls are made to the random-\nnumber generator RANDOM in the worst case? How about in the best case? Give\nyour answer in terms of ‚-notation.\n7.4\nAnalysis of quicksort\nSection 7.2 gave some intuition for the worst-case behavior of quicksort and for\nwhy we expect it to run quickly. In this section, we analyze the behavior of quick-\nsort more rigorously. We begin with a worst-case analysis, which applies to either\nQUICKSORT or RANDOMIZED-QUICKSORT, and conclude with an analysis of the\nexpected running time of RANDOMIZED-QUICKSORT.\n7.4.1\nWorst-case analysis\nWe saw in Section 7.2 that a worst-case split at every level of recursion in quicksort\nproduces a ‚.n2/ running time, which, intuitively, is the worst-case running time\nof the algorithm. We now prove this assertion.\nUsing the substitution method (see Section 4.3), we can show that the running\ntime of quicksort is O.n2/. Let T .n/ be the worst-case time for the procedure\nQUICKSORT on an input of size n. We have the recurrence\nT .n/ D\nmax\n0\u0005q\u0005n\u00031.T .q/ C T .n \u0005 q \u0005 1// C ‚.n/ ;\n(7.1)\nwhere the parameter q ranges from 0 to n \u0005 1 because the procedure PARTITION\nproduces two subproblems with total size n \u0005 1. We guess that T .n/ \u0002 cn2 for\nsome constant c. Substituting this guess into recurrence (7.1), we obtain\nT .n/\n\u0002\nmax\n0\u0005q\u0005n\u00031.cq2 C c.n \u0005 q \u0005 1/2/ C ‚.n/\nD\nc \u0003 max\n0\u0005q\u0005n\u00031.q2 C .n \u0005 q \u0005 1/2/ C ‚.n/ :\nThe expression q2 C .n \u0005 q \u0005 1/2 achieves a maximum over the parameter’s\nrange 0 \u0002 q \u0002 n \u0005 1 at either endpoint. To verify this claim, note that the second",
    "parent_1dfd270c-5066-4e7b-bd8a-099cfad63de7": "T .n/\n\u0002\nmax\n0\u0005q\u0005n\u00031.cq2 C c.n \u0005 q \u0005 1/2/ C ‚.n/\nD\nc \u0003 max\n0\u0005q\u0005n\u00031.q2 C .n \u0005 q \u0005 1/2/ C ‚.n/ :\nThe expression q2 C .n \u0005 q \u0005 1/2 achieves a maximum over the parameter’s\nrange 0 \u0002 q \u0002 n \u0005 1 at either endpoint. To verify this claim, note that the second\nderivative of the expression with respect to q is positive (see Exercise 7.4-3). This\n7.4\nAnalysis of quicksort\n181\nobservation gives us the bound max0\u0005q\u0005n\u00031.q2 C .n \u0005 q \u0005 1/2/ \u0002 .n \u0005 1/2 D\nn2 \u0005 2n C 1. Continuing with our bounding of T .n/, we obtain\nT .n/\n\u0002\ncn2 \u0005 c.2n \u0005 1/ C ‚.n/\n\u0002\ncn2 ;\nsince we can pick the constant c large enough so that the c.2n \u0005 1/ term dom-\ninates the ‚.n/ term. Thus, T .n/ D O.n2/. We saw in Section 7.2 a speciﬁc\ncase in which quicksort takes \u0004.n2/ time: when partitioning is unbalanced. Al-\nternatively, Exercise 7.4-1 asks you to show that recurrence (7.1) has a solution of\nT .n/ D \u0004.n2/. Thus, the (worst-case) running time of quicksort is ‚.n2/.\n7.4.2\nExpected running time\nWe have already seen the intuition behind why the expected running time of\nRANDOMIZED-QUICKSORT is O.n lg n/: if, in each level of recursion, the split\ninduced by RANDOMIZED-PARTITION puts any constant fraction of the elements\non one side of the partition, then the recursion tree has depth ‚.lg n/, and O.n/\nwork is performed at each level. Even if we add a few new levels with the most un-\nbalanced split possible between these levels, the total time remains O.n lg n/. We\ncan analyze the expected running time of RANDOMIZED-QUICKSORT precisely\nby ﬁrst understanding how the partitioning procedure operates and then using this\nunderstanding to derive an O.n lg n/ bound on the expected running time. This\nupper bound on the expected running time, combined with the ‚.n lg n/ best-case\nbound we saw in Section 7.2, yields a ‚.n lg n/ expected running time. We assume\nthroughout that the values of the elements being sorted are distinct.\nRunning time and comparisons\nThe QUICKSORT and RANDOMIZED-QUICKSORT procedures differ only in how",
    "parent_d6257791-57c5-4c8d-8877-b57e86f90707": "bound we saw in Section 7.2, yields a ‚.n lg n/ expected running time. We assume\nthroughout that the values of the elements being sorted are distinct.\nRunning time and comparisons\nThe QUICKSORT and RANDOMIZED-QUICKSORT procedures differ only in how\nthey select pivot elements; they are the same in all other respects. We can therefore\ncouch our analysis of RANDOMIZED-QUICKSORT by discussing the QUICKSORT\nand PARTITION procedures, but with the assumption that pivot elements are se-\nlected randomly from the subarray passed to RANDOMIZED-PARTITION.\nThe running time of QUICKSORT is dominated by the time spent in the PARTI-\nTION procedure. Each time the PARTITION procedure is called, it selects a pivot\nelement, and this element is never included in any future recursive calls to QUICK-\nSORT and PARTITION. Thus, there can be at most n calls to PARTITION over the\nentire execution of the quicksort algorithm. One call to PARTITION takes O.1/\ntime plus an amount of time that is proportional to the number of iterations of the\nfor loop in lines 3–6. Each iteration of this for loop performs a comparison in\nline 4, comparing the pivot element to another element of the array A. Therefore,\n182\nChapter 7\nQuicksort\nif we can count the total number of times that line 4 is executed, we can bound the\ntotal time spent in the for loop during the entire execution of QUICKSORT.\nLemma 7.1\nLet X be the number of comparisons performed in line 4 of PARTITION over the\nentire execution of QUICKSORT on an n-element array. Then the running time of\nQUICKSORT is O.n C X/.\nProof\nBy the discussion above, the algorithm makes at most n calls to PARTI-\nTION, each of which does a constant amount of work and then executes the for\nloop some number of times. Each iteration of the for loop executes line 4.\nOur goal, therefore, is to compute X, the total number of comparisons performed\nin all calls to PARTITION. We will not attempt to analyze how many comparisons",
    "parent_8076dc64-e7f7-4a0e-ae8d-f2b20f5739e7": "loop some number of times. Each iteration of the for loop executes line 4.\nOur goal, therefore, is to compute X, the total number of comparisons performed\nin all calls to PARTITION. We will not attempt to analyze how many comparisons\nare made in each call to PARTITION. Rather, we will derive an overall bound on the\ntotal number of comparisons. To do so, we must understand when the algorithm\ncompares two elements of the array and when it does not. For ease of analysis, we\nrename the elements of the array A as ´1; ´2; : : : ; ´n, with ´i being the ith smallest\nelement. We also deﬁne the set Zij D f´i; ´iC1; : : : ; ´jg to be the set of elements\nbetween ´i and ´j, inclusive.\nWhen does the algorithm compare ´i and ´j? To answer this question, we ﬁrst\nobserve that each pair of elements is compared at most once. Why? Elements\nare compared only to the pivot element and, after a particular call of PARTITION\nﬁnishes, the pivot element used in that call is never again compared to any other\nelements.\nOur analysis uses indicator random variables (see Section 5.2). We deﬁne\nXij D I f´i is compared to ´jg ;\nwhere we are considering whether the comparison takes place at any time during\nthe execution of the algorithm, not just during one iteration or one call of PARTI-\nTION. Since each pair is compared at most once, we can easily characterize the\ntotal number of comparisons performed by the algorithm:\nX D\nn\u00031\nX\niD1\nn\nX\njDiC1\nXij :\nTaking expectations of both sides, and then using linearity of expectation and\nLemma 5.1, we obtain\nE ŒX\u0002\nD\nE\n\"n\u00031\nX\niD1\nn\nX\njDiC1\nXij\n#\n7.4\nAnalysis of quicksort\n183\nD\nn\u00031\nX\niD1\nn\nX\njDiC1\nE ŒXij\u0002\nD\nn\u00031\nX\niD1\nn\nX\njDiC1\nPr f´i is compared to ´jg :\n(7.2)\nIt remains to compute Pr f´i is compared to ´jg. Our analysis assumes that the\nRANDOMIZED-PARTITION procedure chooses each pivot randomly and indepen-\ndently.\nLet us think about when two items are not compared. Consider an input to",
    "parent_9c2bed9e-240f-40b7-a747-cbc379ed4c3a": "E ŒXij\u0002\nD\nn\u00031\nX\niD1\nn\nX\njDiC1\nPr f´i is compared to ´jg :\n(7.2)\nIt remains to compute Pr f´i is compared to ´jg. Our analysis assumes that the\nRANDOMIZED-PARTITION procedure chooses each pivot randomly and indepen-\ndently.\nLet us think about when two items are not compared. Consider an input to\nquicksort of the numbers 1 through 10 (in any order), and suppose that the ﬁrst\npivot element is 7. Then the ﬁrst call to PARTITION separates the numbers into two\nsets: f1; 2; 3; 4; 5; 6g and f8; 9; 10g. In doing so, the pivot element 7 is compared\nto all other elements, but no number from the ﬁrst set (e.g., 2) is or ever will be\ncompared to any number from the second set (e.g., 9).\nIn general, because we assume that element values are distinct, once a pivot x\nis chosen with ´i < x < ´j, we know that ´i and ´j cannot be compared at any\nsubsequent time. If, on the other hand, ´i is chosen as a pivot before any other item\nin Zij, then ´i will be compared to each item in Zij , except for itself. Similarly,\nif ´j is chosen as a pivot before any other item in Zij , then ´j will be compared to\neach item in Zij , except for itself. In our example, the values 7 and 9 are compared\nbecause 7 is the ﬁrst item from Z7;9 to be chosen as a pivot. In contrast, 2 and 9 will\nnever be compared because the ﬁrst pivot element chosen from Z2;9 is 7. Thus, ´i\nand ´j are compared if and only if the ﬁrst element to be chosen as a pivot from Zij\nis either ´i or ´j.\nWe now compute the probability that this event occurs. Prior to the point at\nwhich an element from Zij has been chosen as a pivot, the whole set Zij is together\nin the same partition. Therefore, any element of Zij is equally likely to be the ﬁrst\none chosen as a pivot. Because the set Zij has j \u0005iC1 elements, and because pivots\nare chosen randomly and independently, the probability that any given element is\nthe ﬁrst one chosen as a pivot is 1=.j \u0005 i C 1/. Thus, we have\nPr f´i is compared to ´jg\nD",
    "parent_3a5dd813-1d03-42e9-9298-bf51cf4ed2a5": "one chosen as a pivot. Because the set Zij has j \u0005iC1 elements, and because pivots\nare chosen randomly and independently, the probability that any given element is\nthe ﬁrst one chosen as a pivot is 1=.j \u0005 i C 1/. Thus, we have\nPr f´i is compared to ´jg\nD\nPr f´i or ´j is ﬁrst pivot chosen from Zij g\nD\nPr f´i is ﬁrst pivot chosen from Zij g\nC Pr f´j is ﬁrst pivot chosen from Zijg\nD\n1\nj \u0005 i C 1 C\n1\nj \u0005 i C 1\nD\n2\nj \u0005 i C 1 :\n(7.3)\n184\nChapter 7\nQuicksort\nThe second line follows because the two events are mutually exclusive. Combining\nequations (7.2) and (7.3), we get that\nE ŒX\u0002 D\nn\u00031\nX\niD1\nn\nX\njDiC1\n2\nj \u0005 i C 1 :\nWe can evaluate this sum using a change of variables (k D j \u0005 i) and the bound\non the harmonic series in equation (A.7):\nE ŒX\u0002\nD\nn\u00031\nX\niD1\nn\nX\njDiC1\n2\nj \u0005 i C 1\nD\nn\u00031\nX\niD1\nn\u0003i\nX\nkD1\n2\nk C 1\n<\nn\u00031\nX\niD1\nn\nX\nkD1\n2\nk\nD\nn\u00031\nX\niD1\nO.lg n/\nD\nO.n lg n/ :\n(7.4)\nThus we conclude that, using RANDOMIZED-PARTITION, the expected running\ntime of quicksort is O.n lg n/ when element values are distinct.\nExercises\n7.4-1\nShow that in the recurrence\nT .n/ D\nmax\n0\u0005q\u0005n\u00031.T .q/ C T .n \u0005 q \u0005 1// C ‚.n/ ;\nT .n/ D \u0004.n2/.\n7.4-2\nShow that quicksort’s best-case running time is \u0004.n lg n/.\n7.4-3\nShow that the expression q2 C .n \u0005 q \u0005 1/2 achieves a maximum over q D\n0; 1; : : : ; n \u0005 1 when q D 0 or q D n \u0005 1.\n7.4-4\nShow that RANDOMIZED-QUICKSORT’s expected running time is \u0004.n lg n/.\nProblems for Chapter 7\n185\n7.4-5\nWe can improve the running time of quicksort in practice by taking advantage of the\nfast running time of insertion sort when its input is “nearly” sorted. Upon calling\nquicksort on a subarray with fewer than k elements, let it simply return without\nsorting the subarray. After the top-level call to quicksort returns, run insertion sort\non the entire array to ﬁnish the sorting process. Argue that this sorting algorithm\nruns in O.nk C n lg.n=k// expected time. How should we pick k, both in theory\nand in practice?\n7.4-6\n?",
    "parent_c11696c4-12b1-46c0-b72b-b32bc182de14": "sorting the subarray. After the top-level call to quicksort returns, run insertion sort\non the entire array to ﬁnish the sorting process. Argue that this sorting algorithm\nruns in O.nk C n lg.n=k// expected time. How should we pick k, both in theory\nand in practice?\n7.4-6\n?\nConsider modifying the PARTITION procedure by randomly picking three elements\nfrom array A and partitioning about their median (the middle value of the three\nelements). Approximate the probability of getting at worst an ˛-to-.1\u0005 ˛/ split, as\na function of ˛ in the range 0 < ˛ < 1.\nProblems\n7-1\nHoare partition correctness\nThe version of PARTITION given in this chapter is not the original partitioning\nalgorithm. Here is the original partition algorithm, which is due to C. A. R. Hoare:\nHOARE-PARTITION.A; p; r/\n1\nx D AŒp\u0002\n2\ni D p \u0005 1\n3\nj D r C 1\n4\nwhile TRUE\n5\nrepeat\n6\nj D j \u0005 1\n7\nuntil AŒj \u0002 \u0002 x\n8\nrepeat\n9\ni D i C 1\n10\nuntil AŒi\u0002 \u0006 x\n11\nif i < j\n12\nexchange AŒi\u0002 with AŒj \u0002\n13\nelse return j\na. Demonstrate the operation of HOARE-PARTITION on the array A D h13; 19; 9;\n5; 12; 8; 7; 4; 11; 2; 6; 21i, showing the values of the array and auxiliary values\nafter each iteration of the while loop in lines 4–13.\n186\nChapter 7\nQuicksort\nThe next three questions ask you to give a careful argument that the procedure\nHOARE-PARTITION is correct. Assuming that the subarray AŒp : : r\u0002 contains at\nleast two elements, prove the following:\nb. The indices i and j are such that we never access an element of A outside the\nsubarray AŒp : : r\u0002.\nc. When HOARE-PARTITION terminates, it returns a value j such that p \u0002 j < r.\nd. Every element of AŒp : : j \u0002 is less than or equal to every element of AŒj C1 : : r\u0002\nwhen HOARE-PARTITION terminates.\nThe PARTITION procedure in Section 7.1 separates the pivot value (originally\nin AŒr\u0002) from the two partitions it forms. The HOARE-PARTITION procedure, on\nthe other hand, always places the pivot value (originally in AŒp\u0002) into one of the",
    "parent_89dba089-1692-4bcb-8cca-5d0a5c25970a": "when HOARE-PARTITION terminates.\nThe PARTITION procedure in Section 7.1 separates the pivot value (originally\nin AŒr\u0002) from the two partitions it forms. The HOARE-PARTITION procedure, on\nthe other hand, always places the pivot value (originally in AŒp\u0002) into one of the\ntwo partitions AŒp : : j \u0002 and AŒj C 1 : : r\u0002. Since p \u0002 j < r, this split is always\nnontrivial.\ne. Rewrite the QUICKSORT procedure to use HOARE-PARTITION.\n7-2\nQuicksort with equal element values\nThe analysis of the expected running time of randomized quicksort in Section 7.4.2\nassumes that all element values are distinct. In this problem, we examine what\nhappens when they are not.\na. Suppose that all element values are equal. What would be randomized quick-\nsort’s running time in this case?\nb. The PARTITION procedure returns an index q such that each element of\nAŒp : : q \u0005 1\u0002 is less than or equal to AŒq\u0002 and each element of AŒq C 1 : : r\u0002\nis greater than AŒq\u0002. Modify the PARTITION procedure to produce a procedure\nPARTITION0.A; p; r/, which permutes the elements of AŒp : : r\u0002 and returns two\nindices q and t, where p \u0002 q \u0002 t \u0002 r, such that\n\u0002 all elements of AŒq : : t\u0002 are equal,\n\u0002 each element of AŒp : : q \u0005 1\u0002 is less than AŒq\u0002, and\n\u0002 each element of AŒt C 1 : : r\u0002 is greater than AŒq\u0002.\nLike PARTITION, your PARTITION0 procedure should take ‚.r \u0005 p/ time.\nc. Modify the RANDOMIZED-QUICKSORT procedure to call PARTITION0, and\nname the new procedure RANDOMIZED-QUICKSORT0.\nThen modify the\nQUICKSORT procedure to produce a procedure QUICKSORT0.p; r/ that calls\nProblems for Chapter 7\n187\nRANDOMIZED-PARTITION0 and recurses only on partitions of elements not\nknown to be equal to each other.\nd. Using QUICKSORT0, how would you adjust the analysis in Section 7.4.2 to\navoid the assumption that all elements are distinct?\n7-3\nAlternative quicksort analysis\nAn alternative analysis of the running time of randomized quicksort focuses on\nthe expected running time of each individual recursive call to RANDOMIZED-",
    "parent_7a7d9f06-805c-41cc-9f7f-c69027ed2f92": "avoid the assumption that all elements are distinct?\n7-3\nAlternative quicksort analysis\nAn alternative analysis of the running time of randomized quicksort focuses on\nthe expected running time of each individual recursive call to RANDOMIZED-\nQUICKSORT, rather than on the number of comparisons performed.\na. Argue that, given an array of size n, the probability that any particular element\nis chosen as the pivot is 1=n. Use this to deﬁne indicator random variables\nXi D I fith smallest element is chosen as the pivotg. What is E ŒXi\u0002?\nb. Let T .n/ be a random variable denoting the running time of quicksort on an\narray of size n. Argue that\nE ŒT .n/\u0002 D E\n\" n\nX\nqD1\nXq .T .q \u0005 1/ C T .n \u0005 q/ C ‚.n//\n#\n:\n(7.5)\nc. Show that we can rewrite equation (7.5) as\nE ŒT .n/\u0002 D 2\nn\nn\u00031\nX\nqD2\nE ŒT .q/\u0002 C ‚.n/ :\n(7.6)\nd. Show that\nn\u00031\nX\nkD2\nk lg k \u0002 1\n2n2 lg n \u0005 1\n8n2 :\n(7.7)\n(Hint: Split the summation into two parts, one for k D 2; 3; : : : ; dn=2e \u0005 1 and\none for k D dn=2e ; : : : ; n \u0005 1.)\ne. Using the bound from equation (7.7), show that the recurrence in equation (7.6)\nhas the solution E ŒT .n/\u0002 D ‚.n lg n/.\n(Hint: Show, by substitution, that\nE ŒT .n/\u0002 \u0002 an lg n for sufﬁciently large n and for some positive constant a.)\n188\nChapter 7\nQuicksort\n7-4\nStack depth for quicksort\nThe QUICKSORT algorithm of Section 7.1 contains two recursive calls to itself.\nAfter QUICKSORT calls PARTITION, it recursively sorts the left subarray and then\nit recursively sorts the right subarray. The second recursive call in QUICKSORT\nis not really necessary; we can avoid it by using an iterative control structure.\nThis technique, called tail recursion, is provided automatically by good compilers.\nConsider the following version of quicksort, which simulates tail recursion:\nTAIL-RECURSIVE-QUICKSORT.A; p; r/\n1\nwhile p < r\n2\n// Partition and sort left subarray.\n3\nq D PARTITION.A; p; r/\n4\nTAIL-RECURSIVE-QUICKSORT.A; p; q \u0005 1/\n5\np D q C 1\na. Argue that TAIL-RECURSIVE-QUICKSORT.A; 1; A:length/ correctly sorts the",
    "parent_eeaf1ca5-345e-4240-8ed3-bb2b68132224": "TAIL-RECURSIVE-QUICKSORT.A; p; r/\n1\nwhile p < r\n2\n// Partition and sort left subarray.\n3\nq D PARTITION.A; p; r/\n4\nTAIL-RECURSIVE-QUICKSORT.A; p; q \u0005 1/\n5\np D q C 1\na. Argue that TAIL-RECURSIVE-QUICKSORT.A; 1; A:length/ correctly sorts the\narray A.\nCompilers usually execute recursive procedures by using a stack that contains per-\ntinent information, including the parameter values, for each recursive call. The\ninformation for the most recent call is at the top of the stack, and the information\nfor the initial call is at the bottom. Upon calling a procedure, its information is\npushed onto the stack; when it terminates, its information is popped. Since we\nassume that array parameters are represented by pointers, the information for each\nprocedure call on the stack requires O.1/ stack space. The stack depth is the max-\nimum amount of stack space used at any time during a computation.\nb. Describe a scenario in which TAIL-RECURSIVE-QUICKSORT’s stack depth is\n‚.n/ on an n-element input array.\nc. Modify the code for TAIL-RECURSIVE-QUICKSORT so that the worst-case\nstack depth is ‚.lg n/. Maintain the O.n lg n/ expected running time of the\nalgorithm.\n7-5\nMedian-of-3 partition\nOne way to improve the RANDOMIZED-QUICKSORT procedure is to partition\naround a pivot that is chosen more carefully than by picking a random element\nfrom the subarray. One common approach is the median-of-3 method: choose\nthe pivot as the median (middle element) of a set of 3 elements randomly selected\nfrom the subarray. (See Exercise 7.4-6.) For this problem, let us assume that the\nelements in the input array AŒ1 : : n\u0002 are distinct and that n \u0006 3. We denote the\nProblems for Chapter 7\n189\nsorted output array by A0Œ1 : : n\u0002. Using the median-of-3 method to choose the\npivot element x, deﬁne pi D Pr fx D A0Œi\u0002g.\na. Give an exact formula for pi as a function of n and i for i D 2; 3; : : : ; n \u0005 1.\n(Note that p1 D pn D 0.)\nb. By what amount have we increased the likelihood of choosing the pivot as",
    "parent_cca13e9b-775d-4ef5-9138-c8331d3192fb": "pivot element x, deﬁne pi D Pr fx D A0Œi\u0002g.\na. Give an exact formula for pi as a function of n and i for i D 2; 3; : : : ; n \u0005 1.\n(Note that p1 D pn D 0.)\nb. By what amount have we increased the likelihood of choosing the pivot as\nx D A0Œb.n C 1/=2c\u0002, the median of AŒ1 : : n\u0002, compared with the ordinary\nimplementation? Assume that n ! 1, and give the limiting ratio of these\nprobabilities.\nc. If we deﬁne a “good” split to mean choosing the pivot as x D A0Œi\u0002, where\nn=3 \u0002 i \u0002 2n=3, by what amount have we increased the likelihood of getting\na good split compared with the ordinary implementation? (Hint: Approximate\nthe sum by an integral.)\nd. Argue that in the \u0004.n lg n/ running time of quicksort, the median-of-3 method\naffects only the constant factor.\n7-6\nFuzzy sorting of intervals\nConsider a sorting problem in which we do not know the numbers exactly. In-\nstead, for each number, we know an interval on the real line to which it belongs.\nThat is, we are given n closed intervals of the form Œai; bi\u0002, where ai \u0002 bi. We\nwish to fuzzy-sort these intervals, i.e., to produce a permutation hi1; i2; : : : ; ini of\nthe intervals such that for j D 1; 2; : : : ; n, there exist cj 2 Œaij ; bij \u0002 satisfying\nc1 \u0002 c2 \u0002 \u0003 \u0003 \u0003 \u0002 cn.\na. Design a randomized algorithm for fuzzy-sorting n intervals. Your algorithm\nshould have the general structure of an algorithm that quicksorts the left end-\npoints (the ai values), but it should take advantage of overlapping intervals to\nimprove the running time. (As the intervals overlap more and more, the prob-\nlem of fuzzy-sorting the intervals becomes progressively easier. Your algorithm\nshould take advantage of such overlapping, to the extent that it exists.)\nb. Argue that your algorithm runs in expected time ‚.n lg n/ in general, but runs\nin expected time ‚.n/ when all of the intervals overlap (i.e., when there exists a\nvalue x such that x 2 Œai; bi\u0002 for all i). Your algorithm should not be checking",
    "parent_77f237e8-e46d-4709-9e86-5b52c0c67a4d": "b. Argue that your algorithm runs in expected time ‚.n lg n/ in general, but runs\nin expected time ‚.n/ when all of the intervals overlap (i.e., when there exists a\nvalue x such that x 2 Œai; bi\u0002 for all i). Your algorithm should not be checking\nfor this case explicitly; rather, its performance should naturally improve as the\namount of overlap increases.\n190\nChapter 7\nQuicksort\nChapter notes\nThe quicksort procedure was invented by Hoare [170]; Hoare’s version appears in\nProblem 7-1. The PARTITION procedure given in Section 7.1 is due to N. Lomuto.\nThe analysis in Section 7.4 is due to Avrim Blum. Sedgewick [305] and Bent-\nley [43] provide a good reference on the details of implementation and how they\nmatter.\nMcIlroy [248] showed how to engineer a “killer adversary” that produces an\narray on which virtually any implementation of quicksort takes ‚.n2/ time. If the\nimplementation is randomized, the adversary produces the array after seeing the\nrandom choices of the quicksort algorithm.\n8\nSorting in Linear Time\nWe have now introduced several algorithms that can sort n numbers in O.n lg n/\ntime. Merge sort and heapsort achieve this upper bound in the worst case; quicksort\nachieves it on average. Moreover, for each of these algorithms, we can produce a\nsequence of n input numbers that causes the algorithm to run in \u0004.n lg n/ time.\nThese algorithms share an interesting property: the sorted order they determine\nis based only on comparisons between the input elements. We call such sorting\nalgorithms comparison sorts. All the sorting algorithms introduced thus far are\ncomparison sorts.\nIn Section 8.1, we shall prove that any comparison sort must make \u0004.n lg n/\ncomparisons in the worst case to sort n elements. Thus, merge sort and heapsort\nare asymptotically optimal, and no comparison sort exists that is faster by more\nthan a constant factor.\nSections 8.2, 8.3, and 8.4 examine three sorting algorithms—counting sort, radix",
    "parent_4ebb9595-44f0-4930-99e4-05bf68f5e26a": "comparisons in the worst case to sort n elements. Thus, merge sort and heapsort\nare asymptotically optimal, and no comparison sort exists that is faster by more\nthan a constant factor.\nSections 8.2, 8.3, and 8.4 examine three sorting algorithms—counting sort, radix\nsort, and bucket sort—that run in linear time. Of course, these algorithms use\noperations other than comparisons to determine the sorted order. Consequently,\nthe \u0004.n lg n/ lower bound does not apply to them.\n8.1\nLower bounds for sorting\nIn a comparison sort, we use only comparisons between elements to gain order\ninformation about an input sequence ha1; a2; : : : ; ani. That is, given two elements\nai and aj, we perform one of the tests ai < aj, ai \u0002 aj, ai D aj, ai \u0006 aj, or\nai > aj to determine their relative order. We may not inspect the values of the\nelements or gain order information about them in any other way.\nIn this section, we assume without loss of generality that all the input elements\nare distinct. Given this assumption, comparisons of the form ai D aj are useless,\nso we can assume that no comparisons of this form are made. We also note that\nthe comparisons ai \u0002 aj, ai \u0006 aj, ai > aj, and ai < aj are all equivalent in that\n192\nChapter 8\nSorting in Linear Time\n≤\n>\n≤\n>\n1:2\n2:3\n1:3\n〈1,2,3〉\n1:3\n〈2,1,3〉\n2:3\n〈1,3,2〉\n〈3,1,2〉\n〈3,2,1〉\n≤\n>\n≤\n>\n≤\n>\n〈2,3,1〉\nFigure 8.1\nThe decision tree for insertion sort operating on three elements. An internal node an-\nnotated by i:j indicates a comparison between ai and aj . A leaf annotated by the permutation\nh\u0006.1/; \u0006.2/; : : : ; \u0006.n/i indicates the ordering a\u0003.1/ \u0002 a\u0003.2/ \u0002 \u0003 \u0003 \u0003 \u0002 a\u0003.n/. The shaded path\nindicates the decisions made when sorting the input sequence ha1 D 6; a2 D 8; a3 D 5i; the\npermutation h3; 1; 2i at the leaf indicates that the sorted ordering is a3 D 5 \u0002 a1 D 6 \u0002 a2 D 8.\nThere are 3Š D 6 possible permutations of the input elements, and so the decision tree must have at\nleast 6 leaves.",
    "parent_bf3333df-267c-4c6e-ad7e-5c3cf77fadde": "permutation h3; 1; 2i at the leaf indicates that the sorted ordering is a3 D 5 \u0002 a1 D 6 \u0002 a2 D 8.\nThere are 3Š D 6 possible permutations of the input elements, and so the decision tree must have at\nleast 6 leaves.\nthey yield identical information about the relative order of ai and aj. We therefore\nassume that all comparisons have the form ai \u0002 aj.\nThe decision-tree model\nWe can view comparison sorts abstractly in terms of decision trees. A decision\ntree is a full binary tree that represents the comparisons between elements that\nare performed by a particular sorting algorithm operating on an input of a given\nsize. Control, data movement, and all other aspects of the algorithm are ignored.\nFigure 8.1 shows the decision tree corresponding to the insertion sort algorithm\nfrom Section 2.1 operating on an input sequence of three elements.\nIn a decision tree, we annotate each internal node by i:j for some i and j in the\nrange 1 \u0002 i; j \u0002 n, where n is the number of elements in the input sequence. We\nalso annotate each leaf by a permutation h\u0006.1/; \u0006.2/; : : : ; \u0006.n/i. (See Section C.1\nfor background on permutations.) The execution of the sorting algorithm corre-\nsponds to tracing a simple path from the root of the decision tree down to a leaf.\nEach internal node indicates a comparison ai \u0002 aj. The left subtree then dictates\nsubsequent comparisons once we know that ai \u0002 aj, and the right subtree dictates\nsubsequent comparisons knowing that ai > aj. When we come to a leaf, the sort-\ning algorithm has established the ordering a\u0003.1/ \u0002 a\u0003.2/ \u0002 \u0003 \u0003 \u0003 \u0002 a\u0003.n/. Because\nany correct sorting algorithm must be able to produce each permutation of its input,\neach of the nŠ permutations on n elements must appear as one of the leaves of the\ndecision tree for a comparison sort to be correct. Furthermore, each of these leaves\nmust be reachable from the root by a downward path corresponding to an actual\n8.1\nLower bounds for sorting\n193",
    "parent_823045b9-e37c-4e92-ba83-74c634916283": "each of the nŠ permutations on n elements must appear as one of the leaves of the\ndecision tree for a comparison sort to be correct. Furthermore, each of these leaves\nmust be reachable from the root by a downward path corresponding to an actual\n8.1\nLower bounds for sorting\n193\nexecution of the comparison sort. (We shall refer to such leaves as “reachable.”)\nThus, we shall consider only decision trees in which each permutation appears as\na reachable leaf.\nA lower bound for the worst case\nThe length of the longest simple path from the root of a decision tree to any of\nits reachable leaves represents the worst-case number of comparisons that the cor-\nresponding sorting algorithm performs. Consequently, the worst-case number of\ncomparisons for a given comparison sort algorithm equals the height of its decision\ntree. A lower bound on the heights of all decision trees in which each permutation\nappears as a reachable leaf is therefore a lower bound on the running time of any\ncomparison sort algorithm. The following theorem establishes such a lower bound.\nTheorem 8.1\nAny comparison sort algorithm requires \u0004.n lg n/ comparisons in the worst case.\nProof\nFrom the preceding discussion, it sufﬁces to determine the height of a\ndecision tree in which each permutation appears as a reachable leaf. Consider a\ndecision tree of height h with l reachable leaves corresponding to a comparison\nsort on n elements. Because each of the nŠ permutations of the input appears as\nsome leaf, we have nŠ \u0002 l. Since a binary tree of height h has no more than 2h\nleaves, we have\nnŠ \u0002 l \u0002 2h ;\nwhich, by taking logarithms, implies\nh\n\u0006\nlg.nŠ/\n(since the lg function is monotonically increasing)\nD\n\u0004.n lg n/\n(by equation (3.19)) .\nCorollary 8.2\nHeapsort and merge sort are asymptotically optimal comparison sorts.\nProof\nThe O.n lg n/ upper bounds on the running times for heapsort and merge\nsort match the \u0004.n lg n/ worst-case lower bound from Theorem 8.1.\nExercises\n8.1-1",
    "parent_98008b55-9781-4292-ad36-9f44949eb593": "D\n\u0004.n lg n/\n(by equation (3.19)) .\nCorollary 8.2\nHeapsort and merge sort are asymptotically optimal comparison sorts.\nProof\nThe O.n lg n/ upper bounds on the running times for heapsort and merge\nsort match the \u0004.n lg n/ worst-case lower bound from Theorem 8.1.\nExercises\n8.1-1\nWhat is the smallest possible depth of a leaf in a decision tree for a comparison\nsort?\n194\nChapter 8\nSorting in Linear Time\n8.1-2\nObtain asymptotically tight bounds on lg.nŠ/ without using Stirling’s approxi-\nmation. Instead, evaluate the summation Pn\nkD1 lg k using techniques from Sec-\ntion A.2.\n8.1-3\nShow that there is no comparison sort whose running time is linear for at least half\nof the nŠ inputs of length n. What about a fraction of 1=n of the inputs of length n?\nWhat about a fraction 1=2n?\n8.1-4\nSuppose that you are given a sequence of n elements to sort. The input sequence\nconsists of n=k subsequences, each containing k elements. The elements in a given\nsubsequence are all smaller than the elements in the succeeding subsequence and\nlarger than the elements in the preceding subsequence. Thus, all that is needed to\nsort the whole sequence of length n is to sort the k elements in each of the n=k\nsubsequences. Show an \u0004.n lg k/ lower bound on the number of comparisons\nneeded to solve this variant of the sorting problem. (Hint: It is not rigorous to\nsimply combine the lower bounds for the individual subsequences.)\n8.2\nCounting sort\nCounting sort assumes that each of the n input elements is an integer in the range\n0 to k, for some integer k. When k D O.n/, the sort runs in ‚.n/ time.\nCounting sort determines, for each input element x, the number of elements less\nthan x. It uses this information to place element x directly into its position in the\noutput array. For example, if 17 elements are less than x, then x belongs in output\nposition 18. We must modify this scheme slightly to handle the situation in which\nseveral elements have the same value, since we do not want to put them all in the",
    "parent_7fcea93f-120d-4091-9799-a164e5045676": "output array. For example, if 17 elements are less than x, then x belongs in output\nposition 18. We must modify this scheme slightly to handle the situation in which\nseveral elements have the same value, since we do not want to put them all in the\nsame position.\nIn the code for counting sort, we assume that the input is an array AŒ1 : : n\u0002, and\nthus A:length D n. We require two other arrays: the array BŒ1 : : n\u0002 holds the\nsorted output, and the array CŒ0 : : k\u0002 provides temporary working storage.\n8.2\nCounting sort\n195\n2\n5\n3\n0\n2\n3\n0\n3\n1\n2\n3\n4\n5\n6\n7\n8\n2\n0\n2\n3\n0\n1\n1\n2\n3\n4\n5\nA\nC\n(a)\n2\n2\n4\n7\n7\n8\nC\n(b)\n3\n1\n2\n3\n4\n5\n6\n7\n8\n2\n2\n4\n6\n7\n8\nB\nC\n(c)\n3\n1\n2\n3\n4\n5\n6\n7\n8\n1\n2\n4\n6\n7\n8\nB\nC\n(d)\n0\n3\n1\n2\n3\n4\n5\n6\n7\n8\n1\n2\n4\n5\n7\n8\nB\nC\n(e)\n0\n3\n3\n1\n2\n3\n4\n5\n6\n7\n8\nB\n(f)\n0\n3\n0\n2\n2\n3\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\nFigure 8.2\nThe operation of COUNTING-SORT on an input array AŒ1 : : 8\u0002, where each element\nof A is a nonnegative integer no larger than k D 5. (a) The array A and the auxiliary array C after\nline 5. (b) The array C after line 8. (c)–(e) The output array B and the auxiliary array C after one,\ntwo, and three iterations of the loop in lines 10–12, respectively. Only the lightly shaded elements of\narray B have been ﬁlled in. (f) The ﬁnal sorted output array B.\nCOUNTING-SORT.A; B; k/\n1\nlet CŒ0 : : k\u0002 be a new array\n2\nfor i D 0 to k\n3\nCŒi\u0002 D 0\n4\nfor j D 1 to A:length\n5\nCŒAŒj \u0002\u0002 D CŒAŒj \u0002\u0002 C 1\n6\n// CŒi\u0002 now contains the number of elements equal to i.\n7\nfor i D 1 to k\n8\nCŒi\u0002 D CŒi\u0002 C CŒi \u0005 1\u0002\n9\n// CŒi\u0002 now contains the number of elements less than or equal to i.\n10\nfor j D A:length downto 1\n11\nBŒCŒAŒj \u0002\u0002\u0002 D AŒj \u0002\n12\nCŒAŒj \u0002\u0002 D CŒAŒj \u0002\u0002 \u0005 1\nFigure 8.2 illustrates counting sort. After the for loop of lines 2–3 initializes the\narray C to all zeros, the for loop of lines 4–5 inspects each input element. If the\nvalue of an input element is i, we increment CŒi\u0002. Thus, after line 5, CŒi\u0002 holds\nthe number of input elements equal to i for each integer i D 0; 1; : : : ; k. Lines 7–8",
    "parent_72d3e1cd-07be-4a1d-8361-86cc1dbc59e2": "array C to all zeros, the for loop of lines 4–5 inspects each input element. If the\nvalue of an input element is i, we increment CŒi\u0002. Thus, after line 5, CŒi\u0002 holds\nthe number of input elements equal to i for each integer i D 0; 1; : : : ; k. Lines 7–8\ndetermine for each i D 0; 1; : : : ; k how many input elements are less than or equal\nto i by keeping a running sum of the array C.\n196\nChapter 8\nSorting in Linear Time\nFinally, the for loop of lines 10–12 places each element AŒj \u0002 into its correct\nsorted position in the output array B. If all n elements are distinct, then when we\nﬁrst enter line 10, for each AŒj \u0002, the value CŒAŒj \u0002\u0002 is the correct ﬁnal position\nof AŒj \u0002 in the output array, since there are CŒAŒj \u0002\u0002 elements less than or equal\nto AŒj \u0002. Because the elements might not be distinct, we decrement CŒAŒj \u0002\u0002 each\ntime we place a value AŒj \u0002 into the B array. Decrementing CŒAŒj \u0002\u0002 causes the\nnext input element with a value equal to AŒj \u0002, if one exists, to go to the position\nimmediately before AŒj \u0002 in the output array.\nHow much time does counting sort require? The for loop of lines 2–3 takes\ntime ‚.k/, the for loop of lines 4–5 takes time ‚.n/, the for loop of lines 7–8 takes\ntime ‚.k/, and the for loop of lines 10–12 takes time ‚.n/. Thus, the overall time\nis ‚.k C n/. In practice, we usually use counting sort when we have k D O.n/, in\nwhich case the running time is ‚.n/.\nCounting sort beats the lower bound of \u0004.n lg n/ proved in Section 8.1 because\nit is not a comparison sort. In fact, no comparisons between input elements occur\nanywhere in the code. Instead, counting sort uses the actual values of the elements\nto index into an array. The \u0004.n lg n/ lower bound for sorting does not apply when\nwe depart from the comparison sort model.\nAn important property of counting sort is that it is stable: numbers with the same\nvalue appear in the output array in the same order as they do in the input array. That",
    "parent_2f5139cb-9176-43bf-b220-c595d7e2a2f5": "to index into an array. The \u0004.n lg n/ lower bound for sorting does not apply when\nwe depart from the comparison sort model.\nAn important property of counting sort is that it is stable: numbers with the same\nvalue appear in the output array in the same order as they do in the input array. That\nis, it breaks ties between two numbers by the rule that whichever number appears\nﬁrst in the input array appears ﬁrst in the output array. Normally, the property of\nstability is important only when satellite data are carried around with the element\nbeing sorted. Counting sort’s stability is important for another reason: counting\nsort is often used as a subroutine in radix sort. As we shall see in the next section,\nin order for radix sort to work correctly, counting sort must be stable.\nExercises\n8.2-1\nUsing Figure 8.2 as a model, illustrate the operation of COUNTING-SORT on the\narray A D h6; 0; 2; 0; 1; 3; 4; 6; 1; 3; 2i.\n8.2-2\nProve that COUNTING-SORT is stable.\n8.2-3\nSuppose that we were to rewrite the for loop header in line 10 of the COUNTING-\nSORT as\n10\nfor j D 1 to A:length\nShow that the algorithm still works properly. Is the modiﬁed algorithm stable?\n8.3\nRadix sort\n197\n8.2-4\nDescribe an algorithm that, given n integers in the range 0 to k, preprocesses its\ninput and then answers any query about how many of the n integers fall into a\nrange Œa : : b\u0002 in O.1/ time. Your algorithm should use ‚.n C k/ preprocessing\ntime.\n8.3\nRadix sort\nRadix sort is the algorithm used by the card-sorting machines you now ﬁnd only in\ncomputer museums. The cards have 80 columns, and in each column a machine can\npunch a hole in one of 12 places. The sorter can be mechanically “programmed”\nto examine a given column of each card in a deck and distribute the card into one\nof 12 bins depending on which place has been punched. An operator can then\ngather the cards bin by bin, so that cards with the ﬁrst place punched are on top of\ncards with the second place punched, and so on.",
    "parent_d7cde4c9-9c1b-4e88-a22f-c04dca121fd8": "to examine a given column of each card in a deck and distribute the card into one\nof 12 bins depending on which place has been punched. An operator can then\ngather the cards bin by bin, so that cards with the ﬁrst place punched are on top of\ncards with the second place punched, and so on.\nFor decimal digits, each column uses only 10 places. (The other two places\nare reserved for encoding nonnumeric characters.) A d-digit number would then\noccupy a ﬁeld of d columns. Since the card sorter can look at only one column\nat a time, the problem of sorting n cards on a d-digit number requires a sorting\nalgorithm.\nIntuitively, you might sort numbers on their most signiﬁcant digit, sort each of\nthe resulting bins recursively, and then combine the decks in order. Unfortunately,\nsince the cards in 9 of the 10 bins must be put aside to sort each of the bins, this\nprocedure generates many intermediate piles of cards that you would have to keep\ntrack of. (See Exercise 8.3-5.)\nRadix sort solves the problem of card sorting—counterintuitively—by sorting on\nthe least signiﬁcant digit ﬁrst. The algorithm then combines the cards into a single\ndeck, with the cards in the 0 bin preceding the cards in the 1 bin preceding the\ncards in the 2 bin, and so on. Then it sorts the entire deck again on the second-least\nsigniﬁcant digit and recombines the deck in a like manner. The process continues\nuntil the cards have been sorted on all d digits. Remarkably, at that point the cards\nare fully sorted on the d-digit number. Thus, only d passes through the deck are\nrequired to sort. Figure 8.3 shows how radix sort operates on a “deck” of seven\n3-digit numbers.\nIn order for radix sort to work correctly, the digit sorts must be stable. The sort\nperformed by a card sorter is stable, but the operator has to be wary about not\nchanging the order of the cards as they come out of a bin, even though all the cards\nin a bin have the same digit in the chosen column.\n198\nChapter 8\nSorting in Linear Time\n329\n457",
    "parent_24166855-ab32-400f-8b41-c92aa59e1a54": "performed by a card sorter is stable, but the operator has to be wary about not\nchanging the order of the cards as they come out of a bin, even though all the cards\nin a bin have the same digit in the chosen column.\n198\nChapter 8\nSorting in Linear Time\n329\n457\n657\n839\n436\n720\n355\n329\n457\n657\n839\n436\n720\n355\n329\n457\n657\n839\n436\n720\n355\n329\n457\n657\n839\n436\n720\n355\nFigure 8.3\nThe operation of radix sort on a list of seven 3-digit numbers. The leftmost column is\nthe input. The remaining columns show the list after successive sorts on increasingly signiﬁcant digit\npositions. Shading indicates the digit position sorted on to produce each list from the previous one.\nIn a typical computer, which is a sequential random-access machine, we some-\ntimes use radix sort to sort records of information that are keyed by multiple ﬁelds.\nFor example, we might wish to sort dates by three keys: year, month, and day. We\ncould run a sorting algorithm with a comparison function that, given two dates,\ncompares years, and if there is a tie, compares months, and if another tie occurs,\ncompares days. Alternatively, we could sort the information three times with a\nstable sort: ﬁrst on day, next on month, and ﬁnally on year.\nThe code for radix sort is straightforward. The following procedure assumes that\neach element in the n-element array A has d digits, where digit 1 is the lowest-order\ndigit and digit d is the highest-order digit.\nRADIX-SORT.A; d/\n1\nfor i D 1 to d\n2\nuse a stable sort to sort array A on digit i\nLemma 8.3\nGiven n d-digit numbers in which each digit can take on up to k possible values,\nRADIX-SORT correctly sorts these numbers in ‚.d.n C k// time if the stable sort\nit uses takes ‚.n C k/ time.\nProof\nThe correctness of radix sort follows by induction on the column being\nsorted (see Exercise 8.3-3). The analysis of the running time depends on the stable\nsort used as the intermediate sorting algorithm. When each digit is in the range 0",
    "parent_8fa352ad-f3a5-4d5a-a121-89e1b4247a00": "it uses takes ‚.n C k/ time.\nProof\nThe correctness of radix sort follows by induction on the column being\nsorted (see Exercise 8.3-3). The analysis of the running time depends on the stable\nsort used as the intermediate sorting algorithm. When each digit is in the range 0\nto k\u00051 (so that it can take on k possible values), and k is not too large, counting sort\nis the obvious choice. Each pass over n d-digit numbers then takes time ‚.nCk/.\nThere are d passes, and so the total time for radix sort is ‚.d.n C k//.\nWhen d is constant and k D O.n/, we can make radix sort run in linear time.\nMore generally, we have some ﬂexibility in how to break each key into digits.\n8.3\nRadix sort\n199\nLemma 8.4\nGiven n b-bit numbers and any positive integer r \u0002 b, RADIX-SORT correctly sorts\nthese numbers in ‚..b=r/.n C 2r// time if the stable sort it uses takes ‚.n C k/\ntime for inputs in the range 0 to k.\nProof\nFor a value r \u0002 b, we view each key as having d D db=re digits of r bits\neach. Each digit is an integer in the range 0 to 2r \u0005 1, so that we can use counting\nsort with k D 2r \u00051. (For example, we can view a 32-bit word as having four 8-bit\ndigits, so that b D 32, r D 8, k D 2r \u0005 1 D 255, and d D b=r D 4.) Each pass of\ncounting sort takes time ‚.n C k/ D ‚.n C 2r/ and there are d passes, for a total\nrunning time of ‚.d.n C 2r// D ‚..b=r/.n C 2r//.\nFor given values of n and b, we wish to choose the value of r, with r \u0002 b,\nthat minimizes the expression .b=r/.n C 2r/. If b < blg nc, then for any value\nof r \u0002 b, we have that .n C 2r/ D ‚.n/. Thus, choosing r D b yields a running\ntime of .b=b/.n C 2b/ D ‚.n/, which is asymptotically optimal. If b \u0006 blg nc,\nthen choosing r D blg nc gives the best time to within a constant factor, which\nwe can see as follows. Choosing r D blg nc yields a running time of ‚.bn= lg n/.\nAs we increase r above blg nc, the 2r term in the numerator increases faster than\nthe r term in the denominator, and so increasing r above blg nc yields a running",
    "parent_d5a48eaf-8671-4d31-9bb7-f739c4102837": "we can see as follows. Choosing r D blg nc yields a running time of ‚.bn= lg n/.\nAs we increase r above blg nc, the 2r term in the numerator increases faster than\nthe r term in the denominator, and so increasing r above blg nc yields a running\ntime of \u0004.bn= lg n/. If instead we were to decrease r below blg nc, then the b=r\nterm increases and the n C 2r term remains at ‚.n/.\nIs radix sort preferable to a comparison-based sorting algorithm, such as quick-\nsort? If b D O.lg n/, as is often the case, and we choose r \u0004 lg n, then radix sort’s\nrunning time is ‚.n/, which appears to be better than quicksort’s expected running\ntime of ‚.n lg n/. The constant factors hidden in the ‚-notation differ, however.\nAlthough radix sort may make fewer passes than quicksort over the n keys, each\npass of radix sort may take signiﬁcantly longer. Which sorting algorithm we prefer\ndepends on the characteristics of the implementations, of the underlying machine\n(e.g., quicksort often uses hardware caches more effectively than radix sort), and\nof the input data. Moreover, the version of radix sort that uses counting sort as the\nintermediate stable sort does not sort in place, which many of the ‚.n lg n/-time\ncomparison sorts do. Thus, when primary memory storage is at a premium, we\nmight prefer an in-place algorithm such as quicksort.\nExercises\n8.3-1\nUsing Figure 8.3 as a model, illustrate the operation of RADIX-SORT on the fol-\nlowing list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB,\nBAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.\n200\nChapter 8\nSorting in Linear Time\n8.3-2\nWhich of the following sorting algorithms are stable: insertion sort, merge sort,\nheapsort, and quicksort? Give a simple scheme that makes any sorting algorithm\nstable. How much additional time and space does your scheme entail?\n8.3-3\nUse induction to prove that radix sort works. Where does your proof need the\nassumption that the intermediate sort is stable?\n8.3-4",
    "parent_705b9e1d-06ba-49e0-8ef9-a16a97c4252e": "heapsort, and quicksort? Give a simple scheme that makes any sorting algorithm\nstable. How much additional time and space does your scheme entail?\n8.3-3\nUse induction to prove that radix sort works. Where does your proof need the\nassumption that the intermediate sort is stable?\n8.3-4\nShow how to sort n integers in the range 0 to n3 \u0005 1 in O.n/ time.\n8.3-5\n?\nIn the ﬁrst card-sorting algorithm in this section, exactly how many sorting passes\nare needed to sort d-digit decimal numbers in the worst case? How many piles of\ncards would an operator need to keep track of in the worst case?\n8.4\nBucket sort\nBucket sort assumes that the input is drawn from a uniform distribution and has an\naverage-case running time of O.n/. Like counting sort, bucket sort is fast because\nit assumes something about the input. Whereas counting sort assumes that the input\nconsists of integers in a small range, bucket sort assumes that the input is generated\nby a random process that distributes elements uniformly and independently over\nthe interval Œ0; 1/. (See Section C.2 for a deﬁnition of uniform distribution.)\nBucket sort divides the interval Œ0; 1/ into n equal-sized subintervals, or buckets,\nand then distributes the n input numbers into the buckets. Since the inputs are uni-\nformly and independently distributed over Œ0; 1/, we do not expect many numbers\nto fall into each bucket. To produce the output, we simply sort the numbers in each\nbucket and then go through the buckets in order, listing the elements in each.\nOur code for bucket sort assumes that the input is an n-element array A and\nthat each element AŒi\u0002 in the array satisﬁes 0 \u0002 AŒi\u0002 < 1. The code requires an\nauxiliary array BŒ0 : : n \u0005 1\u0002 of linked lists (buckets) and assumes that there is a\nmechanism for maintaining such lists. (Section 10.2 describes how to implement\nbasic operations on linked lists.)\n8.4\nBucket sort\n201\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n.78\n.17\n.39\n.72\n.94\n.21\n.12\n.23\n.68\nA\n(a)\n1\n2\n3\n4\n5\n6\n7\n8\n9\nB\n(b)\n0\n.12\n.17\n.21\n.23\n.26",
    "parent_ab532812-51d9-46a9-9b65-de797db25045": "mechanism for maintaining such lists. (Section 10.2 describes how to implement\nbasic operations on linked lists.)\n8.4\nBucket sort\n201\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n.78\n.17\n.39\n.72\n.94\n.21\n.12\n.23\n.68\nA\n(a)\n1\n2\n3\n4\n5\n6\n7\n8\n9\nB\n(b)\n0\n.12\n.17\n.21\n.23\n.26\n.26\n.39\n.68\n.72\n.78\n.94\nFigure 8.4\nThe operation of BUCKET-SORT for n D 10. (a) The input array AŒ1 : : 10\u0002. (b) The\narray BŒ0 : : 9\u0002 of sorted lists (buckets) after line 8 of the algorithm. Bucket i holds values in the\nhalf-open interval Œi=10; .i C 1/=10/. The sorted output consists of a concatenation in order of the\nlists BŒ0\u0002; BŒ1\u0002; : : : ; BŒ9\u0002.\nBUCKET-SORT.A/\n1\nlet BŒ0 : : n \u0005 1\u0002 be a new array\n2\nn D A:length\n3\nfor i D 0 to n \u0005 1\n4\nmake BŒi\u0002 an empty list\n5\nfor i D 1 to n\n6\ninsert AŒi\u0002 into list BŒbnAŒi\u0002c\u0002\n7\nfor i D 0 to n \u0005 1\n8\nsort list BŒi\u0002 with insertion sort\n9\nconcatenate the lists BŒ0\u0002; BŒ1\u0002; : : : ; BŒn \u0005 1\u0002 together in order\nFigure 8.4 shows the operation of bucket sort on an input array of 10 numbers.\nTo see that this algorithm works, consider two elements AŒi\u0002 and AŒj \u0002. Assume\nwithout loss of generality that AŒi\u0002 \u0002 AŒj \u0002. Since bnAŒi\u0002c \u0002 bnAŒj \u0002c, either\nelement AŒi\u0002 goes into the same bucket as AŒj \u0002 or it goes into a bucket with a lower\nindex. If AŒi\u0002 and AŒj \u0002 go into the same bucket, then the for loop of lines 7–8 puts\nthem into the proper order. If AŒi\u0002 and AŒj \u0002 go into different buckets, then line 9\nputs them into the proper order. Therefore, bucket sort works correctly.\nTo analyze the running time, observe that all lines except line 8 take O.n/ time\nin the worst case. We need to analyze the total time taken by the n calls to insertion\nsort in line 8.\n202\nChapter 8\nSorting in Linear Time\nTo analyze the cost of the calls to insertion sort, let ni be the random variable\ndenoting the number of elements placed in bucket BŒi\u0002. Since insertion sort runs\nin quadratic time (see Section 2.2), the running time of bucket sort is\nT .n/ D ‚.n/ C\nn\u00031\nX\niD0\nO.n2\ni / :",
    "parent_4b0ad71b-0ff7-4e18-a8bf-c49b593134b3": "Sorting in Linear Time\nTo analyze the cost of the calls to insertion sort, let ni be the random variable\ndenoting the number of elements placed in bucket BŒi\u0002. Since insertion sort runs\nin quadratic time (see Section 2.2), the running time of bucket sort is\nT .n/ D ‚.n/ C\nn\u00031\nX\niD0\nO.n2\ni / :\nWe now analyze the average-case running time of bucket sort, by computing the\nexpected value of the running time, where we take the expectation over the input\ndistribution. Taking expectations of both sides and using linearity of expectation,\nwe have\nE ŒT .n/\u0002\nD\nE\n\"\n‚.n/ C\nn\u00031\nX\niD0\nO.n2\ni /\n#\nD\n‚.n/ C\nn\u00031\nX\niD0\nE\n\u000f\nO.n2\ni /\n\u0010\n(by linearity of expectation)\nD\n‚.n/ C\nn\u00031\nX\niD0\nO\n\u000b\nE\n\u000f\nn2\ni\n\u0010\f\n(by equation (C.22)) .\n(8.1)\nWe claim that\nE\n\u000f\nn2\ni\n\u0010\nD 2 \u0005 1=n\n(8.2)\nfor i D 0; 1; : : : ; n \u0005 1. It is no surprise that each bucket i has the same value of\nE Œn2\ni \u0002, since each value in the input array A is equally likely to fall in any bucket.\nTo prove equation (8.2), we deﬁne indicator random variables\nXij D I fAŒj \u0002 falls in bucket ig\nfor i D 0; 1; : : : ; n \u0005 1 and j D 1; 2; : : : ; n. Thus,\nni D\nn\nX\njD1\nXij :\nTo compute E Œn2\ni \u0002, we expand the square and regroup terms:\n8.4\nBucket sort\n203\nE\n\u000f\nn2\ni\n\u0010\nD\nE\n\" n\nX\njD1\nXij\n!2#\nD\nE\n\" n\nX\njD1\nn\nX\nkD1\nXijXik\n#\nD\nE\n2\n4\nn\nX\njD1\nX 2\nij C\nX\n1\u0005j\u0005n\nX\n1\u0005k\u0005n\nk¤j\nXijXik\n3\n5\nD\nn\nX\njD1\nE\n\u000f\nX 2\nij\n\u0010\nC\nX\n1\u0005j\u0005n\nX\n1\u0005k\u0005n\nk¤j\nE ŒXijXik\u0002 ;\n(8.3)\nwhere the last line follows by linearity of expectation. We evaluate the two sum-\nmations separately. Indicator random variable Xij is 1 with probability 1=n and 0\notherwise, and therefore\nE\n\u000f\nX 2\nij\n\u0010\nD\n12 \u0003 1\nn C 02 \u0003\n\u0002\n1 \u0005 1\nn\n\u0003\nD\n1\nn :\nWhen k ¤ j , the variables Xij and Xik are independent, and hence\nE ŒXijXik\u0002\nD\nE ŒXij\u0002 E ŒXik\u0002\nD\n1\nn \u0003 1\nn\nD\n1\nn2 :\nSubstituting these two expected values in equation (8.3), we obtain\nE\n\u000f\nn2\ni\n\u0010\nD\nn\nX\njD1\n1\nn C\nX\n1\u0005j\u0005n\nX\n1\u0005k\u0005n\nk¤j\n1\nn2\nD\nn \u0003 1\nn C n.n \u0005 1/ \u0003 1\nn2\nD\n1 C n \u0005 1\nn\nD\n2 \u0005 1\nn ;\nwhich proves equation (8.2).\n204\nChapter 8\nSorting in Linear Time",
    "parent_3a946853-3ee3-45ea-ae24-d11fcde348dc": "E ŒXijXik\u0002\nD\nE ŒXij\u0002 E ŒXik\u0002\nD\n1\nn \u0003 1\nn\nD\n1\nn2 :\nSubstituting these two expected values in equation (8.3), we obtain\nE\n\u000f\nn2\ni\n\u0010\nD\nn\nX\njD1\n1\nn C\nX\n1\u0005j\u0005n\nX\n1\u0005k\u0005n\nk¤j\n1\nn2\nD\nn \u0003 1\nn C n.n \u0005 1/ \u0003 1\nn2\nD\n1 C n \u0005 1\nn\nD\n2 \u0005 1\nn ;\nwhich proves equation (8.2).\n204\nChapter 8\nSorting in Linear Time\nUsing this expected value in equation (8.1), we conclude that the average-case\nrunning time for bucket sort is ‚.n/ C n \u0003 O.2 \u0005 1=n/ D ‚.n/.\nEven if the input is not drawn from a uniform distribution, bucket sort may still\nrun in linear time. As long as the input has the property that the sum of the squares\nof the bucket sizes is linear in the total number of elements, equation (8.1) tells us\nthat bucket sort will run in linear time.\nExercises\n8.4-1\nUsing Figure 8.4 as a model, illustrate the operation of BUCKET-SORT on the array\nA D h:79; :13; :16; :64; :39; :20; :89; :53; :71; :42i.\n8.4-2\nExplain why the worst-case running time for bucket sort is ‚.n2/. What simple\nchange to the algorithm preserves its linear average-case running time and makes\nits worst-case running time O.n lg n/?\n8.4-3\nLet X be a random variable that is equal to the number of heads in two ﬂips of a\nfair coin. What is E ŒX 2\u0002? What is E2 ŒX\u0002?\n8.4-4\n?\nWe are given n points in the unit circle, pi D .xi; yi/, such that 0 < x2\ni C y2\ni \u0002 1\nfor i D 1; 2; : : : ; n. Suppose that the points are uniformly distributed; that is, the\nprobability of ﬁnding a point in any region of the circle is proportional to the area\nof that region. Design an algorithm with an average-case running time of ‚.n/ to\nsort the n points by their distances di D\np\nx2\ni C y2\ni from the origin. (Hint: Design\nthe bucket sizes in BUCKET-SORT to reﬂect the uniform distribution of the points\nin the unit circle.)\n8.4-5\n?\nA probability distribution function P.x/ for a random variable X is deﬁned\nby P.x/ D Pr fX \u0002 xg.\nSuppose that we draw a list of n random variables\nX1; X2; : : : ; Xn from a continuous probability distribution function P that is com-",
    "parent_d927caac-8f15-4a2a-8949-62fdefa1f43d": "in the unit circle.)\n8.4-5\n?\nA probability distribution function P.x/ for a random variable X is deﬁned\nby P.x/ D Pr fX \u0002 xg.\nSuppose that we draw a list of n random variables\nX1; X2; : : : ; Xn from a continuous probability distribution function P that is com-\nputable in O.1/ time. Give an algorithm that sorts these numbers in linear average-\ncase time.\nProblems for Chapter 8\n205\nProblems\n8-1\nProbabilistic lower bounds on comparison sorting\nIn this problem, we prove a probabilistic \u0004.n lg n/ lower bound on the running time\nof any deterministic or randomized comparison sort on n distinct input elements.\nWe begin by examining a deterministic comparison sort A with decision tree TA.\nWe assume that every permutation of A’s inputs is equally likely.\na. Suppose that each leaf of TA is labeled with the probability that it is reached\ngiven a random input. Prove that exactly nŠ leaves are labeled 1=nŠ and that the\nrest are labeled 0.\nb. Let D.T / denote the external path length of a decision tree T ; that is, D.T /\nis the sum of the depths of all the leaves of T . Let T be a decision tree with\nk > 1 leaves, and let LT and RT be the left and right subtrees of T . Show that\nD.T / D D.LT/ C D.RT/ C k.\nc. Let d.k/ be the minimum value of D.T / over all decision trees T with k > 1\nleaves. Show that d.k/ D min1\u0005i\u0005k\u00031 fd.i/ C d.k \u0005 i/ C kg. (Hint: Consider\na decision tree T with k leaves that achieves the minimum. Let i0 be the number\nof leaves in LT and k \u0005 i0 the number of leaves in RT.)\nd. Prove that for a given value of k > 1 and i in the range 1 \u0002 i \u0002 k \u0005 1, the\nfunction i lg i C .k \u0005 i/ lg.k \u0005 i/ is minimized at i D k=2. Conclude that\nd.k/ D \u0004.k lg k/.\ne. Prove that D.TA/ D \u0004.nŠ lg.nŠ//, and conclude that the average-case time to\nsort n elements is \u0004.n lg n/.\nNow, consider a randomized comparison sort B. We can extend the decision-\ntree model to handle randomization by incorporating two kinds of nodes: ordinary",
    "parent_9b0d2892-8690-4d9e-a305-30874bcc2753": "d.k/ D \u0004.k lg k/.\ne. Prove that D.TA/ D \u0004.nŠ lg.nŠ//, and conclude that the average-case time to\nsort n elements is \u0004.n lg n/.\nNow, consider a randomized comparison sort B. We can extend the decision-\ntree model to handle randomization by incorporating two kinds of nodes: ordinary\ncomparison nodes and “randomization” nodes. A randomization node models a\nrandom choice of the form RANDOM.1; r/ made by algorithm B; the node has r\nchildren, each of which is equally likely to be chosen during an execution of the\nalgorithm.\nf. Show that for any randomized comparison sort B, there exists a deterministic\ncomparison sort A whose expected number of comparisons is no more than\nthose made by B.\n206\nChapter 8\nSorting in Linear Time\n8-2\nSorting in place in linear time\nSuppose that we have an array of n data records to sort and that the key of each\nrecord has the value 0 or 1. An algorithm for sorting such a set of records might\npossess some subset of the following three desirable characteristics:\n1. The algorithm runs in O.n/ time.\n2. The algorithm is stable.\n3. The algorithm sorts in place, using no more than a constant amount of storage\nspace in addition to the original array.\na. Give an algorithm that satisﬁes criteria 1 and 2 above.\nb. Give an algorithm that satisﬁes criteria 1 and 3 above.\nc. Give an algorithm that satisﬁes criteria 2 and 3 above.\nd. Can you use any of your sorting algorithms from parts (a)–(c) as the sorting\nmethod used in line 2 of RADIX-SORT, so that RADIX-SORT sorts n records\nwith b-bit keys in O.bn/ time? Explain how or why not.\ne. Suppose that the n records have keys in the range from 1 to k. Show how to\nmodify counting sort so that it sorts the records in place in O.n C k/ time. You\nmay use O.k/ storage outside the input array. Is your algorithm stable? (Hint:\nHow would you do it for k D 3?)\n8-3\nSorting variable-length items\na. You are given an array of integers, where different integers may have different",
    "parent_e8bfe4c6-5ec7-40e8-a63d-171f6f0e7a84": "may use O.k/ storage outside the input array. Is your algorithm stable? (Hint:\nHow would you do it for k D 3?)\n8-3\nSorting variable-length items\na. You are given an array of integers, where different integers may have different\nnumbers of digits, but the total number of digits over all the integers in the array\nis n. Show how to sort the array in O.n/ time.\nb. You are given an array of strings, where different strings may have different\nnumbers of characters, but the total number of characters over all the strings\nis n. Show how to sort the strings in O.n/ time.\n(Note that the desired order here is the standard alphabetical order; for example,\na < ab < b.)\n8-4\nWater jugs\nSuppose that you are given n red and n blue water jugs, all of different shapes and\nsizes. All red jugs hold different amounts of water, as do the blue ones. Moreover,\nfor every red jug, there is a blue jug that holds the same amount of water, and vice\nversa.\nProblems for Chapter 8\n207\nYour task is to ﬁnd a grouping of the jugs into pairs of red and blue jugs that hold\nthe same amount of water. To do so, you may perform the following operation: pick\na pair of jugs in which one is red and one is blue, ﬁll the red jug with water, and\nthen pour the water into the blue jug. This operation will tell you whether the red\nor the blue jug can hold more water, or that they have the same volume. Assume\nthat such a comparison takes one time unit. Your goal is to ﬁnd an algorithm that\nmakes a minimum number of comparisons to determine the grouping. Remember\nthat you may not directly compare two red jugs or two blue jugs.\na. Describe a deterministic algorithm that uses ‚.n2/ comparisons to group the\njugs into pairs.\nb. Prove a lower bound of \u0004.n lg n/ for the number of comparisons that an algo-\nrithm solving this problem must make.\nc. Give a randomized algorithm whose expected number of comparisons is\nO.n lg n/, and prove that this bound is correct. What is the worst-case num-",
    "parent_0a267688-336c-41ae-a2b7-2b91bface588": "jugs into pairs.\nb. Prove a lower bound of \u0004.n lg n/ for the number of comparisons that an algo-\nrithm solving this problem must make.\nc. Give a randomized algorithm whose expected number of comparisons is\nO.n lg n/, and prove that this bound is correct. What is the worst-case num-\nber of comparisons for your algorithm?\n8-5\nAverage sorting\nSuppose that, instead of sorting an array, we just require that the elements increase\non average.\nMore precisely, we call an n-element array A k-sorted if, for all\ni D 1; 2; : : : ; n \u0005 k, the following holds:\nPiCk\u00031\njDi\nAŒj \u0002\nk\n\u0002\nPiCk\njDiC1 AŒj \u0002\nk\n:\na. What does it mean for an array to be 1-sorted?\nb. Give a permutation of the numbers 1; 2; : : : ; 10 that is 2-sorted, but not sorted.\nc. Prove that an n-element array is k-sorted if and only if AŒi\u0002 \u0002 AŒi C k\u0002 for all\ni D 1; 2; : : : ; n \u0005 k.\nd. Give an algorithm that k-sorts an n-element array in O.n lg.n=k// time.\nWe can also show a lower bound on the time to produce a k-sorted array, when k\nis a constant.\ne. Show that we can sort a k-sorted array of length n in O.n lg k/ time. (Hint:\nUse the solution to Exercise 6.5-9. )\nf. Show that when k is a constant, k-sorting an n-element array requires \u0004.n lg n/\ntime. (Hint: Use the solution to the previous part along with the lower bound\non comparison sorts.)\n208\nChapter 8\nSorting in Linear Time\n8-6\nLower bound on merging sorted lists\nThe problem of merging two sorted lists arises frequently. We have seen a pro-\ncedure for it as the subroutine MERGE in Section 2.3.1. In this problem, we will\nprove a lower bound of 2n \u0005 1 on the worst-case number of comparisons required\nto merge two sorted lists, each containing n items.\nFirst we will show a lower bound of 2n \u0005 o.n/ comparisons by using a decision\ntree.\na. Given 2n numbers, compute the number of possible ways to divide them into\ntwo sorted lists, each with n numbers.\nb. Using a decision tree and your answer to part (a), show that any algorithm that",
    "parent_176c41a9-b79c-4391-be92-5b5759a1b000": "First we will show a lower bound of 2n \u0005 o.n/ comparisons by using a decision\ntree.\na. Given 2n numbers, compute the number of possible ways to divide them into\ntwo sorted lists, each with n numbers.\nb. Using a decision tree and your answer to part (a), show that any algorithm that\ncorrectly merges two sorted lists must perform at least 2n \u0005 o.n/ comparisons.\nNow we will show a slightly tighter 2n \u0005 1 bound.\nc. Show that if two elements are consecutive in the sorted order and from different\nlists, then they must be compared.\nd. Use your answer to the previous part to show a lower bound of 2n \u0005 1 compar-\nisons for merging two sorted lists.\n8-7\nThe 0-1 sorting lemma and columnsort\nA compare-exchange operation on two array elements AŒi\u0002 and AŒj \u0002, where i < j ,\nhas the form\nCOMPARE-EXCHANGE.A; i; j /\n1\nif AŒi\u0002 > AŒj \u0002\n2\nexchange AŒi\u0002 with AŒj \u0002\nAfter the compare-exchange operation, we know that AŒi\u0002 \u0002 AŒj \u0002.\nAn oblivious compare-exchange algorithm operates solely by a sequence of\nprespeciﬁed compare-exchange operations. The indices of the positions compared\nin the sequence must be determined in advance, and although they can depend\non the number of elements being sorted, they cannot depend on the values being\nsorted, nor can they depend on the result of any prior compare-exchange operation.\nFor example, here is insertion sort expressed as an oblivious compare-exchange\nalgorithm:\nINSERTION-SORT.A/\n1\nfor j D 2 to A:length\n2\nfor i D j \u0005 1 downto 1\n3\nCOMPARE-EXCHANGE.A; i; i C 1/\nProblems for Chapter 8\n209\nThe 0-1 sorting lemma provides a powerful way to prove that an oblivious\ncompare-exchange algorithm produces a sorted result. It states that if an oblivi-\nous compare-exchange algorithm correctly sorts all input sequences consisting of\nonly 0s and 1s, then it correctly sorts all inputs containing arbitrary values.\nYou will prove the 0-1 sorting lemma by proving its contrapositive: if an oblivi-",
    "parent_498741fb-e4a3-4407-8dd1-7f855906ba1f": "ous compare-exchange algorithm correctly sorts all input sequences consisting of\nonly 0s and 1s, then it correctly sorts all inputs containing arbitrary values.\nYou will prove the 0-1 sorting lemma by proving its contrapositive: if an oblivi-\nous compare-exchange algorithm fails to sort an input containing arbitrary values,\nthen it fails to sort some 0-1 input. Assume that an oblivious compare-exchange al-\ngorithm X fails to correctly sort the array AŒ1 : : n\u0002. Let AŒp\u0002 be the smallest value\nin A that algorithm X puts into the wrong location, and let AŒq\u0002 be the value that\nalgorithm X moves to the location into which AŒp\u0002 should have gone. Deﬁne an\narray BŒ1 : : n\u0002 of 0s and 1s as follows:\nBŒi\u0002 D\n(\n0\nif AŒi\u0002 \u0002 AŒp\u0002 ;\n1\nif AŒi\u0002 > AŒp\u0002 :\na. Argue that AŒq\u0002 > AŒp\u0002, so that BŒp\u0002 D 0 and BŒq\u0002 D 1.\nb. To complete the proof of the 0-1 sorting lemma, prove that algorithm X fails to\nsort array B correctly.\nNow you will use the 0-1 sorting lemma to prove that a particular sorting algo-\nrithm works correctly. The algorithm, columnsort, works on a rectangular array\nof n elements. The array has r rows and s columns (so that n D rs), subject to\nthree restrictions:\n\u0002\nr must be even,\n\u0002\ns must be a divisor of r, and\n\u0002\nr \u0006 2s2.\nWhen columnsort completes, the array is sorted in column-major order: reading\ndown the columns, from left to right, the elements monotonically increase.\nColumnsort operates in eight steps, regardless of the value of n. The odd steps\nare all the same: sort each column individually. Each even step is a ﬁxed permuta-\ntion. Here are the steps:\n1. Sort each column.\n2. Transpose the array, but reshape it back to r rows and s columns. In other\nwords, turn the leftmost column into the top r=s rows, in order; turn the next\ncolumn into the next r=s rows, in order; and so on.\n3. Sort each column.\n4. Perform the inverse of the permutation performed in step 2.\n210\nChapter 8\nSorting in Linear Time\n10\n14\n5\n8\n7\n17\n12\n1\n6\n16\n9\n11\n4\n15\n2\n18\n3\n13\n(a)\n4\n1\n2\n8\n3\n5\n10\n7\n6\n12\n9\n11",
    "parent_2aa37a76-9766-489c-a13e-185b7a4ba546": "column into the next r=s rows, in order; and so on.\n3. Sort each column.\n4. Perform the inverse of the permutation performed in step 2.\n210\nChapter 8\nSorting in Linear Time\n10\n14\n5\n8\n7\n17\n12\n1\n6\n16\n9\n11\n4\n15\n2\n18\n3\n13\n(a)\n4\n1\n2\n8\n3\n5\n10\n7\n6\n12\n9\n11\n16\n14\n13\n18\n15\n17\n(b)\n4\n8\n10\n12\n16\n18\n1\n3\n7\n9\n14\n15\n2\n5\n6\n11\n13\n17\n(c)\n1\n3\n6\n2\n5\n7\n4\n8\n10\n9\n13\n15\n11\n14\n17\n12\n16\n18\n(d)\n1\n4\n11\n3\n8\n14\n6\n10\n17\n2\n9\n12\n5\n13\n16\n7\n15\n18\n(e)\n1\n4\n11\n2\n8\n12\n3\n9\n14\n5\n10\n16\n6\n13\n17\n7\n15\n18\n(f)\n5\n10\n16\n6\n13\n17\n7\n15\n18\n1\n4\n11\n2\n8\n12\n3\n9\n14\n(g)\n4\n10\n16\n5\n11\n17\n6\n12\n18\n1\n7\n13\n2\n8\n14\n3\n9\n15\n(h)\n1\n7\n13\n2\n8\n14\n3\n9\n15\n4\n10\n16\n5\n11\n17\n6\n12\n18\n(i)\nFigure 8.5\nThe steps of columnsort. (a) The input array with 6 rows and 3 columns. (b) After\nsorting each column in step 1. (c) After transposing and reshaping in step 2. (d) After sorting each\ncolumn in step 3. (e) After performing step 4, which inverts the permutation from step 2. (f) After\nsorting each column in step 5. (g) After shifting by half a column in step 6. (h) After sorting each\ncolumn in step 7. (i) After performing step 8, which inverts the permutation from step 6. The array\nis now sorted in column-major order.\n5. Sort each column.\n6. Shift the top half of each column into the bottom half of the same column, and\nshift the bottom half of each column into the top half of the next column to the\nright. Leave the top half of the leftmost column empty. Shift the bottom half\nof the last column into the top half of a new rightmost column, and leave the\nbottom half of this new column empty.\n7. Sort each column.\n8. Perform the inverse of the permutation performed in step 6.\nFigure 8.5 shows an example of the steps of columnsort with r D 6 and s D 3.\n(Even though this example violates the requirement that r \u0006 2s2, it happens to\nwork.)\nc. Argue that we can treat columnsort as an oblivious compare-exchange algo-\nrithm, even if we do not know what sorting method the odd steps use.\nAlthough it might seem hard to believe that columnsort actually sorts, you will",
    "parent_49458fec-885d-4e98-b3fa-afcabaa8d8df": "work.)\nc. Argue that we can treat columnsort as an oblivious compare-exchange algo-\nrithm, even if we do not know what sorting method the odd steps use.\nAlthough it might seem hard to believe that columnsort actually sorts, you will\nuse the 0-1 sorting lemma to prove that it does. The 0-1 sorting lemma applies\nbecause we can treat columnsort as an oblivious compare-exchange algorithm. A\nNotes for Chapter 8\n211\ncouple of deﬁnitions will help you apply the 0-1 sorting lemma. We say that an area\nof an array is clean if we know that it contains either all 0s or all 1s. Otherwise,\nthe area might contain mixed 0s and 1s, and it is dirty. From here on, assume that\nthe input array contains only 0s and 1s, and that we can treat it as an array with r\nrows and s columns.\nd. Prove that after steps 1–3, the array consists of some clean rows of 0s at the top,\nsome clean rows of 1s at the bottom, and at most s dirty rows between them.\ne. Prove that after step 4, the array, read in column-major order, starts with a clean\narea of 0s, ends with a clean area of 1s, and has a dirty area of at most s2\nelements in the middle.\nf. Prove that steps 5–8 produce a fully sorted 0-1 output. Conclude that column-\nsort correctly sorts all inputs containing arbitrary values.\ng. Now suppose that s does not divide r. Prove that after steps 1–3, the array\nconsists of some clean rows of 0s at the top, some clean rows of 1s at the\nbottom, and at most 2s \u0005 1 dirty rows between them. How large must r be,\ncompared with s, for columnsort to correctly sort when s does not divide r?\nh. Suggest a simple change to step 1 that allows us to maintain the requirement\nthat r \u0006 2s2 even when s does not divide r, and prove that with your change,\ncolumnsort correctly sorts.\nChapter notes\nThe decision-tree model for studying comparison sorts was introduced by Ford\nand Johnson [110]. Knuth’s comprehensive treatise on sorting [211] covers many",
    "parent_abe10fbb-7d1a-4fcd-be12-aa301a904cf3": "that r \u0006 2s2 even when s does not divide r, and prove that with your change,\ncolumnsort correctly sorts.\nChapter notes\nThe decision-tree model for studying comparison sorts was introduced by Ford\nand Johnson [110]. Knuth’s comprehensive treatise on sorting [211] covers many\nvariations on the sorting problem, including the information-theoretic lower bound\non the complexity of sorting given here. Ben-Or [39] studied lower bounds for\nsorting using generalizations of the decision-tree model.\nKnuth credits H. H. Seward with inventing counting sort in 1954, as well as with\nthe idea of combining counting sort with radix sort. Radix sorting starting with the\nleast signiﬁcant digit appears to be a folk algorithm widely used by operators of\nmechanical card-sorting machines. According to Knuth, the ﬁrst published refer-\nence to the method is a 1929 document by L. J. Comrie describing punched-card\nequipment. Bucket sorting has been in use since 1956, when the basic idea was\nproposed by E. J. Isaac and R. C. Singleton [188].\nMunro and Raman [263] give a stable sorting algorithm that performs O.n1C\u0002/\ncomparisons in the worst case, where 0 < \b \u0002 1 is any ﬁxed constant. Although\n212\nChapter 8\nSorting in Linear Time\nany of the O.n lg n/-time algorithms make fewer comparisons, the algorithm by\nMunro and Raman moves data only O.n/ times and operates in place.\nThe case of sorting n b-bit integers in o.n lg n/ time has been considered by\nmany researchers. Several positive results have been obtained, each under slightly\ndifferent assumptions about the model of computation and the restrictions placed\non the algorithm. All the results assume that the computer memory is divided into\naddressable b-bit words. Fredman and Willard [115] introduced the fusion tree data\nstructure and used it to sort n integers in O.n lg n= lg lg n/ time. This bound was\nlater improved to O.n\np\nlg n/ time by Andersson [16]. These algorithms require",
    "parent_7c156286-576e-4e8b-8766-542327babd7b": "addressable b-bit words. Fredman and Willard [115] introduced the fusion tree data\nstructure and used it to sort n integers in O.n lg n= lg lg n/ time. This bound was\nlater improved to O.n\np\nlg n/ time by Andersson [16]. These algorithms require\nthe use of multiplication and several precomputed constants. Andersson, Hagerup,\nNilsson, and Raman [17] have shown how to sort n integers in O.n lg lg n/ time\nwithout using multiplication, but their method requires storage that can be un-\nbounded in terms of n. Using multiplicative hashing, we can reduce the storage\nneeded to O.n/, but then the O.n lg lg n/ worst-case bound on the running time\nbecomes an expected-time bound. Generalizing the exponential search trees of\nAndersson [16], Thorup [335] gave an O.n.lg lg n/2/-time sorting algorithm that\ndoes not use multiplication or randomization, and it uses linear space. Combining\nthese techniques with some new ideas, Han [158] improved the bound for sorting\nto O.n lg lg n lg lg lg n/ time. Although these algorithms are important theoretical\nbreakthroughs, they are all fairly complicated and at the present time seem unlikely\nto compete with existing sorting algorithms in practice.\nThe columnsort algorithm in Problem 8-7 is by Leighton [227].\n9\nMedians and Order Statistics\nThe ith order statistic of a set of n elements is the ith smallest element. For\nexample, the minimum of a set of elements is the ﬁrst order statistic (i D 1),\nand the maximum is the nth order statistic (i D n). A median, informally, is\nthe “halfway point” of the set. When n is odd, the median is unique, occurring at\ni D .n C 1/=2. When n is even, there are two medians, occurring at i D n=2 and\ni D n=2C1. Thus, regardless of the parity of n, medians occur at i D b.n C 1/=2c\n(the lower median) and i D d.n C 1/=2e (the upper median). For simplicity in\nthis text, however, we consistently use the phrase “the median” to refer to the lower\nmedian.",
    "parent_7a1baa03-0750-4d38-9cc0-432448acb53e": "i D n=2C1. Thus, regardless of the parity of n, medians occur at i D b.n C 1/=2c\n(the lower median) and i D d.n C 1/=2e (the upper median). For simplicity in\nthis text, however, we consistently use the phrase “the median” to refer to the lower\nmedian.\nThis chapter addresses the problem of selecting the ith order statistic from a\nset of n distinct numbers. We assume for convenience that the set contains dis-\ntinct numbers, although virtually everything that we do extends to the situation in\nwhich a set contains repeated values. We formally specify the selection problem\nas follows:\nInput: A set A of n (distinct) numbers and an integer i, with 1 \u0002 i \u0002 n.\nOutput: The element x 2 A that is larger than exactly i \u0005 1 other elements of A.\nWe can solve the selection problem in O.n lg n/ time, since we can sort the num-\nbers using heapsort or merge sort and then simply index the ith element in the\noutput array. This chapter presents faster algorithms.\nIn Section 9.1, we examine the problem of selecting the minimum and maxi-\nmum of a set of elements. More interesting is the general selection problem, which\nwe investigate in the subsequent two sections. Section 9.2 analyzes a practical\nrandomized algorithm that achieves an O.n/ expected running time, assuming dis-\ntinct elements. Section 9.3 contains an algorithm of more theoretical interest that\nachieves the O.n/ running time in the worst case.\n214\nChapter 9\nMedians and Order Statistics\n9.1\nMinimum and maximum\nHow many comparisons are necessary to determine the minimum of a set of n\nelements? We can easily obtain an upper bound of n \u0005 1 comparisons: examine\neach element of the set in turn and keep track of the smallest element seen so\nfar. In the following procedure, we assume that the set resides in array A, where\nA:length D n.\nMINIMUM.A/\n1\nmin D AŒ1\u0002\n2\nfor i D 2 to A:length\n3\nif min > AŒi\u0002\n4\nmin D AŒi\u0002\n5\nreturn min\nWe can, of course, ﬁnd the maximum with n \u0005 1 comparisons as well.",
    "parent_a02d523a-2ba1-4fbb-a269-d47cdf791fe4": "far. In the following procedure, we assume that the set resides in array A, where\nA:length D n.\nMINIMUM.A/\n1\nmin D AŒ1\u0002\n2\nfor i D 2 to A:length\n3\nif min > AŒi\u0002\n4\nmin D AŒi\u0002\n5\nreturn min\nWe can, of course, ﬁnd the maximum with n \u0005 1 comparisons as well.\nIs this the best we can do? Yes, since we can obtain a lower bound of n \u0005 1\ncomparisons for the problem of determining the minimum. Think of any algorithm\nthat determines the minimum as a tournament among the elements. Each compar-\nison is a match in the tournament in which the smaller of the two elements wins.\nObserving that every element except the winner must lose at least one match, we\nconclude that n \u0005 1 comparisons are necessary to determine the minimum. Hence,\nthe algorithm MINIMUM is optimal with respect to the number of comparisons\nperformed.\nSimultaneous minimum and maximum\nIn some applications, we must ﬁnd both the minimum and the maximum of a set\nof n elements. For example, a graphics program may need to scale a set of .x; y/\ndata to ﬁt onto a rectangular display screen or other graphical output device. To\ndo so, the program must ﬁrst determine the minimum and maximum value of each\ncoordinate.\nAt this point, it should be obvious how to determine both the minimum and the\nmaximum of n elements using ‚.n/ comparisons, which is asymptotically optimal:\nsimply ﬁnd the minimum and maximum independently, using n \u0005 1 comparisons\nfor each, for a total of 2n \u0005 2 comparisons.\nIn fact, we can ﬁnd both the minimum and the maximum using at most 3 bn=2c\ncomparisons. We do so by maintaining both the minimum and maximum elements\nseen thus far. Rather than processing each element of the input by comparing it\nagainst the current minimum and maximum, at a cost of 2 comparisons per element,\n9.2\nSelection in expected linear time\n215\nwe process elements in pairs. We compare pairs of elements from the input ﬁrst\nwith each other, and then we compare the smaller with the current minimum and",
    "parent_8d2801b2-c1d3-4566-84eb-8de5b020080f": "against the current minimum and maximum, at a cost of 2 comparisons per element,\n9.2\nSelection in expected linear time\n215\nwe process elements in pairs. We compare pairs of elements from the input ﬁrst\nwith each other, and then we compare the smaller with the current minimum and\nthe larger to the current maximum, at a cost of 3 comparisons for every 2 elements.\nHow we set up initial values for the current minimum and maximum depends\non whether n is odd or even. If n is odd, we set both the minimum and maximum\nto the value of the ﬁrst element, and then we process the rest of the elements in\npairs. If n is even, we perform 1 comparison on the ﬁrst 2 elements to determine\nthe initial values of the minimum and maximum, and then process the rest of the\nelements in pairs as in the case for odd n.\nLet us analyze the total number of comparisons. If n is odd, then we perform\n3 bn=2c comparisons. If n is even, we perform 1 initial comparison followed by\n3.n \u0005 2/=2 comparisons, for a total of 3n=2 \u0005 2. Thus, in either case, the total\nnumber of comparisons is at most 3 bn=2c.\nExercises\n9.1-1\nShow that the second smallest of n elements can be found with n C dlg ne \u0005 2\ncomparisons in the worst case. (Hint: Also ﬁnd the smallest element.)\n9.1-2\n?\nProve the lower bound of d3n=2e \u0005 2 comparisons in the worst case to ﬁnd both\nthe maximum and minimum of n numbers. (Hint: Consider how many numbers\nare potentially either the maximum or minimum, and investigate how a comparison\naffects these counts.)\n9.2\nSelection in expected linear time\nThe general selection problem appears more difﬁcult than the simple problem of\nﬁnding a minimum. Yet, surprisingly, the asymptotic running time for both prob-\nlems is the same: ‚.n/. In this section, we present a divide-and-conquer algorithm\nfor the selection problem. The algorithm RANDOMIZED-SELECT is modeled after\nthe quicksort algorithm of Chapter 7. As in quicksort, we partition the input array",
    "parent_56a30783-2b7a-4e73-b54a-3445831c10e1": "lems is the same: ‚.n/. In this section, we present a divide-and-conquer algorithm\nfor the selection problem. The algorithm RANDOMIZED-SELECT is modeled after\nthe quicksort algorithm of Chapter 7. As in quicksort, we partition the input array\nrecursively. But unlike quicksort, which recursively processes both sides of the\npartition, RANDOMIZED-SELECT works on only one side of the partition. This\ndifference shows up in the analysis: whereas quicksort has an expected running\ntime of ‚.n lg n/, the expected running time of RANDOMIZED-SELECT is ‚.n/,\nassuming that the elements are distinct.\n216\nChapter 9\nMedians and Order Statistics\nRANDOMIZED-SELECT uses the procedure RANDOMIZED-PARTITION intro-\nduced in Section 7.3. Thus, like RANDOMIZED-QUICKSORT, it is a randomized al-\ngorithm, since its behavior is determined in part by the output of a random-number\ngenerator. The following code for RANDOMIZED-SELECT returns the ith smallest\nelement of the array AŒp : : r\u0002.\nRANDOMIZED-SELECT.A; p; r; i/\n1\nif p == r\n2\nreturn AŒp\u0002\n3\nq D RANDOMIZED-PARTITION.A; p; r/\n4\nk D q \u0005 p C 1\n5\nif i == k\n// the pivot value is the answer\n6\nreturn AŒq\u0002\n7\nelseif i < k\n8\nreturn RANDOMIZED-SELECT.A; p; q \u0005 1; i/\n9\nelse return RANDOMIZED-SELECT.A; q C 1; r; i \u0005 k/\nThe RANDOMIZED-SELECT procedure works as follows. Line 1 checks for the\nbase case of the recursion, in which the subarray AŒp : : r\u0002 consists of just one\nelement. In this case, i must equal 1, and we simply return AŒp\u0002 in line 2 as the\nith smallest element. Otherwise, the call to RANDOMIZED-PARTITION in line 3\npartitions the array AŒp : : r\u0002 into two (possibly empty) subarrays AŒp : : q \u0005 1\u0002\nand AŒq C 1 : : r\u0002 such that each element of AŒp : : q \u0005 1\u0002 is less than or equal\nto AŒq\u0002, which in turn is less than each element of AŒq C 1 : : r\u0002. As in quicksort,\nwe will refer to AŒq\u0002 as the pivot element. Line 4 computes the number k of\nelements in the subarray AŒp : : q\u0002, that is, the number of elements in the low side",
    "parent_01d95989-3e96-4bcb-95d1-6b2d974a39be": "to AŒq\u0002, which in turn is less than each element of AŒq C 1 : : r\u0002. As in quicksort,\nwe will refer to AŒq\u0002 as the pivot element. Line 4 computes the number k of\nelements in the subarray AŒp : : q\u0002, that is, the number of elements in the low side\nof the partition, plus one for the pivot element. Line 5 then checks whether AŒq\u0002 is\nthe ith smallest element. If it is, then line 6 returns AŒq\u0002. Otherwise, the algorithm\ndetermines in which of the two subarrays AŒp : : q \u0005 1\u0002 and AŒq C 1 : : r\u0002 the ith\nsmallest element lies. If i < k, then the desired element lies on the low side of\nthe partition, and line 8 recursively selects it from the subarray. If i > k, however,\nthen the desired element lies on the high side of the partition. Since we already\nknow k values that are smaller than the ith smallest element of AŒp : : r\u0002—namely,\nthe elements of AŒp : : q\u0002—the desired element is the .i \u0005 k/th smallest element\nof AŒq C1 : : r\u0002, which line 9 ﬁnds recursively. The code appears to allow recursive\ncalls to subarrays with 0 elements, but Exercise 9.2-1 asks you to show that this\nsituation cannot happen.\nThe worst-case running time for RANDOMIZED-SELECT is ‚.n2/, even to ﬁnd\nthe minimum, because we could be extremely unlucky and always partition around\nthe largest remaining element, and partitioning takes ‚.n/ time. We will see that\n9.2\nSelection in expected linear time\n217\nthe algorithm has a linear expected running time, though, and because it is random-\nized, no particular input elicits the worst-case behavior.\nTo analyze the expected running time of RANDOMIZED-SELECT, we let the run-\nning time on an input array AŒp : : r\u0002 of n elements be a random variable that we\ndenote by T .n/, and we obtain an upper bound on E ŒT .n/\u0002 as follows. The pro-\ncedure RANDOMIZED-PARTITION is equally likely to return any element as the\npivot. Therefore, for each k such that 1 \u0002 k \u0002 n, the subarray AŒp : : q\u0002 has k ele-",
    "parent_d808122b-65cc-45bd-9d1b-bf8715a10dd8": "denote by T .n/, and we obtain an upper bound on E ŒT .n/\u0002 as follows. The pro-\ncedure RANDOMIZED-PARTITION is equally likely to return any element as the\npivot. Therefore, for each k such that 1 \u0002 k \u0002 n, the subarray AŒp : : q\u0002 has k ele-\nments (all less than or equal to the pivot) with probability 1=n. For k D 1; 2; : : : ; n,\nwe deﬁne indicator random variables Xk where\nXk D I fthe subarray AŒp : : q\u0002 has exactly k elementsg ;\nand so, assuming that the elements are distinct, we have\nE ŒXk\u0002 D 1=n :\n(9.1)\nWhen we call RANDOMIZED-SELECT and choose AŒq\u0002 as the pivot element, we\ndo not know, a priori, if we will terminate immediately with the correct answer,\nrecurse on the subarray AŒp : : q \u0005 1\u0002, or recurse on the subarray AŒq C 1 : : r\u0002.\nThis decision depends on where the ith smallest element falls relative to AŒq\u0002.\nAssuming that T .n/ is monotonically increasing, we can upper-bound the time\nneeded for the recursive call by the time needed for the recursive call on the largest\npossible input. In other words, to obtain an upper bound, we assume that the ith\nelement is always on the side of the partition with the greater number of elements.\nFor a given call of RANDOMIZED-SELECT, the indicator random variable Xk has\nthe value 1 for exactly one value of k, and it is 0 for all other k. When Xk D 1, the\ntwo subarrays on which we might recurse have sizes k \u0005 1 and n \u0005 k. Hence, we\nhave the recurrence\nT .n/\n\u0002\nn\nX\nkD1\nXk \u0003 .T .max.k \u0005 1; n \u0005 k// C O.n//\nD\nn\nX\nkD1\nXk \u0003 T .max.k \u0005 1; n \u0005 k// C O.n/ :\n218\nChapter 9\nMedians and Order Statistics\nTaking expected values, we have\nE ŒT .n/\u0002\n\u0002 E\n\" n\nX\nkD1\nXk \u0003 T .max.k \u0005 1; n \u0005 k// C O.n/\n#\nD\nn\nX\nkD1\nE ŒXk \u0003 T .max.k \u0005 1; n \u0005 k//\u0002 C O.n/\n(by linearity of expectation)\nD\nn\nX\nkD1\nE ŒXk\u0002 \u0003 E ŒT .max.k \u0005 1; n \u0005 k//\u0002 C O.n/ (by equation (C.24))\nD\nn\nX\nkD1\n1\nn \u0003 E ŒT .max.k \u0005 1; n \u0005 k//\u0002 C O.n/\n(by equation (9.1)) .\nIn order to apply equation (C.24), we rely on Xk and T .max.k \u0005 1; n \u0005 k// being",
    "parent_75c0826d-36d7-4932-825a-76a7d0785fd6": "X\nkD1\nE ŒXk \u0003 T .max.k \u0005 1; n \u0005 k//\u0002 C O.n/\n(by linearity of expectation)\nD\nn\nX\nkD1\nE ŒXk\u0002 \u0003 E ŒT .max.k \u0005 1; n \u0005 k//\u0002 C O.n/ (by equation (C.24))\nD\nn\nX\nkD1\n1\nn \u0003 E ŒT .max.k \u0005 1; n \u0005 k//\u0002 C O.n/\n(by equation (9.1)) .\nIn order to apply equation (C.24), we rely on Xk and T .max.k \u0005 1; n \u0005 k// being\nindependent random variables. Exercise 9.2-2 asks you to justify this assertion.\nLet us consider the expression max.k \u0005 1; n \u0005 k/. We have\nmax.k \u0005 1; n \u0005 k/ D\n(\nk \u0005 1\nif k > dn=2e ;\nn \u0005 k\nif k \u0002 dn=2e :\nIf n is even, each term from T .dn=2e/ up to T .n \u0005 1/ appears exactly twice in\nthe summation, and if n is odd, all these terms appear twice and T .bn=2c/ appears\nonce. Thus, we have\nE ŒT .n/\u0002 \u0002 2\nn\nn\u00031\nX\nkDbn=2c\nE ŒT .k/\u0002 C O.n/ :\nWe show that E ŒT .n/\u0002 D O.n/ by substitution. Assume that E ŒT .n/\u0002 \u0002 cn for\nsome constant c that satisﬁes the initial conditions of the recurrence. We assume\nthat T .n/ D O.1/ for n less than some constant; we shall pick this constant later.\nWe also pick a constant a such that the function described by the O.n/ term above\n(which describes the non-recursive component of the running time of the algo-\nrithm) is bounded from above by an for all n > 0. Using this inductive hypothesis,\nwe have\nE ŒT .n/\u0002\n\u0002\n2\nn\nn\u00031\nX\nkDbn=2c\nck C an\nD\n2c\nn\n n\u00031\nX\nkD1\nk \u0005\nbn=2c\u00031\nX\nkD1\nk\n!\nC an\n9.2\nSelection in expected linear time\n219\nD\n2c\nn\n\u0002.n \u0005 1/n\n2\n\u0005 .bn=2c \u0005 1/ bn=2c\n2\n\u0003\nC an\n\u0002\n2c\nn\n\u0002.n \u0005 1/n\n2\n\u0005 .n=2 \u0005 2/.n=2 \u0005 1/\n2\n\u0003\nC an\nD\n2c\nn\n\u0002n2 \u0005 n\n2\n\u0005 n2=4 \u0005 3n=2 C 2\n2\n\u0003\nC an\nD\nc\nn\n\u00023n2\n4\nC n\n2 \u0005 2\n\u0003\nC an\nD\nc\n\u00023n\n4 C 1\n2 \u0005 2\nn\n\u0003\nC an\n\u0002\n3cn\n4\nC c\n2 C an\nD\ncn \u0005\n\u0004cn\n4 \u0005 c\n2 \u0005 an\n\u0005\n:\nIn order to complete the proof, we need to show that for sufﬁciently large n, this\nlast expression is at most cn or, equivalently, that cn=4 \u0005 c=2 \u0005 an \u0006 0. If we\nadd c=2 to both sides and factor out n, we get n.c=4 \u0005 a/ \u0006 c=2. As long as we\nchoose the constant c so that c=4 \u0005 a > 0, i.e., c > 4a, we can divide both sides\nby c=4 \u0005 a, giving\nn \u0006\nc=2\nc=4 \u0005 a D\n2c\nc \u0005 4a :",
    "parent_25e0c71f-1f9b-48e0-b1e6-962b5c37f30a": "last expression is at most cn or, equivalently, that cn=4 \u0005 c=2 \u0005 an \u0006 0. If we\nadd c=2 to both sides and factor out n, we get n.c=4 \u0005 a/ \u0006 c=2. As long as we\nchoose the constant c so that c=4 \u0005 a > 0, i.e., c > 4a, we can divide both sides\nby c=4 \u0005 a, giving\nn \u0006\nc=2\nc=4 \u0005 a D\n2c\nc \u0005 4a :\nThus, if we assume that T .n/ D O.1/ for n < 2c=.c\u00054a/, then E ŒT .n/\u0002 D O.n/.\nWe conclude that we can ﬁnd any order statistic, and in particular the median, in\nexpected linear time, assuming that the elements are distinct.\nExercises\n9.2-1\nShow that RANDOMIZED-SELECT never makes a recursive call to a 0-length array.\n9.2-2\nArgue that the indicator random variable Xk and the value T .max.k \u0005 1; n \u0005 k//\nare independent.\n9.2-3\nWrite an iterative version of RANDOMIZED-SELECT.\n220\nChapter 9\nMedians and Order Statistics\n9.2-4\nSuppose we use RANDOMIZED-SELECT to select the minimum element of the\narray A D h3; 2; 9; 0; 7; 5; 4; 8; 6; 1i. Describe a sequence of partitions that results\nin a worst-case performance of RANDOMIZED-SELECT.\n9.3\nSelection in worst-case linear time\nWe now examine a selection algorithm whose running time is O.n/ in the worst\ncase. Like RANDOMIZED-SELECT, the algorithm SELECT ﬁnds the desired ele-\nment by recursively partitioning the input array. Here, however, we guarantee a\ngood split upon partitioning the array. SELECT uses the deterministic partitioning\nalgorithm PARTITION from quicksort (see Section 7.1), but modiﬁed to take the\nelement to partition around as an input parameter.\nThe SELECT algorithm determines the ith smallest of an input array of n > 1\ndistinct elements by executing the following steps. (If n D 1, then SELECT merely\nreturns its only input value as the ith smallest.)\n1. Divide the n elements of the input array into bn=5c groups of 5 elements each\nand at most one group made up of the remaining n mod 5 elements.\n2. Find the median of each of the dn=5e groups by ﬁrst insertion-sorting the ele-",
    "parent_e15a42ed-2634-4ae5-acca-882f892c4ccc": "returns its only input value as the ith smallest.)\n1. Divide the n elements of the input array into bn=5c groups of 5 elements each\nand at most one group made up of the remaining n mod 5 elements.\n2. Find the median of each of the dn=5e groups by ﬁrst insertion-sorting the ele-\nments of each group (of which there are at most 5) and then picking the median\nfrom the sorted list of group elements.\n3. Use SELECT recursively to ﬁnd the median x of the dn=5e medians found in\nstep 2. (If there are an even number of medians, then by our convention, x is\nthe lower median.)\n4. Partition the input array around the median-of-medians x using the modiﬁed\nversion of PARTITION. Let k be one more than the number of elements on the\nlow side of the partition, so that x is the kth smallest element and there are n\u0005k\nelements on the high side of the partition.\n5. If i D k, then return x. Otherwise, use SELECT recursively to ﬁnd the ith\nsmallest element on the low side if i < k, or the .i \u0005 k/th smallest element on\nthe high side if i > k.\nTo analyze the running time of SELECT, we ﬁrst determine a lower bound on the\nnumber of elements that are greater than the partitioning element x. Figure 9.1\nhelps us to visualize this bookkeeping.\nAt least half of the medians found in\n9.3\nSelection in worst-case linear time\n221\nx\nFigure 9.1\nAnalysis of the algorithm SELECT. The n elements are represented by small circles,\nand each group of 5 elements occupies a column. The medians of the groups are whitened, and the\nmedian-of-medians x is labeled. (When ﬁnding the median of an even number of elements, we use\nthe lower median.) Arrows go from larger elements to smaller, from which we can see that 3 out\nof every full group of 5 elements to the right of x are greater than x, and 3 out of every group of 5\nelements to the left of x are less than x. The elements known to be greater than x appear on a shaded\nbackground.\nstep 2 are greater than or equal to the median-of-medians x.1 Thus, at least half",
    "parent_20032352-2e8d-4f8d-b8e7-4e27c79ee0e8": "of every full group of 5 elements to the right of x are greater than x, and 3 out of every group of 5\nelements to the left of x are less than x. The elements known to be greater than x appear on a shaded\nbackground.\nstep 2 are greater than or equal to the median-of-medians x.1 Thus, at least half\nof the dn=5e groups contribute at least 3 elements that are greater than x, except\nfor the one group that has fewer than 5 elements if 5 does not divide n exactly, and\nthe one group containing x itself. Discounting these two groups, it follows that the\nnumber of elements greater than x is at least\n3\n\u0002\u00061\n2\nln\n5\nm\u0007\n\u0005 2\n\u0003\n\u0006 3n\n10 \u0005 6 :\nSimilarly, at least 3n=10 \u0005 6 elements are less than x. Thus, in the worst case,\nstep 5 calls SELECT recursively on at most 7n=10 C 6 elements.\nWe can now develop a recurrence for the worst-case running time T .n/ of the\nalgorithm SELECT. Steps 1, 2, and 4 take O.n/ time. (Step 2 consists of O.n/\ncalls of insertion sort on sets of size O.1/.) Step 3 takes time T .dn=5e/, and step 5\ntakes time at most T .7n=10 C 6/, assuming that T is monotonically increasing.\nWe make the assumption, which seems unmotivated at ﬁrst, that any input of fewer\nthan 140 elements requires O.1/ time; the origin of the magic constant 140 will be\nclear shortly. We can therefore obtain the recurrence\n1Because of our assumption that the numbers are distinct, all medians except x are either greater\nthan or less than x.\n222\nChapter 9\nMedians and Order Statistics\nT .n/ \u0002\n(\nO.1/\nif n < 140 ;\nT .dn=5e/ C T .7n=10 C 6/ C O.n/\nif n \u0006 140 :\nWe show that the running time is linear by substitution. More speciﬁcally, we will\nshow that T .n/ \u0002 cn for some suitably large constant c and all n > 0. We begin by\nassuming that T .n/ \u0002 cn for some suitably large constant c and all n < 140; this\nassumption holds if c is large enough. We also pick a constant a such that the func-\ntion described by the O.n/ term above (which describes the non-recursive compo-",
    "parent_1a009eb1-c81c-482e-8038-71cbbef39d8e": "assuming that T .n/ \u0002 cn for some suitably large constant c and all n < 140; this\nassumption holds if c is large enough. We also pick a constant a such that the func-\ntion described by the O.n/ term above (which describes the non-recursive compo-\nnent of the running time of the algorithm) is bounded above by an for all n > 0.\nSubstituting this inductive hypothesis into the right-hand side of the recurrence\nyields\nT .n/\n\u0002\nc dn=5e C c.7n=10 C 6/ C an\n\u0002\ncn=5 C c C 7cn=10 C 6c C an\nD\n9cn=10 C 7c C an\nD\ncn C .\u0005cn=10 C 7c C an/ ;\nwhich is at most cn if\n\u0005cn=10 C 7c C an \u0002 0 :\n(9.2)\nInequality (9.2) is equivalent to the inequality c \u0006 10a.n=.n \u0005 70// when n > 70.\nBecause we assume that n \u0006 140, we have n=.n \u0005 70/ \u0002 2, and so choos-\ning c \u0006 20a will satisfy inequality (9.2). (Note that there is nothing special about\nthe constant 140; we could replace it by any integer strictly greater than 70 and\nthen choose c accordingly.) The worst-case running time of SELECT is therefore\nlinear.\nAs in a comparison sort (see Section 8.1), SELECT and RANDOMIZED-SELECT\ndetermine information about the relative order of elements only by comparing ele-\nments. Recall from Chapter 8 that sorting requires \u0004.n lg n/ time in the compari-\nson model, even on average (see Problem 8-1). The linear-time sorting algorithms\nin Chapter 8 make assumptions about the input. In contrast, the linear-time se-\nlection algorithms in this chapter do not require any assumptions about the input.\nThey are not subject to the \u0004.n lg n/ lower bound because they manage to solve\nthe selection problem without sorting. Thus, solving the selection problem by sort-\ning and indexing, as presented in the introduction to this chapter, is asymptotically\ninefﬁcient.\n9.3\nSelection in worst-case linear time\n223\nExercises\n9.3-1\nIn the algorithm SELECT, the input elements are divided into groups of 5. Will\nthe algorithm work in linear time if they are divided into groups of 7? Argue that",
    "parent_5e48475d-0c49-4dde-8b7c-ba3fce81b7ba": "inefﬁcient.\n9.3\nSelection in worst-case linear time\n223\nExercises\n9.3-1\nIn the algorithm SELECT, the input elements are divided into groups of 5. Will\nthe algorithm work in linear time if they are divided into groups of 7? Argue that\nSELECT does not run in linear time if groups of 3 are used.\n9.3-2\nAnalyze SELECT to show that if n \u0006 140, then at least dn=4e elements are greater\nthan the median-of-medians x and at least dn=4e elements are less than x.\n9.3-3\nShow how quicksort can be made to run in O.n lg n/ time in the worst case, as-\nsuming that all elements are distinct.\n9.3-4\n?\nSuppose that an algorithm uses only comparisons to ﬁnd the ith smallest element\nin a set of n elements. Show that it can also ﬁnd the i \u0005 1 smaller elements and\nthe n \u0005 i larger elements without performing any additional comparisons.\n9.3-5\nSuppose that you have a “black-box” worst-case linear-time median subroutine.\nGive a simple, linear-time algorithm that solves the selection problem for an arbi-\ntrary order statistic.\n9.3-6\nThe kth quantiles of an n-element set are the k \u0005 1 order statistics that divide the\nsorted set into k equal-sized sets (to within 1). Give an O.n lg k/-time algorithm\nto list the kth quantiles of a set.\n9.3-7\nDescribe an O.n/-time algorithm that, given a set S of n distinct numbers and\na positive integer k \u0002 n, determines the k numbers in S that are closest to the\nmedian of S.\n9.3-8\nLet XŒ1 : : n\u0002 and Y Œ1 : : n\u0002 be two arrays, each containing n numbers already in\nsorted order. Give an O.lg n/-time algorithm to ﬁnd the median of all 2n elements\nin arrays X and Y .\n9.3-9\nProfessor Olay is consulting for an oil company, which is planning a large pipeline\nrunning east to west through an oil ﬁeld of n wells. The company wants to connect\n224\nChapter 9\nMedians and Order Statistics\nFigure 9.2\nProfessor Olay needs to determine the position of the east-west oil pipeline that mini-\nmizes the total length of the north-south spurs.",
    "parent_ed2cd677-b387-4a8b-bfec-ec688e0afa08": "running east to west through an oil ﬁeld of n wells. The company wants to connect\n224\nChapter 9\nMedians and Order Statistics\nFigure 9.2\nProfessor Olay needs to determine the position of the east-west oil pipeline that mini-\nmizes the total length of the north-south spurs.\na spur pipeline from each well directly to the main pipeline along a shortest route\n(either north or south), as shown in Figure 9.2. Given the x- and y-coordinates of\nthe wells, how should the professor pick the optimal location of the main pipeline,\nwhich would be the one that minimizes the total length of the spurs? Show how to\ndetermine the optimal location in linear time.\nProblems\n9-1\nLargest i numbers in sorted order\nGiven a set of n numbers, we wish to ﬁnd the i largest in sorted order using a\ncomparison-based algorithm. Find the algorithm that implements each of the fol-\nlowing methods with the best asymptotic worst-case running time, and analyze the\nrunning times of the algorithms in terms of n and i.\na. Sort the numbers, and list the i largest.\nb. Build a max-priority queue from the numbers, and call EXTRACT-MAX i times.\nc. Use an order-statistic algorithm to ﬁnd the ith largest number, partition around\nthat number, and sort the i largest numbers.\nProblems for Chapter 9\n225\n9-2\nWeighted median\nFor n distinct elements x1; x2; : : : ; xn with positive weights w1; w2; : : : ; wn such\nthat Pn\niD1 wi D 1, the weighted (lower) median is the element xk satisfying\nX\nxi<xk\nwi < 1\n2\nand\nX\nxi>xk\nwi \u0002 1\n2 :\nFor example, if the elements are 0:1; 0:35; 0:05; 0:1; 0:15; 0:05; 0:2 and each ele-\nment equals its weight (that is, wi D xi for i D 1; 2; : : : ; 7), then the median is 0:1,\nbut the weighted median is 0:2.\na. Argue that the median of x1; x2; : : : ; xn is the weighted median of the xi with\nweights wi D 1=n for i D 1; 2; : : : ; n.\nb. Show how to compute the weighted median of n elements in O.n lg n/ worst-\ncase time using sorting.",
    "parent_b887e1ea-e232-4463-b5be-702c6151c2bd": "but the weighted median is 0:2.\na. Argue that the median of x1; x2; : : : ; xn is the weighted median of the xi with\nweights wi D 1=n for i D 1; 2; : : : ; n.\nb. Show how to compute the weighted median of n elements in O.n lg n/ worst-\ncase time using sorting.\nc. Show how to compute the weighted median in ‚.n/ worst-case time using a\nlinear-time median algorithm such as SELECT from Section 9.3.\nThe post-ofﬁce location problem is deﬁned as follows. We are given n points\np1; p2; : : : ; pn with associated weights w1; w2; : : : ; wn. We wish to ﬁnd a point p\n(not necessarily one of the input points) that minimizes the sum Pn\niD1 wi d.p; pi/,\nwhere d.a; b/ is the distance between points a and b.\nd. Argue that the weighted median is a best solution for the 1-dimensional post-\nofﬁce location problem, in which points are simply real numbers and the dis-\ntance between points a and b is d.a; b/ D ja \u0005 bj.\ne. Find the best solution for the 2-dimensional post-ofﬁce location problem, in\nwhich the points are .x; y/ coordinate pairs and the distance between points\na D .x1; y1/ and b D .x2; y2/ is the Manhattan distance given by d.a; b/ D\njx1 \u0005 x2j C jy1 \u0005 y2j.\n9-3\nSmall order statistics\nWe showed that the worst-case number T .n/ of comparisons used by SELECT\nto select the ith order statistic from n numbers satisﬁes T .n/ D ‚.n/, but the\nconstant hidden by the ‚-notation is rather large. When i is small relative to n, we\ncan implement a different procedure that uses SELECT as a subroutine but makes\nfewer comparisons in the worst case.\n226\nChapter 9\nMedians and Order Statistics\na. Describe an algorithm that uses Ui.n/ comparisons to ﬁnd the ith smallest of n\nelements, where\nUi.n/ D\n(\nT .n/\nif i \u0006 n=2 ;\nbn=2c C Ui.dn=2e/ C T .2i/\notherwise :\n(Hint: Begin with bn=2c disjoint pairwise comparisons, and recurse on the set\ncontaining the smaller element from each pair.)\nb. Show that, if i < n=2, then Ui.n/ D n C O.T .2i/ lg.n=i//.",
    "parent_a27edd18-299a-487f-9bf5-d0f88ab83c68": "elements, where\nUi.n/ D\n(\nT .n/\nif i \u0006 n=2 ;\nbn=2c C Ui.dn=2e/ C T .2i/\notherwise :\n(Hint: Begin with bn=2c disjoint pairwise comparisons, and recurse on the set\ncontaining the smaller element from each pair.)\nb. Show that, if i < n=2, then Ui.n/ D n C O.T .2i/ lg.n=i//.\nc. Show that if i is a constant less than n=2, then Ui.n/ D n C O.lg n/.\nd. Show that if i D n=k for k \u0006 2, then Ui.n/ D n C O.T .2n=k/ lg k/.\n9-4\nAlternative analysis of randomized selection\nIn this problem, we use indicator random variables to analyze the RANDOMIZED-\nSELECT procedure in a manner akin to our analysis of RANDOMIZED-QUICKSORT\nin Section 7.4.2.\nAs in the quicksort analysis, we assume that all elements are distinct, and we\nrename the elements of the input array A as ´1; ´2; : : : ; ´n, where ´i is the ith\nsmallest element. Thus, the call RANDOMIZED-SELECT.A; 1; n; k/ returns ´k.\nFor 1 \u0002 i < j \u0002 n, let\nXijk D I f´i is compared with ´j sometime during the execution of the algorithm\nto ﬁnd ´kg :\na. Give an exact expression for E ŒXijk\u0002. (Hint: Your expression may have differ-\nent values, depending on the values of i, j , and k.)\nb. Let Xk denote the total number of comparisons between elements of array A\nwhen ﬁnding ´k. Show that\nE ŒXk\u0002 \u0002 2\n k\nX\niD1\nn\nX\njDk\n1\nj \u0005 i C 1 C\nn\nX\njDkC1\nj \u0005 k \u0005 1\nj \u0005 k C 1 C\nk\u00032\nX\niD1\nk \u0005 i \u0005 1\nk \u0005 i C 1\n!\n:\nc. Show that E ŒXk\u0002 \u0002 4n.\nd. Conclude that, assuming all elements of array A are distinct, RANDOMIZED-\nSELECT runs in expected time O.n/.\nNotes for Chapter 9\n227\nChapter notes\nThe worst-case linear-time median-ﬁnding algorithm was devised by Blum, Floyd,\nPratt, Rivest, and Tarjan [50]. The fast randomized version is due to Hoare [169].\nFloyd and Rivest [108] have developed an improved randomized version that parti-\ntions around an element recursively selected from a small sample of the elements.\nIt is still unknown exactly how many comparisons are needed to determine the\nmedian. Bent and John [41] gave a lower bound of 2n comparisons for median",
    "parent_2c2f378b-a326-422f-9d73-76d69b3cc174": "tions around an element recursively selected from a small sample of the elements.\nIt is still unknown exactly how many comparisons are needed to determine the\nmedian. Bent and John [41] gave a lower bound of 2n comparisons for median\nﬁnding, and Sch¨onhage, Paterson, and Pippenger [302] gave an upper bound of 3n.\nDor and Zwick have improved on both of these bounds. Their upper bound [93]\nis slightly less than 2:95n, and their lower bound [94] is .2 C \b/n, for a small\npositive constant \b, thereby improving slightly on related work by Dor et al. [92].\nPaterson [272] describes some of these results along with other related work.\nIII\nData Structures\nIntroduction\nSets are as fundamental to computer science as they are to mathematics. Whereas\nmathematical sets are unchanging, the sets manipulated by algorithms can grow,\nshrink, or otherwise change over time. We call such sets dynamic. The next ﬁve\nchapters present some basic techniques for representing ﬁnite dynamic sets and\nmanipulating them on a computer.\nAlgorithms may require several different types of operations to be performed on\nsets. For example, many algorithms need only the ability to insert elements into,\ndelete elements from, and test membership in a set. We call a dynamic set that\nsupports these operations a dictionary. Other algorithms require more complicated\noperations. For example, min-priority queues, which Chapter 6 introduced in the\ncontext of the heap data structure, support the operations of inserting an element\ninto and extracting the smallest element from a set. The best way to implement a\ndynamic set depends upon the operations that must be supported.\nElements of a dynamic set\nIn a typical implementation of a dynamic set, each element is represented by an\nobject whose attributes can be examined and manipulated if we have a pointer to\nthe object. (Section 10.3 discusses the implementation of objects and pointers in\nprogramming environments that do not contain them as basic data types.) Some",
    "parent_723c7288-c988-423f-a5d9-73a60969f997": "object whose attributes can be examined and manipulated if we have a pointer to\nthe object. (Section 10.3 discusses the implementation of objects and pointers in\nprogramming environments that do not contain them as basic data types.) Some\nkinds of dynamic sets assume that one of the object’s attributes is an identifying\nkey. If the keys are all different, we can think of the dynamic set as being a set\nof key values. The object may contain satellite data, which are carried around in\nother object attributes but are otherwise unused by the set implementation. It may\n230\nPart III\nData Structures\nalso have attributes that are manipulated by the set operations; these attributes may\ncontain data or pointers to other objects in the set.\nSome dynamic sets presuppose that the keys are drawn from a totally ordered\nset, such as the real numbers, or the set of all words under the usual alphabetic\nordering. A total ordering allows us to deﬁne the minimum element of the set, for\nexample, or to speak of the next element larger than a given element in a set.\nOperations on dynamic sets\nOperations on a dynamic set can be grouped into two categories: queries, which\nsimply return information about the set, and modifying operations, which change\nthe set. Here is a list of typical operations. Any speciﬁc application will usually\nrequire only a few of these to be implemented.\nSEARCH.S; k/\nA query that, given a set S and a key value k, returns a pointer x to an element\nin S such that x:key D k, or NIL if no such element belongs to S.\nINSERT.S; x/\nA modifying operation that augments the set S with the element pointed to\nby x. We usually assume that any attributes in element x needed by the set\nimplementation have already been initialized.\nDELETE.S; x/\nA modifying operation that, given a pointer x to an element in the set S, re-\nmoves x from S. (Note that this operation takes a pointer to an element x, not\na key value.)\nMINIMUM.S/",
    "parent_4595547a-5808-41dc-8504-3d2e8c10d098": "implementation have already been initialized.\nDELETE.S; x/\nA modifying operation that, given a pointer x to an element in the set S, re-\nmoves x from S. (Note that this operation takes a pointer to an element x, not\na key value.)\nMINIMUM.S/\nA query on a totally ordered set S that returns a pointer to the element of S\nwith the smallest key.\nMAXIMUM.S/\nA query on a totally ordered set S that returns a pointer to the element of S\nwith the largest key.\nSUCCESSOR.S; x/\nA query that, given an element x whose key is from a totally ordered set S,\nreturns a pointer to the next larger element in S, or NIL if x is the maximum\nelement.\nPREDECESSOR.S; x/\nA query that, given an element x whose key is from a totally ordered set S,\nreturns a pointer to the next smaller element in S, or NIL if x is the minimum\nelement.\nPart III\nData Structures\n231\nIn some situations, we can extend the queries SUCCESSOR and PREDECESSOR\nso that they apply to sets with nondistinct keys. For a set on n keys, the normal\npresumption is that a call to MINIMUM followed by n \u0005 1 calls to SUCCESSOR\nenumerates the elements in the set in sorted order.\nWe usually measure the time taken to execute a set operation in terms of the size\nof the set. For example, Chapter 13 describes a data structure that can support any\nof the operations listed above on a set of size n in time O.lg n/.\nOverview of Part III\nChapters 10–14 describe several data structures that we can use to implement\ndynamic sets; we shall use many of these later to construct efﬁcient algorithms\nfor a variety of problems. We already saw another important data structure—the\nheap—in Chapter 6.\nChapter 10 presents the essentials of working with simple data structures such\nas stacks, queues, linked lists, and rooted trees. It also shows how to implement\nobjects and pointers in programming environments that do not support them as\nprimitives. If you have taken an introductory programming course, then much of\nthis material should be familiar to you.",
    "parent_d396a4bd-4ded-467d-82cc-b22ca90a7eae": "as stacks, queues, linked lists, and rooted trees. It also shows how to implement\nobjects and pointers in programming environments that do not support them as\nprimitives. If you have taken an introductory programming course, then much of\nthis material should be familiar to you.\nChapter 11 introduces hash tables, which support the dictionary operations IN-\nSERT, DELETE, and SEARCH. In the worst case, hashing requires ‚.n/ time to per-\nform a SEARCH operation, but the expected time for hash-table operations is O.1/.\nThe analysis of hashing relies on probability, but most of the chapter requires no\nbackground in the subject.\nBinary search trees, which are covered in Chapter 12, support all the dynamic-\nset operations listed above. In the worst case, each operation takes ‚.n/ time on a\ntree with n elements, but on a randomly built binary search tree, the expected time\nfor each operation is O.lg n/. Binary search trees serve as the basis for many other\ndata structures.\nChapter 13 introduces red-black trees, which are a variant of binary search trees.\nUnlike ordinary binary search trees, red-black trees are guaranteed to perform well:\noperations take O.lg n/ time in the worst case. A red-black tree is a balanced search\ntree; Chapter 18 in Part V presents another kind of balanced search tree, called a\nB-tree. Although the mechanics of red-black trees are somewhat intricate, you can\nglean most of their properties from the chapter without studying the mechanics in\ndetail. Nevertheless, you probably will ﬁnd walking through the code to be quite\ninstructive.\nIn Chapter 14, we show how to augment red-black trees to support operations\nother than the basic ones listed above. First, we augment them so that we can\ndynamically maintain order statistics for a set of keys. Then, we augment them in\na different way to maintain intervals of real numbers.\n10\nElementary Data Structures\nIn this chapter, we examine the representation of dynamic sets by simple data struc-",
    "parent_94c380e8-b4b4-49e4-958a-d4f7a635fe12": "dynamically maintain order statistics for a set of keys. Then, we augment them in\na different way to maintain intervals of real numbers.\n10\nElementary Data Structures\nIn this chapter, we examine the representation of dynamic sets by simple data struc-\ntures that use pointers. Although we can construct many complex data structures\nusing pointers, we present only the rudimentary ones: stacks, queues, linked lists,\nand rooted trees. We also show ways to synthesize objects and pointers from ar-\nrays.\n10.1\nStacks and queues\nStacks and queues are dynamic sets in which the element removed from the set\nby the DELETE operation is prespeciﬁed. In a stack, the element deleted from\nthe set is the one most recently inserted: the stack implements a last-in, ﬁrst-out,\nor LIFO, policy. Similarly, in a queue, the element deleted is always the one that\nhas been in the set for the longest time: the queue implements a ﬁrst-in, ﬁrst-out,\nor FIFO, policy. There are several efﬁcient ways to implement stacks and queues\non a computer. In this section we show how to use a simple array to implement\neach.\nStacks\nThe INSERT operation on a stack is often called PUSH, and the DELETE opera-\ntion, which does not take an element argument, is often called POP. These names\nare allusions to physical stacks, such as the spring-loaded stacks of plates used\nin cafeterias. The order in which plates are popped from the stack is the reverse\nof the order in which they were pushed onto the stack, since only the top plate is\naccessible.\nAs Figure 10.1 shows, we can implement a stack of at most n elements with\nan array SŒ1 : : n\u0002. The array has an attribute S:top that indexes the most recently\n10.1\nStacks and queues\n233\n1\n2\n3\n4\n5\n6\n7\nS 15 6\n2\n9\n1\n2\n3\n4\n5\n6\n7\nS\n15 6\n2\n9 17 3\n1\n2\n3\n4\n5\n6\n7\nS\n15 6\n2\n9 17 3\n(a)\n(b)\n(c)\nS:top D 4\nS:top D 6\nS:top D 5\nFigure 10.1\nAn array implementation of a stack S. Stack elements appear only in the lightly shaded",
    "parent_b6f4e8dd-a51d-44d5-abfd-bbecdfab8c78": "10.1\nStacks and queues\n233\n1\n2\n3\n4\n5\n6\n7\nS 15 6\n2\n9\n1\n2\n3\n4\n5\n6\n7\nS\n15 6\n2\n9 17 3\n1\n2\n3\n4\n5\n6\n7\nS\n15 6\n2\n9 17 3\n(a)\n(b)\n(c)\nS:top D 4\nS:top D 6\nS:top D 5\nFigure 10.1\nAn array implementation of a stack S. Stack elements appear only in the lightly shaded\npositions. (a) Stack S has 4 elements. The top element is 9. (b) Stack S after the calls PUSH.S; 17/\nand PUSH.S; 3/. (c) Stack S after the call POP.S/ has returned the element 3, which is the one most\nrecently pushed. Although element 3 still appears in the array, it is no longer in the stack; the top is\nelement 17.\ninserted element. The stack consists of elements SŒ1 : : S:top\u0002, where SŒ1\u0002 is the\nelement at the bottom of the stack and SŒS:top\u0002 is the element at the top.\nWhen S:top D 0, the stack contains no elements and is empty. We can test to\nsee whether the stack is empty by query operation STACK-EMPTY. If we attempt\nto pop an empty stack, we say the stack underﬂows, which is normally an error.\nIf S:top exceeds n, the stack overﬂows. (In our pseudocode implementation, we\ndon’t worry about stack overﬂow.)\nWe can implement each of the stack operations with just a few lines of code:\nSTACK-EMPTY.S/\n1\nif S:top == 0\n2\nreturn TRUE\n3\nelse return FALSE\nPUSH.S; x/\n1\nS:top D S:top C 1\n2\nSŒS:top\u0002 D x\nPOP.S/\n1\nif STACK-EMPTY.S/\n2\nerror “underﬂow”\n3\nelse S:top D S:top \u0005 1\n4\nreturn SŒS:top C 1\u0002\nFigure 10.1 shows the effects of the modifying operations PUSH and POP. Each of\nthe three stack operations takes O.1/ time.\n234\nChapter 10\nElementary Data Structures\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nQ\n(a)\n15 6\n9\n8\n4\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nQ\n(b)\n15 6\n9\n8\n4\n3\n5\n17\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nQ\n(c)\n15 6\n9\n8\n4\n3\n5\n17\nQ:head D 7\nQ:head D 7\nQ:tail D 12\nQ:tail D 3\nQ:tail D 3\nQ:head D 8\nFigure 10.2\nA queue implemented using an array QŒ1 : : 12\u0002. Queue elements appear only in the\nlightly shaded positions. (a) The queue has 5 elements, in locations QŒ7 : : 11\u0002. (b) The conﬁguration",
    "parent_eb6ba137-825c-4dbc-a4fb-f116e6368c1d": "9\n10\n11\n12\nQ\n(c)\n15 6\n9\n8\n4\n3\n5\n17\nQ:head D 7\nQ:head D 7\nQ:tail D 12\nQ:tail D 3\nQ:tail D 3\nQ:head D 8\nFigure 10.2\nA queue implemented using an array QŒ1 : : 12\u0002. Queue elements appear only in the\nlightly shaded positions. (a) The queue has 5 elements, in locations QŒ7 : : 11\u0002. (b) The conﬁguration\nof the queue after the calls ENQUEUE.Q; 17/, ENQUEUE.Q; 3/, and ENQUEUE.Q; 5/. (c) The\nconﬁguration of the queue after the call DEQUEUE.Q/ returns the key value 15 formerly at the\nhead of the queue. The new head has key 6.\nQueues\nWe call the INSERT operation on a queue ENQUEUE, and we call the DELETE\noperation DEQUEUE; like the stack operation POP, DEQUEUE takes no element ar-\ngument. The FIFO property of a queue causes it to operate like a line of customers\nwaiting to pay a cashier. The queue has a head and a tail. When an element is en-\nqueued, it takes its place at the tail of the queue, just as a newly arriving customer\ntakes a place at the end of the line. The element dequeued is always the one at\nthe head of the queue, like the customer at the head of the line who has waited the\nlongest.\nFigure 10.2 shows one way to implement a queue of at most n \u0005 1 elements\nusing an array QŒ1 : : n\u0002. The queue has an attribute Q:head that indexes, or points\nto, its head. The attribute Q:tail indexes the next location at which a newly arriv-\ning element will be inserted into the queue. The elements in the queue reside in\nlocations Q:head; Q:head C 1; : : : ; Q:tail \u0005 1, where we “wrap around” in the\nsense that location 1 immediately follows location n in a circular order. When\nQ:head D Q:tail, the queue is empty. Initially, we have Q:head D Q:tail D 1.\nIf we attempt to dequeue an element from an empty queue, the queue underﬂows.\n10.1\nStacks and queues\n235\nWhen Q:head D Q:tail C 1, the queue is full, and if we attempt to enqueue an\nelement, then the queue overﬂows.\nIn our procedures ENQUEUE and DEQUEUE, we have omitted the error checking",
    "parent_05650aaa-fea2-40e1-adf0-3da78ffc6cec": "If we attempt to dequeue an element from an empty queue, the queue underﬂows.\n10.1\nStacks and queues\n235\nWhen Q:head D Q:tail C 1, the queue is full, and if we attempt to enqueue an\nelement, then the queue overﬂows.\nIn our procedures ENQUEUE and DEQUEUE, we have omitted the error checking\nfor underﬂow and overﬂow. (Exercise 10.1-4 asks you to supply code that checks\nfor these two error conditions.) The pseudocode assumes that n D Q:length.\nENQUEUE.Q; x/\n1\nQŒQ:tail\u0002 D x\n2\nif Q:tail == Q:length\n3\nQ:tail D 1\n4\nelse Q:tail D Q:tail C 1\nDEQUEUE.Q/\n1\nx D QŒQ:head\u0002\n2\nif Q:head == Q:length\n3\nQ:head D 1\n4\nelse Q:head D Q:head C 1\n5\nreturn x\nFigure 10.2 shows the effects of the ENQUEUE and DEQUEUE operations. Each\noperation takes O.1/ time.\nExercises\n10.1-1\nUsing Figure 10.1 as a model, illustrate the result of each operation in the sequence\nPUSH.S; 4/, PUSH.S; 1/, PUSH.S; 3/, POP.S/, PUSH.S; 8/, and POP.S/ on an\ninitially empty stack S stored in array SŒ1 : : 6\u0002.\n10.1-2\nExplain how to implement two stacks in one array AŒ1 : : n\u0002 in such a way that\nneither stack overﬂows unless the total number of elements in both stacks together\nis n. The PUSH and POP operations should run in O.1/ time.\n10.1-3\nUsing Figure 10.2 as a model, illustrate the result of each operation in the\nsequence ENQUEUE.Q; 4/, ENQUEUE.Q; 1/, ENQUEUE.Q; 3/, DEQUEUE.Q/,\nENQUEUE.Q; 8/, and DEQUEUE.Q/ on an initially empty queue Q stored in\narray QŒ1 : : 6\u0002.\n10.1-4\nRewrite ENQUEUE and DEQUEUE to detect underﬂow and overﬂow of a queue.\n236\nChapter 10\nElementary Data Structures\n10.1-5\nWhereas a stack allows insertion and deletion of elements at only one end, and a\nqueue allows insertion at one end and deletion at the other end, a deque (double-\nended queue) allows insertion and deletion at both ends. Write four O.1/-time\nprocedures to insert elements into and delete elements from both ends of a deque\nimplemented by an array.\n10.1-6\nShow how to implement a queue using two stacks. Analyze the running time of the",
    "parent_f14c91e3-8133-4095-af28-46d5c3de4e93": "ended queue) allows insertion and deletion at both ends. Write four O.1/-time\nprocedures to insert elements into and delete elements from both ends of a deque\nimplemented by an array.\n10.1-6\nShow how to implement a queue using two stacks. Analyze the running time of the\nqueue operations.\n10.1-7\nShow how to implement a stack using two queues. Analyze the running time of the\nstack operations.\n10.2\nLinked lists\nA linked list is a data structure in which the objects are arranged in a linear order.\nUnlike an array, however, in which the linear order is determined by the array\nindices, the order in a linked list is determined by a pointer in each object. Linked\nlists provide a simple, ﬂexible representation for dynamic sets, supporting (though\nnot necessarily efﬁciently) all the operations listed on page 230.\nAs shown in Figure 10.3, each element of a doubly linked list L is an object with\nan attribute key and two other pointer attributes: next and pre\u0003. The object may\nalso contain other satellite data. Given an element x in the list, x:next points to its\nsuccessor in the linked list, and x:pre\u0003 points to its predecessor. If x:pre\u0003 D NIL,\nthe element x has no predecessor and is therefore the ﬁrst element, or head, of\nthe list. If x:next D NIL, the element x has no successor and is therefore the last\nelement, or tail, of the list. An attribute L:head points to the ﬁrst element of the\nlist. If L:head D NIL, the list is empty.\nA list may have one of several forms. It may be either singly linked or doubly\nlinked, it may be sorted or not, and it may be circular or not. If a list is singly\nlinked, we omit the pre\u0003 pointer in each element. If a list is sorted, the linear order\nof the list corresponds to the linear order of keys stored in elements of the list; the\nminimum element is then the head of the list, and the maximum element is the\ntail. If the list is unsorted, the elements can appear in any order. In a circular list,",
    "parent_cb9dae8a-4628-47eb-8c2a-174cc524e97b": "of the list corresponds to the linear order of keys stored in elements of the list; the\nminimum element is then the head of the list, and the maximum element is the\ntail. If the list is unsorted, the elements can appear in any order. In a circular list,\nthe pre\u0003 pointer of the head of the list points to the tail, and the next pointer of\nthe tail of the list points to the head. We can think of a circular list as a ring of\n10.2\nLinked lists\n237\n9\n16\n4\n1\nprev\nkey\nnext\n(a)\n9\n16\n4\n1\n(b)\n25\n9\n16\n1\n(c)\n25\nL:head\nL:head\nL:head\nFigure 10.3\n(a) A doubly linked list L representing the dynamic set f1; 4; 9; 16g. Each element in\nthe list is an object with attributes for the key and pointers (shown by arrows) to the next and previous\nobjects. The next attribute of the tail and the pre\u0003 attribute of the head are NIL, indicated by a diagonal\nslash. The attribute L:head points to the head. (b) Following the execution of LIST-INSERT.L; x/,\nwhere x:key D 25, the linked list has a new object with key 25 as the new head. This new object\npoints to the old head with key 9. (c) The result of the subsequent call LIST-DELETE.L; x/, where x\npoints to the object with key 4.\nelements. In the remainder of this section, we assume that the lists with which we\nare working are unsorted and doubly linked.\nSearching a linked list\nThe procedure LIST-SEARCH.L; k/ ﬁnds the ﬁrst element with key k in list L\nby a simple linear search, returning a pointer to this element. If no object with\nkey k appears in the list, then the procedure returns NIL. For the linked list in\nFigure 10.3(a), the call LIST-SEARCH.L; 4/ returns a pointer to the third element,\nand the call LIST-SEARCH.L; 7/ returns NIL.\nLIST-SEARCH.L; k/\n1\nx D L:head\n2\nwhile x ¤ NIL and x:key ¤ k\n3\nx D x:next\n4\nreturn x\nTo search a list of n objects, the LIST-SEARCH procedure takes ‚.n/ time in the\nworst case, since it may have to search the entire list.\nInserting into a linked list",
    "parent_3610db27-b556-49bd-8b0a-9a60ba91c5ce": "and the call LIST-SEARCH.L; 7/ returns NIL.\nLIST-SEARCH.L; k/\n1\nx D L:head\n2\nwhile x ¤ NIL and x:key ¤ k\n3\nx D x:next\n4\nreturn x\nTo search a list of n objects, the LIST-SEARCH procedure takes ‚.n/ time in the\nworst case, since it may have to search the entire list.\nInserting into a linked list\nGiven an element x whose key attribute has already been set, the LIST-INSERT\nprocedure “splices” x onto the front of the linked list, as shown in Figure 10.3(b).\n238\nChapter 10\nElementary Data Structures\nLIST-INSERT.L; x/\n1\nx:next D L:head\n2\nif L:head ¤ NIL\n3\nL:head:pre\u0003 D x\n4\nL:head D x\n5\nx:pre\u0003 D NIL\n(Recall that our attribute notation can cascade, so that L:head:pre\u0003 denotes the\npre\u0003 attribute of the object that L:head points to.) The running time for LIST-\nINSERT on a list of n elements is O.1/.\nDeleting from a linked list\nThe procedure LIST-DELETE removes an element x from a linked list L. It must\nbe given a pointer to x, and it then “splices” x out of the list by updating pointers.\nIf we wish to delete an element with a given key, we must ﬁrst call LIST-SEARCH\nto retrieve a pointer to the element.\nLIST-DELETE.L; x/\n1\nif x:pre\u0003 ¤ NIL\n2\nx:pre\u0003:next D x:next\n3\nelse L:head D x:next\n4\nif x:next ¤ NIL\n5\nx:next:pre\u0003 D x:pre\u0003\nFigure 10.3(c) shows how an element is deleted from a linked list. LIST-DELETE\nruns in O.1/ time, but if we wish to delete an element with a given key, ‚.n/ time\nis required in the worst case because we must ﬁrst call LIST-SEARCH to ﬁnd the\nelement.\nSentinels\nThe code for LIST-DELETE would be simpler if we could ignore the boundary\nconditions at the head and tail of the list:\nLIST-DELETE0.L; x/\n1\nx:pre\u0003:next D x:next\n2\nx:next:pre\u0003 D x:pre\u0003\nA sentinel is a dummy object that allows us to simplify boundary conditions. For\nexample, suppose that we provide with list L an object L:nil that represents NIL\n10.2\nLinked lists\n239\n9\n16\n4\n1\n9\n16\n4\n1\n25\n9\n16\n4\n25\n(a)\n(b)\n(c)\n(d)\nL:nil\nL:nil\nL:nil\nL:nil\nFigure 10.4",
    "parent_0abe85ad-bff8-4aa5-8374-3a277bfb9987": "2\nx:next:pre\u0003 D x:pre\u0003\nA sentinel is a dummy object that allows us to simplify boundary conditions. For\nexample, suppose that we provide with list L an object L:nil that represents NIL\n10.2\nLinked lists\n239\n9\n16\n4\n1\n9\n16\n4\n1\n25\n9\n16\n4\n25\n(a)\n(b)\n(c)\n(d)\nL:nil\nL:nil\nL:nil\nL:nil\nFigure 10.4\nA circular, doubly linked list with a sentinel. The sentinel L:nil appears between the\nhead and tail. The attribute L:head is no longer needed, since we can access the head of the list\nby L:nil:next. (a) An empty list. (b) The linked list from Figure 10.3(a), with key 9 at the head and\nkey 1 at the tail. (c) The list after executing LIST-INSERT0.L; x/, where x:key D 25. The new object\nbecomes the head of the list. (d) The list after deleting the object with key 1. The new tail is the\nobject with key 4.\nbut has all the attributes of the other objects in the list. Wherever we have a ref-\nerence to NIL in list code, we replace it by a reference to the sentinel L:nil. As\nshown in Figure 10.4, this change turns a regular doubly linked list into a circu-\nlar, doubly linked list with a sentinel, in which the sentinel L:nil lies between the\nhead and tail. The attribute L:nil:next points to the head of the list, and L:nil:pre\u0003\npoints to the tail. Similarly, both the next attribute of the tail and the pre\u0003 at-\ntribute of the head point to L:nil. Since L:nil:next points to the head, we can\neliminate the attribute L:head altogether, replacing references to it by references\nto L:nil:next. Figure 10.4(a) shows that an empty list consists of just the sentinel,\nand both L:nil:next and L:nil:pre\u0003 point to L:nil.\nThe code for LIST-SEARCH remains the same as before, but with the references\nto NIL and L:head changed as speciﬁed above:\nLIST-SEARCH0.L; k/\n1\nx D L:nil:next\n2\nwhile x ¤ L:nil and x:key ¤ k\n3\nx D x:next\n4\nreturn x\nWe use the two-line procedure LIST-DELETE0 from before to delete an element\nfrom the list. The following procedure inserts an element into the list:\n240\nChapter 10",
    "parent_566c033f-5cc5-4235-b35e-7342c0ea079e": "LIST-SEARCH0.L; k/\n1\nx D L:nil:next\n2\nwhile x ¤ L:nil and x:key ¤ k\n3\nx D x:next\n4\nreturn x\nWe use the two-line procedure LIST-DELETE0 from before to delete an element\nfrom the list. The following procedure inserts an element into the list:\n240\nChapter 10\nElementary Data Structures\nLIST-INSERT0.L; x/\n1\nx:next D L:nil:next\n2\nL:nil:next:pre\u0003 D x\n3\nL:nil:next D x\n4\nx:pre\u0003 D L:nil\nFigure 10.4 shows the effects of LIST-INSERT0 and LIST-DELETE0 on a sample list.\nSentinels rarely reduce the asymptotic time bounds of data structure operations,\nbut they can reduce constant factors. The gain from using sentinels within loops\nis usually a matter of clarity of code rather than speed; the linked list code, for\nexample, becomes simpler when we use sentinels, but we save only O.1/ time in\nthe LIST-INSERT0 and LIST-DELETE0 procedures. In other situations, however, the\nuse of sentinels helps to tighten the code in a loop, thus reducing the coefﬁcient of,\nsay, n or n2 in the running time.\nWe should use sentinels judiciously. When there are many small lists, the extra\nstorage used by their sentinels can represent signiﬁcant wasted memory. In this\nbook, we use sentinels only when they truly simplify the code.\nExercises\n10.2-1\nCan you implement the dynamic-set operation INSERT on a singly linked list\nin O.1/ time? How about DELETE?\n10.2-2\nImplement a stack using a singly linked list L. The operations PUSH and POP\nshould still take O.1/ time.\n10.2-3\nImplement a queue by a singly linked list L. The operations ENQUEUE and DE-\nQUEUE should still take O.1/ time.\n10.2-4\nAs written, each loop iteration in the LIST-SEARCH0 procedure requires two tests:\none for x ¤ L:nil and one for x:key ¤ k. Show how to eliminate the test for\nx ¤ L:nil in each iteration.\n10.2-5\nImplement the dictionary operations INSERT, DELETE, and SEARCH using singly\nlinked, circular lists. What are the running times of your procedures?\n10.3\nImplementing pointers and objects\n241\n10.2-6",
    "parent_150e2eeb-4279-48e5-bdd7-79a4e6e126ef": "x ¤ L:nil in each iteration.\n10.2-5\nImplement the dictionary operations INSERT, DELETE, and SEARCH using singly\nlinked, circular lists. What are the running times of your procedures?\n10.3\nImplementing pointers and objects\n241\n10.2-6\nThe dynamic-set operation UNION takes two disjoint sets S1 and S2 as input, and\nit returns a set S D S1 [ S2 consisting of all the elements of S1 and S2. The\nsets S1 and S2 are usually destroyed by the operation. Show how to support UNION\nin O.1/ time using a suitable list data structure.\n10.2-7\nGive a ‚.n/-time nonrecursive procedure that reverses a singly linked list of n\nelements. The procedure should use no more than constant storage beyond that\nneeded for the list itself.\n10.2-8\n?\nExplain how to implement doubly linked lists using only one pointer value x:np per\nitem instead of the usual two (next and pre\u0003). Assume that all pointer values can be\ninterpreted as k-bit integers, and deﬁne x:np to be x:np D x:next XOR x:pre\u0003,\nthe k-bit “exclusive-or” of x:next and x:pre\u0003. (The value NIL is represented by 0.)\nBe sure to describe what information you need to access the head of the list. Show\nhow to implement the SEARCH, INSERT, and DELETE operations on such a list.\nAlso show how to reverse such a list in O.1/ time.\n10.3\nImplementing pointers and objects\nHow do we implement pointers and objects in languages that do not provide them?\nIn this section, we shall see two ways of implementing linked data structures with-\nout an explicit pointer data type. We shall synthesize objects and pointers from\narrays and array indices.\nA multiple-array representation of objects\nWe can represent a collection of objects that have the same attributes by using an\narray for each attribute. As an example, Figure 10.5 shows how we can implement\nthe linked list of Figure 10.3(a) with three arrays. The array key holds the values\nof the keys currently in the dynamic set, and the pointers reside in the arrays next",
    "parent_4b36a1a7-8712-42b7-9416-7acffd552630": "array for each attribute. As an example, Figure 10.5 shows how we can implement\nthe linked list of Figure 10.3(a) with three arrays. The array key holds the values\nof the keys currently in the dynamic set, and the pointers reside in the arrays next\nand pre\u0003. For a given array index x, the array entries keyŒx\u0002, nextŒx\u0002, and pre\u0003Œx\u0002\nrepresent an object in the linked list. Under this interpretation, a pointer x is simply\na common index into the key, next, and pre\u0003 arrays.\nIn Figure 10.3(a), the object with key 4 follows the object with key 16 in the\nlinked list. In Figure 10.5, key 4 appears in keyŒ2\u0002, and key 16 appears in keyŒ5\u0002,\nand so nextŒ5\u0002 D 2 and pre\u0003Œ2\u0002 D 5. Although the constant NIL appears in the next\n242\nChapter 10\nElementary Data Structures\n1\n2\n3\n4\n5\n6\n7\n8\nkey\nnext\nprev\nL\n7\n4\n1\n16\n9\n3\n2\n5\n5\n2\n7\nFigure 10.5\nThe linked list of Figure 10.3(a) represented by the arrays key, next, and pre\u0003. Each\nvertical slice of the arrays represents a single object. Stored pointers correspond to the array indices\nshown at the top; the arrows show how to interpret them. Lightly shaded object positions contain list\nelements. The variable L keeps the index of the head.\nattribute of the tail and the pre\u0003 attribute of the head, we usually use an integer\n(such as 0 or \u00051) that cannot possibly represent an actual index into the arrays. A\nvariable L holds the index of the head of the list.\nA single-array representation of objects\nThe words in a computer memory are typically addressed by integers from 0\nto M \u0005 1, where M is a suitably large integer. In many programming languages,\nan object occupies a contiguous set of locations in the computer memory. A pointer\nis simply the address of the ﬁrst memory location of the object, and we can address\nother memory locations within the object by adding an offset to the pointer.\nWe can use the same strategy for implementing objects in programming envi-\nronments that do not provide explicit pointer data types. For example, Figure 10.6",
    "parent_613641ad-edd9-40b8-9747-986eb3a8a452": "other memory locations within the object by adding an offset to the pointer.\nWe can use the same strategy for implementing objects in programming envi-\nronments that do not provide explicit pointer data types. For example, Figure 10.6\nshows how to use a single array A to store the linked list from Figures 10.3(a)\nand 10.5. An object occupies a contiguous subarray AŒj : : k\u0002. Each attribute of\nthe object corresponds to an offset in the range from 0 to k \u0005 j , and a pointer to\nthe object is the index j . In Figure 10.6, the offsets corresponding to key, next, and\npre\u0003 are 0, 1, and 2, respectively. To read the value of i:pre\u0003, given a pointer i, we\nadd the value i of the pointer to the offset 2, thus reading AŒi C 2\u0002.\nThe single-array representation is ﬂexible in that it permits objects of different\nlengths to be stored in the same array. The problem of managing such a heteroge-\nneous collection of objects is more difﬁcult than the problem of managing a homo-\ngeneous collection, where all objects have the same attributes. Since most of the\ndata structures we shall consider are composed of homogeneous elements, it will\nbe sufﬁcient for our purposes to use the multiple-array representation of objects.\n10.3\nImplementing pointers and objects\n243\n1\n2\n3\n4\n5\n6\n7\n8\nA\nL\n4\n1\n16\n9\n7\n4\n4\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nprev\nnext\nkey\n19\n13\n13\n19\nFigure 10.6\nThe linked list of Figures 10.3(a) and 10.5 represented in a single array A. Each list\nelement is an object that occupies a contiguous subarray of length 3 within the array. The three\nattributes key, next, and pre\u0003 correspond to the offsets 0, 1, and 2, respectively, within each object.\nA pointer to an object is the index of the ﬁrst element of the object. Objects containing list elements\nare lightly shaded, and arrows show the list ordering.\nAllocating and freeing objects\nTo insert a key into a dynamic set represented by a doubly linked list, we must al-",
    "parent_fda01f21-3e00-4d12-8644-5f8359f2825e": "A pointer to an object is the index of the ﬁrst element of the object. Objects containing list elements\nare lightly shaded, and arrows show the list ordering.\nAllocating and freeing objects\nTo insert a key into a dynamic set represented by a doubly linked list, we must al-\nlocate a pointer to a currently unused object in the linked-list representation. Thus,\nit is useful to manage the storage of objects not currently used in the linked-list\nrepresentation so that one can be allocated. In some systems, a garbage collec-\ntor is responsible for determining which objects are unused. Many applications,\nhowever, are simple enough that they can bear responsibility for returning an un-\nused object to a storage manager. We shall now explore the problem of allocating\nand freeing (or deallocating) homogeneous objects using the example of a doubly\nlinked list represented by multiple arrays.\nSuppose that the arrays in the multiple-array representation have length m and\nthat at some moment the dynamic set contains n \u0002 m elements. Then n objects\nrepresent elements currently in the dynamic set, and the remaining m\u0005n objects are\nfree; the free objects are available to represent elements inserted into the dynamic\nset in the future.\nWe keep the free objects in a singly linked list, which we call the free list. The\nfree list uses only the next array, which stores the next pointers within the list.\nThe head of the free list is held in the global variable free. When the dynamic\nset represented by linked list L is nonempty, the free list may be intertwined with\nlist L, as shown in Figure 10.7. Note that each object in the representation is either\nin list L or in the free list, but not in both.\nThe free list acts like a stack: the next object allocated is the last one freed. We\ncan use a list implementation of the stack operations PUSH and POP to implement\nthe procedures for allocating and freeing objects, respectively. We assume that the",
    "parent_faa31f83-78e3-4cfb-a04c-6af633c3fc3b": "in list L or in the free list, but not in both.\nThe free list acts like a stack: the next object allocated is the last one freed. We\ncan use a list implementation of the stack operations PUSH and POP to implement\nthe procedures for allocating and freeing objects, respectively. We assume that the\nglobal variable free used in the following procedures points to the ﬁrst element of\nthe free list.\n244\nChapter 10\nElementary Data Structures\n1\n2\n3\n4\n5\n6\n7\n8\nkey\nnext\nprev\nL\n7\n4\n1\n16\n9\n3\n2\n5\n5\n2\n7\n4\n8\n6\n1\nfree\n(a)\n1\n2\n3\n4\n5\n6\n7\n8\nkey\nnext\nprev\nL\n4\n4\n1\n16\n9\n3\n2\n5\n5\n2\n7\n8\n7\n6\n1\nfree\n(b)\n4\n25\n1\n2\n3\n4\n5\n6\n7\n8\nkey\nnext\nprev\nL\n4\n4\n1\n9\n3\n8\n2\n7\n2\n5\n7\n6\n1\nfree\n(c)\n4\n25\nFigure 10.7\nThe effect of the ALLOCATE-OBJECT and FREE-OBJECT procedures. (a) The list\nof Figure 10.5 (lightly shaded) and a free list (heavily shaded). Arrows show the free-list structure.\n(b) The result of calling ALLOCATE-OBJECT./ (which returns index 4), setting keyŒ4\u0002 to 25, and\ncalling LIST-INSERT.L; 4/. The new free-list head is object 8, which had been nextŒ4\u0002 on the free\nlist. (c) After executing LIST-DELETE.L; 5/, we call FREE-OBJECT.5/. Object 5 becomes the new\nfree-list head, with object 8 following it on the free list.\nALLOCATE-OBJECT./\n1\nif free == NIL\n2\nerror “out of space”\n3\nelse x D free\n4\nfree D x:next\n5\nreturn x\nFREE-OBJECT.x/\n1\nx:next D free\n2\nfree D x\nThe free list initially contains all n unallocated objects. Once the free list has been\nexhausted, running the ALLOCATE-OBJECT procedure signals an error. We can\neven service several linked lists with just a single free list. Figure 10.8 shows two\nlinked lists and a free list intertwined through key, next, and pre\u0003 arrays.\nThe two procedures run in O.1/ time, which makes them quite practical. We\ncan modify them to work for any homogeneous collection of objects by letting any\none of the attributes in the object act like a next attribute in the free list.\n10.3\nImplementing pointers and objects\n245\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nnext\nkey\nprev\nfree\n3\n6\n2\n6\n3\n7\n1\n5",
    "parent_bbcb1673-4f36-4289-bd33-b336e609f487": "can modify them to work for any homogeneous collection of objects by letting any\none of the attributes in the object act like a next attribute in the free list.\n10.3\nImplementing pointers and objects\n245\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nnext\nkey\nprev\nfree\n3\n6\n2\n6\n3\n7\n1\n5\n7\n9\n9\n10\n4\n8\n1\nL2\nL1\nk1 k2 k3\nk5 k6 k7\nk9\nFigure 10.8\nTwo linked lists, L1 (lightly shaded) and L2 (heavily shaded), and a free list (dark-\nened) intertwined.\nExercises\n10.3-1\nDraw a picture of the sequence h13; 4; 8; 19; 5; 11i stored as a doubly linked list\nusing the multiple-array representation. Do the same for the single-array represen-\ntation.\n10.3-2\nWrite the procedures ALLOCATE-OBJECT and FREE-OBJECT for a homogeneous\ncollection of objects implemented by the single-array representation.\n10.3-3\nWhy don’t we need to set or reset the pre\u0003 attributes of objects in the implementa-\ntion of the ALLOCATE-OBJECT and FREE-OBJECT procedures?\n10.3-4\nIt is often desirable to keep all elements of a doubly linked list compact in storage,\nusing, for example, the ﬁrst m index locations in the multiple-array representation.\n(This is the case in a paged, virtual-memory computing environment.) Explain\nhow to implement the procedures ALLOCATE-OBJECT and FREE-OBJECT so that\nthe representation is compact. Assume that there are no pointers to elements of the\nlinked list outside the list itself. (Hint: Use the array implementation of a stack.)\n10.3-5\nLet L be a doubly linked list of length n stored in arrays key, pre\u0003, and next of\nlength m. Suppose that these arrays are managed by ALLOCATE-OBJECT and\nFREE-OBJECT procedures that keep a doubly linked free list F . Suppose further\nthat of the m items, exactly n are on list L and m \u0005 n are on the free list. Write\na procedure COMPACTIFY-LIST.L; F / that, given the list L and the free list F ,\nmoves the items in L so that they occupy array positions 1; 2; : : : ; n and adjusts the\nfree list F so that it remains correct, occupying array positions nC1; nC2; : : : ; m.",
    "parent_9c812085-bbed-47f4-ba08-0faafa56ec8c": "a procedure COMPACTIFY-LIST.L; F / that, given the list L and the free list F ,\nmoves the items in L so that they occupy array positions 1; 2; : : : ; n and adjusts the\nfree list F so that it remains correct, occupying array positions nC1; nC2; : : : ; m.\nThe running time of your procedure should be ‚.n/, and it should use only a\nconstant amount of extra space. Argue that your procedure is correct.\n246\nChapter 10\nElementary Data Structures\n10.4\nRepresenting rooted trees\nThe methods for representing lists given in the previous section extend to any ho-\nmogeneous data structure. In this section, we look speciﬁcally at the problem of\nrepresenting rooted trees by linked data structures. We ﬁrst look at binary trees,\nand then we present a method for rooted trees in which nodes can have an arbitrary\nnumber of children.\nWe represent each node of a tree by an object. As with linked lists, we assume\nthat each node contains a key attribute. The remaining attributes of interest are\npointers to other nodes, and they vary according to the type of tree.\nBinary trees\nFigure 10.9 shows how we use the attributes p, left, and right to store pointers to\nthe parent, left child, and right child of each node in a binary tree T . If x:p D NIL,\nthen x is the root. If node x has no left child, then x:left D NIL, and similarly for\nthe right child. The root of the entire tree T is pointed to by the attribute T:root. If\nT:root D NIL, then the tree is empty.\nRooted trees with unbounded branching\nWe can extend the scheme for representing a binary tree to any class of trees in\nwhich the number of children of each node is at most some constant k: we replace\nthe left and right attributes by child1; child2; : : : ; childk. This scheme no longer\nworks when the number of children of a node is unbounded, since we do not know\nhow many attributes (arrays in the multiple-array representation) to allocate in ad-\nvance. Moreover, even if the number of children k is bounded by a large constant",
    "parent_f6287f30-2bd9-4b81-8442-0c817bce2152": "works when the number of children of a node is unbounded, since we do not know\nhow many attributes (arrays in the multiple-array representation) to allocate in ad-\nvance. Moreover, even if the number of children k is bounded by a large constant\nbut most nodes have a small number of children, we may waste a lot of memory.\nFortunately, there is a clever scheme to represent trees with arbitrary numbers of\nchildren. It has the advantage of using only O.n/ space for any n-node rooted tree.\nThe left-child, right-sibling representation appears in Figure 10.10. As before,\neach node contains a parent pointer p, and T:root points to the root of tree T .\nInstead of having a pointer to each of its children, however, each node x has only\ntwo pointers:\n1. x:left-child points to the leftmost child of node x, and\n2. x:right-sibling points to the sibling of x immediately to its right.\nIf node x has no children, then x:left-child D NIL, and if node x is the rightmost\nchild of its parent, then x:right-sibling D NIL.\n10.4\nRepresenting rooted trees\n247\nT:root\nFigure 10.9\nThe representation of a binary tree T . Each node x has the attributes x:p (top), x:left\n(lower left), and x:right (lower right). The key attributes are not shown.\nT:root\nFigure 10.10\nThe left-child, right-sibling representation of a tree T . Each node x has attributes x:p\n(top), x:left-child (lower left), and x:right-sibling (lower right). The key attributes are not shown.\n248\nChapter 10\nElementary Data Structures\nOther tree representations\nWe sometimes represent rooted trees in other ways. In Chapter 6, for example,\nwe represented a heap, which is based on a complete binary tree, by a single array\nplus the index of the last node in the heap. The trees that appear in Chapter 21 are\ntraversed only toward the root, and so only the parent pointers are present; there\nare no pointers to children. Many other schemes are possible. Which scheme is\nbest depends on the application.\nExercises\n10.4-1",
    "parent_77989624-3ac3-47a5-a263-e0e6dd3e57d6": "plus the index of the last node in the heap. The trees that appear in Chapter 21 are\ntraversed only toward the root, and so only the parent pointers are present; there\nare no pointers to children. Many other schemes are possible. Which scheme is\nbest depends on the application.\nExercises\n10.4-1\nDraw the binary tree rooted at index 6 that is represented by the following at-\ntributes:\nindex\nkey\nleft\nright\n1\n12\n7\n3\n2\n15\n8\nNIL\n3\n4\n10\nNIL\n4\n10\n5\n9\n5\n2\nNIL\nNIL\n6\n18\n1\n4\n7\n7\nNIL\nNIL\n8\n14\n6\n2\n9\n21\nNIL\nNIL\n10\n5\nNIL\nNIL\n10.4-2\nWrite an O.n/-time recursive procedure that, given an n-node binary tree, prints\nout the key of each node in the tree.\n10.4-3\nWrite an O.n/-time nonrecursive procedure that, given an n-node binary tree,\nprints out the key of each node in the tree. Use a stack as an auxiliary data structure.\n10.4-4\nWrite an O.n/-time procedure that prints all the keys of an arbitrary rooted tree\nwith n nodes, where the tree is stored using the left-child, right-sibling representa-\ntion.\n10.4-5\n?\nWrite an O.n/-time nonrecursive procedure that, given an n-node binary tree,\nprints out the key of each node. Use no more than constant extra space outside\nProblems for Chapter 10\n249\nof the tree itself and do not modify the tree, even temporarily, during the proce-\ndure.\n10.4-6\n?\nThe left-child, right-sibling representation of an arbitrary rooted tree uses three\npointers in each node: left-child, right-sibling, and parent. From any node, its\nparent can be reached and identiﬁed in constant time and all its children can be\nreached and identiﬁed in time linear in the number of children. Show how to use\nonly two pointers and one boolean value in each node so that the parent of a node\nor all of its children can be reached and identiﬁed in time linear in the number of\nchildren.\nProblems\n10-1\nComparisons among lists\nFor each of the four types of lists in the following table, what is the asymptotic\nworst-case running time for each dynamic-set operation listed?\nunsorted,\nsorted,",
    "parent_cd2d7d39-b8a8-4ba3-afd7-17332d4200ca": "or all of its children can be reached and identiﬁed in time linear in the number of\nchildren.\nProblems\n10-1\nComparisons among lists\nFor each of the four types of lists in the following table, what is the asymptotic\nworst-case running time for each dynamic-set operation listed?\nunsorted,\nsorted,\nunsorted,\nsorted,\nsingly\nsingly\ndoubly\ndoubly\nlinked\nlinked\nlinked\nlinked\nSEARCH.L; k/\nINSERT.L; x/\nDELETE.L; x/\nSUCCESSOR.L; x/\nPREDECESSOR.L; x/\nMINIMUM.L/\nMAXIMUM.L/\n250\nChapter 10\nElementary Data Structures\n10-2\nMergeable heaps using linked lists\nA mergeable heap supports the following operations: MAKE-HEAP (which creates\nan empty mergeable heap), INSERT, MINIMUM, EXTRACT-MIN, and UNION.1\nShow how to implement mergeable heaps using linked lists in each of the following\ncases. Try to make each operation as efﬁcient as possible. Analyze the running\ntime of each operation in terms of the size of the dynamic set(s) being operated on.\na. Lists are sorted.\nb. Lists are unsorted.\nc. Lists are unsorted, and dynamic sets to be merged are disjoint.\n10-3\nSearching a sorted compact list\nExercise 10.3-4 asked how we might maintain an n-element list compactly in the\nﬁrst n positions of an array. We shall assume that all keys are distinct and that the\ncompact list is also sorted, that is, keyŒi\u0002 < keyŒnextŒi\u0002\u0002 for all i D 1; 2; : : : ; n such\nthat nextŒi\u0002 ¤ NIL. We will also assume that we have a variable L that contains\nthe index of the ﬁrst element on the list. Under these assumptions, you will show\nthat we can use the following randomized algorithm to search the list in O.pn/\nexpected time.\nCOMPACT-LIST-SEARCH.L; n; k/\n1\ni D L\n2\nwhile i ¤ NIL and keyŒi\u0002 < k\n3\nj D RANDOM.1; n/\n4\nif keyŒi\u0002 < keyŒj \u0002 and keyŒj \u0002 \u0002 k\n5\ni D j\n6\nif keyŒi\u0002 == k\n7\nreturn i\n8\ni D nextŒi\u0002\n9\nif i == NIL or keyŒi\u0002 > k\n10\nreturn NIL\n11\nelse return i\nIf we ignore lines 3–7 of the procedure, we have an ordinary algorithm for\nsearching a sorted linked list, in which index i points to each position of the list in",
    "parent_aa194db9-15af-4d84-8a4e-e4d023ad65f7": "5\ni D j\n6\nif keyŒi\u0002 == k\n7\nreturn i\n8\ni D nextŒi\u0002\n9\nif i == NIL or keyŒi\u0002 > k\n10\nreturn NIL\n11\nelse return i\nIf we ignore lines 3–7 of the procedure, we have an ordinary algorithm for\nsearching a sorted linked list, in which index i points to each position of the list in\n1Because we have deﬁned a mergeable heap to support MINIMUM and EXTRACT-MIN, we can also\nrefer to it as a mergeable min-heap. Alternatively, if it supported MAXIMUM and EXTRACT-MAX,\nit would be a mergeable max-heap.\nProblems for Chapter 10\n251\nturn. The search terminates once the index i “falls off” the end of the list or once\nkeyŒi\u0002 \u0006 k. In the latter case, if keyŒi\u0002 D k, clearly we have found a key with the\nvalue k. If, however, keyŒi\u0002 > k, then we will never ﬁnd a key with the value k,\nand so terminating the search was the right thing to do.\nLines 3–7 attempt to skip ahead to a randomly chosen position j . Such a skip\nbeneﬁts us if keyŒj \u0002 is larger than keyŒi\u0002 and no larger than k; in such a case, j\nmarks a position in the list that i would have to reach during an ordinary list search.\nBecause the list is compact, we know that any choice of j between 1 and n indexes\nsome object in the list rather than a slot on the free list.\nInstead of analyzing the performance of COMPACT-LIST-SEARCH directly, we\nshall analyze a related algorithm, COMPACT-LIST-SEARCH0, which executes two\nseparate loops. This algorithm takes an additional parameter t which determines\nan upper bound on the number of iterations of the ﬁrst loop.\nCOMPACT-LIST-SEARCH0.L; n; k; t/\n1\ni D L\n2\nfor q D 1 to t\n3\nj D RANDOM.1; n/\n4\nif keyŒi\u0002 < keyŒj \u0002 and keyŒj \u0002 \u0002 k\n5\ni D j\n6\nif keyŒi\u0002 == k\n7\nreturn i\n8\nwhile i ¤ NIL and keyŒi\u0002 < k\n9\ni D nextŒi\u0002\n10\nif i == NIL or keyŒi\u0002 > k\n11\nreturn NIL\n12\nelse return i\nTo compare the execution of the algorithms COMPACT-LIST-SEARCH.L; n; k/\nand COMPACT-LIST-SEARCH0.L; n; k; t/, assume that the sequence of integers re-\nturned by the calls of RANDOM.1; n/ is the same for both algorithms.",
    "parent_6ca89308-d0a6-413b-85e5-be8845a6e18f": "9\ni D nextŒi\u0002\n10\nif i == NIL or keyŒi\u0002 > k\n11\nreturn NIL\n12\nelse return i\nTo compare the execution of the algorithms COMPACT-LIST-SEARCH.L; n; k/\nand COMPACT-LIST-SEARCH0.L; n; k; t/, assume that the sequence of integers re-\nturned by the calls of RANDOM.1; n/ is the same for both algorithms.\na. Suppose that COMPACT-LIST-SEARCH.L; n; k/ takes t iterations of the while\nloop of lines 2–8. Argue that COMPACT-LIST-SEARCH0.L; n; k; t/ returns the\nsame answer and that the total number of iterations of both the for and while\nloops within COMPACT-LIST-SEARCH0 is at least t.\nIn the call COMPACT-LIST-SEARCH0.L; n; k; t/, let Xt be the random variable that\ndescribes the distance in the linked list (that is, through the chain of next pointers)\nfrom position i to the desired key k after t iterations of the for loop of lines 2–7\nhave occurred.\n252\nChapter 10\nElementary Data Structures\nb. Argue that the expected running time of COMPACT-LIST-SEARCH0.L; n; k; t/\nis O.t C E ŒXt\u0002/.\nc. Show that E ŒXt\u0002 \u0002 Pn\nrD1.1 \u0005 r=n/t. (Hint: Use equation (C.25).)\nd. Show that Pn\u00031\nrD0 rt \u0002 ntC1=.t C 1/.\ne. Prove that E ŒXt\u0002 \u0002 n=.t C 1/.\nf.\nShow that COMPACT-LIST-SEARCH0.L; n; k; t/ runs in O.t C n=t/ expected\ntime.\ng. Conclude that COMPACT-LIST-SEARCH runs in O.pn/ expected time.\nh. Why do we assume that all keys are distinct in COMPACT-LIST-SEARCH? Ar-\ngue that random skips do not necessarily help asymptotically when the list con-\ntains repeated key values.\nChapter notes\nAho, Hopcroft, and Ullman [6] and Knuth [209] are excellent references for ele-\nmentary data structures. Many other texts cover both basic data structures and their\nimplementation in a particular programming language. Examples of these types of\ntextbooks include Goodrich and Tamassia [147], Main [241], Shaffer [311], and\nWeiss [352, 353, 354]. Gonnet [145] provides experimental data on the perfor-\nmance of many data-structure operations.\nThe origin of stacks and queues as data structures in computer science is un-",
    "parent_09f3673b-cba5-4451-ab36-972b0e896ec9": "textbooks include Goodrich and Tamassia [147], Main [241], Shaffer [311], and\nWeiss [352, 353, 354]. Gonnet [145] provides experimental data on the perfor-\nmance of many data-structure operations.\nThe origin of stacks and queues as data structures in computer science is un-\nclear, since corresponding notions already existed in mathematics and paper-based\nbusiness practices before the introduction of digital computers. Knuth [209] cites\nA. M. Turing for the development of stacks for subroutine linkage in 1947.\nPointer-based data structures also seem to be a folk invention. According to\nKnuth, pointers were apparently used in early computers with drum memories. The\nA-1 language developed by G. M. Hopper in 1951 represented algebraic formulas\nas binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell,\nJ. C. Shaw, and H. A. Simon, for recognizing the importance and promoting the\nuse of pointers. Their IPL-III language, developed in 1957, included explicit stack\noperations.\n11\nHash Tables\nMany applications require a dynamic set that supports only the dictionary opera-\ntions INSERT, SEARCH, and DELETE. For example, a compiler that translates a\nprogramming language maintains a symbol table, in which the keys of elements\nare arbitrary character strings corresponding to identiﬁers in the language. A hash\ntable is an effective data structure for implementing dictionaries. Although search-\ning for an element in a hash table can take as long as searching for an element in a\nlinked list—‚.n/ time in the worst case—in practice, hashing performs extremely\nwell. Under reasonable assumptions, the average time to search for an element in\na hash table is O.1/.\nA hash table generalizes the simpler notion of an ordinary array. Directly ad-\ndressing into an ordinary array makes effective use of our ability to examine an\narbitrary position in an array in O.1/ time. Section 11.1 discusses direct address-",
    "parent_e665947b-7ee3-4039-8a02-e2efc0d9efbc": "a hash table is O.1/.\nA hash table generalizes the simpler notion of an ordinary array. Directly ad-\ndressing into an ordinary array makes effective use of our ability to examine an\narbitrary position in an array in O.1/ time. Section 11.1 discusses direct address-\ning in more detail. We can take advantage of direct addressing when we can afford\nto allocate an array that has one position for every possible key.\nWhen the number of keys actually stored is small relative to the total number of\npossible keys, hash tables become an effective alternative to directly addressing an\narray, since a hash table typically uses an array of size proportional to the number\nof keys actually stored. Instead of using the key as an array index directly, the array\nindex is computed from the key. Section 11.2 presents the main ideas, focusing on\n“chaining” as a way to handle “collisions,” in which more than one key maps to the\nsame array index. Section 11.3 describes how we can compute array indices from\nkeys using hash functions. We present and analyze several variations on the basic\ntheme. Section 11.4 looks at “open addressing,” which is another way to deal with\ncollisions. The bottom line is that hashing is an extremely effective and practical\ntechnique: the basic dictionary operations require only O.1/ time on the average.\nSection 11.5 explains how “perfect hashing” can support searches in O.1/ worst-\ncase time, when the set of keys being stored is static (that is, when the set of keys\nnever changes once stored).\n254\nChapter 11\nHash Tables\n11.1\nDirect-address tables\nDirect addressing is a simple technique that works well when the universe U of\nkeys is reasonably small. Suppose that an application needs a dynamic set in which\neach element has a key drawn from the universe U D f0; 1; : : : ; m \u0005 1g, where m\nis not too large. We shall assume that no two elements have the same key.\nTo represent the dynamic set, we use an array, or direct-address table, denoted",
    "parent_6ac35cf3-0594-4880-b63b-17c73d4685ee": "each element has a key drawn from the universe U D f0; 1; : : : ; m \u0005 1g, where m\nis not too large. We shall assume that no two elements have the same key.\nTo represent the dynamic set, we use an array, or direct-address table, denoted\nby T Œ0 : : m \u0005 1\u0002, in which each position, or slot, corresponds to a key in the uni-\nverse U . Figure 11.1 illustrates the approach; slot k points to an element in the set\nwith key k. If the set contains no element with key k, then T Œk\u0002 D NIL.\nThe dictionary operations are trivial to implement:\nDIRECT-ADDRESS-SEARCH.T; k/\n1\nreturn T Œk\u0002\nDIRECT-ADDRESS-INSERT.T; x/\n1\nT Œx:key\u0002 D x\nDIRECT-ADDRESS-DELETE.T; x/\n1\nT Œx:key\u0002 D NIL\nEach of these operations takes only O.1/ time.\nT\nU\n(universe of keys)\nK\n(actual\nkeys)\n2\n3\n5\n8\n1\n9\n4\n0\n7\n6\n2\n3\n5\n8\nkey\nsatellite data\n2\n0\n1\n3\n4\n5\n6\n7\n8\n9\nFigure 11.1\nHow to implement a dynamic set by a direct-address table T . Each key in the universe\nU D f0; 1; : : : ; 9g corresponds to an index in the table. The set K D f2; 3; 5; 8g of actual keys\ndetermines the slots in the table that contain pointers to elements. The other slots, heavily shaded,\ncontain NIL.\n11.1\nDirect-address tables\n255\nFor some applications, the direct-address table itself can hold the elements in the\ndynamic set. That is, rather than storing an element’s key and satellite data in an\nobject external to the direct-address table, with a pointer from a slot in the table to\nthe object, we can store the object in the slot itself, thus saving space. We would\nuse a special key within an object to indicate an empty slot. Moreover, it is often\nunnecessary to store the key of the object, since if we have the index of an object\nin the table, we have its key. If keys are not stored, however, we must have some\nway to tell whether the slot is empty.\nExercises\n11.1-1\nSuppose that a dynamic set S is represented by a direct-address table T of length m.\nDescribe a procedure that ﬁnds the maximum element of S. What is the worst-case",
    "parent_5ec8b26c-d691-4db1-9291-90f35184410b": "way to tell whether the slot is empty.\nExercises\n11.1-1\nSuppose that a dynamic set S is represented by a direct-address table T of length m.\nDescribe a procedure that ﬁnds the maximum element of S. What is the worst-case\nperformance of your procedure?\n11.1-2\nA bit vector is simply an array of bits (0s and 1s). A bit vector of length m takes\nmuch less space than an array of m pointers. Describe how to use a bit vector\nto represent a dynamic set of distinct elements with no satellite data. Dictionary\noperations should run in O.1/ time.\n11.1-3\nSuggest how to implement a direct-address table in which the keys of stored el-\nements do not need to be distinct and the elements can have satellite data. All\nthree dictionary operations (INSERT, DELETE, and SEARCH) should run in O.1/\ntime. (Don’t forget that DELETE takes as an argument a pointer to an object to be\ndeleted, not a key.)\n11.1-4\n?\nWe wish to implement a dictionary by using direct addressing on a huge array. At\nthe start, the array entries may contain garbage, and initializing the entire array\nis impractical because of its size. Describe a scheme for implementing a direct-\naddress dictionary on a huge array. Each stored object should use O.1/ space;\nthe operations SEARCH, INSERT, and DELETE should take O.1/ time each; and\ninitializing the data structure should take O.1/ time. (Hint: Use an additional array,\ntreated somewhat like a stack whose size is the number of keys actually stored in\nthe dictionary, to help determine whether a given entry in the huge array is valid or\nnot.)\n256\nChapter 11\nHash Tables\n11.2\nHash tables\nThe downside of direct addressing is obvious: if the universe U is large, storing\na table T of size jU j may be impractical, or even impossible, given the memory\navailable on a typical computer. Furthermore, the set K of keys actually stored\nmay be so small relative to U that most of the space allocated for T would be\nwasted.",
    "parent_f03332a7-eb4a-494e-86dc-b67b47ee8f0f": "a table T of size jU j may be impractical, or even impossible, given the memory\navailable on a typical computer. Furthermore, the set K of keys actually stored\nmay be so small relative to U that most of the space allocated for T would be\nwasted.\nWhen the set K of keys stored in a dictionary is much smaller than the uni-\nverse U of all possible keys, a hash table requires much less storage than a direct-\naddress table. Speciﬁcally, we can reduce the storage requirement to ‚.jKj/ while\nwe maintain the beneﬁt that searching for an element in the hash table still requires\nonly O.1/ time. The catch is that this bound is for the average-case time, whereas\nfor direct addressing it holds for the worst-case time.\nWith direct addressing, an element with key k is stored in slot k. With hashing,\nthis element is stored in slot h.k/; that is, we use a hash function h to compute the\nslot from the key k. Here, h maps the universe U of keys into the slots of a hash\ntable T Œ0 : : m \u0005 1\u0002:\nh W U ! f0; 1; : : : ; m \u0005 1g ;\nwhere the size m of the hash table is typically much less than jU j. We say that an\nelement with key k hashes to slot h.k/; we also say that h.k/ is the hash value of\nkey k. Figure 11.2 illustrates the basic idea. The hash function reduces the range\nof array indices and hence the size of the array. Instead of a size of jU j, the array\ncan have size m.\nT\nU\n(universe of keys)\nK\n(actual\nkeys)\n0\nm–1\nk1\nk2\nk3\nk4\nk5\nh(k1)\nh(k4)\nh(k3)\nh(k2) = h(k5)\nFigure 11.2\nUsing a hash function h to map keys to hash-table slots. Because keys k2 and k5 map\nto the same slot, they collide.\n11.2\nHash tables\n257\nT\nU\n(universe of keys)\nK\n(actual\nkeys)\nk1\nk2\nk3\nk4\nk5\nk6\nk7\nk8\nk1\nk2\nk3\nk4\nk5\nk6\nk7\nk8\nFigure 11.3\nCollision resolution by chaining. Each hash-table slot T Œj\u0002 contains a linked list of\nall the keys whose hash value is j. For example, h.k1/ D h.k4/ and h.k5/ D h.k7/ D h.k2/.\nThe linked list can be either singly or doubly linked; we show it as doubly linked because deletion is",
    "parent_d5edd655-d378-408b-86ac-72c51c30c66b": "k7\nk8\nFigure 11.3\nCollision resolution by chaining. Each hash-table slot T Œj\u0002 contains a linked list of\nall the keys whose hash value is j. For example, h.k1/ D h.k4/ and h.k5/ D h.k7/ D h.k2/.\nThe linked list can be either singly or doubly linked; we show it as doubly linked because deletion is\nfaster that way.\nThere is one hitch: two keys may hash to the same slot. We call this situation\na collision. Fortunately, we have effective techniques for resolving the conﬂict\ncreated by collisions.\nOf course, the ideal solution would be to avoid collisions altogether. We might\ntry to achieve this goal by choosing a suitable hash function h. One idea is to\nmake h appear to be “random,” thus avoiding collisions or at least minimizing\ntheir number. The very term “to hash,” evoking images of random mixing and\nchopping, captures the spirit of this approach. (Of course, a hash function h must be\ndeterministic in that a given input k should always produce the same output h.k/.)\nBecause jU j > m, however, there must be at least two keys that have the same hash\nvalue; avoiding collisions altogether is therefore impossible. Thus, while a well-\ndesigned, “random”-looking hash function can minimize the number of collisions,\nwe still need a method for resolving the collisions that do occur.\nThe remainder of this section presents the simplest collision resolution tech-\nnique, called chaining. Section 11.4 introduces an alternative method for resolving\ncollisions, called open addressing.\nCollision resolution by chaining\nIn chaining, we place all the elements that hash to the same slot into the same\nlinked list, as Figure 11.3 shows. Slot j contains a pointer to the head of the list of\nall stored elements that hash to j ; if there are no such elements, slot j contains NIL.\n258\nChapter 11\nHash Tables\nThe dictionary operations on a hash table T are easy to implement when colli-\nsions are resolved by chaining:\nCHAINED-HASH-INSERT.T; x/\n1\ninsert x at the head of list T Œh.x:key/\u0002",
    "parent_41355c79-a6a5-4401-943f-a675a50c1d94": "all stored elements that hash to j ; if there are no such elements, slot j contains NIL.\n258\nChapter 11\nHash Tables\nThe dictionary operations on a hash table T are easy to implement when colli-\nsions are resolved by chaining:\nCHAINED-HASH-INSERT.T; x/\n1\ninsert x at the head of list T Œh.x:key/\u0002\nCHAINED-HASH-SEARCH.T; k/\n1\nsearch for an element with key k in list T Œh.k/\u0002\nCHAINED-HASH-DELETE.T; x/\n1\ndelete x from the list T Œh.x:key/\u0002\nThe worst-case running time for insertion is O.1/. The insertion procedure is fast\nin part because it assumes that the element x being inserted is not already present in\nthe table; if necessary, we can check this assumption (at additional cost) by search-\ning for an element whose key is x:key before we insert. For searching, the worst-\ncase running time is proportional to the length of the list; we shall analyze this\noperation more closely below. We can delete an element in O.1/ time if the lists\nare doubly linked, as Figure 11.3 depicts. (Note that CHAINED-HASH-DELETE\ntakes as input an element x and not its key k, so that we don’t have to search for x\nﬁrst. If the hash table supports deletion, then its linked lists should be doubly linked\nso that we can delete an item quickly. If the lists were only singly linked, then to\ndelete element x, we would ﬁrst have to ﬁnd x in the list T Œh.x:key/\u0002 so that we\ncould update the next attribute of x’s predecessor. With singly linked lists, both\ndeletion and searching would have the same asymptotic running times.)\nAnalysis of hashing with chaining\nHow well does hashing with chaining perform? In particular, how long does it take\nto search for an element with a given key?\nGiven a hash table T with m slots that stores n elements, we deﬁne the load\nfactor ˛ for T as n=m, that is, the average number of elements stored in a chain.\nOur analysis will be in terms of ˛, which can be less than, equal to, or greater\nthan 1.\nThe worst-case behavior of hashing with chaining is terrible: all n keys hash",
    "parent_58ec323e-149e-4cb4-8ced-f453a4e8ac2d": "factor ˛ for T as n=m, that is, the average number of elements stored in a chain.\nOur analysis will be in terms of ˛, which can be less than, equal to, or greater\nthan 1.\nThe worst-case behavior of hashing with chaining is terrible: all n keys hash\nto the same slot, creating a list of length n. The worst-case time for searching is\nthus ‚.n/ plus the time to compute the hash function—no better than if we used\none linked list for all the elements. Clearly, we do not use hash tables for their\nworst-case performance. (Perfect hashing, described in Section 11.5, does provide\ngood worst-case performance when the set of keys is static, however.)\nThe average-case performance of hashing depends on how well the hash func-\ntion h distributes the set of keys to be stored among the m slots, on the average.\n11.2\nHash tables\n259\nSection 11.3 discusses these issues, but for now we shall assume that any given\nelement is equally likely to hash into any of the m slots, independently of where\nany other element has hashed to. We call this the assumption of simple uniform\nhashing.\nFor j D 0; 1; : : : ; m \u0005 1, let us denote the length of the list T Œj \u0002 by nj, so that\nn D n0 C n1 C \u0003 \u0003 \u0003 C nm\u00031 ;\n(11.1)\nand the expected value of nj is E Œnj\u0002 D ˛ D n=m.\nWe assume that O.1/ time sufﬁces to compute the hash value h.k/, so that\nthe time required to search for an element with key k depends linearly on the\nlength nh.k/ of the list T Œh.k/\u0002. Setting aside the O.1/ time required to compute\nthe hash function and to access slot h.k/, let us consider the expected number of\nelements examined by the search algorithm, that is, the number of elements in the\nlist T Œh.k/\u0002 that the algorithm checks to see whether any have a key equal to k. We\nshall consider two cases. In the ﬁrst, the search is unsuccessful: no element in the\ntable has key k. In the second, the search successfully ﬁnds an element with key k.\nTheorem 11.1\nIn a hash table in which collisions are resolved by chaining, an unsuccessful search",
    "parent_07c34c41-d3d6-4ce4-83ce-61298b94d583": "shall consider two cases. In the ﬁrst, the search is unsuccessful: no element in the\ntable has key k. In the second, the search successfully ﬁnds an element with key k.\nTheorem 11.1\nIn a hash table in which collisions are resolved by chaining, an unsuccessful search\ntakes average-case time ‚.1C˛/, under the assumption of simple uniform hashing.\nProof\nUnder the assumption of simple uniform hashing, any key k not already\nstored in the table is equally likely to hash to any of the m slots. The expected time\nto search unsuccessfully for a key k is the expected time to search to the end of\nlist T Œh.k/\u0002, which has expected length E Œnh.k/\u0002 D ˛. Thus, the expected number\nof elements examined in an unsuccessful search is ˛, and the total time required\n(including the time for computing h.k/) is ‚.1 C ˛/.\nThe situation for a successful search is slightly different, since each list is not\nequally likely to be searched. Instead, the probability that a list is searched is pro-\nportional to the number of elements it contains. Nonetheless, the expected search\ntime still turns out to be ‚.1 C ˛/.\nTheorem 11.2\nIn a hash table in which collisions are resolved by chaining, a successful search\ntakes average-case time ‚.1C˛/, under the assumption of simple uniform hashing.\nProof\nWe assume that the element being searched for is equally likely to be any\nof the n elements stored in the table. The number of elements examined during a\nsuccessful search for an element x is one more than the number of elements that\n260\nChapter 11\nHash Tables\nappear before x in x’s list. Because new elements are placed at the front of the\nlist, elements before x in the list were all inserted after x was inserted. To ﬁnd\nthe expected number of elements examined, we take the average, over the n ele-\nments x in the table, of 1 plus the expected number of elements added to x’s list\nafter x was added to the list. Let xi denote the ith element inserted into the ta-",
    "parent_e21af436-8816-4b79-bd57-dbbecb756981": "the expected number of elements examined, we take the average, over the n ele-\nments x in the table, of 1 plus the expected number of elements added to x’s list\nafter x was added to the list. Let xi denote the ith element inserted into the ta-\nble, for i D 1; 2; : : : ; n, and let ki D xi:key. For keys ki and kj, we deﬁne the\nindicator random variable Xij D I fh.ki/ D h.kj/g. Under the assumption of sim-\nple uniform hashing, we have Pr fh.ki/ D h.kj/g D 1=m, and so by Lemma 5.1,\nE ŒXij\u0002 D 1=m. Thus, the expected number of elements examined in a successful\nsearch is\nE\n\"\n1\nn\nn\nX\niD1\n \n1 C\nn\nX\njDiC1\nXij\n!#\nD\n1\nn\nn\nX\niD1\n \n1 C\nn\nX\njDiC1\nE ŒXij\u0002\n!\n(by linearity of expectation)\nD\n1\nn\nn\nX\niD1\n \n1 C\nn\nX\njDiC1\n1\nm\n!\nD\n1 C 1\nnm\nn\nX\niD1\n.n \u0005 i/\nD\n1 C 1\nnm\n n\nX\niD1\nn \u0005\nn\nX\niD1\ni\n!\nD\n1 C 1\nnm\n\u0002\nn2 \u0005 n.n C 1/\n2\n\u0003\n(by equation (A.1))\nD\n1 C n \u0005 1\n2m\nD\n1 C ˛\n2 \u0005 ˛\n2n :\nThus, the total time required for a successful search (including the time for com-\nputing the hash function) is ‚.2 C ˛=2 \u0005 ˛=2n/ D ‚.1 C ˛/.\nWhat does this analysis mean? If the number of hash-table slots is at least pro-\nportional to the number of elements in the table, we have n D O.m/ and, con-\nsequently, ˛ D n=m D O.m/=m D O.1/. Thus, searching takes constant time\non average. Since insertion takes O.1/ worst-case time and deletion takes O.1/\nworst-case time when the lists are doubly linked, we can support all dictionary\noperations in O.1/ time on average.\n11.2\nHash tables\n261\nExercises\n11.2-1\nSuppose we use a hash function h to hash n distinct keys into an array T of\nlength m. Assuming simple uniform hashing, what is the expected number of\ncollisions? More precisely, what is the expected cardinality of ffk; lg W k ¤ l and\nh.k/ D h.l/g?\n11.2-2\nDemonstrate what happens when we insert the keys 5; 28; 19; 15; 20; 33; 12; 17; 10\ninto a hash table with collisions resolved by chaining. Let the table have 9 slots,\nand let the hash function be h.k/ D k mod 9.\n11.2-3",
    "parent_5f7080dc-fd9a-45b5-a0a8-dfa73378ba57": "h.k/ D h.l/g?\n11.2-2\nDemonstrate what happens when we insert the keys 5; 28; 19; 15; 20; 33; 12; 17; 10\ninto a hash table with collisions resolved by chaining. Let the table have 9 slots,\nand let the hash function be h.k/ D k mod 9.\n11.2-3\nProfessor Marley hypothesizes that he can obtain substantial performance gains by\nmodifying the chaining scheme to keep each list in sorted order. How does the pro-\nfessor’s modiﬁcation affect the running time for successful searches, unsuccessful\nsearches, insertions, and deletions?\n11.2-4\nSuggest how to allocate and deallocate storage for elements within the hash table\nitself by linking all unused slots into a free list. Assume that one slot can store\na ﬂag and either one element plus a pointer or two pointers. All dictionary and\nfree-list operations should run in O.1/ expected time. Does the free list need to be\ndoubly linked, or does a singly linked free list sufﬁce?\n11.2-5\nSuppose that we are storing a set of n keys into a hash table of size m. Show that if\nthe keys are drawn from a universe U with jU j > nm, then U has a subset of size n\nconsisting of keys that all hash to the same slot, so that the worst-case searching\ntime for hashing with chaining is ‚.n/.\n11.2-6\nSuppose we have stored n keys in a hash table of size m, with collisions resolved by\nchaining, and that we know the length of each chain, including the length L of the\nlongest chain. Describe a procedure that selects a key uniformly at random from\namong the keys in the hash table and returns it in expected time O.L \u0003 .1 C 1=˛//.\n262\nChapter 11\nHash Tables\n11.3\nHash functions\nIn this section, we discuss some issues regarding the design of good hash functions\nand then present three schemes for their creation. Two of the schemes, hashing by\ndivision and hashing by multiplication, are heuristic in nature, whereas the third\nscheme, universal hashing, uses randomization to provide provably good perfor-\nmance.\nWhat makes a good hash function?",
    "parent_84239231-c05c-4a1b-b775-7ce4735d6144": "and then present three schemes for their creation. Two of the schemes, hashing by\ndivision and hashing by multiplication, are heuristic in nature, whereas the third\nscheme, universal hashing, uses randomization to provide provably good perfor-\nmance.\nWhat makes a good hash function?\nA good hash function satisﬁes (approximately) the assumption of simple uniform\nhashing: each key is equally likely to hash to any of the m slots, independently of\nwhere any other key has hashed to. Unfortunately, we typically have no way to\ncheck this condition, since we rarely know the probability distribution from which\nthe keys are drawn. Moreover, the keys might not be drawn independently.\nOccasionally we do know the distribution. For example, if we know that the\nkeys are random real numbers k independently and uniformly distributed in the\nrange 0 \u0002 k < 1, then the hash function\nh.k/ D bkmc\nsatisﬁes the condition of simple uniform hashing.\nIn practice, we can often employ heuristic techniques to create a hash function\nthat performs well. Qualitative information about the distribution of keys may be\nuseful in this design process. For example, consider a compiler’s symbol table, in\nwhich the keys are character strings representing identiﬁers in a program. Closely\nrelated symbols, such as pt and pts, often occur in the same program. A good\nhash function would minimize the chance that such variants hash to the same slot.\nA good approach derives the hash value in a way that we expect to be indepen-\ndent of any patterns that might exist in the data. For example, the “division method”\n(discussed in Section 11.3.1) computes the hash value as the remainder when the\nkey is divided by a speciﬁed prime number. This method frequently gives good\nresults, assuming that we choose a prime number that is unrelated to any patterns\nin the distribution of keys.\nFinally, we note that some applications of hash functions might require stronger",
    "parent_c3e9af2a-55e2-44a6-87b1-a2217b9c334d": "key is divided by a speciﬁed prime number. This method frequently gives good\nresults, assuming that we choose a prime number that is unrelated to any patterns\nin the distribution of keys.\nFinally, we note that some applications of hash functions might require stronger\nproperties than are provided by simple uniform hashing. For example, we might\nwant keys that are “close” in some sense to yield hash values that are far apart.\n(This property is especially desirable when we are using linear probing, deﬁned in\nSection 11.4.) Universal hashing, described in Section 11.3.3, often provides the\ndesired properties.\n11.3\nHash functions\n263\nInterpreting keys as natural numbers\nMost hash functions assume that the universe of keys is the set N D f0; 1; 2; : : :g\nof natural numbers. Thus, if the keys are not natural numbers, we ﬁnd a way to\ninterpret them as natural numbers. For example, we can interpret a character string\nas an integer expressed in suitable radix notation. Thus, we might interpret the\nidentiﬁer pt as the pair of decimal integers .112; 116/, since p D 112 and t D 116\nin the ASCII character set; then, expressed as a radix-128 integer, pt becomes\n.112 \u0003 128/ C 116 D 14452. In the context of a given application, we can usually\ndevise some such method for interpreting each key as a (possibly large) natural\nnumber. In what follows, we assume that the keys are natural numbers.\n11.3.1\nThe division method\nIn the division method for creating hash functions, we map a key k into one of m\nslots by taking the remainder of k divided by m. That is, the hash function is\nh.k/ D k mod m :\nFor example, if the hash table has size m D 12 and the key is k D 100, then\nh.k/ D 4. Since it requires only a single division operation, hashing by division is\nquite fast.\nWhen using the division method, we usually avoid certain values of m. For\nexample, m should not be a power of 2, since if m D 2p, then h.k/ is just the p",
    "parent_89c963c6-e9f2-4152-bee7-da1d18974b84": "h.k/ D 4. Since it requires only a single division operation, hashing by division is\nquite fast.\nWhen using the division method, we usually avoid certain values of m. For\nexample, m should not be a power of 2, since if m D 2p, then h.k/ is just the p\nlowest-order bits of k. Unless we know that all low-order p-bit patterns are equally\nlikely, we are better off designing the hash function to depend on all the bits of the\nkey. As Exercise 11.3-3 asks you to show, choosing m D 2p \u0005 1 when k is a\ncharacter string interpreted in radix 2p may be a poor choice, because permuting\nthe characters of k does not change its hash value.\nA prime not too close to an exact power of 2 is often a good choice for m. For\nexample, suppose we wish to allocate a hash table, with collisions resolved by\nchaining, to hold roughly n D 2000 character strings, where a character has 8 bits.\nWe don’t mind examining an average of 3 elements in an unsuccessful search, and\nso we allocate a hash table of size m D 701. We could choose m D 701 because\nit is a prime near 2000=3 but not near any power of 2. Treating each key k as an\ninteger, our hash function would be\nh.k/ D k mod 701 :\n11.3.2\nThe multiplication method\nThe multiplication method for creating hash functions operates in two steps. First,\nwe multiply the key k by a constant A in the range 0 < A < 1 and extract the\n264\nChapter 11\nHash Tables\n×\ns D A \u0003 2w\nw bits\nk\nr0\nr1\nh.k/\nextract p bits\nFigure 11.4\nThe multiplication method of hashing. The w-bit representation of the key k is multi-\nplied by the w-bit value s D A \u0003 2w. The p highest-order bits of the lower w-bit half of the product\nform the desired hash value h.k/.\nfractional part of kA. Then, we multiply this value by m and take the ﬂoor of the\nresult. In short, the hash function is\nh.k/ D bm .kA mod 1/c ;\nwhere “kA mod 1” means the fractional part of kA, that is, kA \u0005 bkAc.\nAn advantage of the multiplication method is that the value of m is not critical.",
    "parent_1aa4e6be-44fb-495c-8c00-f529a1f5b38a": "fractional part of kA. Then, we multiply this value by m and take the ﬂoor of the\nresult. In short, the hash function is\nh.k/ D bm .kA mod 1/c ;\nwhere “kA mod 1” means the fractional part of kA, that is, kA \u0005 bkAc.\nAn advantage of the multiplication method is that the value of m is not critical.\nWe typically choose it to be a power of 2 (m D 2p for some integer p), since we\ncan then easily implement the function on most computers as follows. Suppose\nthat the word size of the machine is w bits and that k ﬁts into a single word. We\nrestrict A to be a fraction of the form s=2w, where s is an integer in the range\n0 < s < 2w. Referring to Figure 11.4, we ﬁrst multiply k by the w-bit integer\ns D A \u00032w. The result is a 2w-bit value r12w C r0, where r1 is the high-order word\nof the product and r0 is the low-order word of the product. The desired p-bit hash\nvalue consists of the p most signiﬁcant bits of r0.\nAlthough this method works with any value of the constant A, it works better\nwith some values than with others. The optimal choice depends on the character-\nistics of the data being hashed. Knuth [211] suggests that\nA \u0004 .\np\n5 \u0005 1/=2 D 0:6180339887 : : :\n(11.2)\nis likely to work reasonably well.\nAs an example, suppose we have k D 123456, p D 14, m D 214 D 16384,\nand w D 32. Adapting Knuth’s suggestion, we choose A to be the fraction of the\nform s=232 that is closest to .\np\n5 \u0005 1/=2, so that A D 2654435769=232. Then\nk \u0003 s D 327706022297664 D .76300 \u0003 232/ C 17612864, and so r1 D 76300\nand r0 D 17612864. The 14 most signiﬁcant bits of r0 yield the value h.k/ D 67.\n11.3\nHash functions\n265\n?\n11.3.3\nUniversal hashing\nIf a malicious adversary chooses the keys to be hashed by some ﬁxed hash function,\nthen the adversary can choose n keys that all hash to the same slot, yielding an av-\nerage retrieval time of ‚.n/. Any ﬁxed hash function is vulnerable to such terrible\nworst-case behavior; the only effective way to improve the situation is to choose",
    "parent_7b070552-0be2-49fe-b1b9-97b70320a322": "then the adversary can choose n keys that all hash to the same slot, yielding an av-\nerage retrieval time of ‚.n/. Any ﬁxed hash function is vulnerable to such terrible\nworst-case behavior; the only effective way to improve the situation is to choose\nthe hash function randomly in a way that is independent of the keys that are actually\ngoing to be stored. This approach, called universal hashing, can yield provably\ngood performance on average, no matter which keys the adversary chooses.\nIn universal hashing, at the beginning of execution we select the hash function\nat random from a carefully designed class of functions. As in the case of quick-\nsort, randomization guarantees that no single input will always evoke worst-case\nbehavior. Because we randomly select the hash function, the algorithm can be-\nhave differently on each execution, even for the same input, guaranteeing good\naverage-case performance for any input. Returning to the example of a compiler’s\nsymbol table, we ﬁnd that the programmer’s choice of identiﬁers cannot now cause\nconsistently poor hashing performance. Poor performance occurs only when the\ncompiler chooses a random hash function that causes the set of identiﬁers to hash\npoorly, but the probability of this situation occurring is small and is the same for\nany set of identiﬁers of the same size.\nLet H be a ﬁnite collection of hash functions that map a given universe U of\nkeys into the range f0; 1; : : : ; m \u0005 1g. Such a collection is said to be universal\nif for each pair of distinct keys k; l 2 U , the number of hash functions h 2 H\nfor which h.k/ D h.l/ is at most jHj =m. In other words, with a hash function\nrandomly chosen from H, the chance of a collision between distinct keys k and l\nis no more than the chance 1=m of a collision if h.k/ and h.l/ were randomly and\nindependently chosen from the set f0; 1; : : : ; m \u0005 1g.\nThe following theorem shows that a universal class of hash functions gives good",
    "parent_8206767a-21f5-4926-a7aa-3d9af8d4ac12": "randomly chosen from H, the chance of a collision between distinct keys k and l\nis no more than the chance 1=m of a collision if h.k/ and h.l/ were randomly and\nindependently chosen from the set f0; 1; : : : ; m \u0005 1g.\nThe following theorem shows that a universal class of hash functions gives good\naverage-case behavior. Recall that ni denotes the length of list T Œi\u0002.\nTheorem 11.3\nSuppose that a hash function h is chosen randomly from a universal collection of\nhash functions and has been used to hash n keys into a table T of size m, us-\ning chaining to resolve collisions. If key k is not in the table, then the expected\nlength E Œnh.k/\u0002 of the list that key k hashes to is at most the load factor ˛ D n=m.\nIf key k is in the table, then the expected length E Œnh.k/\u0002 of the list containing key k\nis at most 1 C ˛.\nProof\nWe note that the expectations here are over the choice of the hash func-\ntion and do not depend on any assumptions about the distribution of the keys.\nFor each pair k and l of distinct keys, deﬁne the indicator random variable\n266\nChapter 11\nHash Tables\nXkl D I fh.k/ D h.l/g. Since by the deﬁnition of a universal collection of hash\nfunctions, a single pair of keys collides with probability at most 1=m, we have\nPr fh.k/ D h.l/g \u0002 1=m. By Lemma 5.1, therefore, we have E ŒXkl\u0002 \u0002 1=m.\nNext we deﬁne, for each key k, the random variable Yk that equals the number\nof keys other than k that hash to the same slot as k, so that\nYk D\nX\nl2T\nl¤k\nXkl :\nThus we have\nE ŒYk\u0002\nD\nE\n2\n4\nX\nl2T\nl¤k\nXkl\n3\n5\nD\nX\nl2T\nl¤k\nE ŒXkl\u0002\n(by linearity of expectation)\n\u0002\nX\nl2T\nl¤k\n1\nm :\nThe remainder of the proof depends on whether key k is in table T .\n\u0002\nIf k 62 T , then nh.k/ D Yk and jfl W l 2 T and l ¤ kgj D n. Thus E Œnh.k/\u0002 D\nE ŒYk\u0002 \u0002 n=m D ˛.\n\u0002\nIf k 2 T , then because key k appears in list T Œh.k/\u0002 and the count Yk does not\ninclude key k, we have nh.k/ D Yk C 1 and jfl W l 2 T and l ¤ kgj D n \u0005 1.\nThus E Œnh.k/\u0002 D E ŒYk\u0002 C 1 \u0002 .n \u0005 1/=m C 1 D 1 C ˛ \u0005 1=m < 1 C ˛.",
    "parent_062bca93-a097-4a6b-8367-149ef8c3ad19": "E ŒYk\u0002 \u0002 n=m D ˛.\n\u0002\nIf k 2 T , then because key k appears in list T Œh.k/\u0002 and the count Yk does not\ninclude key k, we have nh.k/ D Yk C 1 and jfl W l 2 T and l ¤ kgj D n \u0005 1.\nThus E Œnh.k/\u0002 D E ŒYk\u0002 C 1 \u0002 .n \u0005 1/=m C 1 D 1 C ˛ \u0005 1=m < 1 C ˛.\nThe following corollary says universal hashing provides the desired payoff: it\nhas now become impossible for an adversary to pick a sequence of operations that\nforces the worst-case running time. By cleverly randomizing the choice of hash\nfunction at run time, we guarantee that we can process every sequence of operations\nwith a good average-case running time.\nCorollary 11.4\nUsing universal hashing and collision resolution by chaining in an initially empty\ntable with m slots, it takes expected time ‚.n/ to handle any sequence of n INSERT,\nSEARCH, and DELETE operations containing O.m/ INSERT operations.\nProof\nSince the number of insertions is O.m/, we have n D O.m/ and so\n˛ D O.1/. The INSERT and DELETE operations take constant time and, by The-\norem 11.3, the expected time for each SEARCH operation is O.1/. By linearity of\n11.3\nHash functions\n267\nexpectation, therefore, the expected time for the entire sequence of n operations\nis O.n/. Since each operation takes \u0004.1/ time, the ‚.n/ bound follows.\nDesigning a universal class of hash functions\nIt is quite easy to design a universal class of hash functions, as a little number\ntheory will help us prove. You may wish to consult Chapter 31 ﬁrst if you are\nunfamiliar with number theory.\nWe begin by choosing a prime number p large enough so that every possible\nkey k is in the range 0 to p \u0005 1, inclusive. Let Zp denote the set f0; 1; : : : ; p \u0005 1g,\nand let Z\u0004\np denote the set f1; 2; : : : ; p \u0005 1g. Since p is prime, we can solve equa-\ntions modulo p with the methods given in Chapter 31. Because we assume that the\nsize of the universe of keys is greater than the number of slots in the hash table, we\nhave p > m.\nWe now deﬁne the hash function hab for any a 2 Z\u0004\np and any b 2 Zp using a",
    "parent_ce4e988b-70e6-4ef9-8725-f2ba92625a72": "tions modulo p with the methods given in Chapter 31. Because we assume that the\nsize of the universe of keys is greater than the number of slots in the hash table, we\nhave p > m.\nWe now deﬁne the hash function hab for any a 2 Z\u0004\np and any b 2 Zp using a\nlinear transformation followed by reductions modulo p and then modulo m:\nhab.k/ D ..ak C b/ mod p/ mod m :\n(11.3)\nFor example, with p D 17 and m D 6, we have h3;4.8/ D 5. The family of all\nsuch hash functions is\nHpm D\n˚\nhab W a 2 Z\u0004\np and b 2 Zp",
    "parent_b1f5529e-cc96-4aca-82d9-993977f8fae8": ":\n(11.4)\nEach hash function hab maps Zp to Zm. This class of hash functions has the nice\nproperty that the size m of the output range is arbitrary—not necessarily prime—a\nfeature which we shall use in Section 11.5. Since we have p \u0005 1 choices for a\nand p choices for b, the collection Hpm contains p.p \u0005 1/ hash functions.\nTheorem 11.5\nThe class Hpm of hash functions deﬁned by equations (11.3) and (11.4) is universal.\nProof\nConsider two distinct keys k and l from Zp, so that k ¤ l. For a given\nhash function hab we let\nr\nD\n.ak C b/ mod p ;\ns\nD\n.al C b/ mod p :\nWe ﬁrst note that r ¤ s. Why? Observe that\nr \u0005 s \b a.k \u0005 l/ .mod p/ :\nIt follows that r ¤ s because p is prime and both a and .k \u0005 l/ are nonzero\nmodulo p, and so their product must also be nonzero modulo p by Theorem 31.6.\nTherefore, when computing any hab 2 Hpm, distinct inputs k and l map to distinct\n268\nChapter 11\nHash Tables\nvalues r and s modulo p; there are no collisions yet at the “mod p level.” Moreover,\neach of the possible p.p\u00051/ choices for the pair .a; b/ with a ¤ 0 yields a different\nresulting pair .r; s/ with r ¤ s, since we can solve for a and b given r and s:\na\nD\n\u000b\n.r \u0005 s/..k \u0005 l/\u00031 mod p/\n\f\nmod p ;\nb\nD\n.r \u0005 ak/ mod p ;\nwhere ..k \u0005 l/\u00031 mod p/ denotes the unique multiplicative inverse, modulo p,\nof k \u0005 l. Since there are only p.p \u0005 1/ possible pairs .r; s/ with r ¤ s, there\nis a one-to-one correspondence between pairs .a; b/ with a ¤ 0 and pairs .r; s/\nwith r ¤ s. Thus, for any given pair of inputs k and l, if we pick .a; b/ uniformly\nat random from Z\u0004\np \t Zp, the resulting pair .r; s/ is equally likely to be any pair of\ndistinct values modulo p.\nTherefore, the probability that distinct keys k and l collide is equal to the prob-\nability that r \b s .mod m/ when r and s are randomly chosen as distinct values\nmodulo p. For a given value of r, of the p \u0005 1 possible remaining values for s, the\nnumber of values s such that s ¤ r and s \b r .mod m/ is at most\ndp=me \u0005 1\n\u0002\n..p C m \u0005 1/=m/ \u0005 1",
    "parent_5329f005-8543-4189-9b6e-534bc44cd96f": "ability that r \b s .mod m/ when r and s are randomly chosen as distinct values\nmodulo p. For a given value of r, of the p \u0005 1 possible remaining values for s, the\nnumber of values s such that s ¤ r and s \b r .mod m/ is at most\ndp=me \u0005 1\n\u0002\n..p C m \u0005 1/=m/ \u0005 1\n(by inequality (3.6))\nD\n.p \u0005 1/=m :\nThe probability that s collides with r when reduced modulo m is at most\n..p \u0005 1/=m/=.p \u0005 1/ D 1=m.\nTherefore, for any pair of distinct values k; l 2 Zp,\nPr fhab.k/ D hab.l/g \u0002 1=m ;\nso that Hpm is indeed universal.\nExercises\n11.3-1\nSuppose we wish to search a linked list of length n, where each element contains\na key k along with a hash value h.k/. Each key is a long character string. How\nmight we take advantage of the hash values when searching the list for an element\nwith a given key?\n11.3-2\nSuppose that we hash a string of r characters into m slots by treating it as a\nradix-128 number and then using the division method. We can easily represent\nthe number m as a 32-bit computer word, but the string of r characters, treated as\na radix-128 number, takes many words. How can we apply the division method to\ncompute the hash value of the character string without using more than a constant\nnumber of words of storage outside the string itself?\n11.4\nOpen addressing\n269\n11.3-3\nConsider a version of the division method in which h.k/ D k mod m, where\nm D 2p \u0005 1 and k is a character string interpreted in radix 2p. Show that if we\ncan derive string x from string y by permuting its characters, then x and y hash to\nthe same value. Give an example of an application in which this property would be\nundesirable in a hash function.\n11.3-4\nConsider a hash table of size m D 1000 and a corresponding hash function h.k/ D\nbm .kA mod 1/c for A D .\np\n5 \u0005 1/=2. Compute the locations to which the keys\n61, 62, 63, 64, and 65 are mapped.\n11.3-5\n?\nDeﬁne a family H of hash functions from a ﬁnite set U to a ﬁnite set B to be\n\u0003-universal if for all pairs of distinct elements k and l in U ,",
    "parent_38a9baa9-f90f-4532-a7d5-b8f508521a95": "bm .kA mod 1/c for A D .\np\n5 \u0005 1/=2. Compute the locations to which the keys\n61, 62, 63, 64, and 65 are mapped.\n11.3-5\n?\nDeﬁne a family H of hash functions from a ﬁnite set U to a ﬁnite set B to be\n\u0003-universal if for all pairs of distinct elements k and l in U ,\nPr fh.k/ D h.l/g \u0002 \b ;\nwhere the probability is over the choice of the hash function h drawn at random\nfrom the family H. Show that an \b-universal family of hash functions must have\n\b \u0006\n1\njBj \u0005\n1\njU j :\n11.3-6\n?\nLet U be the set of n-tuples of values drawn from Zp, and let B D Zp, where p\nis prime. Deﬁne the hash function hb W U ! B for b 2 Zp on an input n-tuple\nha0; a1; : : : ; an\u00031i from U as\nhb.ha0; a1; : : : ; an\u00031i/ D\n n\u00031\nX\njD0\najbj\n!\nmod p ;\nand let H D fhb W b 2 Zpg. Argue that H is ..n \u0005 1/=p/-universal according to\nthe deﬁnition of \b-universal in Exercise 11.3-5. (Hint: See Exercise 31.4-4.)\n11.4\nOpen addressing\nIn open addressing, all elements occupy the hash table itself. That is, each table\nentry contains either an element of the dynamic set or NIL. When searching for\nan element, we systematically examine table slots until either we ﬁnd the desired\nelement or we have ascertained that the element is not in the table. No lists and\n270\nChapter 11\nHash Tables\nno elements are stored outside the table, unlike in chaining. Thus, in open ad-\ndressing, the hash table can “ﬁll up” so that no further insertions can be made; one\nconsequence is that the load factor ˛ can never exceed 1.\nOf course, we could store the linked lists for chaining inside the hash table, in\nthe otherwise unused hash-table slots (see Exercise 11.2-4), but the advantage of\nopen addressing is that it avoids pointers altogether. Instead of following pointers,\nwe compute the sequence of slots to be examined. The extra memory freed by not\nstoring pointers provides the hash table with a larger number of slots for the same\namount of memory, potentially yielding fewer collisions and faster retrieval.",
    "parent_21e3db20-91d3-4612-a236-103a5962008d": "we compute the sequence of slots to be examined. The extra memory freed by not\nstoring pointers provides the hash table with a larger number of slots for the same\namount of memory, potentially yielding fewer collisions and faster retrieval.\nTo perform insertion using open addressing, we successively examine, or probe,\nthe hash table until we ﬁnd an empty slot in which to put the key. Instead of being\nﬁxed in the order 0; 1; : : : ; m \u0005 1 (which requires ‚.n/ search time), the sequence\nof positions probed depends upon the key being inserted. To determine which slots\nto probe, we extend the hash function to include the probe number (starting from 0)\nas a second input. Thus, the hash function becomes\nh W U \t f0; 1; : : : ; m \u0005 1g ! f0; 1; : : : ; m \u0005 1g :\nWith open addressing, we require that for every key k, the probe sequence\nhh.k; 0/; h.k; 1/; : : : ; h.k; m \u0005 1/i\nbe a permutation of h0;1;: : : ;m\u00051i, so that every hash-table position is eventually\nconsidered as a slot for a new key as the table ﬁlls up. In the following pseudocode,\nwe assume that the elements in the hash table T are keys with no satellite infor-\nmation; the key k is identical to the element containing key k. Each slot contains\neither a key or NIL (if the slot is empty). The HASH-INSERT procedure takes as\ninput a hash table T and a key k. It either returns the slot number where it stores\nkey k or ﬂags an error because the hash table is already full.\nHASH-INSERT.T; k/\n1\ni D 0\n2\nrepeat\n3\nj D h.k; i/\n4\nif T Œj \u0002 == NIL\n5\nT Œj \u0002 D k\n6\nreturn j\n7\nelse i D i C 1\n8\nuntil i == m\n9\nerror “hash table overﬂow”\nThe algorithm for searching for key k probes the same sequence of slots that the\ninsertion algorithm examined when key k was inserted. Therefore, the search can\n11.4\nOpen addressing\n271\nterminate (unsuccessfully) when it ﬁnds an empty slot, since k would have been\ninserted there and not later in its probe sequence. (This argument assumes that keys",
    "parent_03225e1f-d400-47c2-9aa6-22b5f37de4a6": "insertion algorithm examined when key k was inserted. Therefore, the search can\n11.4\nOpen addressing\n271\nterminate (unsuccessfully) when it ﬁnds an empty slot, since k would have been\ninserted there and not later in its probe sequence. (This argument assumes that keys\nare not deleted from the hash table.) The procedure HASH-SEARCH takes as input\na hash table T and a key k, returning j if it ﬁnds that slot j contains key k, or NIL\nif key k is not present in table T .\nHASH-SEARCH.T; k/\n1\ni D 0\n2\nrepeat\n3\nj D h.k; i/\n4\nif T Œj \u0002 == k\n5\nreturn j\n6\ni D i C 1\n7\nuntil T Œj \u0002 == NIL or i == m\n8\nreturn NIL\nDeletion from an open-address hash table is difﬁcult. When we delete a key\nfrom slot i, we cannot simply mark that slot as empty by storing NIL in it. If\nwe did, we might be unable to retrieve any key k during whose insertion we had\nprobed slot i and found it occupied. We can solve this problem by marking the\nslot, storing in it the special value DELETED instead of NIL. We would then modify\nthe procedure HASH-INSERT to treat such a slot as if it were empty so that we can\ninsert a new key there. We do not need to modify HASH-SEARCH, since it will pass\nover DELETED values while searching. When we use the special value DELETED,\nhowever, search times no longer depend on the load factor ˛, and for this reason\nchaining is more commonly selected as a collision resolution technique when keys\nmust be deleted.\nIn our analysis, we assume uniform hashing: the probe sequence of each key\nis equally likely to be any of the mŠ permutations of h0; 1; : : : ; m \u0005 1i. Uni-\nform hashing generalizes the notion of simple uniform hashing deﬁned earlier to a\nhash function that produces not just a single number, but a whole probe sequence.\nTrue uniform hashing is difﬁcult to implement, however, and in practice suitable\napproximations (such as double hashing, deﬁned below) are used.\nWe will examine three commonly used techniques to compute the probe se-",
    "parent_05ad2e4a-c654-4468-b6a0-51942c14d1e0": "hash function that produces not just a single number, but a whole probe sequence.\nTrue uniform hashing is difﬁcult to implement, however, and in practice suitable\napproximations (such as double hashing, deﬁned below) are used.\nWe will examine three commonly used techniques to compute the probe se-\nquences required for open addressing: linear probing, quadratic probing, and dou-\nble hashing. These techniques all guarantee that hh.k;0/;h.k;1/;: : : ;h.k;m \u0005 1/i\nis a permutation of h0; 1; : : : ; m \u0005 1i for each key k. None of these techniques ful-\nﬁlls the assumption of uniform hashing, however, since none of them is capable of\ngenerating more than m2 different probe sequences (instead of the mŠ that uniform\nhashing requires). Double hashing has the greatest number of probe sequences and,\nas one might expect, seems to give the best results.\n272\nChapter 11\nHash Tables\nLinear probing\nGiven an ordinary hash function h0 W U ! f0; 1; : : : ; m \u0005 1g, which we refer to as\nan auxiliary hash function, the method of linear probing uses the hash function\nh.k; i/ D .h0.k/ C i/ mod m\nfor i D 0; 1; : : : ; m \u0005 1. Given key k, we ﬁrst probe T Œh0.k/\u0002, i.e., the slot given\nby the auxiliary hash function. We next probe slot T Œh0.k/ C 1\u0002, and so on up to\nslot T Œm \u0005 1\u0002. Then we wrap around to slots T Œ0\u0002; T Œ1\u0002; : : : until we ﬁnally probe\nslot T Œh0.k/ \u0005 1\u0002. Because the initial probe determines the entire probe sequence,\nthere are only m distinct probe sequences.\nLinear probing is easy to implement, but it suffers from a problem known as\nprimary clustering. Long runs of occupied slots build up, increasing the average\nsearch time. Clusters arise because an empty slot preceded by i full slots gets ﬁlled\nnext with probability .i C 1/=m. Long runs of occupied slots tend to get longer,\nand the average search time increases.\nQuadratic probing\nQuadratic probing uses a hash function of the form\nh.k; i/ D .h0.k/ C c1i C c2i 2/ mod m ;\n(11.5)",
    "parent_18e05b03-7c7b-4763-84e5-77c6ea2c032f": "next with probability .i C 1/=m. Long runs of occupied slots tend to get longer,\nand the average search time increases.\nQuadratic probing\nQuadratic probing uses a hash function of the form\nh.k; i/ D .h0.k/ C c1i C c2i 2/ mod m ;\n(11.5)\nwhere h0 is an auxiliary hash function, c1 and c2 are positive auxiliary constants,\nand i D 0; 1; : : : ; m \u0005 1. The initial position probed is T Œh0.k/\u0002; later positions\nprobed are offset by amounts that depend in a quadratic manner on the probe num-\nber i. This method works much better than linear probing, but to make full use of\nthe hash table, the values of c1, c2, and m are constrained. Problem 11-3 shows\none way to select these parameters. Also, if two keys have the same initial probe\nposition, then their probe sequences are the same, since h.k1; 0/ D h.k2; 0/ im-\nplies h.k1; i/ D h.k2; i/. This property leads to a milder form of clustering, called\nsecondary clustering. As in linear probing, the initial probe determines the entire\nsequence, and so only m distinct probe sequences are used.\nDouble hashing\nDouble hashing offers one of the best methods available for open addressing be-\ncause the permutations produced have many of the characteristics of randomly\nchosen permutations. Double hashing uses a hash function of the form\nh.k; i/ D .h1.k/ C ih2.k// mod m ;\nwhere both h1 and h2 are auxiliary hash functions. The initial probe goes to posi-\ntion T Œh1.k/\u0002; successive probe positions are offset from previous positions by the\n11.4\nOpen addressing\n273\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n79\n69\n98\n72\n14\n50\nFigure 11.5\nInsertion by double hashing. Here we have a hash table of size 13 with h1.k/ D\nk mod 13 and h2.k/ D 1 C .k mod 11/. Since 14 \b 1 .mod 13/ and 14 \b 3 .mod 11/, we insert\nthe key 14 into empty slot 9, after examining slots 1 and 5 and ﬁnding them to be occupied.\namount h2.k/, modulo m. Thus, unlike the case of linear or quadratic probing, the\nprobe sequence here depends in two ways upon the key k, since the initial probe",
    "parent_40df1bf7-5ce0-47b6-b4ed-5baa6028368e": "the key 14 into empty slot 9, after examining slots 1 and 5 and ﬁnding them to be occupied.\namount h2.k/, modulo m. Thus, unlike the case of linear or quadratic probing, the\nprobe sequence here depends in two ways upon the key k, since the initial probe\nposition, the offset, or both, may vary. Figure 11.5 gives an example of insertion\nby double hashing.\nThe value h2.k/ must be relatively prime to the hash-table size m for the entire\nhash table to be searched. (See Exercise 11.4-4.) A convenient way to ensure this\ncondition is to let m be a power of 2 and to design h2 so that it always produces an\nodd number. Another way is to let m be prime and to design h2 so that it always\nreturns a positive integer less than m. For example, we could choose m prime and\nlet\nh1.k/\nD\nk mod m ;\nh2.k/\nD\n1 C .k mod m0/ ;\nwhere m0 is chosen to be slightly less than m (say, m \u0005 1).\nFor example, if\nk D 123456, m D 701, and m0 D 700, we have h1.k/ D 80 and h2.k/ D 257, so\nthat we ﬁrst probe position 80, and then we examine every 257th slot (modulo m)\nuntil we ﬁnd the key or have examined every slot.\nWhen m is prime or a power of 2, double hashing improves over linear or qua-\ndratic probing in that ‚.m2/ probe sequences are used, rather than ‚.m/, since\neach possible .h1.k/; h2.k// pair yields a distinct probe sequence. As a result, for\n274\nChapter 11\nHash Tables\nsuch values of m, the performance of double hashing appears to be very close to\nthe performance of the “ideal” scheme of uniform hashing.\nAlthough values of m other than primes or powers of 2 could in principle be\nused with double hashing, in practice it becomes more difﬁcult to efﬁciently gen-\nerate h2.k/ in a way that ensures that it is relatively prime to m, in part because the\nrelative density \u0007.m/=m of such numbers may be small (see equation (31.24)).\nAnalysis of open-address hashing\nAs in our analysis of chaining, we express our analysis of open addressing in terms",
    "parent_55b9f567-06e5-4424-bc7d-5d58d0c9b6b1": "erate h2.k/ in a way that ensures that it is relatively prime to m, in part because the\nrelative density \u0007.m/=m of such numbers may be small (see equation (31.24)).\nAnalysis of open-address hashing\nAs in our analysis of chaining, we express our analysis of open addressing in terms\nof the load factor ˛ D n=m of the hash table. Of course, with open addressing, at\nmost one element occupies each slot, and thus n \u0002 m, which implies ˛ \u0002 1.\nWe assume that we are using uniform hashing. In this idealized scheme, the\nprobe sequence hh.k; 0/; h.k; 1/; : : : ; h.k; m \u0005 1/i used to insert or search for\neach key k is equally likely to be any permutation of h0; 1; : : : ; m \u0005 1i. Of course,\na given key has a unique ﬁxed probe sequence associated with it; what we mean\nhere is that, considering the probability distribution on the space of keys and the\noperation of the hash function on the keys, each possible probe sequence is equally\nlikely.\nWe now analyze the expected number of probes for hashing with open address-\ning under the assumption of uniform hashing, beginning with an analysis of the\nnumber of probes made in an unsuccessful search.\nTheorem 11.6\nGiven an open-address hash table with load factor ˛ D n=m < 1, the expected\nnumber of probes in an unsuccessful search is at most 1=.1\u0005˛/, assuming uniform\nhashing.\nProof\nIn an unsuccessful search, every probe but the last accesses an occupied\nslot that does not contain the desired key, and the last slot probed is empty. Let us\ndeﬁne the random variable X to be the number of probes made in an unsuccessful\nsearch, and let us also deﬁne the event Ai, for i D 1; 2; : : :, to be the event that\nan ith probe occurs and it is to an occupied slot. Then the event fX \u0006 ig is the\nintersection of events A1\\A2\\\u0003 \u0003 \u0003\\Ai\u00031. We will bound Pr fX \u0006 ig by bounding\nPr fA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ai\u00031g. By Exercise C.2-5,\nPr fA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ai\u00031g D Pr fA1g \u0003 Pr fA2 j A1g \u0003 Pr fA3 j A1 \\ A2g \u0003 \u0003 \u0003\nPr fAi\u00031 j A1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ai\u00032g :",
    "parent_ac617c49-8424-420b-87dc-561a32ff1b94": "intersection of events A1\\A2\\\u0003 \u0003 \u0003\\Ai\u00031. We will bound Pr fX \u0006 ig by bounding\nPr fA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ai\u00031g. By Exercise C.2-5,\nPr fA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ai\u00031g D Pr fA1g \u0003 Pr fA2 j A1g \u0003 Pr fA3 j A1 \\ A2g \u0003 \u0003 \u0003\nPr fAi\u00031 j A1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ai\u00032g :\nSince there are n elements and m slots, Pr fA1g D n=m. For j > 1, the probability\nthat there is a j th probe and it is to an occupied slot, given that the ﬁrst j \u0005 1\nprobes were to occupied slots, is .n\u0005j C1/=.m\u0005j C1/. This probability follows\n11.4\nOpen addressing\n275\nbecause we would be ﬁnding one of the remaining .n \u0005 .j \u0005 1// elements in one\nof the .m \u0005 .j \u0005 1// unexamined slots, and by the assumption of uniform hashing,\nthe probability is the ratio of these quantities. Observing that n < m implies that\n.n \u0005 j /=.m \u0005 j / \u0002 n=m for all j such that 0 \u0002 j < m, we have for all i such that\n1 \u0002 i \u0002 m,\nPr fX \u0006 ig\nD\nn\nm \u0003 n \u0005 1\nm \u0005 1 \u0003 n \u0005 2\nm \u0005 2 \u0003 \u0003 \u0003 n \u0005 i C 2\nm \u0005 i C 2\n\u0002\n\u0004 n\nm\n\u0005i\u00031\nD\n˛i\u00031 :\nNow, we use equation (C.25) to bound the expected number of probes:\nE ŒX\u0002\nD\n1\nX\niD1\nPr fX \u0006 ig\n\u0002\n1\nX\niD1\n˛i\u00031\nD\n1\nX\niD0\n˛i\nD\n1\n1 \u0005 ˛ :\nThis bound of 1=.1\u0005˛/ D 1C˛ C˛2 C˛3 C\u0003 \u0003 \u0003 has an intuitive interpretation.\nWe always make the ﬁrst probe. With probability approximately ˛, the ﬁrst probe\nﬁnds an occupied slot, so that we need to probe a second time. With probability\napproximately ˛2, the ﬁrst two slots are occupied so that we make a third probe,\nand so on.\nIf ˛ is a constant, Theorem 11.6 predicts that an unsuccessful search runs in O.1/\ntime. For example, if the hash table is half full, the average number of probes in an\nunsuccessful search is at most 1=.1 \u0005 :5/ D 2. If it is 90 percent full, the average\nnumber of probes is at most 1=.1 \u0005 :9/ D 10.\nTheorem 11.6 gives us the performance of the HASH-INSERT procedure almost\nimmediately.\nCorollary 11.7\nInserting an element into an open-address hash table with load factor ˛ requires at\nmost 1=.1 \u0005 ˛/ probes on average, assuming uniform hashing.\n276\nChapter 11\nHash Tables\nProof",
    "parent_af698725-36e4-4fc8-8e2a-b8cc20fce718": "Theorem 11.6 gives us the performance of the HASH-INSERT procedure almost\nimmediately.\nCorollary 11.7\nInserting an element into an open-address hash table with load factor ˛ requires at\nmost 1=.1 \u0005 ˛/ probes on average, assuming uniform hashing.\n276\nChapter 11\nHash Tables\nProof\nAn element is inserted only if there is room in the table, and thus ˛ < 1.\nInserting a key requires an unsuccessful search followed by placing the key into the\nﬁrst empty slot found. Thus, the expected number of probes is at most 1=.1\u0005˛/.\nWe have to do a little more work to compute the expected number of probes for\na successful search.\nTheorem 11.8\nGiven an open-address hash table with load factor ˛ < 1, the expected number of\nprobes in a successful search is at most\n1\n˛ ln\n1\n1 \u0005 ˛ ;\nassuming uniform hashing and assuming that each key in the table is equally likely\nto be searched for.\nProof\nA search for a key k reproduces the same probe sequence as when the\nelement with key k was inserted. By Corollary 11.7, if k was the .i C 1/st key\ninserted into the hash table, the expected number of probes made in a search for k\nis at most 1=.1 \u0005 i=m/ D m=.m \u0005 i/. Averaging over all n keys in the hash table\ngives us the expected number of probes in a successful search:\n1\nn\nn\u00031\nX\niD0\nm\nm \u0005 i\nD\nm\nn\nn\u00031\nX\niD0\n1\nm \u0005 i\nD\n1\n˛\nm\nX\nkDm\u0003nC1\n1\nk\n\u0002\n1\n˛\nZ m\nm\u0003n\n.1=x/ dx\n(by inequality (A.12))\nD\n1\n˛ ln\nm\nm \u0005 n\nD\n1\n˛ ln\n1\n1 \u0005 ˛ :\nIf the hash table is half full, the expected number of probes in a successful search\nis less than 1:387. If the hash table is 90 percent full, the expected number of probes\nis less than 2:559.\n11.5\nPerfect hashing\n277\nExercises\n11.4-1\nConsider inserting the keys 10; 22; 31; 4; 15; 28; 17; 88; 59 into a hash table of\nlength m D 11 using open addressing with the auxiliary hash function h0.k/ D k.\nIllustrate the result of inserting these keys using linear probing, using quadratic\nprobing with c1 D 1 and c2 D 3, and using double hashing with h1.k/ D k and\nh2.k/ D 1 C .k mod .m \u0005 1//.\n11.4-2",
    "parent_68c989c9-268d-4562-8446-356352d8ed4a": "length m D 11 using open addressing with the auxiliary hash function h0.k/ D k.\nIllustrate the result of inserting these keys using linear probing, using quadratic\nprobing with c1 D 1 and c2 D 3, and using double hashing with h1.k/ D k and\nh2.k/ D 1 C .k mod .m \u0005 1//.\n11.4-2\nWrite pseudocode for HASH-DELETE as outlined in the text, and modify HASH-\nINSERT to handle the special value DELETED.\n11.4-3\nConsider an open-address hash table with uniform hashing. Give upper bounds\non the expected number of probes in an unsuccessful search and on the expected\nnumber of probes in a successful search when the load factor is 3=4 and when it\nis 7=8.\n11.4-4\n?\nSuppose that we use double hashing to resolve collisions—that is, we use the hash\nfunction h.k; i/ D .h1.k/ C ih2.k// mod m. Show that if m and h2.k/ have\ngreatest common divisor d \u0006 1 for some key k, then an unsuccessful search for\nkey k examines .1=d/th of the hash table before returning to slot h1.k/. Thus,\nwhen d D 1, so that m and h2.k/ are relatively prime, the search may examine the\nentire hash table. (Hint: See Chapter 31.)\n11.4-5\n?\nConsider an open-address hash table with a load factor ˛. Find the nonzero value ˛\nfor which the expected number of probes in an unsuccessful search equals twice\nthe expected number of probes in a successful search. Use the upper bounds given\nby Theorems 11.6 and 11.8 for these expected numbers of probes.\n?\n11.5\nPerfect hashing\nAlthough hashing is often a good choice for its excellent average-case perfor-\nmance, hashing can also provide excellent worst-case performance when the set of\nkeys is static: once the keys are stored in the table, the set of keys never changes.\nSome applications naturally have static sets of keys: consider the set of reserved\nwords in a programming language, or the set of ﬁle names on a CD-ROM. We\n278\nChapter 11\nHash Tables\n0\n1\n2\n3\n4\n5\n6\n7\n8\n1\n0\n0 10\n9 10 18\n60\n75\n0\n1\n2\n3\n1\n0\n0 70\n0\n0\n16 23 88\n40\n37\n0\n1\n2\n3\n4\n5\n6\n7\n8\n52\nm2\nS2\na2 b2\nm0\nS0\na0 b0\nm5\nS5\na5 b5\nm7\nS7",
    "parent_70055324-8212-4408-a725-c1210b4ed9b5": "words in a programming language, or the set of ﬁle names on a CD-ROM. We\n278\nChapter 11\nHash Tables\n0\n1\n2\n3\n4\n5\n6\n7\n8\n1\n0\n0 10\n9 10 18\n60\n75\n0\n1\n2\n3\n1\n0\n0 70\n0\n0\n16 23 88\n40\n37\n0\n1\n2\n3\n4\n5\n6\n7\n8\n52\nm2\nS2\na2 b2\nm0\nS0\na0 b0\nm5\nS5\na5 b5\nm7\nS7\na7 b7\nT\n4\n5\n6\n7\n8\n72\n9\n10\n11\n12\n13\n14\n15\n22\nFigure 11.6\nUsing perfect hashing to store the set K D f10; 22; 37; 40; 52; 60; 70; 72; 75g. The\nouter hash function is h.k/ D ..ak C b/ mod p/ mod m, where a D 3, b D 42, p D 101, and\nm D 9. For example, h.75/ D 2, and so key 75 hashes to slot 2 of table T . A secondary hash\ntable Sj stores all keys hashing to slot j. The size of hash table Sj is mj D n2\nj , and the associated\nhash function is hj .k/ D ..aj k C bj / mod p/ mod mj . Since h2.75/ D 7, key 75 is stored in slot 7\nof secondary hash table S2. No collisions occur in any of the secondary hash tables, and so searching\ntakes constant time in the worst case.\ncall a hashing technique perfect hashing if O.1/ memory accesses are required to\nperform a search in the worst case.\nTo create a perfect hashing scheme, we use two levels of hashing, with universal\nhashing at each level. Figure 11.6 illustrates the approach.\nThe ﬁrst level is essentially the same as for hashing with chaining: we hash\nthe n keys into m slots using a hash function h carefully selected from a family of\nuniversal hash functions.\nInstead of making a linked list of the keys hashing to slot j , however, we use a\nsmall secondary hash table Sj with an associated hash function hj . By choosing\nthe hash functions hj carefully, we can guarantee that there are no collisions at the\nsecondary level.\nIn order to guarantee that there are no collisions at the secondary level, however,\nwe will need to let the size mj of hash table Sj be the square of the number nj of\nkeys hashing to slot j . Although you might think that the quadratic dependence\nof mj on nj may seem likely to cause the overall storage requirement to be exces-",
    "parent_6a81d6ef-e47d-4863-9da3-2671e2f0323d": "we will need to let the size mj of hash table Sj be the square of the number nj of\nkeys hashing to slot j . Although you might think that the quadratic dependence\nof mj on nj may seem likely to cause the overall storage requirement to be exces-\nsive, we shall show that by choosing the ﬁrst-level hash function well, we can limit\nthe expected total amount of space used to O.n/.\nWe use hash functions chosen from the universal classes of hash functions of\nSection 11.3.3. The ﬁrst-level hash function comes from the class Hpm, where as\nin Section 11.3.3, p is a prime number greater than any key value. Those keys\n11.5\nPerfect hashing\n279\nhashing to slot j are re-hashed into a secondary hash table Sj of size mj using a\nhash function hj chosen from the class Hp;mj .1\nWe shall proceed in two steps. First, we shall determine how to ensure that\nthe secondary tables have no collisions. Second, we shall show that the expected\namount of memory used overall—for the primary hash table and all the secondary\nhash tables—is O.n/.\nTheorem 11.9\nSuppose that we store n keys in a hash table of size m D n2 using a hash function h\nrandomly chosen from a universal class of hash functions. Then, the probability is\nless than 1=2 that there are any collisions.\nProof\nThere are\n\u000bn\n2\n\f\npairs of keys that may collide; each pair collides with prob-\nability 1=m if h is chosen at random from a universal family H of hash functions.\nLet X be a random variable that counts the number of collisions. When m D n2,\nthe expected number of collisions is\nE ŒX\u0002\nD\n \nn\n2\n!\n\u0003 1\nn2\nD\nn2 \u0005 n\n2\n\u0003 1\nn2\n<\n1=2 :\n(This analysis is similar to the analysis of the birthday paradox in Section 5.4.1.)\nApplying Markov’s inequality (C.30), Pr fX \u0006 tg \u0002 E ŒX\u0002 =t, with t D 1, com-\npletes the proof.\nIn the situation described in Theorem 11.9, where m D n2, it follows that a hash\nfunction h chosen at random from H is more likely than not to have no collisions.",
    "parent_4c40c7dd-ecca-41ac-b3b3-a2baabf6273b": "Applying Markov’s inequality (C.30), Pr fX \u0006 tg \u0002 E ŒX\u0002 =t, with t D 1, com-\npletes the proof.\nIn the situation described in Theorem 11.9, where m D n2, it follows that a hash\nfunction h chosen at random from H is more likely than not to have no collisions.\nGiven the set K of n keys to be hashed (remember that K is static), it is thus easy\nto ﬁnd a collision-free hash function h with a few random trials.\nWhen n is large, however, a hash table of size m D n2 is excessive. Therefore,\nwe adopt the two-level hashing approach, and we use the approach of Theorem 11.9\nonly to hash the entries within each slot. We use an outer, or ﬁrst-level, hash\nfunction h to hash the keys into m D n slots. Then, if nj keys hash to slot j , we\nuse a secondary hash table Sj of size mj D n2\nj to provide collision-free constant-\ntime lookup.\n1When nj D mj D 1, we don’t really need a hash function for slot j; when we choose a hash\nfunction hab.k/ D ..ak C b/ mod p/ mod mj for such a slot, we just use a D b D 0.\n280\nChapter 11\nHash Tables\nWe now turn to the issue of ensuring that the overall memory used is O.n/.\nSince the size mj of the j th secondary hash table grows quadratically with the\nnumber nj of keys stored, we run the risk that the overall amount of storage could\nbe excessive.\nIf the ﬁrst-level table size is m D n, then the amount of memory used is O.n/\nfor the primary hash table, for the storage of the sizes mj of the secondary hash\ntables, and for the storage of the parameters aj and bj deﬁning the secondary hash\nfunctions hj drawn from the class Hp;mj of Section 11.3.3 (except when nj D 1\nand we use a D b D 0). The following theorem and a corollary provide a bound on\nthe expected combined sizes of all the secondary hash tables. A second corollary\nbounds the probability that the combined size of all the secondary hash tables is\nsuperlinear (actually, that it equals or exceeds 4n).\nTheorem 11.10\nSuppose that we store n keys in a hash table of size m D n using a hash function h",
    "parent_2d42a131-629b-4bc9-8d87-d70ac7b1c29d": "bounds the probability that the combined size of all the secondary hash tables is\nsuperlinear (actually, that it equals or exceeds 4n).\nTheorem 11.10\nSuppose that we store n keys in a hash table of size m D n using a hash function h\nrandomly chosen from a universal class of hash functions. Then, we have\nE\n\"m\u00031\nX\njD0\nn2\nj\n#\n< 2n ;\nwhere nj is the number of keys hashing to slot j .\nProof\nWe start with the following identity, which holds for any nonnegative inte-\nger a:\na2 D a C 2\n \na\n2\n!\n:\n(11.6)\nWe have\nE\n\"m\u00031\nX\njD0\nn2\nj\n#\nD\nE\n\"m\u00031\nX\njD0\n \nnj C 2\n \nnj\n2\n!!#\n(by equation (11.6))\nD\nE\n\"m\u00031\nX\njD0\nnj\n#\nC 2 E\n\"m\u00031\nX\njD0\n \nnj\n2\n!#\n(by linearity of expectation)\nD\nE Œn\u0002 C 2 E\n\"m\u00031\nX\njD0\n \nnj\n2\n!#\n(by equation (11.1))\n11.5\nPerfect hashing\n281\nD\nn C 2 E\n\"m\u00031\nX\njD0\n \nnj\n2\n!#\n(since n is not a random variable) .\nTo evaluate the summation Pm\u00031\njD0\n\u000bnj\n2\n\f\n, we observe that it is just the total number\nof pairs of keys in the hash table that collide. By the properties of universal hashing,\nthe expected value of this summation is at most\n \nn\n2\n!\n1\nm\nD\nn.n \u0005 1/\n2m\nD\nn \u0005 1\n2\n;\nsince m D n. Thus,\nE\n\"m\u00031\nX\njD0\nn2\nj\n#\n\u0002\nn C 2 n \u0005 1\n2\nD\n2n \u0005 1\n<\n2n :\nCorollary 11.11\nSuppose that we store n keys in a hash table of size m D n using a hash func-\ntion h randomly chosen from a universal class of hash functions, and we set the\nsize of each secondary hash table to mj D n2\nj for j D 0; 1; : : : ; m \u0005 1. Then,\nthe expected amount of storage required for all secondary hash tables in a perfect\nhashing scheme is less than 2n.\nProof\nSince mj D n2\nj for j D 0; 1; : : : ; m \u0005 1, Theorem 11.10 gives\nE\n\"m\u00031\nX\njD0\nmj\n#\nD\nE\n\"m\u00031\nX\njD0\nn2\nj\n#\n<\n2n ;\n(11.7)\nwhich completes the proof.\nCorollary 11.12\nSuppose that we store n keys in a hash table of size m D n using a hash function h\nrandomly chosen from a universal class of hash functions, and we set the size\nof each secondary hash table to mj D n2\nj for j D 0; 1; : : : ; m \u0005 1. Then, the",
    "parent_d0e151c0-6aec-4ab3-9586-84892d108d38": "<\n2n ;\n(11.7)\nwhich completes the proof.\nCorollary 11.12\nSuppose that we store n keys in a hash table of size m D n using a hash function h\nrandomly chosen from a universal class of hash functions, and we set the size\nof each secondary hash table to mj D n2\nj for j D 0; 1; : : : ; m \u0005 1. Then, the\nprobability is less than 1=2 that the total storage used for secondary hash tables\nequals or exceeds 4n.\n282\nChapter 11\nHash Tables\nProof\nAgain we apply Markov’s inequality (C.30), Pr fX \u0006 tg \u0002 E ŒX\u0002 =t, this\ntime to inequality (11.7), with X D Pm\u00031\njD0 mj and t D 4n:\nPr\n(m\u00031\nX\njD0\nmj \u0006 4n\n)\n\u0002\nE\n\u000fPm\u00031\njD0 mj\n\u0010\n4n\n<\n2n\n4n\nD\n1=2 :\nFrom Corollary 11.12, we see that if we test a few randomly chosen hash func-\ntions from the universal family, we will quickly ﬁnd one that uses a reasonable\namount of storage.\nExercises\n11.5-1\n?\nSuppose that we insert n keys into a hash table of size m using open addressing\nand uniform hashing. Let p.n; m/ be the probability that no collisions occur. Show\nthat p.n; m/ \u0002 e\u0003n.n\u00031/=2m. (Hint: See equation (3.12).) Argue that when n ex-\nceeds pm, the probability of avoiding collisions goes rapidly to zero.\nProblems\n11-1\nLongest-probe bound for hashing\nSuppose that we use an open-addressed hash table of size m to store n \u0002 m=2\nitems.\na. Assuming uniform hashing, show that for i D 1; 2; : : : ; n, the probability is at\nmost 2\u0003k that the ith insertion requires strictly more than k probes.\nb. Show that for i D 1; 2; : : : ; n, the probability is O.1=n2/ that the ith insertion\nrequires more than 2 lg n probes.\nLet the random variable Xi denote the number of probes required by the ith inser-\ntion. You have shown in part (b) that Pr fXi > 2 lg ng D O.1=n2/. Let the random\nvariable X D max1\u0005i\u0005n Xi denote the maximum number of probes required by\nany of the n insertions.\nc. Show that Pr fX > 2 lg ng D O.1=n/.\nd. Show that the expected length E ŒX\u0002 of the longest probe sequence is O.lg n/.\nProblems for Chapter 11\n283\n11-2\nSlot-size bound for chaining",
    "parent_6d5e45eb-86c0-43b8-8c48-8c6b4873285f": "variable X D max1\u0005i\u0005n Xi denote the maximum number of probes required by\nany of the n insertions.\nc. Show that Pr fX > 2 lg ng D O.1=n/.\nd. Show that the expected length E ŒX\u0002 of the longest probe sequence is O.lg n/.\nProblems for Chapter 11\n283\n11-2\nSlot-size bound for chaining\nSuppose that we have a hash table with n slots, with collisions resolved by chain-\ning, and suppose that n keys are inserted into the table. Each key is equally likely\nto be hashed to each slot. Let M be the maximum number of keys in any slot after\nall the keys have been inserted. Your mission is to prove an O.lg n= lg lg n/ upper\nbound on E ŒM\u0002, the expected value of M.\na. Argue that the probability Qk that exactly k keys hash to a particular slot is\ngiven by\nQk D\n\u00021\nn\n\u0003k\u0002\n1 \u0005 1\nn\n\u0003n\u0003k \nn\nk\n!\n:\nb. Let Pk be the probability that M D k, that is, the probability that the slot\ncontaining the most keys contains k keys. Show that Pk \u0002 nQk.\nc. Use Stirling’s approximation, equation (3.18), to show that Qk < ek=kk.\nd. Show that there exists a constant c > 1 such that Qk0 < 1=n3 for k0 D\nc lg n= lg lg n. Conclude that Pk < 1=n2 for k \u0006 k0 D c lg n= lg lg n.\ne. Argue that\nE ŒM\u0002 \u0002 Pr\n\u0011\nM > c lg n\nlg lg n\n\u0012\n\u0003 n C Pr\n\u0011\nM \u0002 c lg n\nlg lg n\n\u0012\n\u0003 c lg n\nlg lg n :\nConclude that E ŒM\u0002 D O.lg n= lg lg n/.\n11-3\nQuadratic probing\nSuppose that we are given a key k to search for in a hash table with positions\n0; 1; : : : ; m\u00051, and suppose that we have a hash function h mapping the key space\ninto the set f0; 1; : : : ; m \u0005 1g. The search scheme is as follows:\n1. Compute the value j D h.k/, and set i D 0.\n2. Probe in position j for the desired key k. If you ﬁnd it, or if this position is\nempty, terminate the search.\n3. Set i D i C 1. If i now equals m, the table is full, so terminate the search.\nOtherwise, set j D .i C j / mod m, and return to step 2.\nAssume that m is a power of 2.\na. Show that this scheme is an instance of the general “quadratic probing” scheme",
    "parent_f73e9f6c-e1fb-46d5-a0d9-48c18700df40": "empty, terminate the search.\n3. Set i D i C 1. If i now equals m, the table is full, so terminate the search.\nOtherwise, set j D .i C j / mod m, and return to step 2.\nAssume that m is a power of 2.\na. Show that this scheme is an instance of the general “quadratic probing” scheme\nby exhibiting the appropriate constants c1 and c2 for equation (11.5).\nb. Prove that this algorithm examines every table position in the worst case.\n284\nChapter 11\nHash Tables\n11-4\nHashing and authentication\nLet H be a class of hash functions in which each hash function h 2 H maps the\nuniverse U of keys to f0; 1; : : : ; m \u0005 1g. We say that H is k-universal if, for every\nﬁxed sequence of k distinct keys hx.1/; x.2/; : : : ; x.k/i and for any h chosen at\nrandom from H, the sequence hh.x.1//;h.x.2//;: : : ;h.x.k//i is equally likely to be\nany of the mk sequences of length k with elements drawn from f0; 1; : : : ; m \u0005 1g.\na. Show that if the family H of hash functions is 2-universal, then it is universal.\nb. Suppose that the universe U is the set of n-tuples of values drawn from\nZp\nD f0; 1; : : : ; p \u0005 1g, where p is prime.\nConsider an element x D\nhx0; x1; : : : ; xn\u00031i 2 U . For any n-tuple a D ha0; a1; : : : ; an\u00031i 2 U , de-\nﬁne the hash function ha by\nha.x/ D\n n\u00031\nX\njD0\najxj\n!\nmod p :\nLet H D fhag. Show that H is universal, but not 2-universal. (Hint: Find a key\nfor which all hash functions in H produce the same value.)\nc. Suppose that we modify H slightly from part (b): for any a 2 U and for any\nb 2 Zp, deﬁne\nh0\nab.x/ D\n n\u00031\nX\njD0\najxj C b\n!\nmod p\nand H 0 D fh0\nabg. Argue that H 0 is 2-universal. (Hint: Consider ﬁxed n-tuples\nx 2 U and y 2 U , with xi ¤ yi for some i. What happens to h0\nab.x/\nand h0\nab.y/ as ai and b range over Zp?)\nd. Suppose that Alice and Bob secretly agree on a hash function h from a\n2-universal family H of hash functions. Each h 2 H maps from a universe of\nkeys U to Zp, where p is prime. Later, Alice sends a message m to Bob over the",
    "parent_ee39f60f-4676-444f-aa4e-166c0c213548": "ab.x/\nand h0\nab.y/ as ai and b range over Zp?)\nd. Suppose that Alice and Bob secretly agree on a hash function h from a\n2-universal family H of hash functions. Each h 2 H maps from a universe of\nkeys U to Zp, where p is prime. Later, Alice sends a message m to Bob over the\nInternet, where m 2 U . She authenticates this message to Bob by also sending\nan authentication tag t D h.m/, and Bob checks that the pair .m; t/ he receives\nindeed satisﬁes t D h.m/. Suppose that an adversary intercepts .m; t/ en route\nand tries to fool Bob by replacing the pair .m; t/ with a different pair .m0; t0/.\nArgue that the probability that the adversary succeeds in fooling Bob into ac-\ncepting .m0; t0/ is at most 1=p, no matter how much computing power the ad-\nversary has, and even if the adversary knows the family H of hash functions\nused.\nNotes for Chapter 11\n285\nChapter notes\nKnuth [211] and Gonnet [145] are excellent references for the analysis of hash-\ning algorithms. Knuth credits H. P. Luhn (1953) for inventing hash tables, along\nwith the chaining method for resolving collisions. At about the same time, G. M.\nAmdahl originated the idea of open addressing.\nCarter and Wegman introduced the notion of universal classes of hash functions\nin 1979 [58].\nFredman, Koml´os, and Szemer´edi [112] developed the perfect hashing scheme\nfor static sets presented in Section 11.5. An extension of their method to dynamic\nsets, handling insertions and deletions in amortized expected time O.1/, has been\ngiven by Dietzfelbinger et al. [86].\n12\nBinary Search Trees\nThe search tree data structure supports many dynamic-set operations, including\nSEARCH, MINIMUM, MAXIMUM, PREDECESSOR, SUCCESSOR, INSERT, and\nDELETE. Thus, we can use a search tree both as a dictionary and as a priority\nqueue.\nBasic operations on a binary search tree take time proportional to the height of\nthe tree. For a complete binary tree with n nodes, such operations run in ‚.lg n/",
    "parent_ca3ab93f-168f-4730-9038-234ded8e94f4": "DELETE. Thus, we can use a search tree both as a dictionary and as a priority\nqueue.\nBasic operations on a binary search tree take time proportional to the height of\nthe tree. For a complete binary tree with n nodes, such operations run in ‚.lg n/\nworst-case time. If the tree is a linear chain of n nodes, however, the same oper-\nations take ‚.n/ worst-case time. We shall see in Section 12.4 that the expected\nheight of a randomly built binary search tree is O.lg n/, so that basic dynamic-set\noperations on such a tree take ‚.lg n/ time on average.\nIn practice, we can’t always guarantee that binary search trees are built ran-\ndomly, but we can design variations of binary search trees with good guaranteed\nworst-case performance on basic operations. Chapter 13 presents one such vari-\nation, red-black trees, which have height O.lg n/. Chapter 18 introduces B-trees,\nwhich are particularly good for maintaining databases on secondary (disk) storage.\nAfter presenting the basic properties of binary search trees, the following sec-\ntions show how to walk a binary search tree to print its values in sorted order, how\nto search for a value in a binary search tree, how to ﬁnd the minimum or maximum\nelement, how to ﬁnd the predecessor or successor of an element, and how to insert\ninto or delete from a binary search tree. The basic mathematical properties of trees\nappear in Appendix B.\n12.1\nWhat is a binary search tree?\nA binary search tree is organized, as the name suggests, in a binary tree, as shown\nin Figure 12.1. We can represent such a tree by a linked data structure in which\neach node is an object. In addition to a key and satellite data, each node contains\nattributes left, right, and p that point to the nodes corresponding to its left child,\n12.1\nWhat is a binary search tree?\n287\n5\n2\n5\n5\n8\n7\n6\n(a)\n6\n8\n7\n5\n2\n(b)\nFigure 12.1\nBinary search trees. For any node x, the keys in the left subtree of x are at most x:key,",
    "parent_ffb7167f-d831-41ce-80d3-5422f6bf3143": "attributes left, right, and p that point to the nodes corresponding to its left child,\n12.1\nWhat is a binary search tree?\n287\n5\n2\n5\n5\n8\n7\n6\n(a)\n6\n8\n7\n5\n2\n(b)\nFigure 12.1\nBinary search trees. For any node x, the keys in the left subtree of x are at most x:key,\nand the keys in the right subtree of x are at least x:key. Different binary search trees can represent\nthe same set of values. The worst-case running time for most search-tree operations is proportional\nto the height of the tree. (a) A binary search tree on 6 nodes with height 2. (b) A less efﬁcient binary\nsearch tree with height 4 that contains the same keys.\nits right child, and its parent, respectively. If a child or the parent is missing, the\nappropriate attribute contains the value NIL. The root node is the only node in the\ntree whose parent is NIL.\nThe keys in a binary search tree are always stored in such a way as to satisfy the\nbinary-search-tree property:\nLet x be a node in a binary search tree. If y is a node in the left subtree\nof x, then y:key \u0002 x:key. If y is a node in the right subtree of x, then\ny:key \u0006 x:key.\nThus, in Figure 12.1(a), the key of the root is 6, the keys 2, 5, and 5 in its left\nsubtree are no larger than 6, and the keys 7 and 8 in its right subtree are no smaller\nthan 6. The same property holds for every node in the tree. For example, the key 5\nin the root’s left child is no smaller than the key 2 in that node’s left subtree and no\nlarger than the key 5 in the right subtree.\nThe binary-search-tree property allows us to print out all the keys in a binary\nsearch tree in sorted order by a simple recursive algorithm, called an inorder tree\nwalk. This algorithm is so named because it prints the key of the root of a subtree\nbetween printing the values in its left subtree and printing those in its right subtree.\n(Similarly, a preorder tree walk prints the root before the values in either subtree,\nand a postorder tree walk prints the root after the values in its subtrees.) To use",
    "parent_859ab7a7-5998-4334-a798-478387e02bca": "between printing the values in its left subtree and printing those in its right subtree.\n(Similarly, a preorder tree walk prints the root before the values in either subtree,\nand a postorder tree walk prints the root after the values in its subtrees.) To use\nthe following procedure to print all the elements in a binary search tree T , we call\nINORDER-TREE-WALK.T:root/.\n288\nChapter 12\nBinary Search Trees\nINORDER-TREE-WALK.x/\n1\nif x ¤ NIL\n2\nINORDER-TREE-WALK.x:left/\n3\nprint x:key\n4\nINORDER-TREE-WALK.x:right/\nAs an example, the inorder tree walk prints the keys in each of the two binary\nsearch trees from Figure 12.1 in the order 2; 5; 5; 6; 7; 8. The correctness of the\nalgorithm follows by induction directly from the binary-search-tree property.\nIt takes ‚.n/ time to walk an n-node binary search tree, since after the ini-\ntial call, the procedure calls itself recursively exactly twice for each node in the\ntree—once for its left child and once for its right child. The following theorem\ngives a formal proof that it takes linear time to perform an inorder tree walk.\nTheorem 12.1\nIf x is the root of an n-node subtree, then the call INORDER-TREE-WALK.x/\ntakes ‚.n/ time.\nProof\nLet T .n/ denote the time taken by INORDER-TREE-WALK when it is\ncalled on the root of an n-node subtree. Since INORDER-TREE-WALK visits all n\nnodes of the subtree, we have T .n/ D \u0004.n/. It remains to show that T .n/ D O.n/.\nSince INORDER-TREE-WALK takes a small, constant amount of time on an\nempty subtree (for the test x ¤ NIL), we have T .0/ D c for some constant c > 0.\nFor n > 0, suppose that INORDER-TREE-WALK is called on a node x whose\nleft subtree has k nodes and whose right subtree has n \u0005 k \u0005 1 nodes. The time to\nperform INORDER-TREE-WALK.x/ is bounded by T .n/ \u0002 T .k/CT .n\u0005k\u00051/Cd\nfor some constant d > 0 that reﬂects an upper bound on the time to execute the\nbody of INORDER-TREE-WALK.x/, exclusive of the time spent in recursive calls.",
    "parent_92ec2fb1-0e55-4c82-90b0-4ffa966afb66": "perform INORDER-TREE-WALK.x/ is bounded by T .n/ \u0002 T .k/CT .n\u0005k\u00051/Cd\nfor some constant d > 0 that reﬂects an upper bound on the time to execute the\nbody of INORDER-TREE-WALK.x/, exclusive of the time spent in recursive calls.\nWe use the substitution method to show that T .n/ D O.n/ by proving that\nT .n/ \u0002 .c Cd/nCc. For n D 0, we have .c Cd/\u00030Cc D c D T .0/. For n > 0,\nwe have\nT .n/\n\u0002\nT .k/ C T .n \u0005 k \u0005 1/ C d\nD\n..c C d/k C c/ C ..c C d/.n \u0005 k \u0005 1/ C c/ C d\nD\n.c C d/n C c \u0005 .c C d/ C c C d\nD\n.c C d/n C c ;\nwhich completes the proof.\n12.2\nQuerying a binary search tree\n289\nExercises\n12.1-1\nFor the set of f1; 4; 5; 10; 16; 17; 21g of keys, draw binary search trees of heights 2,\n3, 4, 5, and 6.\n12.1-2\nWhat is the difference between the binary-search-tree property and the min-heap\nproperty (see page 153)? Can the min-heap property be used to print out the keys\nof an n-node tree in sorted order in O.n/ time? Show how, or explain why not.\n12.1-3\nGive a nonrecursive algorithm that performs an inorder tree walk. (Hint: An easy\nsolution uses a stack as an auxiliary data structure. A more complicated, but ele-\ngant, solution uses no stack but assumes that we can test two pointers for equality.)\n12.1-4\nGive recursive algorithms that perform preorder and postorder tree walks in ‚.n/\ntime on a tree of n nodes.\n12.1-5\nArgue that since sorting n elements takes \u0004.n lg n/ time in the worst case in\nthe comparison model, any comparison-based algorithm for constructing a binary\nsearch tree from an arbitrary list of n elements takes \u0004.n lg n/ time in the worst\ncase.\n12.2\nQuerying a binary search tree\nWe often need to search for a key stored in a binary search tree. Besides the\nSEARCH operation, binary search trees can support such queries as MINIMUM,\nMAXIMUM, SUCCESSOR, and PREDECESSOR. In this section, we shall examine\nthese operations and show how to support each one in time O.h/ on any binary\nsearch tree of height h.\nSearching",
    "parent_d76d8f09-e7b4-4b6f-a08a-a39a1f49aeb1": "SEARCH operation, binary search trees can support such queries as MINIMUM,\nMAXIMUM, SUCCESSOR, and PREDECESSOR. In this section, we shall examine\nthese operations and show how to support each one in time O.h/ on any binary\nsearch tree of height h.\nSearching\nWe use the following procedure to search for a node with a given key in a binary\nsearch tree. Given a pointer to the root of the tree and a key k, TREE-SEARCH\nreturns a pointer to a node with key k if one exists; otherwise, it returns NIL.\n290\nChapter 12\nBinary Search Trees\n2\n4\n3\n13\n7\n6\n17\n20\n18\n15\n9\nFigure 12.2\nQueries on a binary search tree. To search for the key 13 in the tree, we follow the path\n15 ! 6 ! 7 ! 13 from the root. The minimum key in the tree is 2, which is found by following\nleft pointers from the root. The maximum key 20 is found by following right pointers from the root.\nThe successor of the node with key 15 is the node with key 17, since it is the minimum key in the\nright subtree of 15. The node with key 13 has no right subtree, and thus its successor is its lowest\nancestor whose left child is also an ancestor. In this case, the node with key 15 is its successor.\nTREE-SEARCH.x; k/\n1\nif x == NIL or k == x:key\n2\nreturn x\n3\nif k < x:key\n4\nreturn TREE-SEARCH.x:left; k/\n5\nelse return TREE-SEARCH.x:right; k/\nThe procedure begins its search at the root and traces a simple path downward in\nthe tree, as shown in Figure 12.2. For each node x it encounters, it compares the\nkey k with x:key. If the two keys are equal, the search terminates. If k is smaller\nthan x:key, the search continues in the left subtree of x, since the binary-search-\ntree property implies that k could not be stored in the right subtree. Symmetrically,\nif k is larger than x:key, the search continues in the right subtree. The nodes\nencountered during the recursion form a simple path downward from the root of\nthe tree, and thus the running time of TREE-SEARCH is O.h/, where h is the height\nof the tree.",
    "parent_9480e2a8-ca0b-47e8-b351-f405460975b5": "if k is larger than x:key, the search continues in the right subtree. The nodes\nencountered during the recursion form a simple path downward from the root of\nthe tree, and thus the running time of TREE-SEARCH is O.h/, where h is the height\nof the tree.\nWe can rewrite this procedure in an iterative fashion by “unrolling” the recursion\ninto a while loop. On most computers, the iterative version is more efﬁcient.\n12.2\nQuerying a binary search tree\n291\nITERATIVE-TREE-SEARCH.x; k/\n1\nwhile x ¤ NIL and k ¤ x:key\n2\nif k < x:key\n3\nx D x:left\n4\nelse x D x:right\n5\nreturn x\nMinimum and maximum\nWe can always ﬁnd an element in a binary search tree whose key is a minimum by\nfollowing left child pointers from the root until we encounter a NIL, as shown in\nFigure 12.2. The following procedure returns a pointer to the minimum element in\nthe subtree rooted at a given node x, which we assume to be non-NIL:\nTREE-MINIMUM.x/\n1\nwhile x:left ¤ NIL\n2\nx D x:left\n3\nreturn x\nThe binary-search-tree property guarantees that TREE-MINIMUM is correct. If a\nnode x has no left subtree, then since every key in the right subtree of x is at least as\nlarge as x:key, the minimum key in the subtree rooted at x is x:key. If node x has\na left subtree, then since no key in the right subtree is smaller than x:key and every\nkey in the left subtree is not larger than x:key, the minimum key in the subtree\nrooted at x resides in the subtree rooted at x:left.\nThe pseudocode for TREE-MAXIMUM is symmetric:\nTREE-MAXIMUM.x/\n1\nwhile x:right ¤ NIL\n2\nx D x:right\n3\nreturn x\nBoth of these procedures run in O.h/ time on a tree of height h since, as in TREE-\nSEARCH, the sequence of nodes encountered forms a simple path downward from\nthe root.\nSuccessor and predecessor\nGiven a node in a binary search tree, sometimes we need to ﬁnd its successor in\nthe sorted order determined by an inorder tree walk. If all keys are distinct, the\n292\nChapter 12\nBinary Search Trees",
    "parent_d7fe322a-727d-4a09-bc96-99010323bba9": "the root.\nSuccessor and predecessor\nGiven a node in a binary search tree, sometimes we need to ﬁnd its successor in\nthe sorted order determined by an inorder tree walk. If all keys are distinct, the\n292\nChapter 12\nBinary Search Trees\nsuccessor of a node x is the node with the smallest key greater than x:key. The\nstructure of a binary search tree allows us to determine the successor of a node\nwithout ever comparing keys. The following procedure returns the successor of a\nnode x in a binary search tree if it exists, and NIL if x has the largest key in the\ntree:\nTREE-SUCCESSOR.x/\n1\nif x:right ¤ NIL\n2\nreturn TREE-MINIMUM.x:right/\n3\ny D x:p\n4\nwhile y ¤ NIL and x == y:right\n5\nx D y\n6\ny D y:p\n7\nreturn y\nWe break the code for TREE-SUCCESSOR into two cases. If the right subtree\nof node x is nonempty, then the successor of x is just the leftmost node in x’s\nright subtree, which we ﬁnd in line 2 by calling TREE-MINIMUM.x:right/. For\nexample, the successor of the node with key 15 in Figure 12.2 is the node with\nkey 17.\nOn the other hand, as Exercise 12.2-6 asks you to show, if the right subtree of\nnode x is empty and x has a successor y, then y is the lowest ancestor of x whose\nleft child is also an ancestor of x. In Figure 12.2, the successor of the node with\nkey 13 is the node with key 15. To ﬁnd y, we simply go up the tree from x until we\nencounter a node that is the left child of its parent; lines 3–7 of TREE-SUCCESSOR\nhandle this case.\nThe running time of TREE-SUCCESSOR on a tree of height h is O.h/, since we\neither follow a simple path up the tree or follow a simple path down the tree. The\nprocedure TREE-PREDECESSOR, which is symmetric to TREE-SUCCESSOR, also\nruns in time O.h/.\nEven if keys are not distinct, we deﬁne the successor and predecessor of any\nnode x as the node returned by calls made to TREE-SUCCESSOR.x/ and TREE-\nPREDECESSOR.x/, respectively.\nIn summary, we have proved the following theorem.\nTheorem 12.2",
    "parent_ee98673e-ea10-4adf-985d-12bdf4112b26": "runs in time O.h/.\nEven if keys are not distinct, we deﬁne the successor and predecessor of any\nnode x as the node returned by calls made to TREE-SUCCESSOR.x/ and TREE-\nPREDECESSOR.x/, respectively.\nIn summary, we have proved the following theorem.\nTheorem 12.2\nWe can implement the dynamic-set operations SEARCH, MINIMUM, MAXIMUM,\nSUCCESSOR, and PREDECESSOR so that each one runs in O.h/ time on a binary\nsearch tree of height h.\n12.2\nQuerying a binary search tree\n293\nExercises\n12.2-1\nSuppose that we have numbers between 1 and 1000 in a binary search tree, and we\nwant to search for the number 363. Which of the following sequences could not be\nthe sequence of nodes examined?\na. 2, 252, 401, 398, 330, 344, 397, 363.\nb. 924, 220, 911, 244, 898, 258, 362, 363.\nc. 925, 202, 911, 240, 912, 245, 363.\nd. 2, 399, 387, 219, 266, 382, 381, 278, 363.\ne. 935, 278, 347, 621, 299, 392, 358, 363.\n12.2-2\nWrite recursive versions of TREE-MINIMUM and TREE-MAXIMUM.\n12.2-3\nWrite the TREE-PREDECESSOR procedure.\n12.2-4\nProfessor Bunyan thinks he has discovered a remarkable property of binary search\ntrees. Suppose that the search for key k in a binary search tree ends up in a leaf.\nConsider three sets: A, the keys to the left of the search path; B, the keys on the\nsearch path; and C, the keys to the right of the search path. Professor Bunyan\nclaims that any three keys a 2 A, b 2 B, and c 2 C must satisfy a \u0002 b \u0002 c. Give\na smallest possible counterexample to the professor’s claim.\n12.2-5\nShow that if a node in a binary search tree has two children, then its successor has\nno left child and its predecessor has no right child.\n12.2-6\nConsider a binary search tree T whose keys are distinct. Show that if the right\nsubtree of a node x in T is empty and x has a successor y, then y is the lowest\nancestor of x whose left child is also an ancestor of x. (Recall that every node is\nits own ancestor.)\n12.2-7\nAn alternative method of performing an inorder tree walk of an n-node binary",
    "parent_14ca8027-b84c-44a0-a8bb-02969732c8ae": "subtree of a node x in T is empty and x has a successor y, then y is the lowest\nancestor of x whose left child is also an ancestor of x. (Recall that every node is\nits own ancestor.)\n12.2-7\nAn alternative method of performing an inorder tree walk of an n-node binary\nsearch tree ﬁnds the minimum element in the tree by calling TREE-MINIMUM and\nthen making n \u0005 1 calls to TREE-SUCCESSOR. Prove that this algorithm runs\nin ‚.n/ time.\n294\nChapter 12\nBinary Search Trees\n12.2-8\nProve that no matter what node we start at in a height-h binary search tree, k\nsuccessive calls to TREE-SUCCESSOR take O.k C h/ time.\n12.2-9\nLet T be a binary search tree whose keys are distinct, let x be a leaf node, and let y\nbe its parent. Show that y:key is either the smallest key in T larger than x:key or\nthe largest key in T smaller than x:key.\n12.3\nInsertion and deletion\nThe operations of insertion and deletion cause the dynamic set represented by a\nbinary search tree to change. The data structure must be modiﬁed to reﬂect this\nchange, but in such a way that the binary-search-tree property continues to hold.\nAs we shall see, modifying the tree to insert a new element is relatively straight-\nforward, but handling deletion is somewhat more intricate.\nInsertion\nTo insert a new value \u0003 into a binary search tree T , we use the procedure TREE-\nINSERT.\nThe procedure takes a node ´ for which ´:key D \u0003, ´:left D NIL,\nand ´:right D NIL. It modiﬁes T and some of the attributes of ´ in such a way that\nit inserts ´ into an appropriate position in the tree.\nTREE-INSERT.T; ´/\n1\ny D NIL\n2\nx D T:root\n3\nwhile x ¤ NIL\n4\ny D x\n5\nif ´:key < x:key\n6\nx D x:left\n7\nelse x D x:right\n8\n´:p D y\n9\nif y == NIL\n10\nT:root D ´\n// tree T was empty\n11\nelseif ´:key < y:key\n12\ny:left D ´\n13\nelse y:right D ´\n12.3\nInsertion and deletion\n295\n2\n9\n5\n13\n17\n15\n19\n18\n12\nFigure 12.3\nInserting an item with key 13 into a binary search tree. Lightly shaded nodes indicate",
    "parent_36434ca2-66f3-42e6-be8c-46fadce600f6": "7\nelse x D x:right\n8\n´:p D y\n9\nif y == NIL\n10\nT:root D ´\n// tree T was empty\n11\nelseif ´:key < y:key\n12\ny:left D ´\n13\nelse y:right D ´\n12.3\nInsertion and deletion\n295\n2\n9\n5\n13\n17\n15\n19\n18\n12\nFigure 12.3\nInserting an item with key 13 into a binary search tree. Lightly shaded nodes indicate\nthe simple path from the root down to the position where the item is inserted. The dashed line\nindicates the link in the tree that is added to insert the item.\nFigure 12.3 shows how TREE-INSERT works. Just like the procedures TREE-\nSEARCH and ITERATIVE-TREE-SEARCH, TREE-INSERT begins at the root of the\ntree and the pointer x traces a simple path downward looking for a NIL to replace\nwith the input item ´. The procedure maintains the trailing pointer y as the parent\nof x. After initialization, the while loop in lines 3–7 causes these two pointers\nto move down the tree, going left or right depending on the comparison of ´:key\nwith x:key, until x becomes NIL. This NIL occupies the position where we wish to\nplace the input item ´. We need the trailing pointer y, because by the time we ﬁnd\nthe NIL where ´ belongs, the search has proceeded one step beyond the node that\nneeds to be changed. Lines 8–13 set the pointers that cause ´ to be inserted.\nLike the other primitive operations on search trees, the procedure TREE-INSERT\nruns in O.h/ time on a tree of height h.\nDeletion\nThe overall strategy for deleting a node ´ from a binary search tree T has three\nbasic cases but, as we shall see, one of the cases is a bit tricky.\n\u0002\nIf ´ has no children, then we simply remove it by modifying its parent to re-\nplace ´ with NIL as its child.\n\u0002\nIf ´ has just one child, then we elevate that child to take ´’s position in the tree\nby modifying ´’s parent to replace ´ by ´’s child.\n\u0002\nIf ´ has two children, then we ﬁnd ´’s successor y—which must be in ´’s right\nsubtree—and have y take ´’s position in the tree. The rest of ´’s original right",
    "parent_d43a0ab9-c623-4c6d-982e-416e55ef2d63": "\u0002\nIf ´ has just one child, then we elevate that child to take ´’s position in the tree\nby modifying ´’s parent to replace ´ by ´’s child.\n\u0002\nIf ´ has two children, then we ﬁnd ´’s successor y—which must be in ´’s right\nsubtree—and have y take ´’s position in the tree. The rest of ´’s original right\nsubtree becomes y’s new right subtree, and ´’s left subtree becomes y’s new\nleft subtree. This case is the tricky one because, as we shall see, it matters\nwhether y is ´’s right child.\n296\nChapter 12\nBinary Search Trees\nThe procedure for deleting a given node ´ from a binary search tree T takes as\narguments pointers to T and ´. It organizes its cases a bit differently from the three\ncases outlined previously by considering the four cases shown in Figure 12.4.\n\u0002\nIf ´ has no left child (part (a) of the ﬁgure), then we replace ´ by its right child,\nwhich may or may not be NIL. When ´’s right child is NIL, this case deals with\nthe situation in which ´ has no children. When ´’s right child is non-NIL, this\ncase handles the situation in which ´ has just one child, which is its right child.\n\u0002\nIf ´ has just one child, which is its left child (part (b) of the ﬁgure), then we\nreplace ´ by its left child.\n\u0002\nOtherwise, ´ has both a left and a right child. We ﬁnd ´’s successor y, which\nlies in ´’s right subtree and has no left child (see Exercise 12.2-5). We want to\nsplice y out of its current location and have it replace ´ in the tree.\n\u0002 If y is ´’s right child (part (c)), then we replace ´ by y, leaving y’s right\nchild alone.\n\u0002 Otherwise, y lies within ´’s right subtree but is not ´’s right child (part (d)).\nIn this case, we ﬁrst replace y by its own right child, and then we replace ´\nby y.\nIn order to move subtrees around within the binary search tree, we deﬁne a\nsubroutine TRANSPLANT, which replaces one subtree as a child of its parent with\nanother subtree. When TRANSPLANT replaces the subtree rooted at node u with",
    "parent_377259af-44c3-485e-b1f4-c5ed0de2660f": "by y.\nIn order to move subtrees around within the binary search tree, we deﬁne a\nsubroutine TRANSPLANT, which replaces one subtree as a child of its parent with\nanother subtree. When TRANSPLANT replaces the subtree rooted at node u with\nthe subtree rooted at node \u0003, node u’s parent becomes node \u0003’s parent, and u’s\nparent ends up having \u0003 as its appropriate child.\nTRANSPLANT.T; u; \u0003/\n1\nif u:p == NIL\n2\nT:root D \u0003\n3\nelseif u == u:p:left\n4\nu:p:left D \u0003\n5\nelse u:p:right D \u0003\n6\nif \u0003 ¤ NIL\n7\n\u0003:p D u:p\nLines 1–2 handle the case in which u is the root of T . Otherwise, u is either a left\nchild or a right child of its parent. Lines 3–4 take care of updating u:p:left if u\nis a left child, and line 5 updates u:p:right if u is a right child. We allow \u0003 to be\nNIL, and lines 6–7 update \u0003:p if \u0003 is non-NIL. Note that TRANSPLANT does not\nattempt to update \u0003:left and \u0003:right; doing so, or not doing so, is the responsibility\nof TRANSPLANT’s caller.\n12.3\nInsertion and deletion\n297\nq\nq\nz\n(a)\nr\nq\nq\nz\nl\n(b)\nq\nz\nl\n(c)\nq\ny\nl\ny\nq\nz\nl\n(d)\nr\nq\nz\nl\nr\ny\nq\nl\nr\ny\nr\nl\nx\nx\nx\ny\nx\nx\nNIL\nNIL\nNIL\nNIL\nNIL\nFigure 12.4\nDeleting a node ´ from a binary search tree. Node ´ may be the root, a left child of\nnode q, or a right child of q. (a) Node ´ has no left child. We replace ´ by its right child r, which\nmay or may not be NIL. (b) Node ´ has a left child l but no right child. We replace ´ by l. (c) Node ´\nhas two children; its left child is node l, its right child is its successor y, and y’s right child is node x.\nWe replace ´ by y, updating y’s left child to become l, but leaving x as y’s right child. (d) Node ´\nhas two children (left child l and right child r), and its successor y ¤ r lies within the subtree rooted\nat r. We replace y by its own right child x, and we set y to be r’s parent. Then, we set y to be q’s\nchild and the parent of l.\n298\nChapter 12\nBinary Search Trees\nWith the TRANSPLANT procedure in hand, here is the procedure that deletes\nnode ´ from binary search tree T :\nTREE-DELETE.T; ´/\n1",
    "parent_05f094ca-e8db-4981-803d-1cfeba16488e": "at r. We replace y by its own right child x, and we set y to be r’s parent. Then, we set y to be q’s\nchild and the parent of l.\n298\nChapter 12\nBinary Search Trees\nWith the TRANSPLANT procedure in hand, here is the procedure that deletes\nnode ´ from binary search tree T :\nTREE-DELETE.T; ´/\n1\nif ´:left == NIL\n2\nTRANSPLANT.T; ´; ´:right/\n3\nelseif ´:right == NIL\n4\nTRANSPLANT.T; ´; ´:left/\n5\nelse y D TREE-MINIMUM.´:right/\n6\nif y:p ¤ ´\n7\nTRANSPLANT.T; y; y:right/\n8\ny:right D ´:right\n9\ny:right:p D y\n10\nTRANSPLANT.T; ´; y/\n11\ny:left D ´:left\n12\ny:left:p D y\nThe TREE-DELETE procedure executes the four cases as follows. Lines 1–2\nhandle the case in which node ´ has no left child, and lines 3–4 handle the case in\nwhich ´ has a left child but no right child. Lines 5–12 deal with the remaining two\ncases, in which ´ has two children. Line 5 ﬁnds node y, which is the successor\nof ´. Because ´ has a nonempty right subtree, its successor must be the node in\nthat subtree with the smallest key; hence the call to TREE-MINIMUM.´:right/. As\nwe noted before, y has no left child. We want to splice y out of its current location,\nand it should replace ´ in the tree. If y is ´’s right child, then lines 10–12 replace ´\nas a child of its parent by y and replace y’s left child by ´’s left child. If y is\nnot ´’s left child, lines 7–9 replace y as a child of its parent by y’s right child and\nturn ´’s right child into y’s right child, and then lines 10–12 replace ´ as a child of\nits parent by y and replace y’s left child by ´’s left child.\nEach line of TREE-DELETE, including the calls to TRANSPLANT, takes constant\ntime, except for the call to TREE-MINIMUM in line 5. Thus, TREE-DELETE runs\nin O.h/ time on a tree of height h.\nIn summary, we have proved the following theorem.\nTheorem 12.3\nWe can implement the dynamic-set operations INSERT and DELETE so that each\none runs in O.h/ time on a binary search tree of height h.\n12.4\nRandomly built binary search trees\n299\nExercises\n12.3-1",
    "parent_98d91d9e-f8ce-4498-a0d2-4abe8d85946d": "in O.h/ time on a tree of height h.\nIn summary, we have proved the following theorem.\nTheorem 12.3\nWe can implement the dynamic-set operations INSERT and DELETE so that each\none runs in O.h/ time on a binary search tree of height h.\n12.4\nRandomly built binary search trees\n299\nExercises\n12.3-1\nGive a recursive version of the TREE-INSERT procedure.\n12.3-2\nSuppose that we construct a binary search tree by repeatedly inserting distinct val-\nues into the tree. Argue that the number of nodes examined in searching for a\nvalue in the tree is one plus the number of nodes examined when the value was\nﬁrst inserted into the tree.\n12.3-3\nWe can sort a given set of n numbers by ﬁrst building a binary search tree contain-\ning these numbers (using TREE-INSERT repeatedly to insert the numbers one by\none) and then printing the numbers by an inorder tree walk. What are the worst-\ncase and best-case running times for this sorting algorithm?\n12.3-4\nIs the operation of deletion “commutative” in the sense that deleting x and then y\nfrom a binary search tree leaves the same tree as deleting y and then x? Argue why\nit is or give a counterexample.\n12.3-5\nSuppose that instead of each node x keeping the attribute x:p, pointing to x’s\nparent, it keeps x:succ, pointing to x’s successor. Give pseudocode for SEARCH,\nINSERT, and DELETE on a binary search tree T using this representation. These\nprocedures should operate in time O.h/, where h is the height of the tree T . (Hint:\nYou may wish to implement a subroutine that returns the parent of a node.)\n12.3-6\nWhen node ´ in TREE-DELETE has two children, we could choose node y as\nits predecessor rather than its successor. What other changes to TREE-DELETE\nwould be necessary if we did so? Some have argued that a fair strategy, giving\nequal priority to predecessor and successor, yields better empirical performance.\nHow might TREE-DELETE be changed to implement such a fair strategy?\n?\n12.4\nRandomly built binary search trees",
    "parent_683e56c5-c383-48f9-8e2f-d25a2ed6d302": "would be necessary if we did so? Some have argued that a fair strategy, giving\nequal priority to predecessor and successor, yields better empirical performance.\nHow might TREE-DELETE be changed to implement such a fair strategy?\n?\n12.4\nRandomly built binary search trees\nWe have shown that each of the basic operations on a binary search tree runs\nin O.h/ time, where h is the height of the tree. The height of a binary search\n300\nChapter 12\nBinary Search Trees\ntree varies, however, as items are inserted and deleted. If, for example, the n items\nare inserted in strictly increasing order, the tree will be a chain with height n \u0005 1.\nOn the other hand, Exercise B.5-4 shows that h \u0006 blg nc. As with quicksort, we\ncan show that the behavior of the average case is much closer to the best case than\nto the worst case.\nUnfortunately, little is known about the average height of a binary search tree\nwhen both insertion and deletion are used to create it. When the tree is created\nby insertion alone, the analysis becomes more tractable. Let us therefore deﬁne a\nrandomly built binary search tree on n keys as one that arises from inserting the\nkeys in random order into an initially empty tree, where each of the nŠ permutations\nof the input keys is equally likely. (Exercise 12.4-3 asks you to show that this notion\nis different from assuming that every binary search tree on n keys is equally likely.)\nIn this section, we shall prove the following theorem.\nTheorem 12.4\nThe expected height of a randomly built binary search tree on n distinct keys is\nO.lg n/.\nProof\nWe start by deﬁning three random variables that help measure the height\nof a randomly built binary search tree. We denote the height of a randomly built\nbinary search on n keys by Xn, and we deﬁne the exponential height Yn D 2Xn.\nWhen we build a binary search tree on n keys, we choose one key as that of the\nroot, and we let Rn denote the random variable that holds this key’s rank within",
    "parent_e5d5b9e5-68e1-4cbf-88c5-b61a995c9e4c": "binary search on n keys by Xn, and we deﬁne the exponential height Yn D 2Xn.\nWhen we build a binary search tree on n keys, we choose one key as that of the\nroot, and we let Rn denote the random variable that holds this key’s rank within\nthe set of n keys; that is, Rn holds the position that this key would occupy if the\nset of keys were sorted. The value of Rn is equally likely to be any element of the\nset f1; 2; : : : ; ng. If Rn D i, then the left subtree of the root is a randomly built\nbinary search tree on i \u0005 1 keys, and the right subtree is a randomly built binary\nsearch tree on n \u0005 i keys. Because the height of a binary tree is 1 more than the\nlarger of the heights of the two subtrees of the root, the exponential height of a\nbinary tree is twice the larger of the exponential heights of the two subtrees of the\nroot. If we know that Rn D i, it follows that\nYn D 2 \u0003 max.Yi\u00031; Yn\u0003i/ :\nAs base cases, we have that Y1 D 1, because the exponential height of a tree with 1\nnode is 20 D 1 and, for convenience, we deﬁne Y0 D 0.\nNext, deﬁne indicator random variables Zn;1; Zn;2; : : : ; Zn;n, where\nZn;i D I fRn D ig :\nBecause Rn is equally likely to be any element of f1; 2; : : : ; ng, it follows that\nPr fRn D ig D 1=n for i D 1; 2; : : : ; n, and hence, by Lemma 5.1, we have\nE ŒZn;i\u0002 D 1=n ;\n(12.1)\n12.4\nRandomly built binary search trees\n301\nfor i D 1; 2; : : : ; n. Because exactly one value of Zn;i is 1 and all others are 0, we\nalso have\nYn D\nn\nX\niD1\nZn;i .2 \u0003 max.Yi\u00031; Yn\u0003i// :\nWe shall show that E ŒYn\u0002 is polynomial in n, which will ultimately imply that\nE ŒXn\u0002 D O.lg n/.\nWe claim that the indicator random variable Zn;i D I fRn D ig is independent\nof the values of Yi\u00031 and Yn\u0003i. Having chosen Rn D i, the left subtree (whose\nexponential height is Yi\u00031) is randomly built on the i \u0005 1 keys whose ranks are\nless than i. This subtree is just like any other randomly built binary search tree\non i \u0005 1 keys. Other than the number of keys it contains, this subtree’s structure",
    "parent_4be3ea75-6b44-4034-a437-37c830f1abeb": "exponential height is Yi\u00031) is randomly built on the i \u0005 1 keys whose ranks are\nless than i. This subtree is just like any other randomly built binary search tree\non i \u0005 1 keys. Other than the number of keys it contains, this subtree’s structure\nis not affected at all by the choice of Rn D i, and hence the random variables\nYi\u00031 and Zn;i are independent. Likewise, the right subtree, whose exponential\nheight is Yn\u0003i, is randomly built on the n \u0005 i keys whose ranks are greater than i.\nIts structure is independent of the value of Rn, and so the random variables Yn\u0003i\nand Zn;i are independent. Hence, we have\nE ŒYn\u0002\nD\nE\n\" n\nX\niD1\nZn;i .2 \u0003 max.Yi\u00031; Yn\u0003i//\n#\nD\nn\nX\niD1\nE ŒZn;i .2 \u0003 max.Yi\u00031; Yn\u0003i//\u0002\n(by linearity of expectation)\nD\nn\nX\niD1\nE ŒZn;i\u0002 E Œ2 \u0003 max.Yi\u00031; Yn\u0003i/\u0002\n(by independence)\nD\nn\nX\niD1\n1\nn \u0003 E Œ2 \u0003 max.Yi\u00031; Yn\u0003i/\u0002\n(by equation (12.1))\nD\n2\nn\nn\nX\niD1\nE Œmax.Yi\u00031; Yn\u0003i/\u0002\n(by equation (C.22))\n\u0002\n2\nn\nn\nX\niD1\n.E ŒYi\u00031\u0002 C E ŒYn\u0003i\u0002/\n(by Exercise C.3-4) .\nSince each term E ŒY0\u0002 ; E ŒY1\u0002 ; : : : ; E ŒYn\u00031\u0002 appears twice in the last summation,\nonce as E ŒYi\u00031\u0002 and once as E ŒYn\u0003i\u0002, we have the recurrence\nE ŒYn\u0002 \u0002 4\nn\nn\u00031\nX\niD0\nE ŒYi\u0002 :\n(12.2)\n302\nChapter 12\nBinary Search Trees\nUsing the substitution method, we shall show that for all positive integers n, the\nrecurrence (12.2) has the solution\nE ŒYn\u0002 \u0002 1\n4\n \nn C 3\n3\n!\n:\nIn doing so, we shall use the identity\nn\u00031\nX\niD0\n \ni C 3\n3\n!\nD\n \nn C 3\n4\n!\n:\n(12.3)\n(Exercise 12.4-1 asks you to prove this identity.)\nFor the base cases, we note that the bounds 0 D Y0 D E ŒY0\u0002 \u0002 .1=4/\n\u000b3\n3\n\f\nD 1=4\nand 1 D Y1 D E ŒY1\u0002 \u0002 .1=4/\n\u000b1C3\n3\n\f\nD 1 hold. For the inductive case, we have that\nE ŒYn\u0002\n\u0002\n4\nn\nn\u00031\nX\niD0\nE ŒYi\u0002\n\u0002\n4\nn\nn\u00031\nX\niD0\n1\n4\n \ni C 3\n3\n!\n(by the inductive hypothesis)\nD\n1\nn\nn\u00031\nX\niD0\n \ni C 3\n3\n!\nD\n1\nn\n \nn C 3\n4\n!\n(by equation (12.3))\nD\n1\nn \u0003 .n C 3/Š\n4Š .n \u0005 1/Š\nD\n1\n4 \u0003 .n C 3/Š\n3Š nŠ\nD\n1\n4\n \nn C 3\n3\n!\n:\nWe have bounded E ŒYn\u0002, but our ultimate goal is to bound E ŒXn\u0002. As Exer-",
    "parent_69e27b57-1bcc-4fcd-900f-d3ff6ef5e1b0": "\u0002\n4\nn\nn\u00031\nX\niD0\nE ŒYi\u0002\n\u0002\n4\nn\nn\u00031\nX\niD0\n1\n4\n \ni C 3\n3\n!\n(by the inductive hypothesis)\nD\n1\nn\nn\u00031\nX\niD0\n \ni C 3\n3\n!\nD\n1\nn\n \nn C 3\n4\n!\n(by equation (12.3))\nD\n1\nn \u0003 .n C 3/Š\n4Š .n \u0005 1/Š\nD\n1\n4 \u0003 .n C 3/Š\n3Š nŠ\nD\n1\n4\n \nn C 3\n3\n!\n:\nWe have bounded E ŒYn\u0002, but our ultimate goal is to bound E ŒXn\u0002. As Exer-\ncise 12.4-4 asks you to show, the function f .x/ D 2x is convex (see page 1199).\nTherefore, we can employ Jensen’s inequality (C.26), which says that\n2EŒXn\u0004\n\u0002\nE\n\u000f\n2Xn\u0010\nD\nE ŒYn\u0002 ;\nas follows:\n2EŒXn\u0004\n\u0002\n1\n4\n \nn C 3\n3\n!\nProblems for Chapter 12\n303\nD\n1\n4 \u0003 .n C 3/.n C 2/.n C 1/\n6\nD\nn3 C 6n2 C 11n C 6\n24\n:\nTaking logarithms of both sides gives E ŒXn\u0002 D O.lg n/.\nExercises\n12.4-1\nProve equation (12.3).\n12.4-2\nDescribe a binary search tree on n nodes such that the average depth of a node in\nthe tree is ‚.lg n/ but the height of the tree is !.lg n/. Give an asymptotic upper\nbound on the height of an n-node binary search tree in which the average depth of\na node is ‚.lg n/.\n12.4-3\nShow that the notion of a randomly chosen binary search tree on n keys, where\neach binary search tree of n keys is equally likely to be chosen, is different from\nthe notion of a randomly built binary search tree given in this section. (Hint: List\nthe possibilities when n D 3.)\n12.4-4\nShow that the function f .x/ D 2x is convex.\n12.4-5\n?\nConsider RANDOMIZED-QUICKSORT operating on a sequence of n distinct input\nnumbers. Prove that for any constant k > 0, all but O.1=nk/ of the nŠ input\npermutations yield an O.n lg n/ running time.\nProblems\n12-1\nBinary search trees with equal keys\nEqual keys pose a problem for the implementation of binary search trees.\na. What is the asymptotic performance of TREE-INSERT when used to insert n\nitems with identical keys into an initially empty binary search tree?\nWe propose to improve TREE-INSERT by testing before line 5 to determine whether\n´:key D x:key and by testing before line 11 to determine whether ´:key D y:key.\n304\nChapter 12\nBinary Search Trees",
    "parent_072af4e8-621c-4d0c-b39a-97a343452980": "items with identical keys into an initially empty binary search tree?\nWe propose to improve TREE-INSERT by testing before line 5 to determine whether\n´:key D x:key and by testing before line 11 to determine whether ´:key D y:key.\n304\nChapter 12\nBinary Search Trees\nIf equality holds, we implement one of the following strategies. For each strategy,\nﬁnd the asymptotic performance of inserting n items with identical keys into an\ninitially empty binary search tree. (The strategies are described for line 5, in which\nwe compare the keys of ´ and x. Substitute y for x to arrive at the strategies for\nline 11.)\nb. Keep a boolean ﬂag x:b at node x, and set x to either x:left or x:right based\non the value of x:b, which alternates between FALSE and TRUE each time we\nvisit x while inserting a node with the same key as x.\nc. Keep a list of nodes with equal keys at x, and insert ´ into the list.\nd. Randomly set x to either x:left or x:right. (Give the worst-case performance\nand informally derive the expected running time.)\n12-2\nRadix trees\nGiven two strings a D a0a1 : : : ap and b D b0b1 : : : bq, where each ai and each bj\nis in some ordered set of characters, we say that string a is lexicographically less\nthan string b if either\n1. there exists an integer j , where 0 \u0002 j \u0002 min.p; q/, such that ai D bi for all\ni D 0; 1; : : : ; j \u0005 1 and aj < bj, or\n2. p < q and ai D bi for all i D 0; 1; : : : ; p.\nFor example, if a and b are bit strings, then 10100 < 10110 by rule 1 (letting\nj D 3) and 10100 < 101000 by rule 2. This ordering is similar to that used in\nEnglish-language dictionaries.\nThe radix tree data structure shown in Figure 12.5 stores the bit strings 1011,\n10, 011, 100, and 0. When searching for a key a D a0a1 : : : ap, we go left at a\nnode of depth i if ai D 0 and right if ai D 1. Let S be a set of distinct bit strings\nwhose lengths sum to n. Show how to use a radix tree to sort S lexicographically",
    "parent_d6d7b7f4-ac92-4e88-b222-4daba8167b55": "10, 011, 100, and 0. When searching for a key a D a0a1 : : : ap, we go left at a\nnode of depth i if ai D 0 and right if ai D 1. Let S be a set of distinct bit strings\nwhose lengths sum to n. Show how to use a radix tree to sort S lexicographically\nin ‚.n/ time. For the example in Figure 12.5, the output of the sort should be the\nsequence 0, 011, 10, 100, 1011.\n12-3\nAverage node depth in a randomly built binary search tree\nIn this problem, we prove that the average depth of a node in a randomly built\nbinary search tree with n nodes is O.lg n/. Although this result is weaker than\nthat of Theorem 12.4, the technique we shall use reveals a surprising similarity\nbetween the building of a binary search tree and the execution of RANDOMIZED-\nQUICKSORT from Section 7.3.\nWe deﬁne the total path length P.T / of a binary tree T as the sum, over all\nnodes x in T , of the depth of node x, which we denote by d.x; T /.\nProblems for Chapter 12\n305\n011\n0\n100\n10\n1011\n0\n1\n1\n0\n1\n0\n1\n1\nFigure 12.5\nA radix tree storing the bit strings 1011, 10, 011, 100, and 0. We can determine each\nnode’s key by traversing the simple path from the root to that node. There is no need, therefore, to\nstore the keys in the nodes; the keys appear here for illustrative purposes only. Nodes are heavily\nshaded if the keys corresponding to them are not in the tree; such nodes are present only to establish\na path to other nodes.\na. Argue that the average depth of a node in T is\n1\nn\nX\nx2T\nd.x; T / D 1\nnP.T / :\nThus, we wish to show that the expected value of P.T / is O.n lg n/.\nb. Let TL and TR denote the left and right subtrees of tree T , respectively. Argue\nthat if T has n nodes, then\nP.T / D P.TL/ C P.TR/ C n \u0005 1 :\nc. Let P.n/ denote the average total path length of a randomly built binary search\ntree with n nodes. Show that\nP.n/ D 1\nn\nn\u00031\nX\niD0\n.P.i/ C P.n \u0005 i \u0005 1/ C n \u0005 1/ :\nd. Show how to rewrite P.n/ as\nP.n/ D 2\nn\nn\u00031\nX\nkD1\nP.k/ C ‚.n/ :",
    "parent_96d2a239-85cd-4ae5-95ea-4c294c8bfde3": "that if T has n nodes, then\nP.T / D P.TL/ C P.TR/ C n \u0005 1 :\nc. Let P.n/ denote the average total path length of a randomly built binary search\ntree with n nodes. Show that\nP.n/ D 1\nn\nn\u00031\nX\niD0\n.P.i/ C P.n \u0005 i \u0005 1/ C n \u0005 1/ :\nd. Show how to rewrite P.n/ as\nP.n/ D 2\nn\nn\u00031\nX\nkD1\nP.k/ C ‚.n/ :\ne. Recalling the alternative analysis of the randomized version of quicksort given\nin Problem 7-3, conclude that P.n/ D O.n lg n/.\n306\nChapter 12\nBinary Search Trees\nAt each recursive invocation of quicksort, we choose a random pivot element to\npartition the set of elements being sorted. Each node of a binary search tree parti-\ntions the set of elements that fall into the subtree rooted at that node.\nf.\nDescribe an implementation of quicksort in which the comparisons to sort a set\nof elements are exactly the same as the comparisons to insert the elements into\na binary search tree. (The order in which comparisons are made may differ, but\nthe same comparisons must occur.)\n12-4\nNumber of different binary trees\nLet bn denote the number of different binary trees with n nodes. In this problem,\nyou will ﬁnd a formula for bn, as well as an asymptotic estimate.\na. Show that b0 D 1 and that, for n \u0006 1,\nbn D\nn\u00031\nX\nkD0\nbkbn\u00031\u0003k :\nb. Referring to Problem 4-4 for the deﬁnition of a generating function, let B.x/\nbe the generating function\nB.x/ D\n1\nX\nnD0\nbnxn :\nShow that B.x/ D xB.x/2 C 1, and hence one way to express B.x/ in closed\nform is\nB.x/ D 1\n2x\n\u000b\n1 \u0005\np\n1 \u0005 4x\n\f\n:\nThe Taylor expansion of f .x/ around the point x D a is given by\nf .x/ D\n1\nX\nkD0\nf .k/.a/\nkŠ\n.x \u0005 a/k ;\nwhere f .k/.x/ is the kth derivative of f evaluated at x.\nc. Show that\nbn D\n1\nn C 1\n \n2n\nn\n!\nNotes for Chapter 12\n307\n(the nth Catalan number) by using the Taylor expansion of\np\n1 \u0005 4x around\nx D 0. (If you wish, instead of using the Taylor expansion, you may use\nthe generalization of the binomial expansion (C.4) to nonintegral exponents n,\nwhere for any real number n and for any integer k, we interpret\n\u000bn\nk\n\f\nto be",
    "parent_380db955-200b-4607-8ab4-acea20a90a29": "p\n1 \u0005 4x around\nx D 0. (If you wish, instead of using the Taylor expansion, you may use\nthe generalization of the binomial expansion (C.4) to nonintegral exponents n,\nwhere for any real number n and for any integer k, we interpret\n\u000bn\nk\n\f\nto be\nn.n \u0005 1/ \u0003 \u0003 \u0003 .n \u0005 k C 1/=kŠ if k \u0006 0, and 0 otherwise.)\nd. Show that\nbn D\n4n\np\u0006n3=2 .1 C O.1=n// :\nChapter notes\nKnuth [211] contains a good discussion of simple binary search trees as well as\nmany variations. Binary search trees seem to have been independently discovered\nby a number of people in the late 1950s. Radix trees are often called “tries,” which\ncomes from the middle letters in the word retrieval. Knuth [211] also discusses\nthem.\nMany texts, including the ﬁrst two editions of this book, have a somewhat sim-\npler method of deleting a node from a binary search tree when both of its children\nare present. Instead of replacing node ´ by its successor y, we delete node y but\ncopy its key and satellite data into node ´. The downside of this approach is that\nthe node actually deleted might not be the node passed to the delete procedure. If\nother components of a program maintain pointers to nodes in the tree, they could\nmistakenly end up with “stale” pointers to nodes that have been deleted. Although\nthe deletion method presented in this edition of this book is a bit more complicated,\nit guarantees that a call to delete node ´ deletes node ´ and only node ´.\nSection 15.5 will show how to construct an optimal binary search tree when\nwe know the search frequencies before constructing the tree. That is, given the\nfrequencies of searching for each key and the frequencies of searching for values\nthat fall between keys in the tree, we construct a binary search tree for which a\nset of searches that follows these frequencies examines the minimum number of\nnodes.\nThe proof in Section 12.4 that bounds the expected height of a randomly built\nbinary search tree is due to Aslam [24]. Mart´ınez and Roura [243] give randomized",
    "parent_61bf53d1-9ca7-43d2-b065-4f10541b97dc": "set of searches that follows these frequencies examines the minimum number of\nnodes.\nThe proof in Section 12.4 that bounds the expected height of a randomly built\nbinary search tree is due to Aslam [24]. Mart´ınez and Roura [243] give randomized\nalgorithms for insertion into and deletion from binary search trees in which the\nresult of either operation is a random binary search tree. Their deﬁnition of a\nrandom binary search tree differs—only slightly—from that of a randomly built\nbinary search tree in this chapter, however.\n13\nRed-Black Trees\nChapter 12 showed that a binary search tree of height h can support any of the basic\ndynamic-set operations—such as SEARCH, PREDECESSOR, SUCCESSOR, MINI-\nMUM, MAXIMUM, INSERT, and DELETE—in O.h/ time. Thus, the set operations\nare fast if the height of the search tree is small. If its height is large, however, the\nset operations may run no faster than with a linked list. Red-black trees are one\nof many search-tree schemes that are “balanced” in order to guarantee that basic\ndynamic-set operations take O.lg n/ time in the worst case.\n13.1\nProperties of red-black trees\nA red-black tree is a binary search tree with one extra bit of storage per node: its\ncolor, which can be either RED or BLACK. By constraining the node colors on any\nsimple path from the root to a leaf, red-black trees ensure that no such path is more\nthan twice as long as any other, so that the tree is approximately balanced.\nEach node of the tree now contains the attributes color, key, left, right, and p. If\na child or the parent of a node does not exist, the corresponding pointer attribute\nof the node contains the value NIL. We shall regard these NILs as being pointers to\nleaves (external nodes) of the binary search tree and the normal, key-bearing nodes\nas being internal nodes of the tree.\nA red-black tree is a binary tree that satisﬁes the following red-black properties:\n1. Every node is either red or black.\n2. The root is black.\n3. Every leaf (NIL) is black.",
    "parent_f4c5aa46-5695-472c-b38e-6ef7001676ef": "leaves (external nodes) of the binary search tree and the normal, key-bearing nodes\nas being internal nodes of the tree.\nA red-black tree is a binary tree that satisﬁes the following red-black properties:\n1. Every node is either red or black.\n2. The root is black.\n3. Every leaf (NIL) is black.\n4. If a node is red, then both its children are black.\n5. For each node, all simple paths from the node to descendant leaves contain the\nsame number of black nodes.\n13.1\nProperties of red-black trees\n309\nFigure 13.1(a) shows an example of a red-black tree.\nAs a matter of convenience in dealing with boundary conditions in red-black\ntree code, we use a single sentinel to represent NIL (see page 238). For a red-black\ntree T , the sentinel T:nil is an object with the same attributes as an ordinary node\nin the tree. Its color attribute is BLACK, and its other attributes—p, left, right,\nand key—can take on arbitrary values. As Figure 13.1(b) shows, all pointers to NIL\nare replaced by pointers to the sentinel T:nil.\nWe use the sentinel so that we can treat a NIL child of a node x as an ordinary\nnode whose parent is x. Although we instead could add a distinct sentinel node\nfor each NIL in the tree, so that the parent of each NIL is well deﬁned, that ap-\nproach would waste space. Instead, we use the one sentinel T:nil to represent all\nthe NILs—all leaves and the root’s parent. The values of the attributes p, left, right,\nand key of the sentinel are immaterial, although we may set them during the course\nof a procedure for our convenience.\nWe generally conﬁne our interest to the internal nodes of a red-black tree, since\nthey hold the key values. In the remainder of this chapter, we omit the leaves when\nwe draw red-black trees, as shown in Figure 13.1(c).\nWe call the number of black nodes on any simple path from, but not including, a\nnode x down to a leaf the black-height of the node, denoted bh.x/. By property 5,",
    "parent_b47e3335-8476-4fbe-b141-8bdc5d5d37ba": "they hold the key values. In the remainder of this chapter, we omit the leaves when\nwe draw red-black trees, as shown in Figure 13.1(c).\nWe call the number of black nodes on any simple path from, but not including, a\nnode x down to a leaf the black-height of the node, denoted bh.x/. By property 5,\nthe notion of black-height is well deﬁned, since all descending simple paths from\nthe node have the same number of black nodes. We deﬁne the black-height of a\nred-black tree to be the black-height of its root.\nThe following lemma shows why red-black trees make good search trees.\nLemma 13.1\nA red-black tree with n internal nodes has height at most 2 lg.n C 1/.\nProof\nWe start by showing that the subtree rooted at any node x contains at least\n2bh.x/ \u0005 1 internal nodes. We prove this claim by induction on the height of x. If\nthe height of x is 0, then x must be a leaf (T:nil), and the subtree rooted at x indeed\ncontains at least 2bh.x/ \u0005 1 D 20 \u0005 1 D 0 internal nodes. For the inductive step,\nconsider a node x that has positive height and is an internal node with two children.\nEach child has a black-height of either bh.x/ or bh.x/ \u0005 1, depending on whether\nits color is red or black, respectively. Since the height of a child of x is less than\nthe height of x itself, we can apply the inductive hypothesis to conclude that each\nchild has at least 2bh.x/\u00031 \u0005 1 internal nodes. Thus, the subtree rooted at x contains\nat least .2bh.x/\u00031 \u00051/C.2bh.x/\u00031 \u00051/C1 D 2bh.x/ \u00051 internal nodes, which proves\nthe claim.\nTo complete the proof of the lemma, let h be the height of the tree. According\nto property 4, at least half the nodes on any simple path from the root to a leaf, not\n310\nChapter 13\nRed-Black Trees\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\n26\n41\n47\n30\n28\n38\n35\n39\n17\n21\n23\n19\n20\n14\n16\n15\n10\n12\n7\n3\n1\n1\n1\n2\n1\n1\n2\n1\n1\n1\n2\n3\n1\n1\n1\n1\n2\n1\n2\n3\n(a)\n26\n41\n47\n30\n28\n38\n35\n39\n17\n21\n23\n19\n20\n14\n16\n15\n10\n12\n7\n3\n(b)\n26\n41\n47\n30\n28\n38\n35\n39\n17\n21\n23\n19\n20\n14",
    "parent_a94e0507-849c-4f2f-bf9c-430fe6db1a82": "NIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\nNIL\n26\n41\n47\n30\n28\n38\n35\n39\n17\n21\n23\n19\n20\n14\n16\n15\n10\n12\n7\n3\n1\n1\n1\n2\n1\n1\n2\n1\n1\n1\n2\n3\n1\n1\n1\n1\n2\n1\n2\n3\n(a)\n26\n41\n47\n30\n28\n38\n35\n39\n17\n21\n23\n19\n20\n14\n16\n15\n10\n12\n7\n3\n(b)\n26\n41\n47\n30\n28\n38\n35\n39\n17\n21\n23\n19\n20\n14\n16\n15\n10\n12\n7\n3\n(c)\nT:nil\nFigure 13.1\nA red-black tree with black nodes darkened and red nodes shaded. Every node in a\nred-black tree is either red or black, the children of a red node are both black, and every simple path\nfrom a node to a descendant leaf contains the same number of black nodes. (a) Every leaf, shown\nas a NIL, is black. Each non-NIL node is marked with its black-height; NILs have black-height 0.\n(b) The same red-black tree but with each NIL replaced by the single sentinel T:nil, which is always\nblack, and with black-heights omitted. The root’s parent is also the sentinel. (c) The same red-black\ntree but with leaves and the root’s parent omitted entirely. We shall use this drawing style in the\nremainder of this chapter.\n13.1\nProperties of red-black trees\n311\nincluding the root, must be black. Consequently, the black-height of the root must\nbe at least h=2; thus,\nn \u0006 2h=2 \u0005 1 :\nMoving the 1 to the left-hand side and taking logarithms on both sides yields\nlg.n C 1/ \u0006 h=2, or h \u0002 2 lg.n C 1/.\nAs an immediate consequence of this lemma, we can implement the dynamic-set\noperations SEARCH, MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR\nin O.lg n/ time on red-black trees, since each can run in O.h/ time on a binary\nsearch tree of height h (as shown in Chapter 12) and any red-black tree on n nodes\nis a binary search tree with height O.lg n/. (Of course, references to NIL in the\nalgorithms of Chapter 12 would have to be replaced by T:nil.) Although the al-\ngorithms TREE-INSERT and TREE-DELETE from Chapter 12 run in O.lg n/ time\nwhen given a red-black tree as input, they do not directly support the dynamic-set",
    "parent_94838b72-0c2d-4de1-957c-e8b0f88daac3": "algorithms of Chapter 12 would have to be replaced by T:nil.) Although the al-\ngorithms TREE-INSERT and TREE-DELETE from Chapter 12 run in O.lg n/ time\nwhen given a red-black tree as input, they do not directly support the dynamic-set\noperations INSERT and DELETE, since they do not guarantee that the modiﬁed bi-\nnary search tree will be a red-black tree. We shall see in Sections 13.3 and 13.4,\nhowever, how to support these two operations in O.lg n/ time.\nExercises\n13.1-1\nIn the style of Figure 13.1(a), draw the complete binary search tree of height 3 on\nthe keys f1; 2; : : : ; 15g. Add the NIL leaves and color the nodes in three different\nways such that the black-heights of the resulting red-black trees are 2, 3, and 4.\n13.1-2\nDraw the red-black tree that results after TREE-INSERT is called on the tree in\nFigure 13.1 with key 36. If the inserted node is colored red, is the resulting tree a\nred-black tree? What if it is colored black?\n13.1-3\nLet us deﬁne a relaxed red-black tree as a binary search tree that satisﬁes red-\nblack properties 1, 3, 4, and 5. In other words, the root may be either red or black.\nConsider a relaxed red-black tree T whose root is red. If we color the root of T\nblack but make no other changes to T , is the resulting tree a red-black tree?\n13.1-4\nSuppose that we “absorb” every red node in a red-black tree into its black parent,\nso that the children of the red node become children of the black parent. (Ignore\nwhat happens to the keys.) What are the possible degrees of a black node after all\n312\nChapter 13\nRed-Black Trees\nits red children are absorbed? What can you say about the depths of the leaves of\nthe resulting tree?\n13.1-5\nShow that the longest simple path from a node x in a red-black tree to a descendant\nleaf has length at most twice that of the shortest simple path from node x to a\ndescendant leaf.\n13.1-6\nWhat is the largest possible number of internal nodes in a red-black tree with black-\nheight k? What is the smallest possible number?",
    "parent_15054d91-a752-4096-9da8-cee07810a586": "leaf has length at most twice that of the shortest simple path from node x to a\ndescendant leaf.\n13.1-6\nWhat is the largest possible number of internal nodes in a red-black tree with black-\nheight k? What is the smallest possible number?\n13.1-7\nDescribe a red-black tree on n keys that realizes the largest possible ratio of red in-\nternal nodes to black internal nodes. What is this ratio? What tree has the smallest\npossible ratio, and what is the ratio?\n13.2\nRotations\nThe search-tree operations TREE-INSERT and TREE-DELETE, when run on a red-\nblack tree with n keys, take O.lg n/ time. Because they modify the tree, the result\nmay violate the red-black properties enumerated in Section 13.1. To restore these\nproperties, we must change the colors of some of the nodes in the tree and also\nchange the pointer structure.\nWe change the pointer structure through rotation, which is a local operation in\na search tree that preserves the binary-search-tree property. Figure 13.2 shows the\ntwo kinds of rotations: left rotations and right rotations. When we do a left rotation\non a node x, we assume that its right child y is not T:nil; x may be any node in\nthe tree whose right child is not T:nil. The left rotation “pivots” around the link\nfrom x to y. It makes y the new root of the subtree, with x as y’s left child and y’s\nleft child as x’s right child.\nThe pseudocode for LEFT-ROTATE assumes that x:right ¤ T:nil and that the\nroot’s parent is T:nil.\n13.2\nRotations\n313\ny\nx\nα\nβ\nγ\nx\ny\nα\nβ\nγ\nLEFT-ROTATE(T, x)\nRIGHT-ROTATE(T, y)\nFigure 13.2\nThe rotation operations on a binary search tree. The operation LEFT-ROTATE.T; x/\ntransforms the conﬁguration of the two nodes on the right into the conﬁguration on the left by chang-\ning a constant number of pointers. The inverse operation RIGHT-ROTATE.T; y/ transforms the con-\nﬁguration on the left into the conﬁguration on the right. The letters ˛, ˇ, and \n represent arbitrary",
    "parent_765b24a2-2b2d-43f1-bff5-c2d852bf0937": "transforms the conﬁguration of the two nodes on the right into the conﬁguration on the left by chang-\ning a constant number of pointers. The inverse operation RIGHT-ROTATE.T; y/ transforms the con-\nﬁguration on the left into the conﬁguration on the right. The letters ˛, ˇ, and \n represent arbitrary\nsubtrees. A rotation operation preserves the binary-search-tree property: the keys in ˛ precede x:key,\nwhich precedes the keys in ˇ, which precede y:key, which precedes the keys in \n.\nLEFT-ROTATE.T; x/\n1\ny D x:right\n// set y\n2\nx:right D y:left\n// turn y’s left subtree into x’s right subtree\n3\nif y:left ¤ T:nil\n4\ny:left:p D x\n5\ny:p D x:p\n// link x’s parent to y\n6\nif x:p == T:nil\n7\nT:root D y\n8\nelseif x == x:p:left\n9\nx:p:left D y\n10\nelse x:p:right D y\n11\ny:left D x\n// put x on y’s left\n12\nx:p D y\nFigure 13.3 shows an example of how LEFT-ROTATE modiﬁes a binary search\ntree. The code for RIGHT-ROTATE is symmetric. Both LEFT-ROTATE and RIGHT-\nROTATE run in O.1/ time. Only pointers are changed by a rotation; all other\nattributes in a node remain the same.\nExercises\n13.2-1\nWrite pseudocode for RIGHT-ROTATE.\n13.2-2\nArgue that in every n-node binary search tree, there are exactly n \u0005 1 possible\nrotations.\n314\nChapter 13\nRed-Black Trees\n2\n3\n4\n6\n7\n11\n9\n18\n14\n12\n17\n19\n22\n20\nx\ny\n2\n3\n4\n6\n7\n18\n19\n14\n12\n17\n22\n20\nx\ny\n11\n9\nLEFT-ROTATE(T, x)\nFigure 13.3\nAn example of how the procedure LEFT-ROTATE.T; x/ modiﬁes a binary search tree.\nInorder tree walks of the input tree and the modiﬁed tree produce the same listing of key values.\n13.2-3\nLet a, b, and c be arbitrary nodes in subtrees ˛, ˇ, and \n, respectively, in the left\ntree of Figure 13.2. How do the depths of a, b, and c change when a left rotation\nis performed on node x in the ﬁgure?\n13.2-4\nShow that any arbitrary n-node binary search tree can be transformed into any other\narbitrary n-node binary search tree using O.n/ rotations. (Hint: First show that at\nmost n \u0005 1 right rotations sufﬁce to transform the tree into a right-going chain.)",
    "parent_d1ef01ab-e746-4736-a798-fd8ffebcb0ee": "is performed on node x in the ﬁgure?\n13.2-4\nShow that any arbitrary n-node binary search tree can be transformed into any other\narbitrary n-node binary search tree using O.n/ rotations. (Hint: First show that at\nmost n \u0005 1 right rotations sufﬁce to transform the tree into a right-going chain.)\n13.2-5\n?\nWe say that a binary search tree T1 can be right-converted to binary search tree T2\nif it is possible to obtain T2 from T1 via a series of calls to RIGHT-ROTATE. Give\nan example of two trees T1 and T2 such that T1 cannot be right-converted to T2.\nThen, show that if a tree T1 can be right-converted to T2, it can be right-converted\nusing O.n2/ calls to RIGHT-ROTATE.\n13.3\nInsertion\n315\n13.3\nInsertion\nWe can insert a node into an n-node red-black tree in O.lg n/ time. To do so, we\nuse a slightly modiﬁed version of the TREE-INSERT procedure (Section 12.3) to\ninsert node ´ into the tree T as if it were an ordinary binary search tree, and then we\ncolor ´ red. (Exercise 13.3-1 asks you to explain why we choose to make node ´\nred rather than black.) To guarantee that the red-black properties are preserved, we\nthen call an auxiliary procedure RB-INSERT-FIXUP to recolor nodes and perform\nrotations. The call RB-INSERT.T; ´/ inserts node ´, whose key is assumed to have\nalready been ﬁlled in, into the red-black tree T .\nRB-INSERT.T; ´/\n1\ny D T:nil\n2\nx D T:root\n3\nwhile x ¤ T:nil\n4\ny D x\n5\nif ´:key < x:key\n6\nx D x:left\n7\nelse x D x:right\n8\n´:p D y\n9\nif y == T:nil\n10\nT:root D ´\n11\nelseif ´:key < y:key\n12\ny:left D ´\n13\nelse y:right D ´\n14\n´:left D T:nil\n15\n´:right D T:nil\n16\n´:color D RED\n17\nRB-INSERT-FIXUP.T; ´/\nThe procedures TREE-INSERT and RB-INSERT differ in four ways. First, all\ninstances of NIL in TREE-INSERT are replaced by T:nil. Second, we set ´:left\nand ´:right to T:nil in lines 14–15 of RB-INSERT, in order to maintain the\nproper tree structure.\nThird, we color ´ red in line 16.\nFourth, because col-",
    "parent_37f97afb-25e0-451e-a8e2-966220436db5": "instances of NIL in TREE-INSERT are replaced by T:nil. Second, we set ´:left\nand ´:right to T:nil in lines 14–15 of RB-INSERT, in order to maintain the\nproper tree structure.\nThird, we color ´ red in line 16.\nFourth, because col-\noring ´ red may cause a violation of one of the red-black properties, we call\nRB-INSERT-FIXUP.T; ´/ in line 17 of RB-INSERT to restore the red-black prop-\nerties.\n316\nChapter 13\nRed-Black Trees\nRB-INSERT-FIXUP.T; ´/\n1\nwhile ´:p:color == RED\n2\nif ´:p == ´:p:p:left\n3\ny D ´:p:p:right\n4\nif y:color == RED\n5\n´:p:color D BLACK\n// case 1\n6\ny:color D BLACK\n// case 1\n7\n´:p:p:color D RED\n// case 1\n8\n´ D ´:p:p\n// case 1\n9\nelse if ´ == ´:p:right\n10\n´ D ´:p\n// case 2\n11\nLEFT-ROTATE.T; ´/\n// case 2\n12\n´:p:color D BLACK\n// case 3\n13\n´:p:p:color D RED\n// case 3\n14\nRIGHT-ROTATE.T; ´:p:p/\n// case 3\n15\nelse (same as then clause\nwith “right” and “left” exchanged)\n16\nT:root:color D BLACK\nTo understand how RB-INSERT-FIXUP works, we shall break our examination\nof the code into three major steps. First, we shall determine what violations of\nthe red-black properties are introduced in RB-INSERT when node ´ is inserted\nand colored red. Second, we shall examine the overall goal of the while loop in\nlines 1–15. Finally, we shall explore each of the three cases1 within the while\nloop’s body and see how they accomplish the goal. Figure 13.4 shows how RB-\nINSERT-FIXUP operates on a sample red-black tree.\nWhich of the red-black properties might be violated upon the call to RB-\nINSERT-FIXUP? Property 1 certainly continues to hold, as does property 3, since\nboth children of the newly inserted red node are the sentinel T:nil. Property 5,\nwhich says that the number of black nodes is the same on every simple path from\na given node, is satisﬁed as well, because node ´ replaces the (black) sentinel, and\nnode ´ is red with sentinel children. Thus, the only properties that might be vi-\nolated are property 2, which requires the root to be black, and property 4, which",
    "parent_2cb18855-4e59-48a7-9f53-44b4fb32dcd2": "a given node, is satisﬁed as well, because node ´ replaces the (black) sentinel, and\nnode ´ is red with sentinel children. Thus, the only properties that might be vi-\nolated are property 2, which requires the root to be black, and property 4, which\nsays that a red node cannot have a red child. Both possible violations are due to ´\nbeing colored red. Property 2 is violated if ´ is the root, and property 4 is violated\nif ´’s parent is red. Figure 13.4(a) shows a violation of property 4 after the node ´\nhas been inserted.\n1Case 2 falls through into case 3, and so these two cases are not mutually exclusive.\n13.3\nInsertion\n317\nz\ny\n11\n2\n1\n7\n5\n4\n8\n14\n15\nz\ny\n11\n2\n1\n7\n5\n4\n8\n14\n15\n(a)\n(b)\nCase 1\nz\ny\n11\n7\n2\n8\n4\n14\n15\n(c)\nCase 2\n1\n5\n4\nz\n7\n2\n1\n5\n11\n14\n(d)\nCase 3\n4\n8\n15\nFigure 13.4\nThe operation of RB-INSERT-FIXUP. (a) A node ´ after insertion. Because both ´\nand its parent ´:p are red, a violation of property 4 occurs. Since ´’s uncle y is red, case 1 in the\ncode applies. We recolor nodes and move the pointer ´ up the tree, resulting in the tree shown in (b).\nOnce again, ´ and its parent are both red, but ´’s uncle y is black. Since ´ is the right child of ´:p,\ncase 2 applies. We perform a left rotation, and the tree that results is shown in (c). Now, ´ is the left\nchild of its parent, and case 3 applies. Recoloring and right rotation yield the tree in (d), which is a\nlegal red-black tree.\n318\nChapter 13\nRed-Black Trees\nThe while loop in lines 1–15 maintains the following three-part invariant at the\nstart of each iteration of the loop:\na. Node ´ is red.\nb. If ´:p is the root, then ´:p is black.\nc. If the tree violates any of the red-black properties, then it violates at most\none of them, and the violation is of either property 2 or property 4. If the\ntree violates property 2, it is because ´ is the root and is red. If the tree\nviolates property 4, it is because both ´ and ´:p are red.\nPart (c), which deals with violations of red-black properties, is more central to",
    "parent_e5c232b0-89d1-47f7-a6d9-908ea83607d1": "one of them, and the violation is of either property 2 or property 4. If the\ntree violates property 2, it is because ´ is the root and is red. If the tree\nviolates property 4, it is because both ´ and ´:p are red.\nPart (c), which deals with violations of red-black properties, is more central to\nshowing that RB-INSERT-FIXUP restores the red-black properties than parts (a)\nand (b), which we use along the way to understand situations in the code. Because\nwe’ll be focusing on node ´ and nodes near it in the tree, it helps to know from\npart (a) that ´ is red. We shall use part (b) to show that the node ´:p:p exists when\nwe reference it in lines 2, 3, 7, 8, 13, and 14.\nRecall that we need to show that a loop invariant is true prior to the ﬁrst itera-\ntion of the loop, that each iteration maintains the loop invariant, and that the loop\ninvariant gives us a useful property at loop termination.\nWe start with the initialization and termination arguments. Then, as we exam-\nine how the body of the loop works in more detail, we shall argue that the loop\nmaintains the invariant upon each iteration. Along the way, we shall also demon-\nstrate that each iteration of the loop has two possible outcomes: either the pointer ´\nmoves up the tree, or we perform some rotations and then the loop terminates.\nInitialization: Prior to the ﬁrst iteration of the loop, we started with a red-black\ntree with no violations, and we added a red node ´. We show that each part of\nthe invariant holds at the time RB-INSERT-FIXUP is called:\na. When RB-INSERT-FIXUP is called, ´ is the red node that was added.\nb. If ´:p is the root, then ´:p started out black and did not change prior to the\ncall of RB-INSERT-FIXUP.\nc. We have already seen that properties 1, 3, and 5 hold when RB-INSERT-\nFIXUP is called.\nIf the tree violates property 2, then the red root must be the newly added\nnode ´, which is the only internal node in the tree. Because the parent and",
    "parent_0324feb9-3172-44a2-8b0b-d9f547585dde": "call of RB-INSERT-FIXUP.\nc. We have already seen that properties 1, 3, and 5 hold when RB-INSERT-\nFIXUP is called.\nIf the tree violates property 2, then the red root must be the newly added\nnode ´, which is the only internal node in the tree. Because the parent and\nboth children of ´ are the sentinel, which is black, the tree does not also\nviolate property 4. Thus, this violation of property 2 is the only violation of\nred-black properties in the entire tree.\nIf the tree violates property 4, then, because the children of node ´ are black\nsentinels and the tree had no other violations prior to ´ being added, the\n13.3\nInsertion\n319\nviolation must be because both ´ and ´:p are red. Moreover, the tree violates\nno other red-black properties.\nTermination: When the loop terminates, it does so because ´:p is black. (If ´ is\nthe root, then ´:p is the sentinel T:nil, which is black.) Thus, the tree does not\nviolate property 4 at loop termination. By the loop invariant, the only property\nthat might fail to hold is property 2. Line 16 restores this property, too, so that\nwhen RB-INSERT-FIXUP terminates, all the red-black properties hold.\nMaintenance: We actually need to consider six cases in the while loop, but three\nof them are symmetric to the other three, depending on whether line 2 deter-\nmines ´’s parent ´:p to be a left child or a right child of ´’s grandparent ´:p:p.\nWe have given the code only for the situation in which ´:p is a left child. The\nnode ´:p:p exists, since by part (b) of the loop invariant, if ´:p is the root,\nthen ´:p is black. Since we enter a loop iteration only if ´:p is red, we know\nthat ´:p cannot be the root. Hence, ´:p:p exists.\nWe distinguish case 1 from cases 2 and 3 by the color of ´’s parent’s sibling,\nor “uncle.” Line 3 makes y point to ´’s uncle ´:p:p:right, and line 4 tests y’s\ncolor. If y is red, then we execute case 1. Otherwise, control passes to cases 2\nand 3. In all three cases, ´’s grandparent ´:p:p is black, since its parent ´:p is",
    "parent_693dc983-5e63-4b12-adc0-bf1be6ebc64a": "or “uncle.” Line 3 makes y point to ´’s uncle ´:p:p:right, and line 4 tests y’s\ncolor. If y is red, then we execute case 1. Otherwise, control passes to cases 2\nand 3. In all three cases, ´’s grandparent ´:p:p is black, since its parent ´:p is\nred, and property 4 is violated only between ´ and ´:p.\nCase 1: ´’s uncle y is red\nFigure 13.5 shows the situation for case 1 (lines 5–8), which occurs when\nboth ´:p and y are red. Because ´:p:p is black, we can color both ´:p and y\nblack, thereby ﬁxing the problem of ´ and ´:p both being red, and we can\ncolor ´:p:p red, thereby maintaining property 5. We then repeat the while loop\nwith ´:p:p as the new node ´. The pointer ´ moves up two levels in the tree.\nNow, we show that case 1 maintains the loop invariant at the start of the next\niteration. We use ´ to denote node ´ in the current iteration, and ´0 D ´:p:p\nto denote the node that will be called node ´ at the test in line 1 upon the next\niteration.\na. Because this iteration colors ´:p:p red, node ´0 is red at the start of the next\niteration.\nb. The node ´0:p is ´:p:p:p in this iteration, and the color of this node does not\nchange. If this node is the root, it was black prior to this iteration, and it\nremains black at the start of the next iteration.\nc. We have already argued that case 1 maintains property 5, and it does not\nintroduce a violation of properties 1 or 3.\n320\nChapter 13\nRed-Black Trees\nz\ny\nC\nD\nA\nB\nα\nβ\nγ\nδ\nε\n(a)\nC\nD\nA\nB\nα\nβ\nγ\nδ\nε\nnew z\ny\nC\nD\nB\nδ\nε\nC\nD\nB\nA\nα\nβ\nγ\nδ\nε\nnew z\n(b)\nA\nα\nβ\nγ\nz\nFigure 13.5\nCase 1 of the procedure RB-INSERT-FIXUP. Property 4 is violated, since ´ and its\nparent ´:p are both red. We take the same action whether (a) ´ is a right child or (b) ´ is a left\nchild. Each of the subtrees ˛, ˇ, \n, ı, and \" has a black root, and each has the same black-height.\nThe code for case 1 changes the colors of some nodes, preserving property 5: all downward simple",
    "parent_475e7a3b-1d5a-417c-9204-e5f6e79148eb": "parent ´:p are both red. We take the same action whether (a) ´ is a right child or (b) ´ is a left\nchild. Each of the subtrees ˛, ˇ, \n, ı, and \" has a black root, and each has the same black-height.\nThe code for case 1 changes the colors of some nodes, preserving property 5: all downward simple\npaths from a node to a leaf have the same number of blacks. The while loop continues with node ´’s\ngrandparent ´:p:p as the new ´. Any violation of property 4 can now occur only between the new ´,\nwhich is red, and its parent, if it is red as well.\nIf node ´0 is the root at the start of the next iteration, then case 1 corrected\nthe lone violation of property 4 in this iteration. Since ´0 is red and it is the\nroot, property 2 becomes the only one that is violated, and this violation is\ndue to ´0.\nIf node ´0 is not the root at the start of the next iteration, then case 1 has\nnot created a violation of property 2. Case 1 corrected the lone violation\nof property 4 that existed at the start of this iteration. It then made ´0 red\nand left ´0:p alone. If ´0:p was black, there is no violation of property 4.\nIf ´0:p was red, coloring ´0 red created one violation of property 4 between ´0\nand ´0:p.\nCase 2: ´’s uncle y is black and ´ is a right child\nCase 3: ´’s uncle y is black and ´ is a left child\nIn cases 2 and 3, the color of ´’s uncle y is black. We distinguish the two cases\naccording to whether ´ is a right or left child of ´:p. Lines 10–11 constitute\ncase 2, which is shown in Figure 13.6 together with case 3. In case 2, node ´\nis a right child of its parent. We immediately use a left rotation to transform\nthe situation into case 3 (lines 12–14), in which node ´ is a left child. Because\n13.3\nInsertion\n321\nC\nA\nB\nα\nβ\nγ\nδ\nCase 2\nz\ny\nB\nA\nα\nβ\nγ\nδ\nCase 3\nz\ny\nz\nA\nB\nC\nα\nβ\nγ\nδ\nC\nFigure 13.6\nCases 2 and 3 of the procedure RB-INSERT-FIXUP. As in case 1, property 4 is violated\nin either case 2 or case 3 because ´ and its parent ´:p are both red. Each of the subtrees ˛, ˇ, \n, and ı",
    "parent_9661d04e-329a-4bd1-b48b-a112f1aea746": "13.3\nInsertion\n321\nC\nA\nB\nα\nβ\nγ\nδ\nCase 2\nz\ny\nB\nA\nα\nβ\nγ\nδ\nCase 3\nz\ny\nz\nA\nB\nC\nα\nβ\nγ\nδ\nC\nFigure 13.6\nCases 2 and 3 of the procedure RB-INSERT-FIXUP. As in case 1, property 4 is violated\nin either case 2 or case 3 because ´ and its parent ´:p are both red. Each of the subtrees ˛, ˇ, \n, and ı\nhas a black root (˛, ˇ, and \n from property 4, and ı because otherwise we would be in case 1), and\neach has the same black-height. We transform case 2 into case 3 by a left rotation, which preserves\nproperty 5: all downward simple paths from a node to a leaf have the same number of blacks. Case 3\ncauses some color changes and a right rotation, which also preserve property 5. The while loop then\nterminates, because property 4 is satisﬁed: there are no longer two red nodes in a row.\nboth ´ and ´:p are red, the rotation affects neither the black-height of nodes\nnor property 5. Whether we enter case 3 directly or through case 2, ´’s uncle y\nis black, since otherwise we would have executed case 1. Additionally, the\nnode ´:p:p exists, since we have argued that this node existed at the time that\nlines 2 and 3 were executed, and after moving ´ up one level in line 10 and then\ndown one level in line 11, the identity of ´:p:p remains unchanged. In case 3,\nwe execute some color changes and a right rotation, which preserve property 5,\nand then, since we no longer have two red nodes in a row, we are done. The\nwhile loop does not iterate another time, since ´:p is now black.\nWe now show that cases 2 and 3 maintain the loop invariant. (As we have just\nargued, ´:p will be black upon the next test in line 1, and the loop body will not\nexecute again.)\na. Case 2 makes ´ point to ´:p, which is red. No further change to ´ or its color\noccurs in cases 2 and 3.\nb. Case 3 makes ´:p black, so that if ´:p is the root at the start of the next\niteration, it is black.\nc. As in case 1, properties 1, 3, and 5 are maintained in cases 2 and 3.",
    "parent_506bb6bc-6014-4ea2-b793-bf71efa9e3a8": "execute again.)\na. Case 2 makes ´ point to ´:p, which is red. No further change to ´ or its color\noccurs in cases 2 and 3.\nb. Case 3 makes ´:p black, so that if ´:p is the root at the start of the next\niteration, it is black.\nc. As in case 1, properties 1, 3, and 5 are maintained in cases 2 and 3.\nSince node ´ is not the root in cases 2 and 3, we know that there is no viola-\ntion of property 2. Cases 2 and 3 do not introduce a violation of property 2,\nsince the only node that is made red becomes a child of a black node by the\nrotation in case 3.\nCases 2 and 3 correct the lone violation of property 4, and they do not intro-\nduce another violation.\n322\nChapter 13\nRed-Black Trees\nHaving shown that each iteration of the loop maintains the invariant, we have\nshown that RB-INSERT-FIXUP correctly restores the red-black properties.\nAnalysis\nWhat is the running time of RB-INSERT? Since the height of a red-black tree on n\nnodes is O.lg n/, lines 1–16 of RB-INSERT take O.lg n/ time. In RB-INSERT-\nFIXUP, the while loop repeats only if case 1 occurs, and then the pointer ´ moves\ntwo levels up the tree. The total number of times the while loop can be executed\nis therefore O.lg n/. Thus, RB-INSERT takes a total of O.lg n/ time. Moreover, it\nnever performs more than two rotations, since the while loop terminates if case 2\nor case 3 is executed.\nExercises\n13.3-1\nIn line 16 of RB-INSERT, we set the color of the newly inserted node ´ to red.\nObserve that if we had chosen to set ´’s color to black, then property 4 of a red-\nblack tree would not be violated. Why didn’t we choose to set ´’s color to black?\n13.3-2\nShow the red-black trees that result after successively inserting the keys 41; 38; 31;\n12; 19; 8 into an initially empty red-black tree.\n13.3-3\nSuppose that the black-height of each of the subtrees ˛; ˇ; \n; ı; \" in Figures 13.5\nand 13.6 is k. Label each node in each ﬁgure with its black-height to verify that\nthe indicated transformation preserves property 5.\n13.3-4",
    "parent_a316c167-cb9f-4c56-882a-ff5de92d7156": "12; 19; 8 into an initially empty red-black tree.\n13.3-3\nSuppose that the black-height of each of the subtrees ˛; ˇ; \n; ı; \" in Figures 13.5\nand 13.6 is k. Label each node in each ﬁgure with its black-height to verify that\nthe indicated transformation preserves property 5.\n13.3-4\nProfessor Teach is concerned that RB-INSERT-FIXUP might set T:nil:color to\nRED, in which case the test in line 1 would not cause the loop to terminate when ´\nis the root. Show that the professor’s concern is unfounded by arguing that RB-\nINSERT-FIXUP never sets T:nil:color to RED.\n13.3-5\nConsider a red-black tree formed by inserting n nodes with RB-INSERT. Argue\nthat if n > 1, the tree has at least one red node.\n13.3-6\nSuggest how to implement RB-INSERT efﬁciently if the representation for red-\nblack trees includes no storage for parent pointers.\n13.4\nDeletion\n323\n13.4\nDeletion\nLike the other basic operations on an n-node red-black tree, deletion of a node takes\ntime O.lg n/. Deleting a node from a red-black tree is a bit more complicated than\ninserting a node.\nThe procedure for deleting a node from a red-black tree is based on the TREE-\nDELETE procedure (Section 12.3). First, we need to customize the TRANSPLANT\nsubroutine that TREE-DELETE calls so that it applies to a red-black tree:\nRB-TRANSPLANT.T; u; \u0003/\n1\nif u:p == T:nil\n2\nT:root D \u0003\n3\nelseif u == u:p:left\n4\nu:p:left D \u0003\n5\nelse u:p:right D \u0003\n6\n\u0003:p D u:p\nThe procedure RB-TRANSPLANT differs from TRANSPLANT in two ways. First,\nline 1 references the sentinel T:nil instead of NIL. Second, the assignment to \u0003:p in\nline 6 occurs unconditionally: we can assign to \u0003:p even if \u0003 points to the sentinel.\nIn fact, we shall exploit the ability to assign to \u0003:p when \u0003 D T:nil.\nThe procedure RB-DELETE is like the TREE-DELETE procedure, but with ad-\nditional lines of pseudocode. Some of the additional lines keep track of a node y\nthat might cause violations of the red-black properties. When we want to delete",
    "parent_898f8ddc-952a-41e8-bfbf-29a070823dd2": "The procedure RB-DELETE is like the TREE-DELETE procedure, but with ad-\nditional lines of pseudocode. Some of the additional lines keep track of a node y\nthat might cause violations of the red-black properties. When we want to delete\nnode ´ and ´ has fewer than two children, then ´ is removed from the tree, and we\nwant y to be ´. When ´ has two children, then y should be ´’s successor, and y\nmoves into ´’s position in the tree. We also remember y’s color before it is re-\nmoved from or moved within the tree, and we keep track of the node x that moves\ninto y’s original position in the tree, because node x might also cause violations\nof the red-black properties. After deleting node ´, RB-DELETE calls an auxiliary\nprocedure RB-DELETE-FIXUP, which changes colors and performs rotations to\nrestore the red-black properties.\n324\nChapter 13\nRed-Black Trees\nRB-DELETE.T; ´/\n1\ny D ´\n2\ny-original-color D y:color\n3\nif ´:left == T:nil\n4\nx D ´:right\n5\nRB-TRANSPLANT.T; ´; ´:right/\n6\nelseif ´:right == T:nil\n7\nx D ´:left\n8\nRB-TRANSPLANT.T; ´; ´:left/\n9\nelse y D TREE-MINIMUM.´:right/\n10\ny-original-color D y:color\n11\nx D y:right\n12\nif y:p == ´\n13\nx:p D y\n14\nelse RB-TRANSPLANT.T; y; y:right/\n15\ny:right D ´:right\n16\ny:right:p D y\n17\nRB-TRANSPLANT.T; ´; y/\n18\ny:left D ´:left\n19\ny:left:p D y\n20\ny:color D ´:color\n21\nif y-original-color == BLACK\n22\nRB-DELETE-FIXUP.T; x/\nAlthough RB-DELETE contains almost twice as many lines of pseudocode as\nTREE-DELETE, the two procedures have the same basic structure. You can ﬁnd\neach line of TREE-DELETE within RB-DELETE (with the changes of replacing\nNIL by T:nil and replacing calls to TRANSPLANT by calls to RB-TRANSPLANT),\nexecuted under the same conditions.\nHere are the other differences between the two procedures:\n\u0002\nWe maintain node y as the node either removed from the tree or moved within\nthe tree. Line 1 sets y to point to node ´ when ´ has fewer than two children\nand is therefore removed. When ´ has two children, line 9 sets y to point to ´’s",
    "parent_0c1444a0-82cc-44be-9d92-289eaab745ad": "Here are the other differences between the two procedures:\n\u0002\nWe maintain node y as the node either removed from the tree or moved within\nthe tree. Line 1 sets y to point to node ´ when ´ has fewer than two children\nand is therefore removed. When ´ has two children, line 9 sets y to point to ´’s\nsuccessor, just as in TREE-DELETE, and y will move into ´’s position in the\ntree.\n\u0002\nBecause node y’s color might change, the variable y-original-color stores y’s\ncolor before any changes occur. Lines 2 and 10 set this variable immediately\nafter assignments to y. When ´ has two children, then y ¤ ´ and node y\nmoves into node ´’s original position in the red-black tree; line 20 gives y the\nsame color as ´. We need to save y’s original color in order to test it at the\n13.4\nDeletion\n325\nend of RB-DELETE; if it was black, then removing or moving y could cause\nviolations of the red-black properties.\n\u0002\nAs discussed, we keep track of the node x that moves into node y’s original\nposition. The assignments in lines 4, 7, and 11 set x to point to either y’s only\nchild or, if y has no children, the sentinel T:nil. (Recall from Section 12.3\nthat y has no left child.)\n\u0002\nSince node x moves into node y’s original position, the attribute x:p is always\nset to point to the original position in the tree of y’s parent, even if x is, in fact,\nthe sentinel T:nil. Unless ´ is y’s original parent (which occurs only when ´ has\ntwo children and its successor y is ´’s right child), the assignment to x:p takes\nplace in line 6 of RB-TRANSPLANT. (Observe that when RB-TRANSPLANT\nis called in lines 5, 8, or 14, the second parameter passed is the same as x.)\nWhen y’s original parent is ´, however, we do not want x:p to point to y’s orig-\ninal parent, since we are removing that node from the tree. Because node y will\nmove up to take ´’s position in the tree, setting x:p to y in line 13 causes x:p\nto point to the original position of y’s parent, even if x D T:nil.\n\u0002",
    "parent_6933280e-07c6-4dd2-9772-5dccde3ea50c": "inal parent, since we are removing that node from the tree. Because node y will\nmove up to take ´’s position in the tree, setting x:p to y in line 13 causes x:p\nto point to the original position of y’s parent, even if x D T:nil.\n\u0002\nFinally, if node y was black, we might have introduced one or more violations\nof the red-black properties, and so we call RB-DELETE-FIXUP in line 22 to\nrestore the red-black properties. If y was red, the red-black properties still hold\nwhen y is removed or moved, for the following reasons:\n1. No black-heights in the tree have changed.\n2. No red nodes have been made adjacent. Because y takes ´’s place in the\ntree, along with ´’s color, we cannot have two adjacent red nodes at y’s new\nposition in the tree. In addition, if y was not ´’s right child, then y’s original\nright child x replaces y in the tree. If y is red, then x must be black, and so\nreplacing y by x cannot cause two red nodes to become adjacent.\n3. Since y could not have been the root if it was red, the root remains black.\nIf node y was black, three problems may arise, which the call of RB-DELETE-\nFIXUP will remedy. First, if y had been the root and a red child of y becomes the\nnew root, we have violated property 2. Second, if both x and x:p are red, then\nwe have violated property 4. Third, moving y within the tree causes any simple\npath that previously contained y to have one fewer black node. Thus, property 5\nis now violated by any ancestor of y in the tree. We can correct the violation\nof property 5 by saying that node x, now occupying y’s original position, has an\n“extra” black. That is, if we add 1 to the count of black nodes on any simple path\nthat contains x, then under this interpretation, property 5 holds. When we remove\nor move the black node y, we “push” its blackness onto node x. The problem is\nthat now node x is neither red nor black, thereby violating property 1. Instead,\n326\nChapter 13\nRed-Black Trees",
    "parent_01ca6a56-3141-42d2-8136-fb9323d05ca4": "that contains x, then under this interpretation, property 5 holds. When we remove\nor move the black node y, we “push” its blackness onto node x. The problem is\nthat now node x is neither red nor black, thereby violating property 1. Instead,\n326\nChapter 13\nRed-Black Trees\nnode x is either “doubly black” or “red-and-black,” and it contributes either 2 or 1,\nrespectively, to the count of black nodes on simple paths containing x. The color\nattribute of x will still be either RED (if x is red-and-black) or BLACK (if x is\ndoubly black). In other words, the extra black on a node is reﬂected in x’s pointing\nto the node rather than in the color attribute.\nWe can now see the procedure RB-DELETE-FIXUP and examine how it restores\nthe red-black properties to the search tree.\nRB-DELETE-FIXUP.T; x/\n1\nwhile x ¤ T:root and x:color == BLACK\n2\nif x == x:p:left\n3\nw D x:p:right\n4\nif w:color == RED\n5\nw:color D BLACK\n// case 1\n6\nx:p:color D RED\n// case 1\n7\nLEFT-ROTATE.T; x:p/\n// case 1\n8\nw D x:p:right\n// case 1\n9\nif w:left:color == BLACK and w:right:color == BLACK\n10\nw:color D RED\n// case 2\n11\nx D x:p\n// case 2\n12\nelse if w:right:color == BLACK\n13\nw:left:color D BLACK\n// case 3\n14\nw:color D RED\n// case 3\n15\nRIGHT-ROTATE.T; w/\n// case 3\n16\nw D x:p:right\n// case 3\n17\nw:color D x:p:color\n// case 4\n18\nx:p:color D BLACK\n// case 4\n19\nw:right:color D BLACK\n// case 4\n20\nLEFT-ROTATE.T; x:p/\n// case 4\n21\nx D T:root\n// case 4\n22\nelse (same as then clause with “right” and “left” exchanged)\n23\nx:color D BLACK\nThe procedure RB-DELETE-FIXUP restores properties 1, 2, and 4.\nExercises\n13.4-1 and 13.4-2 ask you to show that the procedure restores properties 2 and 4,\nand so in the remainder of this section, we shall focus on property 1. The goal of\nthe while loop in lines 1–22 is to move the extra black up the tree until\n1. x points to a red-and-black node, in which case we color x (singly) black in\nline 23;\n2. x points to the root, in which case we simply “remove” the extra black; or",
    "parent_5a40fd37-d798-45f8-b702-61a1d711261c": "the while loop in lines 1–22 is to move the extra black up the tree until\n1. x points to a red-and-black node, in which case we color x (singly) black in\nline 23;\n2. x points to the root, in which case we simply “remove” the extra black; or\n3. having performed suitable rotations and recolorings, we exit the loop.\n13.4\nDeletion\n327\nWithin the while loop, x always points to a nonroot doubly black node. We\ndetermine in line 2 whether x is a left child or a right child of its parent x:p. (We\nhave given the code for the situation in which x is a left child; the situation in\nwhich x is a right child—line 22—is symmetric.) We maintain a pointer w to\nthe sibling of x. Since node x is doubly black, node w cannot be T:nil, because\notherwise, the number of blacks on the simple path from x:p to the (singly black)\nleaf w would be smaller than the number on the simple path from x:p to x.\nThe four cases2 in the code appear in Figure 13.7. Before examining each case\nin detail, let’s look more generally at how we can verify that the transformation\nin each of the cases preserves property 5. The key idea is that in each case, the\ntransformation applied preserves the number of black nodes (including x’s extra\nblack) from (and including) the root of the subtree shown to each of the subtrees\n˛; ˇ; : : : ; \u000b. Thus, if property 5 holds prior to the transformation, it continues to\nhold afterward. For example, in Figure 13.7(a), which illustrates case 1, the num-\nber of black nodes from the root to either subtree ˛ or ˇ is 3, both before and after\nthe transformation. (Again, remember that node x adds an extra black.) Similarly,\nthe number of black nodes from the root to any of \n, ı, \", and \u000b is 2, both be-\nfore and after the transformation. In Figure 13.7(b), the counting must involve the\nvalue c of the color attribute of the root of the subtree shown, which can be either\nRED or BLACK. If we deﬁne count.RED/ D 0 and count.BLACK/ D 1, then the",
    "parent_a7c4698d-46c7-41c1-adaa-7a2e5854341c": ", ı, \", and \u000b is 2, both be-\nfore and after the transformation. In Figure 13.7(b), the counting must involve the\nvalue c of the color attribute of the root of the subtree shown, which can be either\nRED or BLACK. If we deﬁne count.RED/ D 0 and count.BLACK/ D 1, then the\nnumber of black nodes from the root to ˛ is 2 C count.c/, both before and after\nthe transformation. In this case, after the transformation, the new node x has color\nattribute c, but this node is really either red-and-black (if c D RED) or doubly black\n(if c D BLACK). You can verify the other cases similarly (see Exercise 13.4-5).\nCase 1: x’s sibling w is red\nCase 1 (lines 5–8 of RB-DELETE-FIXUP and Figure 13.7(a)) occurs when node w,\nthe sibling of node x, is red. Since w must have black children, we can switch the\ncolors of w and x:p and then perform a left-rotation on x:p without violating any\nof the red-black properties. The new sibling of x, which is one of w’s children\nprior to the rotation, is now black, and thus we have converted case 1 into case 2,\n3, or 4.\nCases 2, 3, and 4 occur when node w is black; they are distinguished by the\ncolors of w’s children.\n2As in RB-INSERT-FIXUP, the cases in RB-DELETE-FIXUP are not mutually exclusive.\n328\nChapter 13\nRed-Black Trees\nCase 2: x’s sibling w is black, and both of w’s children are black\nIn case 2 (lines 10–11 of RB-DELETE-FIXUP and Figure 13.7(b)), both of w’s\nchildren are black. Since w is also black, we take one black off both x and w,\nleaving x with only one black and leaving w red. To compensate for removing\none black from x and w, we would like to add an extra black to x:p, which was\noriginally either red or black. We do so by repeating the while loop with x:p as\nthe new node x. Observe that if we enter case 2 through case 1, the new node x\nis red-and-black, since the original x:p was red. Hence, the value c of the color\nattribute of the new node x is RED, and the loop terminates when it tests the loop",
    "parent_bad1c866-8442-442b-99b7-07825176de2d": "the new node x. Observe that if we enter case 2 through case 1, the new node x\nis red-and-black, since the original x:p was red. Hence, the value c of the color\nattribute of the new node x is RED, and the loop terminates when it tests the loop\ncondition. We then color the new node x (singly) black in line 23.\nCase 3: x’s sibling w is black, w’s left child is red, and w’s right child is black\nCase 3 (lines 13–16 and Figure 13.7(c)) occurs when w is black, its left child\nis red, and its right child is black. We can switch the colors of w and its left\nchild w:left and then perform a right rotation on w without violating any of the\nred-black properties. The new sibling w of x is now a black node with a red right\nchild, and thus we have transformed case 3 into case 4.\nCase 4: x’s sibling w is black, and w’s right child is red\nCase 4 (lines 17–21 and Figure 13.7(d)) occurs when node x’s sibling w is black\nand w’s right child is red. By making some color changes and performing a left ro-\ntation on x:p, we can remove the extra black on x, making it singly black, without\nviolating any of the red-black properties. Setting x to be the root causes the while\nloop to terminate when it tests the loop condition.\nAnalysis\nWhat is the running time of RB-DELETE? Since the height of a red-black tree of n\nnodes is O.lg n/, the total cost of the procedure without the call to RB-DELETE-\nFIXUP takes O.lg n/ time. Within RB-DELETE-FIXUP, each of cases 1, 3, and 4\nlead to termination after performing a constant number of color changes and at\nmost three rotations. Case 2 is the only case in which the while loop can be re-\npeated, and then the pointer x moves up the tree at most O.lg n/ times, performing\nno rotations. Thus, the procedure RB-DELETE-FIXUP takes O.lg n/ time and per-\nforms at most three rotations, and the overall time for RB-DELETE is therefore\nalso O.lg n/.\n13.4\nDeletion\n329\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nx\nw\nA\nB\nC\nD\nE\nx\nnew w\nα\nβ\nγ\nδ\nε\nζ\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nx\nw\nc\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε",
    "parent_058ecb8b-c861-4260-a0b4-468673a6d2dc": "no rotations. Thus, the procedure RB-DELETE-FIXUP takes O.lg n/ time and per-\nforms at most three rotations, and the overall time for RB-DELETE is therefore\nalso O.lg n/.\n13.4\nDeletion\n329\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nx\nw\nA\nB\nC\nD\nE\nx\nnew w\nα\nβ\nγ\nδ\nε\nζ\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nx\nw\nc\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nc\nnew x\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nx\nw\nc\nA\nB\nC\nD\nα\nβ\nγ\nδ\nε\nζ\nx\nc\nnew w\nA\nB\nD\nC\nE\nα\nβ\nγ\nδ\nε\nζ\nx\nw\nc\nc\nα\nβ\nA\nB\nC\nD\nE\n(d)\n(c)\n(b)\n(a)\nγ\nδ\nε\nζ\nCase 4\nCase 3\nCase 2\nCase 1\nE\nc′\nc′\nnew x D T:root\nFigure 13.7\nThe cases in the while loop of the procedure RB-DELETE-FIXUP. Darkened nodes\nhave color attributes BLACK, heavily shaded nodes have color attributes RED, and lightly shaded\nnodes have color attributes represented by c and c0, which may be either RED or BLACK. The letters\n˛; ˇ; : : : ; \u000b represent arbitrary subtrees. Each case transforms the conﬁguration on the left into the\nconﬁguration on the right by changing some colors and/or performing a rotation. Any node pointed\nto by x has an extra black and is either doubly black or red-and-black. Only case 2 causes the loop to\nrepeat. (a) Case 1 is transformed to case 2, 3, or 4 by exchanging the colors of nodes B and D and\nperforming a left rotation. (b) In case 2, the extra black represented by the pointer x moves up the\ntree by coloring node D red and setting x to point to node B. If we enter case 2 through case 1, the\nwhile loop terminates because the new node x is red-and-black, and therefore the value c of its color\nattribute is RED. (c) Case 3 is transformed to case 4 by exchanging the colors of nodes C and D and\nperforming a right rotation. (d) Case 4 removes the extra black represented by x by changing some\ncolors and performing a left rotation (without violating the red-black properties), and then the loop\nterminates.\n330\nChapter 13\nRed-Black Trees\nExercises\n13.4-1\nArgue that after executing RB-DELETE-FIXUP, the root of the tree must be black.\n13.4-2",
    "parent_6d6b1d8e-c228-4626-8b9e-0a5004e0e183": "colors and performing a left rotation (without violating the red-black properties), and then the loop\nterminates.\n330\nChapter 13\nRed-Black Trees\nExercises\n13.4-1\nArgue that after executing RB-DELETE-FIXUP, the root of the tree must be black.\n13.4-2\nArgue that if in RB-DELETE both x and x:p are red, then property 4 is restored by\nthe call to RB-DELETE-FIXUP.T; x/.\n13.4-3\nIn Exercise 13.3-2, you found the red-black tree that results from successively\ninserting the keys 41; 38; 31; 12; 19; 8 into an initially empty tree. Now show the\nred-black trees that result from the successive deletion of the keys in the order\n8; 12; 19; 31; 38; 41.\n13.4-4\nIn which lines of the code for RB-DELETE-FIXUP might we examine or modify\nthe sentinel T:nil?\n13.4-5\nIn each of the cases of Figure 13.7, give the count of black nodes from the root of\nthe subtree shown to each of the subtrees ˛; ˇ; : : : ; \u000b, and verify that each count\nremains the same after the transformation. When a node has a color attribute c\nor c0, use the notation count.c/ or count.c0/ symbolically in your count.\n13.4-6\nProfessors Skelton and Baron are concerned that at the start of case 1 of RB-\nDELETE-FIXUP, the node x:p might not be black. If the professors are correct,\nthen lines 5–6 are wrong. Show that x:p must be black at the start of case 1, so that\nthe professors have nothing to worry about.\n13.4-7\nSuppose that a node x is inserted into a red-black tree with RB-INSERT and then\nis immediately deleted with RB-DELETE. Is the resulting red-black tree the same\nas the initial red-black tree? Justify your answer.\nProblems for Chapter 13\n331\nProblems\n13-1\nPersistent dynamic sets\nDuring the course of an algorithm, we sometimes ﬁnd that we need to maintain past\nversions of a dynamic set as it is updated. We call such a set persistent. One way to\nimplement a persistent set is to copy the entire set whenever it is modiﬁed, but this\napproach can slow down a program and also consume much space. Sometimes, we",
    "parent_fa9cc53b-c261-4cf0-9fac-68a9766765a5": "versions of a dynamic set as it is updated. We call such a set persistent. One way to\nimplement a persistent set is to copy the entire set whenever it is modiﬁed, but this\napproach can slow down a program and also consume much space. Sometimes, we\ncan do much better.\nConsider a persistent set S with the operations INSERT, DELETE, and SEARCH,\nwhich we implement using binary search trees as shown in Figure 13.8(a). We\nmaintain a separate root for every version of the set. In order to insert the key 5\ninto the set, we create a new node with key 5. This node becomes the left child\nof a new node with key 7, since we cannot modify the existing node with key 7.\nSimilarly, the new node with key 7 becomes the left child of a new node with\nkey 8 whose right child is the existing node with key 10. The new node with key 8\nbecomes, in turn, the right child of a new root r0 with key 4 whose left child is the\nexisting node with key 3. We thus copy only part of the tree and share some of the\nnodes with the original tree, as shown in Figure 13.8(b).\nAssume that each tree node has the attributes key, left, and right but no parent.\n(See also Exercise 13.3-6.)\n4\n3\n2\n8\n7\n10\n4\n3\n2\n8\n7\n10\n4\n8\n7\n5\n(b)\n(a)\nr\nr\nr′\nFigure 13.8\n(a) A binary search tree with keys 2; 3; 4; 7; 8; 10. (b) The persistent binary search\ntree that results from the insertion of key 5. The most recent version of the set consists of the nodes\nreachable from the root r0, and the previous version consists of the nodes reachable from r. Heavily\nshaded nodes are added when key 5 is inserted.\n332\nChapter 13\nRed-Black Trees\na. For a general persistent binary search tree, identify the nodes that we need to\nchange to insert a key k or delete a node y.\nb. Write a procedure PERSISTENT-TREE-INSERT that, given a persistent tree T\nand a key k to insert, returns a new persistent tree T 0 that is the result of insert-\ning k into T .\nc. If the height of the persistent binary search tree T is h, what are the time and",
    "parent_4e37f8a5-3070-4ecd-8756-fd1048584efb": "b. Write a procedure PERSISTENT-TREE-INSERT that, given a persistent tree T\nand a key k to insert, returns a new persistent tree T 0 that is the result of insert-\ning k into T .\nc. If the height of the persistent binary search tree T is h, what are the time and\nspace requirements of your implementation of PERSISTENT-TREE-INSERT?\n(The space requirement is proportional to the number of new nodes allocated.)\nd. Suppose that we had included the parent attribute in each node. In this case,\nPERSISTENT-TREE-INSERT would need to perform additional copying. Prove\nthat PERSISTENT-TREE-INSERT would then require \u0004.n/ time and space,\nwhere n is the number of nodes in the tree.\ne. Show how to use red-black trees to guarantee that the worst-case running time\nand space are O.lg n/ per insertion or deletion.\n13-2\nJoin operation on red-black trees\nThe join operation takes two dynamic sets S1 and S2 and an element x such that\nfor any x1 2 S1 and x2 2 S2, we have x1:key \u0002 x:key \u0002 x2:key. It returns a set\nS D S1 [ fxg [ S2. In this problem, we investigate how to implement the join\noperation on red-black trees.\na. Given a red-black tree T , let us store its black-height as the new attribute T:bh.\nArgue that RB-INSERT and RB-DELETE can maintain the bh attribute with-\nout requiring extra storage in the nodes of the tree and without increasing the\nasymptotic running times. Show that while descending through T , we can de-\ntermine the black-height of each node we visit in O.1/ time per node visited.\nWe wish to implement the operation RB-JOIN.T1; x; T2/, which destroys T1 and T2\nand returns a red-black tree T D T1 [fxg[T2. Let n be the total number of nodes\nin T1 and T2.\nb. Assume that T1:bh \u0006 T2:bh. Describe an O.lg n/-time algorithm that ﬁnds a\nblack node y in T1 with the largest key from among those nodes whose black-\nheight is T2:bh.\nc. Let Ty be the subtree rooted at y. Describe how Ty [ fxg [ T2 can replace Ty\nin O.1/ time without destroying the binary-search-tree property.",
    "parent_407e4a08-421e-4bb7-8463-a5ef4092aee8": "black node y in T1 with the largest key from among those nodes whose black-\nheight is T2:bh.\nc. Let Ty be the subtree rooted at y. Describe how Ty [ fxg [ T2 can replace Ty\nin O.1/ time without destroying the binary-search-tree property.\nd. What color should we make x so that red-black properties 1, 3, and 5 are main-\ntained? Describe how to enforce properties 2 and 4 in O.lg n/ time.\nProblems for Chapter 13\n333\ne. Argue that no generality is lost by making the assumption in part (b). Describe\nthe symmetric situation that arises when T1:bh \u0002 T2:bh.\nf. Argue that the running time of RB-JOIN is O.lg n/.\n13-3\nAVL trees\nAn AVL tree is a binary search tree that is height balanced: for each node x, the\nheights of the left and right subtrees of x differ by at most 1. To implement an AVL\ntree, we maintain an extra attribute in each node: x:h is the height of node x. As\nfor any other binary search tree T , we assume that T:root points to the root node.\na. Prove that an AVL tree with n nodes has height O.lg n/. (Hint: Prove that\nan AVL tree of height h has at least Fh nodes, where Fh is the hth Fibonacci\nnumber.)\nb. To insert into an AVL tree, we ﬁrst place a node into the appropriate place in bi-\nnary search tree order. Afterward, the tree might no longer be height balanced.\nSpeciﬁcally, the heights of the left and right children of some node might differ\nby 2. Describe a procedure BALANCE.x/, which takes a subtree rooted at x\nwhose left and right children are height balanced and have heights that differ\nby at most 2, i.e., jx:right:h \u0005 x:left:hj \u0002 2, and alters the subtree rooted at x\nto be height balanced. (Hint: Use rotations.)\nc. Using part (b), describe a recursive procedure AVL-INSERT.x; ´/ that takes\na node x within an AVL tree and a newly created node ´ (whose key has al-\nready been ﬁlled in), and adds ´ to the subtree rooted at x, maintaining the\nproperty that x is the root of an AVL tree. As in TREE-INSERT from Sec-",
    "parent_2d0aef0f-3dd4-42c7-8424-e29f9db67972": "a node x within an AVL tree and a newly created node ´ (whose key has al-\nready been ﬁlled in), and adds ´ to the subtree rooted at x, maintaining the\nproperty that x is the root of an AVL tree. As in TREE-INSERT from Sec-\ntion 12.3, assume that ´:key has already been ﬁlled in and that ´:left D NIL\nand ´:right D NIL; also assume that ´:h D 0. Thus, to insert the node ´ into\nthe AVL tree T , we call AVL-INSERT.T:root; ´/.\nd. Show that AVL-INSERT, run on an n-node AVL tree, takes O.lg n/ time and\nperforms O.1/ rotations.\n13-4\nTreaps\nIf we insert a set of n items into a binary search tree, the resulting tree may be\nhorribly unbalanced, leading to long search times. As we saw in Section 12.4,\nhowever, randomly built binary search trees tend to be balanced. Therefore, one\nstrategy that, on average, builds a balanced tree for a ﬁxed set of items would be to\nrandomly permute the items and then insert them in that order into the tree.\nWhat if we do not have all the items at once? If we receive the items one at a\ntime, can we still randomly build a binary search tree out of them?\n334\nChapter 13\nRed-Black Trees\nG: 4\nB: 7\nH: 5\nA: 10\nE: 23\nK: 65\nI: 73\nFigure 13.9\nA treap. Each node x is labeled with x:key: x:priority. For example, the root has\nkey G and priority 4.\nWe will examine a data structure that answers this question in the afﬁrmative. A\ntreap is a binary search tree with a modiﬁed way of ordering the nodes. Figure 13.9\nshows an example. As usual, each node x in the tree has a key value x:key. In\naddition, we assign x:priority, which is a random number chosen independently\nfor each node. We assume that all priorities are distinct and also that all keys are\ndistinct. The nodes of the treap are ordered so that the keys obey the binary-search-\ntree property and the priorities obey the min-heap order property:\n\u0002\nIf \u0003 is a left child of u, then \u0003:key < u:key.\n\u0002\nIf \u0003 is a right child of u, then \u0003:key > u:key.\n\u0002\nIf \u0003 is a child of u, then \u0003:priority > u:priority.",
    "parent_8b7049d8-06f3-4a41-a433-f61fd31c75b7": "tree property and the priorities obey the min-heap order property:\n\u0002\nIf \u0003 is a left child of u, then \u0003:key < u:key.\n\u0002\nIf \u0003 is a right child of u, then \u0003:key > u:key.\n\u0002\nIf \u0003 is a child of u, then \u0003:priority > u:priority.\n(This combination of properties is why the tree is called a “treap”: it has features\nof both a binary search tree and a heap.)\nIt helps to think of treaps in the following way. Suppose that we insert nodes\nx1; x2; : : : ; xn, with associated keys, into a treap. Then the resulting treap is the\ntree that would have been formed if the nodes had been inserted into a normal\nbinary search tree in the order given by their (randomly chosen) priorities, i.e.,\nxi:priority < xj:priority means that we had inserted xi before xj.\na. Show that given a set of nodes x1; x2; : : : ; xn, with associated keys and priori-\nties, all distinct, the treap associated with these nodes is unique.\nb. Show that the expected height of a treap is ‚.lg n/, and hence the expected time\nto search for a value in the treap is ‚.lg n/.\nLet us see how to insert a new node into an existing treap. The ﬁrst thing we do\nis assign to the new node a random priority. Then we call the insertion algorithm,\nwhich we call TREAP-INSERT, whose operation is illustrated in Figure 13.10.\nProblems for Chapter 13\n335\nG: 4\nB: 7\nH: 5\nA: 10\nE: 23\nK: 65\nI: 73\nG: 4\nB: 7\nH: 5\nA: 10\nE: 23\nK: 65\nI: 73\nC: 25\nC: 25\n(a)\n(b)\nG: 4\nB: 7\nH: 5\nA: 10\nE: 23\nK: 65\nI: 73\nC: 25\n(c)\nD: 9\nD: 9\nG: 4\nB: 7\nH: 5\nA: 10\nE: 23\nK: 65\nI: 73\n(d)\nD: 9\nC: 25\nG: 4\nB: 7\nH: 5\nA: 10\nK: 65\nI: 73\n(e)\nD: 9\nC: 25\nE: 23\nB: 7\nA: 10\n(f)\nD: 9\nC: 25\nE: 23\nF: 2\nI: 73\nK: 65\nH: 5\nG: 4\nF: 2\n…\nFigure 13.10\nThe operation of TREAP-INSERT. (a) The original treap, prior to insertion. (b) The\ntreap after inserting a node with key C and priority 25. (c)–(d) Intermediate stages when inserting a\nnode with key D and priority 9. (e) The treap after the insertion of parts (c) and (d) is done. (f) The\ntreap after inserting a node with key F and priority 2.\n336",
    "parent_5832099d-45f4-4122-bcf1-9df75e055e82": "treap after inserting a node with key C and priority 25. (c)–(d) Intermediate stages when inserting a\nnode with key D and priority 9. (e) The treap after the insertion of parts (c) and (d) is done. (f) The\ntreap after inserting a node with key F and priority 2.\n336\nChapter 13\nRed-Black Trees\n15\n9\n18\n3\n12\n25\n21\n6\n(a)\n15\n9\n18\n3\n12\n25\n21\n6\n(b)\nFigure 13.11\nSpines of a binary search tree. The left spine is shaded in (a), and the right spine is\nshaded in (b).\nc. Explain how TREAP-INSERT works. Explain the idea in English and give pseu-\ndocode. (Hint: Execute the usual binary-search-tree insertion procedure and\nthen perform rotations to restore the min-heap order property.)\nd. Show that the expected running time of TREAP-INSERT is ‚.lg n/.\nTREAP-INSERT performs a search and then a sequence of rotations. Although\nthese two operations have the same expected running time, they have different\ncosts in practice. A search reads information from the treap without modifying it.\nIn contrast, a rotation changes parent and child pointers within the treap. On most\ncomputers, read operations are much faster than write operations. Thus we would\nlike TREAP-INSERT to perform few rotations. We will show that the expected\nnumber of rotations performed is bounded by a constant.\nIn order to do so, we will need some deﬁnitions, which Figure 13.11 depicts.\nThe left spine of a binary search tree T is the simple path from the root to the node\nwith the smallest key. In other words, the left spine is the simple path from the\nroot that consists of only left edges. Symmetrically, the right spine of T is the\nsimple path from the root consisting of only right edges. The length of a spine is\nthe number of nodes it contains.\ne. Consider the treap T immediately after TREAP-INSERT has inserted node x.\nLet C be the length of the right spine of the left subtree of x. Let D be the\nlength of the left spine of the right subtree of x. Prove that the total number of",
    "parent_27be9c9d-7526-4c0d-b8ee-a665b47eb665": "the number of nodes it contains.\ne. Consider the treap T immediately after TREAP-INSERT has inserted node x.\nLet C be the length of the right spine of the left subtree of x. Let D be the\nlength of the left spine of the right subtree of x. Prove that the total number of\nrotations that were performed during the insertion of x is equal to C C D.\nWe will now calculate the expected values of C and D. Without loss of generality,\nwe assume that the keys are 1; 2; : : : ; n, since we are comparing them only to one\nanother.\nNotes for Chapter 13\n337\nFor nodes x and y in treap T , where y ¤ x, let k D x:key and i D y:key. We\ndeﬁne indicator random variables\nXik D I fy is in the right spine of the left subtree of xg :\nf. Show that Xik D 1 if and only if y:priority > x:priority, y:key < x:key, and,\nfor every ´ such that y:key < ´:key < x:key, we have y:priority < ´:priority.\ng. Show that\nPr fXik D 1g\nD\n.k \u0005 i \u0005 1/Š\n.k \u0005 i C 1/Š\nD\n1\n.k \u0005 i C 1/.k \u0005 i/ :\nh. Show that\nE ŒC\u0002\nD\nk\u00031\nX\njD1\n1\nj.j C 1/\nD\n1 \u0005 1\nk :\ni.\nUse a symmetry argument to show that\nE ŒD\u0002 D 1 \u0005\n1\nn \u0005 k C 1 :\nj.\nConclude that the expected number of rotations performed when inserting a\nnode into a treap is less than 2.\nChapter notes\nThe idea of balancing a search tree is due to Adel’son-Vel’ski˘ı and Landis [2], who\nintroduced a class of balanced search trees called “AVL trees” in 1962, described in\nProblem 13-3. Another class of search trees, called “2-3 trees,” was introduced by\nJ. E. Hopcroft (unpublished) in 1970. A 2-3 tree maintains balance by manipulating\nthe degrees of nodes in the tree. Chapter 18 covers a generalization of 2-3 trees\nintroduced by Bayer and McCreight [35], called “B-trees.”\nRed-black trees were invented by Bayer [34] under the name “symmetric binary\nB-trees.” Guibas and Sedgewick [155] studied their properties at length and in-\ntroduced the red/black color convention. Andersson [15] gives a simpler-to-code\n338\nChapter 13\nRed-Black Trees",
    "parent_652e97a5-026b-4df9-9ea1-ec4c8c569ff3": "Red-black trees were invented by Bayer [34] under the name “symmetric binary\nB-trees.” Guibas and Sedgewick [155] studied their properties at length and in-\ntroduced the red/black color convention. Andersson [15] gives a simpler-to-code\n338\nChapter 13\nRed-Black Trees\nvariant of red-black trees. Weiss [351] calls this variant AA-trees. An AA-tree is\nsimilar to a red-black tree except that left children may never be red.\nTreaps, the subject of Problem 13-4, were proposed by Seidel and Aragon [309].\nThey are the default implementation of a dictionary in LEDA [253], which is a\nwell-implemented collection of data structures and algorithms.\nThere are many other variations on balanced binary trees, including weight-\nbalanced trees [264], k-neighbor trees [245], and scapegoat trees [127]. Perhaps\nthe most intriguing are the “splay trees” introduced by Sleator and Tarjan [320],\nwhich are “self-adjusting.” (See Tarjan [330] for a good description of splay trees.)\nSplay trees maintain balance without any explicit balance condition such as color.\nInstead, “splay operations” (which involve rotations) are performed within the tree\nevery time an access is made. The amortized cost (see Chapter 17) of each opera-\ntion on an n-node tree is O.lg n/.\nSkip lists [286] provide an alternative to balanced binary trees. A skip list is a\nlinked list that is augmented with a number of additional pointers. Each dictionary\noperation runs in expected time O.lg n/ on a skip list of n items.\n14\nAugmenting Data Structures\nSome engineering situations require no more than a “textbook” data struc-\nture—such as a doubly linked list, a hash table, or a binary search tree—but many\nothers require a dash of creativity. Only in rare situations will you need to cre-\nate an entirely new type of data structure, though. More often, it will sufﬁce to\naugment a textbook data structure by storing additional information in it. You can",
    "parent_d98ae3a5-9291-43d0-a0e9-c98faa5c40a2": "others require a dash of creativity. Only in rare situations will you need to cre-\nate an entirely new type of data structure, though. More often, it will sufﬁce to\naugment a textbook data structure by storing additional information in it. You can\nthen program new operations for the data structure to support the desired applica-\ntion. Augmenting a data structure is not always straightforward, however, since the\nadded information must be updated and maintained by the ordinary operations on\nthe data structure.\nThis chapter discusses two data structures that we construct by augmenting red-\nblack trees. Section 14.1 describes a data structure that supports general order-\nstatistic operations on a dynamic set. We can then quickly ﬁnd the ith smallest\nnumber in a set or the rank of a given element in the total ordering of the set.\nSection 14.2 abstracts the process of augmenting a data structure and provides a\ntheorem that can simplify the process of augmenting red-black trees. Section 14.3\nuses this theorem to help design a data structure for maintaining a dynamic set of\nintervals, such as time intervals. Given a query interval, we can then quickly ﬁnd\nan interval in the set that overlaps it.\n14.1\nDynamic order statistics\nChapter 9 introduced the notion of an order statistic. Speciﬁcally, the ith order\nstatistic of a set of n elements, where i 2 f1; 2; : : : ; ng, is simply the element in the\nset with the ith smallest key. We saw how to determine any order statistic in O.n/\ntime from an unordered set. In this section, we shall see how to modify red-black\ntrees so that we can determine any order statistic for a dynamic set in O.lg n/ time.\nWe shall also see how to compute the rank of an element—its position in the linear\norder of the set—in O.lg n/ time.\n340\nChapter 14\nAugmenting Data Structures\n1\n3\n7\n12\n10\n14\n16\n14\n2\n1\n1\n2\n4\n7\n20\n19\n21\n21\n17\n28\n35\n39\n38\n47\n30\n41\n26\n1\n2\n1\n4\n12\n1\n1\n1\n3\n5\n1\n7\n20\nkey\nsize\nFigure 14.1",
    "parent_5132c13f-20b7-47c6-861d-72e165c2e94a": "We shall also see how to compute the rank of an element—its position in the linear\norder of the set—in O.lg n/ time.\n340\nChapter 14\nAugmenting Data Structures\n1\n3\n7\n12\n10\n14\n16\n14\n2\n1\n1\n2\n4\n7\n20\n19\n21\n21\n17\n28\n35\n39\n38\n47\n30\n41\n26\n1\n2\n1\n4\n12\n1\n1\n1\n3\n5\n1\n7\n20\nkey\nsize\nFigure 14.1\nAn order-statistic tree, which is an augmented red-black tree. Shaded nodes are red,\nand darkened nodes are black. In addition to its usual attributes, each node x has an attribute x:size,\nwhich is the number of nodes, other than the sentinel, in the subtree rooted at x.\nFigure 14.1 shows a data structure that can support fast order-statistic operations.\nAn order-statistic tree T is simply a red-black tree with additional information\nstored in each node. Besides the usual red-black tree attributes x:key, x:color, x:p,\nx:left, and x:right in a node x, we have another attribute, x:size. This attribute\ncontains the number of (internal) nodes in the subtree rooted at x (including x\nitself), that is, the size of the subtree. If we deﬁne the sentinel’s size to be 0—that\nis, we set T:nil:size to be 0—then we have the identity\nx:size D x:left:size C x:right:size C 1 :\nWe do not require keys to be distinct in an order-statistic tree. (For example, the\ntree in Figure 14.1 has two keys with value 14 and two keys with value 21.) In the\npresence of equal keys, the above notion of rank is not well deﬁned. We remove\nthis ambiguity for an order-statistic tree by deﬁning the rank of an element as the\nposition at which it would be printed in an inorder walk of the tree. In Figure 14.1,\nfor example, the key 14 stored in a black node has rank 5, and the key 14 stored in\na red node has rank 6.\nRetrieving an element with a given rank\nBefore we show how to maintain this size information during insertion and dele-\ntion, let us examine the implementation of two order-statistic queries that use this\nadditional information. We begin with an operation that retrieves an element with",
    "parent_08687d12-d496-4295-9858-f20e591f6fba": "Retrieving an element with a given rank\nBefore we show how to maintain this size information during insertion and dele-\ntion, let us examine the implementation of two order-statistic queries that use this\nadditional information. We begin with an operation that retrieves an element with\na given rank. The procedure OS-SELECT.x; i/ returns a pointer to the node con-\ntaining the ith smallest key in the subtree rooted at x. To ﬁnd the node with the ith\nsmallest key in an order-statistic tree T , we call OS-SELECT.T:root; i/.\n14.1\nDynamic order statistics\n341\nOS-SELECT.x; i/\n1\nr D x:left:size C 1\n2\nif i == r\n3\nreturn x\n4\nelseif i < r\n5\nreturn OS-SELECT.x:left; i/\n6\nelse return OS-SELECT.x:right; i \u0005 r/\nIn line 1 of OS-SELECT, we compute r, the rank of node x within the subtree\nrooted at x. The value of x:left:size is the number of nodes that come before x\nin an inorder tree walk of the subtree rooted at x. Thus, x:left:size C 1 is the\nrank of x within the subtree rooted at x. If i D r, then node x is the ith smallest\nelement, and so we return x in line 3. If i < r, then the ith smallest element\nresides in x’s left subtree, and so we recurse on x:left in line 5. If i > r, then\nthe ith smallest element resides in x’s right subtree. Since the subtree rooted at x\ncontains r elements that come before x’s right subtree in an inorder tree walk, the\nith smallest element in the subtree rooted at x is the .i \u0005 r/th smallest element in\nthe subtree rooted at x:right. Line 6 determines this element recursively.\nTo see how OS-SELECT operates, consider a search for the 17th smallest ele-\nment in the order-statistic tree of Figure 14.1. We begin with x as the root, whose\nkey is 26, and with i D 17. Since the size of 26’s left subtree is 12, its rank is 13.\nThus, we know that the node with rank 17 is the 17 \u0005 13 D 4th smallest element\nin 26’s right subtree. After the recursive call, x is the node with key 41, and i D 4.",
    "parent_effcf23b-d793-4e68-a334-d69a8c303b06": "key is 26, and with i D 17. Since the size of 26’s left subtree is 12, its rank is 13.\nThus, we know that the node with rank 17 is the 17 \u0005 13 D 4th smallest element\nin 26’s right subtree. After the recursive call, x is the node with key 41, and i D 4.\nSince the size of 41’s left subtree is 5, its rank within its subtree is 6. Thus, we\nknow that the node with rank 4 is the 4th smallest element in 41’s left subtree. Af-\nter the recursive call, x is the node with key 30, and its rank within its subtree is 2.\nThus, we recurse once again to ﬁnd the 4\u00052 D 2nd smallest element in the subtree\nrooted at the node with key 38. We now ﬁnd that its left subtree has size 1, which\nmeans it is the second smallest element. Thus, the procedure returns a pointer to\nthe node with key 38.\nBecause each recursive call goes down one level in the order-statistic tree, the\ntotal time for OS-SELECT is at worst proportional to the height of the tree. Since\nthe tree is a red-black tree, its height is O.lg n/, where n is the number of nodes.\nThus, the running time of OS-SELECT is O.lg n/ for a dynamic set of n elements.\nDetermining the rank of an element\nGiven a pointer to a node x in an order-statistic tree T , the procedure OS-RANK\nreturns the position of x in the linear order determined by an inorder tree walk\nof T .\n342\nChapter 14\nAugmenting Data Structures\nOS-RANK.T; x/\n1\nr D x:left:size C 1\n2\ny D x\n3\nwhile y ¤ T:root\n4\nif y == y:p:right\n5\nr D r C y:p:left:size C 1\n6\ny D y:p\n7\nreturn r\nThe procedure works as follows. We can think of node x’s rank as the number of\nnodes preceding x in an inorder tree walk, plus 1 for x itself. OS-RANK maintains\nthe following loop invariant:\nAt the start of each iteration of the while loop of lines 3–6, r is the rank\nof x:key in the subtree rooted at node y.\nWe use this loop invariant to show that OS-RANK works correctly as follows:\nInitialization: Prior to the ﬁrst iteration, line 1 sets r to be the rank of x:key within",
    "parent_e2581765-2933-4cad-b62c-46e2558f1acc": "At the start of each iteration of the while loop of lines 3–6, r is the rank\nof x:key in the subtree rooted at node y.\nWe use this loop invariant to show that OS-RANK works correctly as follows:\nInitialization: Prior to the ﬁrst iteration, line 1 sets r to be the rank of x:key within\nthe subtree rooted at x. Setting y D x in line 2 makes the invariant true the\nﬁrst time the test in line 3 executes.\nMaintenance: At the end of each iteration of the while loop, we set y D y:p.\nThus we must show that if r is the rank of x:key in the subtree rooted at y at the\nstart of the loop body, then r is the rank of x:key in the subtree rooted at y:p\nat the end of the loop body. In each iteration of the while loop, we consider\nthe subtree rooted at y:p. We have already counted the number of nodes in the\nsubtree rooted at node y that precede x in an inorder walk, and so we must add\nthe nodes in the subtree rooted at y’s sibling that precede x in an inorder walk,\nplus 1 for y:p if it, too, precedes x. If y is a left child, then neither y:p nor any\nnode in y:p’s right subtree precedes x, and so we leave r alone. Otherwise, y is\na right child and all the nodes in y:p’s left subtree precede x, as does y:p itself.\nThus, in line 5, we add y:p:left:size C 1 to the current value of r.\nTermination: The loop terminates when y D T:root, so that the subtree rooted\nat y is the entire tree. Thus, the value of r is the rank of x:key in the entire tree.\nAs an example, when we run OS-RANK on the order-statistic tree of Figure 14.1\nto ﬁnd the rank of the node with key 38, we get the following sequence of values\nof y:key and r at the top of the while loop:\niteration\ny:key\nr\n1\n38\n2\n2\n30\n4\n3\n41\n4\n4\n26\n17\n14.1\nDynamic order statistics\n343\nThe procedure returns the rank 17.\nSince each iteration of the while loop takes O.1/ time, and y goes up one level in\nthe tree with each iteration, the running time of OS-RANK is at worst proportional",
    "parent_2a4bff15-a19f-40b1-9043-4798f6f6edd5": "iteration\ny:key\nr\n1\n38\n2\n2\n30\n4\n3\n41\n4\n4\n26\n17\n14.1\nDynamic order statistics\n343\nThe procedure returns the rank 17.\nSince each iteration of the while loop takes O.1/ time, and y goes up one level in\nthe tree with each iteration, the running time of OS-RANK is at worst proportional\nto the height of the tree: O.lg n/ on an n-node order-statistic tree.\nMaintaining subtree sizes\nGiven the size attribute in each node, OS-SELECT and OS-RANK can quickly\ncompute order-statistic information. But unless we can efﬁciently maintain these\nattributes within the basic modifying operations on red-black trees, our work will\nhave been for naught. We shall now show how to maintain subtree sizes for both\ninsertion and deletion without affecting the asymptotic running time of either op-\neration.\nWe noted in Section 13.3 that insertion into a red-black tree consists of two\nphases. The ﬁrst phase goes down the tree from the root, inserting the new node\nas a child of an existing node. The second phase goes up the tree, changing colors\nand performing rotations to maintain the red-black properties.\nTo maintain the subtree sizes in the ﬁrst phase, we simply increment x:size for\neach node x on the simple path traversed from the root down toward the leaves. The\nnew node added gets a size of 1. Since there are O.lg n/ nodes on the traversed\npath, the additional cost of maintaining the size attributes is O.lg n/.\nIn the second phase, the only structural changes to the underlying red-black tree\nare caused by rotations, of which there are at most two. Moreover, a rotation is\na local operation: only two nodes have their size attributes invalidated. The link\naround which the rotation is performed is incident on these two nodes. Referring\nto the code for LEFT-ROTATE.T; x/ in Section 13.2, we add the following lines:\n13\ny:size D x:size\n14\nx:size D x:left:size C x:right:size C 1\nFigure 14.2 illustrates how the attributes are updated.\nThe change to RIGHT-\nROTATE is symmetric.",
    "parent_0712fae1-5a0f-40d6-8695-95c1851835f5": "to the code for LEFT-ROTATE.T; x/ in Section 13.2, we add the following lines:\n13\ny:size D x:size\n14\nx:size D x:left:size C x:right:size C 1\nFigure 14.2 illustrates how the attributes are updated.\nThe change to RIGHT-\nROTATE is symmetric.\nSince at most two rotations are performed during insertion into a red-black tree,\nwe spend only O.1/ additional time updating size attributes in the second phase.\nThus, the total time for insertion into an n-node order-statistic tree is O.lg n/,\nwhich is asymptotically the same as for an ordinary red-black tree.\nDeletion from a red-black tree also consists of two phases: the ﬁrst operates\non the underlying search tree, and the second causes at most three rotations and\notherwise performs no structural changes. (See Section 13.4.) The ﬁrst phase\neither removes one node y from the tree or moves upward it within the tree. To\nupdate the subtree sizes, we simply traverse a simple path from node y (starting\nfrom its original position within the tree) up to the root, decrementing the size\n344\nChapter 14\nAugmenting Data Structures\nLEFT-ROTATE(T, x)\nRIGHT-ROTATE(T, y)\n93\n19\ny\n42\n11\nx\n6\n4\n7\n93\n42\n19\n12\n6\n4\n7\nx\ny\nFigure 14.2\nUpdating subtree sizes during rotations. The link around which we rotate is incident\non the two nodes whose size attributes need to be updated. The updates are local, requiring only the\nsize information stored in x, y, and the roots of the subtrees shown as triangles.\nattribute of each node on the path. Since this path has length O.lg n/ in an n-\nnode red-black tree, the additional time spent maintaining size attributes in the ﬁrst\nphase is O.lg n/. We handle the O.1/ rotations in the second phase of deletion\nin the same manner as for insertion. Thus, both insertion and deletion, including\nmaintaining the size attributes, take O.lg n/ time for an n-node order-statistic tree.\nExercises\n14.1-1\nShow how OS-SELECT.T:root; 10/ operates on the red-black tree T of Fig-\nure 14.1.\n14.1-2",
    "parent_ab7aa9b1-c13e-40ca-91d9-26447a098a04": "in the same manner as for insertion. Thus, both insertion and deletion, including\nmaintaining the size attributes, take O.lg n/ time for an n-node order-statistic tree.\nExercises\n14.1-1\nShow how OS-SELECT.T:root; 10/ operates on the red-black tree T of Fig-\nure 14.1.\n14.1-2\nShow how OS-RANK.T; x/ operates on the red-black tree T of Figure 14.1 and\nthe node x with x:key D 35.\n14.1-3\nWrite a nonrecursive version of OS-SELECT.\n14.1-4\nWrite a recursive procedure OS-KEY-RANK.T; k/ that takes as input an order-\nstatistic tree T and a key k and returns the rank of k in the dynamic set represented\nby T . Assume that the keys of T are distinct.\n14.1-5\nGiven an element x in an n-node order-statistic tree and a natural number i, how\ncan we determine the ith successor of x in the linear order of the tree in O.lg n/\ntime?\n14.2\nHow to augment a data structure\n345\n14.1-6\nObserve that whenever we reference the size attribute of a node in either OS-\nSELECT or OS-RANK, we use it only to compute a rank. Accordingly, suppose\nwe store in each node its rank in the subtree of which it is the root. Show how to\nmaintain this information during insertion and deletion. (Remember that these two\noperations can cause rotations.)\n14.1-7\nShow how to use an order-statistic tree to count the number of inversions (see\nProblem 2-4) in an array of size n in time O.n lg n/.\n14.1-8\n?\nConsider n chords on a circle, each deﬁned by its endpoints. Describe an O.n lg n/-\ntime algorithm to determine the number of pairs of chords that intersect inside the\ncircle. (For example, if the n chords are all diameters that meet at the center, then\nthe correct answer is\n\u000bn\n2\n\f\n.) Assume that no two chords share an endpoint.\n14.2\nHow to augment a data structure\nThe process of augmenting a basic data structure to support additional functionality\noccurs quite frequently in algorithm design. We shall use it again in the next section\nto design a data structure that supports operations on intervals. In this section, we",
    "parent_bf1979d4-47d7-4934-a8e6-1a950e60e22c": "14.2\nHow to augment a data structure\nThe process of augmenting a basic data structure to support additional functionality\noccurs quite frequently in algorithm design. We shall use it again in the next section\nto design a data structure that supports operations on intervals. In this section, we\nexamine the steps involved in such augmentation. We shall also prove a theorem\nthat allows us to augment red-black trees easily in many cases.\nWe can break the process of augmenting a data structure into four steps:\n1. Choose an underlying data structure.\n2. Determine additional information to maintain in the underlying data structure.\n3. Verify that we can maintain the additional information for the basic modifying\noperations on the underlying data structure.\n4. Develop new operations.\nAs with any prescriptive design method, you should not blindly follow the steps\nin the order given. Most design work contains an element of trial and error, and\nprogress on all steps usually proceeds in parallel. There is no point, for example, in\ndetermining additional information and developing new operations (steps 2 and 4)\nif we will not be able to maintain the additional information efﬁciently. Neverthe-\nless, this four-step method provides a good focus for your efforts in augmenting\na data structure, and it is also a good way to organize the documentation of an\naugmented data structure.\n346\nChapter 14\nAugmenting Data Structures\nWe followed these steps in Section 14.1 to design our order-statistic trees. For\nstep 1, we chose red-black trees as the underlying data structure. A clue to the\nsuitability of red-black trees comes from their efﬁcient support of other dynamic-\nset operations on a total order, such as MINIMUM, MAXIMUM, SUCCESSOR, and\nPREDECESSOR.\nFor step 2, we added the size attribute, in which each node x stores the size of the\nsubtree rooted at x. Generally, the additional information makes operations more\nefﬁcient. For example, we could have implemented OS-SELECT and OS-RANK",
    "parent_916e5d48-7569-4066-a4e2-57224bdcffc4": "PREDECESSOR.\nFor step 2, we added the size attribute, in which each node x stores the size of the\nsubtree rooted at x. Generally, the additional information makes operations more\nefﬁcient. For example, we could have implemented OS-SELECT and OS-RANK\nusing just the keys stored in the tree, but they would not have run in O.lg n/ time.\nSometimes, the additional information is pointer information rather than data, as\nin Exercise 14.2-1.\nFor step 3, we ensured that insertion and deletion could maintain the size at-\ntributes while still running in O.lg n/ time. Ideally, we should need to update only\na few elements of the data structure in order to maintain the additional information.\nFor example, if we simply stored in each node its rank in the tree, the OS-SELECT\nand OS-RANK procedures would run quickly, but inserting a new minimum ele-\nment would cause a change to this information in every node of the tree. When we\nstore subtree sizes instead, inserting a new element causes information to change\nin only O.lg n/ nodes.\nFor step 4, we developed the operations OS-SELECT and OS-RANK. After all,\nthe need for new operations is why we bother to augment a data structure in the ﬁrst\nplace. Occasionally, rather than developing new operations, we use the additional\ninformation to expedite existing ones, as in Exercise 14.2-1.\nAugmenting red-black trees\nWhen red-black trees underlie an augmented data structure, we can prove that in-\nsertion and deletion can always efﬁciently maintain certain kinds of additional in-\nformation, thereby making step 3 very easy. The proof of the following theorem is\nsimilar to the argument from Section 14.1 that we can maintain the size attribute\nfor order-statistic trees.\nTheorem 14.1 (Augmenting a red-black tree)\nLet f be an attribute that augments a red-black tree T of n nodes, and suppose that\nthe value of f for each node x depends on only the information in nodes x, x:left,",
    "parent_28746adc-2dd7-4345-937c-7d5be7bb05db": "for order-statistic trees.\nTheorem 14.1 (Augmenting a red-black tree)\nLet f be an attribute that augments a red-black tree T of n nodes, and suppose that\nthe value of f for each node x depends on only the information in nodes x, x:left,\nand x:right, possibly including x:left:f and x:right:f. Then, we can maintain the\nvalues of f in all nodes of T during insertion and deletion without asymptotically\naffecting the O.lg n/ performance of these operations.\nProof\nThe main idea of the proof is that a change to an f attribute in a node x\npropagates only to ancestors of x in the tree.\nThat is, changing x:f may re-\n14.2\nHow to augment a data structure\n347\nquire x:p:f to be updated, but nothing else; updating x:p:f may require x:p:p:f\nto be updated, but nothing else; and so on up the tree. Once we have updated\nT:root:f, no other node will depend on the new value, and so the process termi-\nnates. Since the height of a red-black tree is O.lg n/, changing an f attribute in a\nnode costs O.lg n/ time in updating all nodes that depend on the change.\nInsertion of a node x into T consists of two phases. (See Section 13.3.) The\nﬁrst phase inserts x as a child of an existing node x:p. We can compute the value\nof x:f in O.1/ time since, by supposition, it depends only on information in the\nother attributes of x itself and the information in x’s children, but x’s children are\nboth the sentinel T:nil. Once we have computed x:f, the change propagates up\nthe tree. Thus, the total time for the ﬁrst phase of insertion is O.lg n/. During the\nsecond phase, the only structural changes to the tree come from rotations. Since\nonly two nodes change in a rotation, the total time for updating the f attributes\nis O.lg n/ per rotation. Since the number of rotations during insertion is at most\ntwo, the total time for insertion is O.lg n/.\nLike insertion, deletion has two phases. (See Section 13.4.) In the ﬁrst phase,\nchanges to the tree occur when the deleted node is removed from the tree. If the",
    "parent_4eeea3ee-10c1-4cdd-aff9-9174f5a6380a": "is O.lg n/ per rotation. Since the number of rotations during insertion is at most\ntwo, the total time for insertion is O.lg n/.\nLike insertion, deletion has two phases. (See Section 13.4.) In the ﬁrst phase,\nchanges to the tree occur when the deleted node is removed from the tree. If the\ndeleted node had two children at the time, then its successor moves into the position\nof the deleted node. Propagating the updates to f caused by these changes costs\nat most O.lg n/, since the changes modify the tree locally. Fixing up the red-black\ntree during the second phase requires at most three rotations, and each rotation\nrequires at most O.lg n/ time to propagate the updates to f . Thus, like insertion,\nthe total time for deletion is O.lg n/.\nIn many cases, such as maintaining the size attributes in order-statistic trees, the\ncost of updating after a rotation is O.1/, rather than the O.lg n/ derived in the proof\nof Theorem 14.1. Exercise 14.2-3 gives an example.\nExercises\n14.2-1\nShow, by adding pointers to the nodes, how to support each of the dynamic-set\nqueries MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR in O.1/ worst-\ncase time on an augmented order-statistic tree. The asymptotic performance of\nother operations on order-statistic trees should not be affected.\n14.2-2\nCan we maintain the black-heights of nodes in a red-black tree as attributes in the\nnodes of the tree without affecting the asymptotic performance of any of the red-\nblack tree operations? Show how, or argue why not. How about maintaining the\ndepths of nodes?\n348\nChapter 14\nAugmenting Data Structures\n14.2-3\n?\nLet ˝ be an associative binary operator, and let a be an attribute maintained in each\nnode of a red-black tree. Suppose that we want to include in each node x an addi-\ntional attribute f such that x:f D x1:a ˝ x2:a ˝ \u0003 \u0003 \u0003 ˝ xm:a, where x1; x2; : : : ; xm\nis the inorder listing of nodes in the subtree rooted at x. Show how to update the f",
    "parent_c2427295-cd53-47b4-af39-89dd398f7fcf": "node of a red-black tree. Suppose that we want to include in each node x an addi-\ntional attribute f such that x:f D x1:a ˝ x2:a ˝ \u0003 \u0003 \u0003 ˝ xm:a, where x1; x2; : : : ; xm\nis the inorder listing of nodes in the subtree rooted at x. Show how to update the f\nattributes in O.1/ time after a rotation. Modify your argument slightly to apply it\nto the size attributes in order-statistic trees.\n14.2-4\n?\nWe wish to augment red-black trees with an operation RB-ENUMERATE.x; a; b/\nthat outputs all the keys k such that a \u0002 k \u0002 b in a red-black tree rooted at x.\nDescribe how to implement RB-ENUMERATE in ‚.mClg n/ time, where m is the\nnumber of keys that are output and n is the number of internal nodes in the tree.\n(Hint: You do not need to add new attributes to the red-black tree.)\n14.3\nInterval trees\nIn this section, we shall augment red-black trees to support operations on dynamic\nsets of intervals. A closed interval is an ordered pair of real numbers Œt1; t2\u0002, with\nt1 \u0002 t2. The interval Œt1; t2\u0002 represents the set ft 2 R W t1 \u0002 t \u0002 t2g. Open and\nhalf-open intervals omit both or one of the endpoints from the set, respectively. In\nthis section, we shall assume that intervals are closed; extending the results to open\nand half-open intervals is conceptually straightforward.\nIntervals are convenient for representing events that each occupy a continuous\nperiod of time. We might, for example, wish to query a database of time intervals\nto ﬁnd out what events occurred during a given interval. The data structure in this\nsection provides an efﬁcient means for maintaining such an interval database.\nWe can represent an interval Œt1; t2\u0002 as an object i, with attributes i:low D t1\n(the low endpoint) and i:high D t2 (the high endpoint). We say that intervals i\nand i 0 overlap if i \\ i 0 ¤ ;, that is, if i:low \u0002 i 0:high and i 0:low \u0002 i:high. As\nFigure 14.3 shows, any two intervals i and i 0 satisfy the interval trichotomy; that\nis, exactly one of the following three properties holds:",
    "parent_e01368d1-7229-4c9f-a016-7b1800d37110": "and i 0 overlap if i \\ i 0 ¤ ;, that is, if i:low \u0002 i 0:high and i 0:low \u0002 i:high. As\nFigure 14.3 shows, any two intervals i and i 0 satisfy the interval trichotomy; that\nis, exactly one of the following three properties holds:\na. i and i 0 overlap,\nb. i is to the left of i 0 (i.e., i:high < i 0:low),\nc. i is to the right of i 0 (i.e., i 0:high < i:low).\nAn interval tree is a red-black tree that maintains a dynamic set of elements, with\neach element x containing an interval x:int. Interval trees support the following\noperations:\n14.3\nInterval trees\n349\ni\ni\ni\ni\n(a)\ni\n(b)\ni\n(c)\ni′\ni′\ni′\ni′\ni′\ni′\nFigure 14.3\nThe interval trichotomy for two closed intervals i and i0. (a) If i and i0 overlap, there\nare four situations; in each, i:low \u0002 i0:high and i0:low \u0002 i:high. (b) The intervals do not overlap,\nand i:high < i0:low. (c) The intervals do not overlap, and i0:high < i:low.\nINTERVAL-INSERT.T; x/ adds the element x, whose int attribute is assumed to\ncontain an interval, to the interval tree T .\nINTERVAL-DELETE.T; x/ removes the element x from the interval tree T .\nINTERVAL-SEARCH.T; i/ returns a pointer to an element x in the interval tree T\nsuch that x:int overlaps interval i, or a pointer to the sentinel T:nil if no such\nelement is in the set.\nFigure 14.4 shows how an interval tree represents a set of intervals. We shall track\nthe four-step method from Section 14.2 as we review the design of an interval tree\nand the operations that run on it.\nStep 1: Underlying data structure\nWe choose a red-black tree in which each node x contains an interval x:int and the\nkey of x is the low endpoint, x:int:low, of the interval. Thus, an inorder tree walk\nof the data structure lists the intervals in sorted order by low endpoint.\nStep 2: Additional information\nIn addition to the intervals themselves, each node x contains a value x:max, which\nis the maximum value of any interval endpoint stored in the subtree rooted at x.\nStep 3: Maintaining the information",
    "parent_d1bf39b4-d0c5-480f-9b55-cbb41a3f9763": "Step 2: Additional information\nIn addition to the intervals themselves, each node x contains a value x:max, which\nis the maximum value of any interval endpoint stored in the subtree rooted at x.\nStep 3: Maintaining the information\nWe must verify that insertion and deletion take O.lg n/ time on an interval tree\nof n nodes. We can determine x:max given interval x:int and the max values of\nnode x’s children:\n350\nChapter 14\nAugmenting Data Structures\n0\n5\n10\n15\n20\n25\n30\n0\n5\n6\n8\n15\n16\n17\n19\n25\n26 26\n30\n20\n19\n21\n23\n9\n10\n8\n3\n(a)\n[0,3]\n3\n[6,10]\n10\n[5,8]\n10\n[8,9]\n23\n[15,23]\n23\n[16,21]\n30\n[17,19]\n20\n[26,26]\n26\n[19,20]\n20\n(b)\n[25,30]\n30\nint\nmax\nFigure 14.4\nAn interval tree. (a) A set of 10 intervals, shown sorted bottom to top by left endpoint.\n(b) The interval tree that represents them. Each node x contains an interval, shown above the dashed\nline, and the maximum value of any interval endpoint in the subtree rooted at x, shown below the\ndashed line. An inorder tree walk of the tree lists the nodes in sorted order by left endpoint.\nx:max D max.x:int:high; x:left:max; x:right:max/ :\nThus, by Theorem 14.1, insertion and deletion run in O.lg n/ time. In fact, we\ncan update the max attributes after a rotation in O.1/ time, as Exercises 14.2-3\nand 14.3-1 show.\nStep 4: Developing new operations\nThe only new operation we need is INTERVAL-SEARCH.T; i/, which ﬁnds a node\nin tree T whose interval overlaps interval i. If there is no interval that overlaps i in\nthe tree, the procedure returns a pointer to the sentinel T:nil.\n14.3\nInterval trees\n351\nINTERVAL-SEARCH.T; i/\n1\nx D T:root\n2\nwhile x ¤ T:nil and i does not overlap x:int\n3\nif x:left ¤ T:nil and x:left:max \u0006 i:low\n4\nx D x:left\n5\nelse x D x:right\n6\nreturn x\nThe search for an interval that overlaps i starts with x at the root of the tree and\nproceeds downward. It terminates when either it ﬁnds an overlapping interval or x\npoints to the sentinel T:nil. Since each iteration of the basic loop takes O.1/ time,",
    "parent_fbc6ec90-c5ba-4d21-b8e3-d4b9e30c54c3": "4\nx D x:left\n5\nelse x D x:right\n6\nreturn x\nThe search for an interval that overlaps i starts with x at the root of the tree and\nproceeds downward. It terminates when either it ﬁnds an overlapping interval or x\npoints to the sentinel T:nil. Since each iteration of the basic loop takes O.1/ time,\nand since the height of an n-node red-black tree is O.lg n/, the INTERVAL-SEARCH\nprocedure takes O.lg n/ time.\nBefore we see why INTERVAL-SEARCH is correct, let’s examine how it works\non the interval tree in Figure 14.4. Suppose we wish to ﬁnd an interval that overlaps\nthe interval i D Œ22; 25\u0002. We begin with x as the root, which contains Œ16; 21\u0002 and\ndoes not overlap i. Since x:left:max D 23 is greater than i:low D 22, the loop\ncontinues with x as the left child of the root—the node containing Œ8; 9\u0002, which also\ndoes not overlap i. This time, x:left:max D 10 is less than i:low D 22, and so the\nloop continues with the right child of x as the new x. Because the interval Œ15; 23\u0002\nstored in this node overlaps i, the procedure returns this node.\nAs an example of an unsuccessful search, suppose we wish to ﬁnd an interval\nthat overlaps i D Œ11; 14\u0002 in the interval tree of Figure 14.4. We once again be-\ngin with x as the root. Since the root’s interval Œ16; 21\u0002 does not overlap i, and\nsince x:left:max D 23 is greater than i:low D 11, we go left to the node con-\ntaining Œ8; 9\u0002. Interval Œ8; 9\u0002 does not overlap i, and x:left:max D 10 is less than\ni:low D 11, and so we go right. (Note that no interval in the left subtree over-\nlaps i.) Interval Œ15; 23\u0002 does not overlap i, and its left child is T:nil, so again we\ngo right, the loop terminates, and we return the sentinel T:nil.\nTo see why INTERVAL-SEARCH is correct, we must understand why it sufﬁces\nto examine a single path from the root. The basic idea is that at any node x,\nif x:int does not overlap i, the search always proceeds in a safe direction: the\nsearch will deﬁnitely ﬁnd an overlapping interval if the tree contains one. The",
    "parent_e007273d-3730-4233-97d0-aebab8406477": "to examine a single path from the root. The basic idea is that at any node x,\nif x:int does not overlap i, the search always proceeds in a safe direction: the\nsearch will deﬁnitely ﬁnd an overlapping interval if the tree contains one. The\nfollowing theorem states this property more precisely.\nTheorem 14.2\nAny execution of INTERVAL-SEARCH.T; i/ either returns a node whose interval\noverlaps i, or it returns T:nil and the tree T contains no node whose interval over-\nlaps i.\n352\nChapter 14\nAugmenting Data Structures\ni\n(a)\n(b)\ni′\ni′\ni\ni′\ni′′\ni′′\ni′′\nFigure 14.5\nIntervals in the proof of Theorem 14.2. The value of x:left:max is shown in each case\nas a dashed line. (a) The search goes right. No interval i0 in x’s left subtree can overlap i. (b) The\nsearch goes left. The left subtree of x contains an interval that overlaps i (situation not shown),\nor x’s left subtree contains an interval i0 such that i0:high D x:left:max. Since i does not overlap i0,\nneither does it overlap any interval i00 in x’s right subtree, since i0:low \u0002 i00:low.\nProof\nThe while loop of lines 2–5 terminates either when x D T:nil or i over-\nlaps x:int. In the latter case, it is certainly correct to return x. Therefore, we focus\non the former case, in which the while loop terminates because x D T:nil.\nWe use the following invariant for the while loop of lines 2–5:\nIf tree T contains an interval that overlaps i, then the subtree rooted at x\ncontains such an interval.\nWe use this loop invariant as follows:\nInitialization: Prior to the ﬁrst iteration, line 1 sets x to be the root of T , so that\nthe invariant holds.\nMaintenance: Each iteration of the while loop executes either line 4 or line 5. We\nshall show that both cases maintain the loop invariant.\nIf line 5 is executed, then because of the branch condition in line 3, we\nhave x:left D T:nil, or x:left:max < i:low. If x:left D T:nil, the subtree\nrooted at x:left clearly contains no interval that overlaps i, and so setting x",
    "parent_19be8910-04e6-497d-a094-173d629d91c7": "shall show that both cases maintain the loop invariant.\nIf line 5 is executed, then because of the branch condition in line 3, we\nhave x:left D T:nil, or x:left:max < i:low. If x:left D T:nil, the subtree\nrooted at x:left clearly contains no interval that overlaps i, and so setting x\nto x:right maintains the invariant. Suppose, therefore, that x:left ¤ T:nil and\nx:left:max < i:low. As Figure 14.5(a) shows, for each interval i 0 in x’s left\nsubtree, we have\ni 0:high\n\u0002\nx:left:max\n<\ni:low :\nBy the interval trichotomy, therefore, i 0 and i do not overlap. Thus, the left\nsubtree of x contains no intervals that overlap i, so that setting x to x:right\nmaintains the invariant.\n14.3\nInterval trees\n353\nIf, on the other hand, line 4 is executed, then we will show that the contrapos-\nitive of the loop invariant holds. That is, if the subtree rooted at x:left con-\ntains no interval overlapping i, then no interval anywhere in the tree overlaps i.\nSince line 4 is executed, then because of the branch condition in line 3, we\nhave x:left:max \u0006 i:low. Moreover, by deﬁnition of the max attribute, x’s left\nsubtree must contain some interval i 0 such that\ni 0:high\nD\nx:left:max\n\u0006\ni:low :\n(Figure 14.5(b) illustrates the situation.) Since i and i 0 do not overlap, and\nsince it is not true that i 0:high < i:low, it follows by the interval trichotomy\nthat i:high < i 0:low. Interval trees are keyed on the low endpoints of intervals,\nand thus the search-tree property implies that for any interval i 00 in x’s right\nsubtree,\ni:high\n<\ni 0:low\n\u0002\ni 00:low :\nBy the interval trichotomy, i and i 00 do not overlap. We conclude that whether\nor not any interval in x’s left subtree overlaps i, setting x to x:left maintains\nthe invariant.\nTermination: If the loop terminates when x D T:nil, then the subtree rooted at x\ncontains no interval overlapping i. The contrapositive of the loop invariant\nimplies that T contains no interval that overlaps i. Hence it is correct to return\nx D T:nil.",
    "parent_9b6caef6-e9a5-45ea-a6b0-dc816a9283c2": "the invariant.\nTermination: If the loop terminates when x D T:nil, then the subtree rooted at x\ncontains no interval overlapping i. The contrapositive of the loop invariant\nimplies that T contains no interval that overlaps i. Hence it is correct to return\nx D T:nil.\nThus, the INTERVAL-SEARCH procedure works correctly.\nExercises\n14.3-1\nWrite pseudocode for LEFT-ROTATE that operates on nodes in an interval tree and\nupdates the max attributes in O.1/ time.\n14.3-2\nRewrite the code for INTERVAL-SEARCH so that it works properly when all inter-\nvals are open.\n14.3-3\nDescribe an efﬁcient algorithm that, given an interval i, returns an interval over-\nlapping i that has the minimum low endpoint, or T:nil if no such interval exists.\n354\nChapter 14\nAugmenting Data Structures\n14.3-4\nGiven an interval tree T and an interval i, describe how to list all intervals in T\nthat overlap i in O.min.n; k lg n// time, where k is the number of intervals in the\noutput list. (Hint: One simple method makes several queries, modifying the tree\nbetween queries. A slightly more complicated method does not modify the tree.)\n14.3-5\nSuggest modiﬁcations to the interval-tree procedures to support the new opera-\ntion INTERVAL-SEARCH-EXACTLY.T; i/, where T is an interval tree and i is\nan interval. The operation should return a pointer to a node x in T such that\nx:int:low D i:low and x:int:high D i:high, or T:nil if T contains no such node.\nAll operations, including INTERVAL-SEARCH-EXACTLY, should run in O.lg n/\ntime on an n-node interval tree.\n14.3-6\nShow how to maintain a dynamic set Q of numbers that supports the operation\nMIN-GAP, which gives the magnitude of the difference of the two closest num-\nbers in Q. For example, if Q D f1; 5; 9; 15; 18; 22g, then MIN-GAP.Q/ returns\n18 \u0005 15 D 3, since 15 and 18 are the two closest numbers in Q. Make the op-\nerations INSERT, DELETE, SEARCH, and MIN-GAP as efﬁcient as possible, and\nanalyze their running times.\n14.3-7\n?",
    "parent_b8928655-45a6-4133-a8c7-04ccb6563d46": "bers in Q. For example, if Q D f1; 5; 9; 15; 18; 22g, then MIN-GAP.Q/ returns\n18 \u0005 15 D 3, since 15 and 18 are the two closest numbers in Q. Make the op-\nerations INSERT, DELETE, SEARCH, and MIN-GAP as efﬁcient as possible, and\nanalyze their running times.\n14.3-7\n?\nVLSI databases commonly represent an integrated circuit as a list of rectan-\ngles. Assume that each rectangle is rectilinearly oriented (sides parallel to the\nx- and y-axes), so that we represent a rectangle by its minimum and maximum x-\nand y-coordinates. Give an O.n lg n/-time algorithm to decide whether or not a set\nof n rectangles so represented contains two rectangles that overlap. Your algorithm\nneed not report all intersecting pairs, but it must report that an overlap exists if one\nrectangle entirely covers another, even if the boundary lines do not intersect. (Hint:\nMove a “sweep” line across the set of rectangles.)\nProblems\n14-1\nPoint of maximum overlap\nSuppose that we wish to keep track of a point of maximum overlap in a set of\nintervals—a point with the largest number of intervals in the set that overlap it.\na. Show that there will always be a point of maximum overlap that is an endpoint\nof one of the segments.\nNotes for Chapter 14\n355\nb. Design a data structure that efﬁciently supports the operations INTERVAL-\nINSERT, INTERVAL-DELETE, and FIND-POM, which returns a point of max-\nimum overlap. (Hint: Keep a red-black tree of all the endpoints. Associate\na value of C1 with each left endpoint, and associate a value of \u00051 with each\nright endpoint. Augment each node of the tree with some extra information to\nmaintain the point of maximum overlap.)\n14-2\nJosephus permutation\nWe deﬁne the Josephus problem as follows. Suppose that n people form a circle\nand that we are given a positive integer m \u0002 n. Beginning with a designated\nﬁrst person, we proceed around the circle, removing every mth person. After each\nperson is removed, counting continues around the circle that remains. This process",
    "parent_0e22f4c3-253c-4b54-ac79-192f0ebbaa2f": "and that we are given a positive integer m \u0002 n. Beginning with a designated\nﬁrst person, we proceed around the circle, removing every mth person. After each\nperson is removed, counting continues around the circle that remains. This process\ncontinues until we have removed all n people. The order in which the people are\nremoved from the circle deﬁnes the .n; m/-Josephus permutation of the integers\n1; 2; : : : ; n. For example, the .7; 3/-Josephus permutation is h3; 6; 2; 7; 5; 1; 4i.\na. Suppose that m is a constant. Describe an O.n/-time algorithm that, given an\ninteger n, outputs the .n; m/-Josephus permutation.\nb. Suppose that m is not a constant. Describe an O.n lg n/-time algorithm that,\ngiven integers n and m, outputs the .n; m/-Josephus permutation.\nChapter notes\nIn their book, Preparata and Shamos [282] describe several of the interval trees\nthat appear in the literature, citing work by H. Edelsbrunner (1980) and E. M.\nMcCreight (1981). The book details an interval tree that, given a static database\nof n intervals, allows us to enumerate all k intervals that overlap a given query\ninterval in O.k C lg n/ time.\nIV\nAdvanced Design and Analysis Techniques\nIntroduction\nThis part covers three important techniques used in designing and analyzing efﬁ-\ncient algorithms: dynamic programming (Chapter 15), greedy algorithms (Chap-\nter 16), and amortized analysis (Chapter 17). Earlier parts have presented other\nwidely applicable techniques, such as divide-and-conquer, randomization, and how\nto solve recurrences. The techniques in this part are somewhat more sophisticated,\nbut they help us to attack many computational problems. The themes introduced in\nthis part will recur later in this book.\nDynamic programming typically applies to optimization problems in which we\nmake a set of choices in order to arrive at an optimal solution.\nAs we make\neach choice, subproblems of the same form often arise. Dynamic programming",
    "parent_822a2955-b082-4c97-81cc-df2561774672": "this part will recur later in this book.\nDynamic programming typically applies to optimization problems in which we\nmake a set of choices in order to arrive at an optimal solution.\nAs we make\neach choice, subproblems of the same form often arise. Dynamic programming\nis effective when a given subproblem may arise from more than one partial set of\nchoices; the key technique is to store the solution to each such subproblem in case it\nshould reappear. Chapter 15 shows how this simple idea can sometimes transform\nexponential-time algorithms into polynomial-time algorithms.\nLike dynamic-programming algorithms, greedy algorithms typically apply to\noptimization problems in which we make a set of choices in order to arrive at an\noptimal solution. The idea of a greedy algorithm is to make each choice in a locally\noptimal manner. A simple example is coin-changing: to minimize the number of\nU.S. coins needed to make change for a given amount, we can repeatedly select\nthe largest-denomination coin that is not larger than the amount that remains. A\ngreedy approach provides an optimal solution for many such problems much more\nquickly than would a dynamic-programming approach. We cannot always easily\ntell whether a greedy approach will be effective, however. Chapter 16 introduces\n358\nPart IV\nAdvanced Design and Analysis Techniques\nmatroid theory, which provides a mathematical basis that can help us to show that\na greedy algorithm yields an optimal solution.\nWe use amortized analysis to analyze certain algorithms that perform a sequence\nof similar operations. Instead of bounding the cost of the sequence of operations\nby bounding the actual cost of each operation separately, an amortized analysis\nprovides a bound on the actual cost of the entire sequence. One advantage of this\napproach is that although some operations might be expensive, many others might\nbe cheap. In other words, many of the operations might run in well under the worst-",
    "parent_68631a32-932d-4d60-b959-9bd7d916032a": "provides a bound on the actual cost of the entire sequence. One advantage of this\napproach is that although some operations might be expensive, many others might\nbe cheap. In other words, many of the operations might run in well under the worst-\ncase time. Amortized analysis is not just an analysis tool, however; it is also a way\nof thinking about the design of algorithms, since the design of an algorithm and the\nanalysis of its running time are often closely intertwined. Chapter 17 introduces\nthree ways to perform an amortized analysis of an algorithm.\n15\nDynamic Programming\nDynamic programming, like the divide-and-conquer method, solves problems by\ncombining the solutions to subproblems. (“Programming” in this context refers\nto a tabular method, not to writing computer code.) As we saw in Chapters 2\nand 4, divide-and-conquer algorithms partition the problem into disjoint subprob-\nlems, solve the subproblems recursively, and then combine their solutions to solve\nthe original problem. In contrast, dynamic programming applies when the subprob-\nlems overlap—that is, when subproblems share subsubproblems. In this context,\na divide-and-conquer algorithm does more work than necessary, repeatedly solv-\ning the common subsubproblems. A dynamic-programming algorithm solves each\nsubsubproblem just once and then saves its answer in a table, thereby avoiding the\nwork of recomputing the answer every time it solves each subsubproblem.\nWe typically apply dynamic programming to optimization problems. Such prob-\nlems can have many possible solutions. Each solution has a value, and we wish to\nﬁnd a solution with the optimal (minimum or maximum) value. We call such a\nsolution an optimal solution to the problem, as opposed to the optimal solution,\nsince there may be several solutions that achieve the optimal value.\nWhen developing a dynamic-programming algorithm, we follow a sequence of\nfour steps:\n1. Characterize the structure of an optimal solution.",
    "parent_6996380d-ec6c-4dbd-8ecd-88ec1d0a9036": "solution an optimal solution to the problem, as opposed to the optimal solution,\nsince there may be several solutions that achieve the optimal value.\nWhen developing a dynamic-programming algorithm, we follow a sequence of\nfour steps:\n1. Characterize the structure of an optimal solution.\n2. Recursively deﬁne the value of an optimal solution.\n3. Compute the value of an optimal solution, typically in a bottom-up fashion.\n4. Construct an optimal solution from computed information.\nSteps 1–3 form the basis of a dynamic-programming solution to a problem. If we\nneed only the value of an optimal solution, and not the solution itself, then we\ncan omit step 4. When we do perform step 4, we sometimes maintain additional\ninformation during step 3 so that we can easily construct an optimal solution.\nThe sections that follow use the dynamic-programming method to solve some\noptimization problems. Section 15.1 examines the problem of cutting a rod into\n360\nChapter 15\nDynamic Programming\nrods of smaller length in way that maximizes their total value. Section 15.2 asks\nhow we can multiply a chain of matrices while performing the fewest total scalar\nmultiplications. Given these examples of dynamic programming, Section 15.3 dis-\ncusses two key characteristics that a problem must have for dynamic programming\nto be a viable solution technique. Section 15.4 then shows how to ﬁnd the longest\ncommon subsequence of two sequences via dynamic programming. Finally, Sec-\ntion 15.5 uses dynamic programming to construct binary search trees that are opti-\nmal, given a known distribution of keys to be looked up.\n15.1\nRod cutting\nOur ﬁrst example uses dynamic programming to solve a simple problem in decid-\ning where to cut steel rods. Serling Enterprises buys long steel rods and cuts them\ninto shorter rods, which it then sells. Each cut is free. The management of Serling\nEnterprises wants to know the best way to cut up the rods.",
    "parent_4db9b0ca-a5fc-4e1c-a9bb-0cc8bd88f6ed": "ing where to cut steel rods. Serling Enterprises buys long steel rods and cuts them\ninto shorter rods, which it then sells. Each cut is free. The management of Serling\nEnterprises wants to know the best way to cut up the rods.\nWe assume that we know, for i D 1; 2; : : :, the price pi in dollars that Serling\nEnterprises charges for a rod of length i inches. Rod lengths are always an integral\nnumber of inches. Figure 15.1 gives a sample price table.\nThe rod-cutting problem is the following. Given a rod of length n inches and a\ntable of prices pi for i D 1; 2; : : : ; n, determine the maximum revenue rn obtain-\nable by cutting up the rod and selling the pieces. Note that if the price pn for a rod\nof length n is large enough, an optimal solution may require no cutting at all.\nConsider the case when n D 4. Figure 15.2 shows all the ways to cut up a rod\nof 4 inches in length, including the way with no cuts at all. We see that cutting a\n4-inch rod into two 2-inch pieces produces revenue p2 C p2 D 5 C 5 D 10, which\nis optimal.\nWe can cut up a rod of length n in 2n\u00031 different ways, since we have an in-\ndependent option of cutting, or not cutting, at distance i inches from the left end,\nlength i\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nprice pi\n1\n5\n8\n9\n10\n17\n17\n20\n24\n30\nFigure 15.1\nA sample price table for rods. Each rod of length i inches earns the company pi\ndollars of revenue.\n15.1\nRod cutting\n361\n9\n(a)\n1\n(b)\n8\n(c)\n(d)\n(e)\n(f)\n(g)\n1\n(h)\n1\n1\n1\n5\n5\n1\n8\n5\n1\n1\n5\n1\n1\n5\n1\n1\nFigure 15.2\nThe 8 possible ways of cutting up a rod of length 4.\nAbove each piece is the\nvalue of that piece, according to the sample price chart of Figure 15.1. The optimal strategy is\npart (c)—cutting the rod into two pieces of length 2—which has total value 10.\nfor i D 1; 2; : : : ; n \u0005 1.1 We denote a decomposition into pieces using ordinary\nadditive notation, so that 7 D 2 C 2 C 3 indicates that a rod of length 7 is cut into\nthree pieces—two of length 2 and one of length 3. If an optimal solution cuts the",
    "parent_a2282e44-5abc-41ae-90d6-3ab4f06b7121": "for i D 1; 2; : : : ; n \u0005 1.1 We denote a decomposition into pieces using ordinary\nadditive notation, so that 7 D 2 C 2 C 3 indicates that a rod of length 7 is cut into\nthree pieces—two of length 2 and one of length 3. If an optimal solution cuts the\nrod into k pieces, for some 1 \u0002 k \u0002 n, then an optimal decomposition\nn D i1 C i2 C \u0003 \u0003 \u0003 C ik\nof the rod into pieces of lengths i1, i2, . . . , ik provides maximum corresponding\nrevenue\nrn D pi1 C pi2 C \u0003 \u0003 \u0003 C pik :\nFor our sample problem, we can determine the optimal revenue ﬁgures ri, for\ni D 1; 2; : : : ; 10, by inspection, with the corresponding optimal decompositions\n1If we required the pieces to be cut in order of nondecreasing size, there would be fewer ways\nto consider. For n D 4, we would consider only 5 such ways: parts (a), (b), (c), (e), and (h)\nin Figure 15.2. The number of ways is called the partition function; it is approximately equal to\ne\u0003\np\n2n=3=4n\np\n3. This quantity is less than 2n\u00031, but still much greater than any polynomial in n.\nWe shall not pursue this line of inquiry further, however.\n362\nChapter 15\nDynamic Programming\nr1 D 1\nfrom solution 1 D 1\n(no cuts) ;\nr2 D 5\nfrom solution 2 D 2\n(no cuts) ;\nr3 D 8\nfrom solution 3 D 3\n(no cuts) ;\nr4 D 10 from solution 4 D 2 C 2 ;\nr5 D 13 from solution 5 D 2 C 3 ;\nr6 D 17 from solution 6 D 6\n(no cuts) ;\nr7 D 18 from solution 7 D 1 C 6 or 7 D 2 C 2 C 3 ;\nr8 D 22 from solution 8 D 2 C 6 ;\nr9 D 25 from solution 9 D 3 C 6 ;\nr10 D 30 from solution 10 D 10\n(no cuts) :\nMore generally, we can frame the values rn for n \u0006 1 in terms of optimal rev-\nenues from shorter rods:\nrn D max .pn; r1 C rn\u00031; r2 C rn\u00032; : : : ; rn\u00031 C r1/ :\n(15.1)\nThe ﬁrst argument, pn, corresponds to making no cuts at all and selling the rod of\nlength n as is. The other n \u0005 1 arguments to max correspond to the maximum rev-\nenue obtained by making an initial cut of the rod into two pieces of size i and n \u0005 i,\nfor each i D 1; 2; : : : ; n \u0005 1, and then optimally cutting up those pieces further,",
    "parent_9a57c451-0a92-44c9-bb73-2e3ce0f1d60b": "length n as is. The other n \u0005 1 arguments to max correspond to the maximum rev-\nenue obtained by making an initial cut of the rod into two pieces of size i and n \u0005 i,\nfor each i D 1; 2; : : : ; n \u0005 1, and then optimally cutting up those pieces further,\nobtaining revenues ri and rn\u0003i from those two pieces. Since we don’t know ahead\nof time which value of i optimizes revenue, we have to consider all possible values\nfor i and pick the one that maximizes revenue. We also have the option of picking\nno i at all if we can obtain more revenue by selling the rod uncut.\nNote that to solve the original problem of size n, we solve smaller problems of\nthe same type, but of smaller sizes. Once we make the ﬁrst cut, we may consider\nthe two pieces as independent instances of the rod-cutting problem. The overall\noptimal solution incorporates optimal solutions to the two related subproblems,\nmaximizing revenue from each of those two pieces. We say that the rod-cutting\nproblem exhibits optimal substructure: optimal solutions to a problem incorporate\noptimal solutions to related subproblems, which we may solve independently.\nIn a related, but slightly simpler, way to arrange a recursive structure for the rod-\ncutting problem, we view a decomposition as consisting of a ﬁrst piece of length i\ncut off the left-hand end, and then a right-hand remainder of length n \u0005 i. Only\nthe remainder, and not the ﬁrst piece, may be further divided. We may view every\ndecomposition of a length-n rod in this way: as a ﬁrst piece followed by some\ndecomposition of the remainder. When doing so, we can couch the solution with\nno cuts at all as saying that the ﬁrst piece has size i D n and revenue pn and that\nthe remainder has size 0 with corresponding revenue r0 D 0. We thus obtain the\nfollowing simpler version of equation (15.1):\nrn D max\n1\u0005i\u0005n .pi C rn\u0003i/ :\n(15.2)\n15.1\nRod cutting\n363\nIn this formulation, an optimal solution embodies the solution to only one related",
    "parent_b3a1ca83-a1bb-47f6-947e-7f8c7cafb5aa": "the remainder has size 0 with corresponding revenue r0 D 0. We thus obtain the\nfollowing simpler version of equation (15.1):\nrn D max\n1\u0005i\u0005n .pi C rn\u0003i/ :\n(15.2)\n15.1\nRod cutting\n363\nIn this formulation, an optimal solution embodies the solution to only one related\nsubproblem—the remainder—rather than two.\nRecursive top-down implementation\nThe following procedure implements the computation implicit in equation (15.2)\nin a straightforward, top-down, recursive manner.\nCUT-ROD.p; n/\n1\nif n == 0\n2\nreturn 0\n3\nq D \u00051\n4\nfor i D 1 to n\n5\nq D max.q; pŒi\u0002 C CUT-ROD.p; n \u0005 i//\n6\nreturn q\nProcedure CUT-ROD takes as input an array pŒ1 : : n\u0002 of prices and an integer n,\nand it returns the maximum revenue possible for a rod of length n. If n D 0, no\nrevenue is possible, and so CUT-ROD returns 0 in line 2. Line 3 initializes the\nmaximum revenue q to \u00051, so that the for loop in lines 4–5 correctly computes\nq D max1\u0005i\u0005n.pi C CUT-ROD.p; n \u0005 i//; line 6 then returns this value. A simple\ninduction on n proves that this answer is equal to the desired answer rn, using\nequation (15.2).\nIf you were to code up CUT-ROD in your favorite programming language and run\nit on your computer, you would ﬁnd that once the input size becomes moderately\nlarge, your program would take a long time to run. For n D 40, you would ﬁnd that\nyour program takes at least several minutes, and most likely more than an hour. In\nfact, you would ﬁnd that each time you increase n by 1, your program’s running\ntime would approximately double.\nWhy is CUT-ROD so inefﬁcient? The problem is that CUT-ROD calls itself\nrecursively over and over again with the same parameter values; it solves the\nsame subproblems repeatedly. Figure 15.3 illustrates what happens for n D 4:\nCUT-ROD.p; n/ calls CUT-ROD.p; n \u0005 i/ for i D 1; 2; : : : ; n.\nEquivalently,\nCUT-ROD.p; n/ calls CUT-ROD.p; j / for each j D 0; 1; : : : ; n \u0005 1. When this\nprocess unfolds recursively, the amount of work done, as a function of n, grows\nexplosively.",
    "parent_69816cc6-2d6a-4384-b34a-55dec0c829b1": "CUT-ROD.p; n/ calls CUT-ROD.p; n \u0005 i/ for i D 1; 2; : : : ; n.\nEquivalently,\nCUT-ROD.p; n/ calls CUT-ROD.p; j / for each j D 0; 1; : : : ; n \u0005 1. When this\nprocess unfolds recursively, the amount of work done, as a function of n, grows\nexplosively.\nTo analyze the running time of CUT-ROD, let T .n/ denote the total number of\ncalls made to CUT-ROD when called with its second parameter equal to n. This\nexpression equals the number of nodes in a subtree whose root is labeled n in the\nrecursion tree. The count includes the initial call at its root. Thus, T .0/ D 1 and\n364\nChapter 15\nDynamic Programming\n3\n1\n0\n0\n0\n0\n1\n2\n0\n0\n1\n2\n0\n1\n0\n4\nFigure 15.3\nThe recursion tree showing recursive calls resulting from a call CUT-ROD.p; n/ for\nn D 4. Each node label gives the size n of the corresponding subproblem, so that an edge from\na parent with label s to a child with label t corresponds to cutting off an initial piece of size s \u0005 t\nand leaving a remaining subproblem of size t. A path from the root to a leaf corresponds to one of\nthe 2n\u00031 ways of cutting up a rod of length n. In general, this recursion tree has 2n nodes and 2n\u00031\nleaves.\nT .n/ D 1 C\nn\u00031\nX\njD0\nT .j / :\n(15.3)\nThe initial 1 is for the call at the root, and the term T .j / counts the number of calls\n(including recursive calls) due to the call CUT-ROD.p; n \u0005 i/, where j D n \u0005 i.\nAs Exercise 15.1-1 asks you to show,\nT .n/ D 2n ;\n(15.4)\nand so the running time of CUT-ROD is exponential in n.\nIn retrospect, this exponential running time is not so surprising. CUT-ROD ex-\nplicitly considers all the 2n\u00031 possible ways of cutting up a rod of length n. The\ntree of recursive calls has 2n\u00031 leaves, one for each possible way of cutting up the\nrod. The labels on the simple path from the root to a leaf give the sizes of each\nremaining right-hand piece before making each cut. That is, the labels give the\ncorresponding cut points, measured from the right-hand end of the rod.\nUsing dynamic programming for optimal rod cutting",
    "parent_3c7a15f7-089f-42ea-aafd-6934c8588d3f": "rod. The labels on the simple path from the root to a leaf give the sizes of each\nremaining right-hand piece before making each cut. That is, the labels give the\ncorresponding cut points, measured from the right-hand end of the rod.\nUsing dynamic programming for optimal rod cutting\nWe now show how to convert CUT-ROD into an efﬁcient algorithm, using dynamic\nprogramming.\nThe dynamic-programming method works as follows. Having observed that a\nnaive recursive solution is inefﬁcient because it solves the same subproblems re-\npeatedly, we arrange for each subproblem to be solved only once, saving its solu-\ntion. If we need to refer to this subproblem’s solution again later, we can just look it\n15.1\nRod cutting\n365\nup, rather than recompute it. Dynamic programming thus uses additional memory\nto save computation time; it serves an example of a time-memory trade-off. The\nsavings may be dramatic: an exponential-time solution may be transformed into a\npolynomial-time solution. A dynamic-programming approach runs in polynomial\ntime when the number of distinct subproblems involved is polynomial in the input\nsize and we can solve each such subproblem in polynomial time.\nThere are usually two equivalent ways to implement a dynamic-programming\napproach. We shall illustrate both of them with our rod-cutting example.\nThe ﬁrst approach is top-down with memoization.2 In this approach, we write\nthe procedure recursively in a natural manner, but modiﬁed to save the result of\neach subproblem (usually in an array or hash table). The procedure now ﬁrst checks\nto see whether it has previously solved this subproblem. If so, it returns the saved\nvalue, saving further computation at this level; if not, the procedure computes the\nvalue in the usual manner. We say that the recursive procedure has been memoized;\nit “remembers” what results it has computed previously.\nThe second approach is the bottom-up method. This approach typically depends",
    "parent_a990611c-fd9c-451b-90e6-2879ee2f8a88": "value, saving further computation at this level; if not, the procedure computes the\nvalue in the usual manner. We say that the recursive procedure has been memoized;\nit “remembers” what results it has computed previously.\nThe second approach is the bottom-up method. This approach typically depends\non some natural notion of the “size” of a subproblem, such that solving any par-\nticular subproblem depends only on solving “smaller” subproblems. We sort the\nsubproblems by size and solve them in size order, smallest ﬁrst. When solving a\nparticular subproblem, we have already solved all of the smaller subproblems its\nsolution depends upon, and we have saved their solutions. We solve each sub-\nproblem only once, and when we ﬁrst see it, we have already solved all of its\nprerequisite subproblems.\nThese two approaches yield algorithms with the same asymptotic running time,\nexcept in unusual circumstances where the top-down approach does not actually\nrecurse to examine all possible subproblems. The bottom-up approach often has\nmuch better constant factors, since it has less overhead for procedure calls.\nHere is the the pseudocode for the top-down CUT-ROD procedure, with memo-\nization added:\nMEMOIZED-CUT-ROD.p; n/\n1\nlet rŒ0 : : n\u0002 be a new array\n2\nfor i D 0 to n\n3\nrŒi\u0002 D \u00051\n4\nreturn MEMOIZED-CUT-ROD-AUX.p; n; r/\n2This is not a misspelling. The word really is memoization, not memorization. Memoization comes\nfrom memo, since the technique consists of recording a value so that we can look it up later.\n366\nChapter 15\nDynamic Programming\nMEMOIZED-CUT-ROD-AUX.p; n; r/\n1\nif rŒn\u0002 \u0006 0\n2\nreturn rŒn\u0002\n3\nif n == 0\n4\nq D 0\n5\nelse q D \u00051\n6\nfor i D 1 to n\n7\nq D max.q; pŒi\u0002 C MEMOIZED-CUT-ROD-AUX.p; n \u0005 i; r//\n8\nrŒn\u0002 D q\n9\nreturn q\nHere, the main procedure MEMOIZED-CUT-ROD initializes a new auxiliary ar-\nray rŒ0 : : n\u0002 with the value \u00051, a convenient choice with which to denote “un-\nknown.” (Known revenue values are always nonnegative.) It then calls its helper\nroutine, MEMOIZED-CUT-ROD-AUX.",
    "parent_5858eac4-9b42-481f-823f-bbfee5656c76": "8\nrŒn\u0002 D q\n9\nreturn q\nHere, the main procedure MEMOIZED-CUT-ROD initializes a new auxiliary ar-\nray rŒ0 : : n\u0002 with the value \u00051, a convenient choice with which to denote “un-\nknown.” (Known revenue values are always nonnegative.) It then calls its helper\nroutine, MEMOIZED-CUT-ROD-AUX.\nThe procedure MEMOIZED-CUT-ROD-AUX is just the memoized version of our\nprevious procedure, CUT-ROD. It ﬁrst checks in line 1 to see whether the desired\nvalue is already known and, if it is, then line 2 returns it. Otherwise, lines 3–7\ncompute the desired value q in the usual manner, line 8 saves it in rŒn\u0002, and line 9\nreturns it.\nThe bottom-up version is even simpler:\nBOTTOM-UP-CUT-ROD.p; n/\n1\nlet rŒ0 : : n\u0002 be a new array\n2\nrŒ0\u0002 D 0\n3\nfor j D 1 to n\n4\nq D \u00051\n5\nfor i D 1 to j\n6\nq D max.q; pŒi\u0002 C rŒj \u0005 i\u0002/\n7\nrŒj \u0002 D q\n8\nreturn rŒn\u0002\nFor the bottom-up dynamic-programming approach, BOTTOM-UP-CUT-ROD\nuses the natural ordering of the subproblems: a problem of size i is “smaller”\nthan a subproblem of size j if i < j . Thus, the procedure solves subproblems of\nsizes j D 0; 1; : : : ; n, in that order.\nLine 1 of procedure BOTTOM-UP-CUT-ROD creates a new array rŒ0 : : n\u0002 in\nwhich to save the results of the subproblems, and line 2 initializes rŒ0\u0002 to 0, since\na rod of length 0 earns no revenue. Lines 3–6 solve each subproblem of size j , for\nj D 1; 2; : : : ; n, in order of increasing size. The approach used to solve a problem\nof a particular size j is the same as that used by CUT-ROD, except that line 6 now\n15.1\nRod cutting\n367\n3\n0\n1\n2\n4\nFigure 15.4\nThe subproblem graph for the rod-cutting problem with n D 4. The vertex labels\ngive the sizes of the corresponding subproblems. A directed edge .x; y/ indicates that we need a\nsolution to subproblem y when solving subproblem x. This graph is a reduced version of the tree of\nFigure 15.3, in which all nodes with the same label are collapsed into a single vertex and all edges\ngo from parent to child.",
    "parent_7976fcf4-ee33-4b55-aa77-8112ecfa09e8": "solution to subproblem y when solving subproblem x. This graph is a reduced version of the tree of\nFigure 15.3, in which all nodes with the same label are collapsed into a single vertex and all edges\ngo from parent to child.\ndirectly references array entry rŒj \u0005 i\u0002 instead of making a recursive call to solve\nthe subproblem of size j \u0005 i. Line 7 saves in rŒj \u0002 the solution to the subproblem\nof size j . Finally, line 8 returns rŒn\u0002, which equals the optimal value rn.\nThe bottom-up and top-down versions have the same asymptotic running time.\nThe running time of procedure BOTTOM-UP-CUT-ROD is ‚.n2/, due to its\ndoubly-nested loop structure. The number of iterations of its inner for loop, in\nlines 5–6, forms an arithmetic series. The running time of its top-down counterpart,\nMEMOIZED-CUT-ROD, is also ‚.n2/, although this running time may be a little\nharder to see. Because a recursive call to solve a previously solved subproblem\nreturns immediately, MEMOIZED-CUT-ROD solves each subproblem just once. It\nsolves subproblems for sizes 0; 1; : : : ; n. To solve a subproblem of size n, the for\nloop of lines 6–7 iterates n times. Thus, the total number of iterations of this for\nloop, over all recursive calls of MEMOIZED-CUT-ROD, forms an arithmetic series,\ngiving a total of ‚.n2/ iterations, just like the inner for loop of BOTTOM-UP-\nCUT-ROD. (We actually are using a form of aggregate analysis here. We shall see\naggregate analysis in detail in Section 17.1.)\nSubproblem graphs\nWhen we think about a dynamic-programming problem, we should understand the\nset of subproblems involved and how subproblems depend on one another.\nThe subproblem graph for the problem embodies exactly this information. Fig-\nure 15.4 shows the subproblem graph for the rod-cutting problem with n D 4. It\nis a directed graph, containing one vertex for each distinct subproblem. The sub-\n368\nChapter 15\nDynamic Programming\nproblem graph has a directed edge from the vertex for subproblem x to the vertex",
    "parent_7655cdc1-f192-43f9-b8e5-f71ba2e79062": "ure 15.4 shows the subproblem graph for the rod-cutting problem with n D 4. It\nis a directed graph, containing one vertex for each distinct subproblem. The sub-\n368\nChapter 15\nDynamic Programming\nproblem graph has a directed edge from the vertex for subproblem x to the vertex\nfor subproblem y if determining an optimal solution for subproblem x involves\ndirectly considering an optimal solution for subproblem y. For example, the sub-\nproblem graph contains an edge from x to y if a top-down recursive procedure for\nsolving x directly calls itself to solve y. We can think of the subproblem graph\nas a “reduced” or “collapsed” version of the recursion tree for the top-down recur-\nsive method, in which we coalesce all nodes for the same subproblem into a single\nvertex and direct all edges from parent to child.\nThe bottom-up method for dynamic programming considers the vertices of the\nsubproblem graph in such an order that we solve the subproblems y adjacent to\na given subproblem x before we solve subproblem x. (Recall from Section B.4\nthat the adjacency relation is not necessarily symmetric.) Using the terminology\nfrom Chapter 22, in a bottom-up dynamic-programming algorithm, we consider the\nvertices of the subproblem graph in an order that is a “reverse topological sort,” or\na “topological sort of the transpose” (see Section 22.4) of the subproblem graph. In\nother words, no subproblem is considered until all of the subproblems it depends\nupon have been solved. Similarly, using notions from the same chapter, we can\nview the top-down method (with memoization) for dynamic programming as a\n“depth-ﬁrst search” of the subproblem graph (see Section 22.3).\nThe size of the subproblem graph G D .V; E/ can help us determine the running\ntime of the dynamic programming algorithm. Since we solve each subproblem just\nonce, the running time is the sum of the times needed to solve each subproblem.\nTypically, the time to compute the solution to a subproblem is proportional to the",
    "parent_5039e15d-fe3c-432d-b256-840eb608ebbb": "time of the dynamic programming algorithm. Since we solve each subproblem just\nonce, the running time is the sum of the times needed to solve each subproblem.\nTypically, the time to compute the solution to a subproblem is proportional to the\ndegree (number of outgoing edges) of the corresponding vertex in the subproblem\ngraph, and the number of subproblems is equal to the number of vertices in the sub-\nproblem graph. In this common case, the running time of dynamic programming\nis linear in the number of vertices and edges.\nReconstructing a solution\nOur dynamic-programming solutions to the rod-cutting problem return the value of\nan optimal solution, but they do not return an actual solution: a list of piece sizes.\nWe can extend the dynamic-programming approach to record not only the optimal\nvalue computed for each subproblem, but also a choice that led to the optimal\nvalue. With this information, we can readily print an optimal solution.\nHere is an extended version of BOTTOM-UP-CUT-ROD that computes, for each\nrod size j , not only the maximum revenue rj, but also sj, the optimal size of the\nﬁrst piece to cut off:\n15.1\nRod cutting\n369\nEXTENDED-BOTTOM-UP-CUT-ROD.p; n/\n1\nlet rŒ0 : : n\u0002 and sŒ0 : : n\u0002 be new arrays\n2\nrŒ0\u0002 D 0\n3\nfor j D 1 to n\n4\nq D \u00051\n5\nfor i D 1 to j\n6\nif q < pŒi\u0002 C rŒj \u0005 i\u0002\n7\nq D pŒi\u0002 C rŒj \u0005 i\u0002\n8\nsŒj \u0002 D i\n9\nrŒj \u0002 D q\n10\nreturn r and s\nThis procedure is similar to BOTTOM-UP-CUT-ROD, except that it creates the ar-\nray s in line 1, and it updates sŒj \u0002 in line 8 to hold the optimal size i of the ﬁrst\npiece to cut off when solving a subproblem of size j .\nThe following procedure takes a price table p and a rod size n, and it calls\nEXTENDED-BOTTOM-UP-CUT-ROD to compute the array sŒ1 : : n\u0002 of optimal\nﬁrst-piece sizes and then prints out the complete list of piece sizes in an optimal\ndecomposition of a rod of length n:\nPRINT-CUT-ROD-SOLUTION.p; n/\n1\n.r; s/ D EXTENDED-BOTTOM-UP-CUT-ROD.p; n/\n2\nwhile n > 0\n3\nprint sŒn\u0002\n4\nn D n \u0005 sŒn\u0002",
    "parent_3853e024-ac4f-4d15-b9dc-5a268a6c5890": "ﬁrst-piece sizes and then prints out the complete list of piece sizes in an optimal\ndecomposition of a rod of length n:\nPRINT-CUT-ROD-SOLUTION.p; n/\n1\n.r; s/ D EXTENDED-BOTTOM-UP-CUT-ROD.p; n/\n2\nwhile n > 0\n3\nprint sŒn\u0002\n4\nn D n \u0005 sŒn\u0002\nIn our rod-cutting example, the call EXTENDED-BOTTOM-UP-CUT-ROD.p; 10/\nwould return the following arrays:\ni\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nrŒi\u0002\n0\n1\n5\n8\n10\n13\n17\n18\n22\n25\n30\nsŒi\u0002\n0\n1\n2\n3\n2\n2\n6\n1\n2\n3\n10\nA call to PRINT-CUT-ROD-SOLUTION.p; 10/ would print just 10, but a call with\nn D 7 would print the cuts 1 and 6, corresponding to the ﬁrst optimal decomposi-\ntion for r7 given earlier.\nExercises\n15.1-1\nShow that equation (15.4) follows from equation (15.3) and the initial condition\nT .0/ D 1.\n370\nChapter 15\nDynamic Programming\n15.1-2\nShow, by means of a counterexample, that the following “greedy” strategy does\nnot always determine an optimal way to cut rods. Deﬁne the density of a rod of\nlength i to be pi=i, that is, its value per inch. The greedy strategy for a rod of\nlength n cuts off a ﬁrst piece of length i, where 1 \u0002 i \u0002 n, having maximum\ndensity. It then continues by applying the greedy strategy to the remaining piece of\nlength n \u0005 i.\n15.1-3\nConsider a modiﬁcation of the rod-cutting problem in which, in addition to a\nprice pi for each rod, each cut incurs a ﬁxed cost of c. The revenue associated with\na solution is now the sum of the prices of the pieces minus the costs of making the\ncuts. Give a dynamic-programming algorithm to solve this modiﬁed problem.\n15.1-4\nModify MEMOIZED-CUT-ROD to return not only the value but the actual solution,\ntoo.\n15.1-5\nThe Fibonacci numbers are deﬁned by recurrence (3.22).\nGive an O.n/-time\ndynamic-programming algorithm to compute the nth Fibonacci number. Draw the\nsubproblem graph. How many vertices and edges are in the graph?\n15.2\nMatrix-chain multiplication\nOur next example of dynamic programming is an algorithm that solves the problem",
    "parent_f5ed3000-afda-4097-b811-23cacd96bfe9": "Give an O.n/-time\ndynamic-programming algorithm to compute the nth Fibonacci number. Draw the\nsubproblem graph. How many vertices and edges are in the graph?\n15.2\nMatrix-chain multiplication\nOur next example of dynamic programming is an algorithm that solves the problem\nof matrix-chain multiplication. We are given a sequence (chain) hA1; A2; : : : ; Ani\nof n matrices to be multiplied, and we wish to compute the product\nA1A2 \u0003 \u0003 \u0003 An :\n(15.5)\nWe can evaluate the expression (15.5) using the standard algorithm for multiply-\ning pairs of matrices as a subroutine once we have parenthesized it to resolve all\nambiguities in how the matrices are multiplied together. Matrix multiplication is\nassociative, and so all parenthesizations yield the same product. A product of ma-\ntrices is fully parenthesized if it is either a single matrix or the product of two fully\nparenthesized matrix products, surrounded by parentheses. For example, if the\nchain of matrices is hA1; A2; A3; A4i, then we can fully parenthesize the product\nA1A2A3A4 in ﬁve distinct ways:\n15.2\nMatrix-chain multiplication\n371\n.A1.A2.A3A4/// ;\n.A1..A2A3/A4// ;\n..A1A2/.A3A4// ;\n..A1.A2A3//A4/ ;\n...A1A2/A3/A4/ :\nHow we parenthesize a chain of matrices can have a dramatic impact on the cost\nof evaluating the product. Consider ﬁrst the cost of multiplying two matrices. The\nstandard algorithm is given by the following pseudocode, which generalizes the\nSQUARE-MATRIX-MULTIPLY procedure from Section 4.2. The attributes rows\nand columns are the numbers of rows and columns in a matrix.\nMATRIX-MULTIPLY.A; B/\n1\nif A:columns ¤ B:rows\n2\nerror “incompatible dimensions”\n3\nelse let C be a new A:rows \t B:columns matrix\n4\nfor i D 1 to A:rows\n5\nfor j D 1 to B:columns\n6\ncij D 0\n7\nfor k D 1 to A:columns\n8\ncij D cij C aik \u0003 bkj\n9\nreturn C\nWe can multiply two matrices A and B only if they are compatible: the number of\ncolumns of A must equal the number of rows of B. If A is a p \t q matrix and B is",
    "parent_9554930c-ca69-413f-a8f7-2b42d9dfa101": "4\nfor i D 1 to A:rows\n5\nfor j D 1 to B:columns\n6\ncij D 0\n7\nfor k D 1 to A:columns\n8\ncij D cij C aik \u0003 bkj\n9\nreturn C\nWe can multiply two matrices A and B only if they are compatible: the number of\ncolumns of A must equal the number of rows of B. If A is a p \t q matrix and B is\na q \t r matrix, the resulting matrix C is a p \t r matrix. The time to compute C is\ndominated by the number of scalar multiplications in line 8, which is pqr. In what\nfollows, we shall express costs in terms of the number of scalar multiplications.\nTo illustrate the different costs incurred by different parenthesizations of a matrix\nproduct, consider the problem of a chain hA1; A2; A3i of three matrices. Suppose\nthat the dimensions of the matrices are 10 \t 100, 100 \t 5, and 5 \t 50, respec-\ntively. If we multiply according to the parenthesization ..A1A2/A3/, we perform\n10 \u0003 100 \u0003 5 D 5000 scalar multiplications to compute the 10 \t 5 matrix prod-\nuct A1A2, plus another 10 \u0003 5 \u0003 50 D 2500 scalar multiplications to multiply this\nmatrix by A3, for a total of 7500 scalar multiplications. If instead we multiply\naccording to the parenthesization .A1.A2A3//, we perform 100 \u0003 5 \u0003 50 D 25,000\nscalar multiplications to compute the 100 \t 50 matrix product A2A3, plus another\n10 \u0003 100 \u0003 50 D 50,000 scalar multiplications to multiply A1 by this matrix, for a\ntotal of 75,000 scalar multiplications. Thus, computing the product according to\nthe ﬁrst parenthesization is 10 times faster.\nWe state the matrix-chain multiplication problem as follows: given a chain\nhA1;A2;: : : ;Ani of n matrices, where for i D 1; 2; : : : ; n, matrix Ai has dimension\n372\nChapter 15\nDynamic Programming\npi\u00031 \t pi, fully parenthesize the product A1A2 \u0003 \u0003 \u0003 An in a way that minimizes the\nnumber of scalar multiplications.\nNote that in the matrix-chain multiplication problem, we are not actually multi-\nplying matrices. Our goal is only to determine an order for multiplying matrices",
    "parent_993b60fd-c2e8-4baf-9a62-986318d50529": "Dynamic Programming\npi\u00031 \t pi, fully parenthesize the product A1A2 \u0003 \u0003 \u0003 An in a way that minimizes the\nnumber of scalar multiplications.\nNote that in the matrix-chain multiplication problem, we are not actually multi-\nplying matrices. Our goal is only to determine an order for multiplying matrices\nthat has the lowest cost. Typically, the time invested in determining this optimal\norder is more than paid for by the time saved later on when actually performing the\nmatrix multiplications (such as performing only 7500 scalar multiplications instead\nof 75,000).\nCounting the number of parenthesizations\nBefore solving the matrix-chain multiplication problem by dynamic programming,\nlet us convince ourselves that exhaustively checking all possible parenthesizations\ndoes not yield an efﬁcient algorithm. Denote the number of alternative parenthe-\nsizations of a sequence of n matrices by P.n/. When n D 1, we have just one\nmatrix and therefore only one way to fully parenthesize the matrix product. When\nn \u0006 2, a fully parenthesized matrix product is the product of two fully parenthe-\nsized matrix subproducts, and the split between the two subproducts may occur\nbetween the kth and .k C 1/st matrices for any k D 1; 2; : : : ; n \u0005 1. Thus, we\nobtain the recurrence\nP.n/ D\n\u0002\n1\nif n D 1 ;\nn\u00031\nX\nkD1\nP.k/P.n \u0005 k/\nif n \u0006 2 :\n(15.6)\nProblem 12-4 asked you to show that the solution to a similar recurrence is the\nsequence of Catalan numbers, which grows as \u0004.4n=n3=2/. A simpler exercise\n(see Exercise 15.2-3) is to show that the solution to the recurrence (15.6) is \u0004.2n/.\nThe number of solutions is thus exponential in n, and the brute-force method of\nexhaustive search makes for a poor strategy when determining how to optimally\nparenthesize a matrix chain.\nApplying dynamic programming\nWe shall use the dynamic-programming method to determine how to optimally\nparenthesize a matrix chain. In so doing, we shall follow the four-step sequence\nthat we stated at the beginning of this chapter:",
    "parent_9a7764bc-51b3-4ed6-b629-f3a732714b63": "parenthesize a matrix chain.\nApplying dynamic programming\nWe shall use the dynamic-programming method to determine how to optimally\nparenthesize a matrix chain. In so doing, we shall follow the four-step sequence\nthat we stated at the beginning of this chapter:\n1. Characterize the structure of an optimal solution.\n2. Recursively deﬁne the value of an optimal solution.\n3. Compute the value of an optimal solution.\n15.2\nMatrix-chain multiplication\n373\n4. Construct an optimal solution from computed information.\nWe shall go through these steps in order, demonstrating clearly how we apply each\nstep to the problem.\nStep 1: The structure of an optimal parenthesization\nFor our ﬁrst step in the dynamic-programming paradigm, we ﬁnd the optimal sub-\nstructure and then use it to construct an optimal solution to the problem from opti-\nmal solutions to subproblems. In the matrix-chain multiplication problem, we can\nperform this step as follows. For convenience, let us adopt the notation Ai::j, where\ni \u0002 j , for the matrix that results from evaluating the product AiAiC1 \u0003 \u0003 \u0003 Aj. Ob-\nserve that if the problem is nontrivial, i.e., i < j , then to parenthesize the product\nAiAiC1 \u0003 \u0003 \u0003 Aj, we must split the product between Ak and AkC1 for some integer k\nin the range i \u0002 k < j . That is, for some value of k, we ﬁrst compute the matrices\nAi::k and AkC1::j and then multiply them together to produce the ﬁnal product Ai::j.\nThe cost of parenthesizing this way is the cost of computing the matrix Ai::k, plus\nthe cost of computing AkC1::j, plus the cost of multiplying them together.\nThe optimal substructure of this problem is as follows. Suppose that to op-\ntimally parenthesize AiAiC1 \u0003 \u0003 \u0003 Aj, we split the product between Ak and AkC1.\nThen the way we parenthesize the “preﬁx” subchain AiAiC1 \u0003 \u0003 \u0003 Ak within this\noptimal parenthesization of AiAiC1 \u0003 \u0003 \u0003 Aj must be an optimal parenthesization of\nAiAiC1 \u0003 \u0003 \u0003 Ak. Why? If there were a less costly way to parenthesize AiAiC1 \u0003 \u0003 \u0003 Ak,",
    "parent_25772fd7-baf9-4bfb-b5c8-4812060694f2": "Then the way we parenthesize the “preﬁx” subchain AiAiC1 \u0003 \u0003 \u0003 Ak within this\noptimal parenthesization of AiAiC1 \u0003 \u0003 \u0003 Aj must be an optimal parenthesization of\nAiAiC1 \u0003 \u0003 \u0003 Ak. Why? If there were a less costly way to parenthesize AiAiC1 \u0003 \u0003 \u0003 Ak,\nthen we could substitute that parenthesization in the optimal parenthesization\nof AiAiC1 \u0003 \u0003 \u0003 Aj to produce another way to parenthesize AiAiC1 \u0003 \u0003 \u0003 Aj whose cost\nwas lower than the optimum: a contradiction. A similar observation holds for how\nwe parenthesize the subchain AkC1AkC2 \u0003 \u0003 \u0003 Aj in the optimal parenthesization of\nAiAiC1 \u0003 \u0003 \u0003 Aj: it must be an optimal parenthesization of AkC1AkC2 \u0003 \u0003 \u0003 Aj.\nNow we use our optimal substructure to show that we can construct an optimal\nsolution to the problem from optimal solutions to subproblems. We have seen that\nany solution to a nontrivial instance of the matrix-chain multiplication problem\nrequires us to split the product, and that any optimal solution contains within it op-\ntimal solutions to subproblem instances. Thus, we can build an optimal solution to\nan instance of the matrix-chain multiplication problem by splitting the problem into\ntwo subproblems (optimally parenthesizing AiAiC1 \u0003 \u0003 \u0003 Ak and AkC1AkC2 \u0003 \u0003 \u0003 Aj),\nﬁnding optimal solutions to subproblem instances, and then combining these op-\ntimal subproblem solutions. We must ensure that when we search for the correct\nplace to split the product, we have considered all possible places, so that we are\nsure of having examined the optimal one.\n374\nChapter 15\nDynamic Programming\nStep 2: A recursive solution\nNext, we deﬁne the cost of an optimal solution recursively in terms of the optimal\nsolutions to subproblems. For the matrix-chain multiplication problem, we pick as\nour subproblems the problems of determining the minimum cost of parenthesizing\nAiAiC1 \u0003 \u0003 \u0003 Aj for 1 \u0002 i \u0002 j \u0002 n. Let mŒi; j \u0002 be the minimum number of scalar\nmultiplications needed to compute the matrix Ai::j; for the full problem, the lowest-",
    "parent_a2ab0d0c-29cc-4cec-acd5-e3d022b21c6f": "our subproblems the problems of determining the minimum cost of parenthesizing\nAiAiC1 \u0003 \u0003 \u0003 Aj for 1 \u0002 i \u0002 j \u0002 n. Let mŒi; j \u0002 be the minimum number of scalar\nmultiplications needed to compute the matrix Ai::j; for the full problem, the lowest-\ncost way to compute A1::n would thus be mŒ1; n\u0002.\nWe can deﬁne mŒi; j \u0002 recursively as follows. If i D j , the problem is trivial;\nthe chain consists of just one matrix Ai::i D Ai, so that no scalar multiplications\nare necessary to compute the product. Thus, mŒi; i\u0002 D 0 for i D 1; 2; : : : ; n. To\ncompute mŒi; j \u0002 when i < j , we take advantage of the structure of an optimal\nsolution from step 1. Let us assume that to optimally parenthesize, we split the\nproduct AiAiC1 \u0003 \u0003 \u0003 Aj between Ak and AkC1, where i \u0002 k < j . Then, mŒi; j \u0002\nequals the minimum cost for computing the subproducts Ai::k and AkC1::j, plus the\ncost of multiplying these two matrices together. Recalling that each matrix Ai is\npi\u00031 \t pi, we see that computing the matrix product Ai::kAkC1::j takes pi\u00031pkpj\nscalar multiplications. Thus, we obtain\nmŒi; j \u0002 D mŒi; k\u0002 C mŒk C 1; j \u0002 C pi\u00031pkpj :\nThis recursive equation assumes that we know the value of k, which we do not.\nThere are only j \u0005i possible values for k, however, namely k D i; i C1; : : : ; j \u00051.\nSince the optimal parenthesization must use one of these values for k, we need only\ncheck them all to ﬁnd the best. Thus, our recursive deﬁnition for the minimum cost\nof parenthesizing the product AiAiC1 \u0003 \u0003 \u0003 Aj becomes\nmŒi; j \u0002 D\n( 0\nif i D j ;\nmin\ni\u0005k<j fmŒi; k\u0002 C mŒk C 1; j \u0002 C pi\u00031pkpjg\nif i < j :\n(15.7)\nThe mŒi; j \u0002 values give the costs of optimal solutions to subproblems, but they\ndo not provide all the information we need to construct an optimal solution. To\nhelp us do so, we deﬁne sŒi; j \u0002 to be a value of k at which we split the product\nAiAiC1 \u0003 \u0003 \u0003 Aj in an optimal parenthesization. That is, sŒi; j \u0002 equals a value k such\nthat mŒi; j \u0002 D mŒi; k\u0002 C mŒk C 1; j \u0002 C pi\u00031pkpj.",
    "parent_fa2496fc-572c-4462-aadb-bba1fe3da873": "help us do so, we deﬁne sŒi; j \u0002 to be a value of k at which we split the product\nAiAiC1 \u0003 \u0003 \u0003 Aj in an optimal parenthesization. That is, sŒi; j \u0002 equals a value k such\nthat mŒi; j \u0002 D mŒi; k\u0002 C mŒk C 1; j \u0002 C pi\u00031pkpj.\nStep 3: Computing the optimal costs\nAt this point, we could easily write a recursive algorithm based on recurrence (15.7)\nto compute the minimum cost mŒ1; n\u0002 for multiplying A1A2 \u0003 \u0003 \u0003 An. As we saw for\nthe rod-cutting problem, and as we shall see in Section 15.3, this recursive algo-\nrithm takes exponential time, which is no better than the brute-force method of\nchecking each way of parenthesizing the product.\n15.2\nMatrix-chain multiplication\n375\nObserve that we have relatively few distinct subproblems: one subproblem for\neach choice of i and j satisfying 1 \u0002 i \u0002 j \u0002 n, or\n\u000bn\n2\n\f\nC n D ‚.n2/ in all.\nA recursive algorithm may encounter each subproblem many times in different\nbranches of its recursion tree. This property of overlapping subproblems is the\nsecond hallmark of when dynamic programming applies (the ﬁrst hallmark being\noptimal substructure).\nInstead of computing the solution to recurrence (15.7) recursively, we compute\nthe optimal cost by using a tabular, bottom-up approach. (We present the corre-\nsponding top-down approach using memoization in Section 15.3.)\nWe shall implement the tabular, bottom-up method in the procedure MATRIX-\nCHAIN-ORDER, which appears below. This procedure assumes that matrix Ai\nhas dimensions pi\u00031 \t pi for i D 1; 2; : : : ; n.\nIts input is a sequence p D\nhp0; p1; : : : ; pni, where p:length D n C 1.\nThe procedure uses an auxiliary\ntable mŒ1 : : n; 1 : : n\u0002 for storing the mŒi; j \u0002 costs and another auxiliary table\nsŒ1 : : n \u0005 1; 2 : : n\u0002 that records which index of k achieved the optimal cost in com-\nputing mŒi; j \u0002. We shall use the table s to construct an optimal solution.\nIn order to implement the bottom-up approach, we must determine which entries",
    "parent_f7eb6956-2a6d-4f81-894d-81151c07fc10": "sŒ1 : : n \u0005 1; 2 : : n\u0002 that records which index of k achieved the optimal cost in com-\nputing mŒi; j \u0002. We shall use the table s to construct an optimal solution.\nIn order to implement the bottom-up approach, we must determine which entries\nof the table we refer to when computing mŒi; j \u0002. Equation (15.7) shows that the\ncost mŒi; j \u0002 of computing a matrix-chain product of j \u0005iC1 matrices depends only\non the costs of computing matrix-chain products of fewer than j \u0005 i C 1 matrices.\nThat is, for k D i; i C 1; : : : ; j \u0005 1, the matrix Ai::k is a product of k \u0005 i C 1 <\nj \u0005 i C 1 matrices and the matrix AkC1::j is a product of j \u0005 k < j \u0005 i C 1\nmatrices. Thus, the algorithm should ﬁll in the table m in a manner that corresponds\nto solving the parenthesization problem on matrix chains of increasing length. For\nthe subproblem of optimally parenthesizing the chain AiAiC1 \u0003 \u0003 \u0003 Aj, we consider\nthe subproblem size to be the length j \u0005 i C 1 of the chain.\nMATRIX-CHAIN-ORDER.p/\n1\nn D p:length \u0005 1\n2\nlet mŒ1 : : n; 1 : : n\u0002 and sŒ1 : : n \u0005 1; 2 : : n\u0002 be new tables\n3\nfor i D 1 to n\n4\nmŒi; i\u0002 D 0\n5\nfor l D 2 to n\n// l is the chain length\n6\nfor i D 1 to n \u0005 l C 1\n7\nj D i C l \u0005 1\n8\nmŒi; j \u0002 D 1\n9\nfor k D i to j \u0005 1\n10\nq D mŒi; k\u0002 C mŒk C 1; j \u0002 C pi\u00031pkpj\n11\nif q < mŒi; j \u0002\n12\nmŒi; j \u0002 D q\n13\nsŒi; j \u0002 D k\n14\nreturn m and s\n376\nChapter 15\nDynamic Programming\nA6\nA5\nA4\nA3\nA2\nA1\n0\n0\n0\n0\n0\n0\n15,750\n2,625\n750\n1,000\n5,000\n7,875\n4,375\n2,500\n3,500\n9,375\n7,125\n5,375\n11,875\n10,500\n15,125\n1\n2\n3\n4\n5\n6\n1\n2\n3\n4\n5\n6\nj\ni\nm\n1\n2\n3\n4\n5\n1\n3\n3\n5\n3\n3\n3\n3\n3\n3\n2\n3\n4\n5\n6\n1\n2\n3\n4\n5\nj\ni\ns\nFigure 15.5\nThe m and s tables computed by MATRIX-CHAIN-ORDER for n D 6 and the follow-\ning matrix dimensions:\nmatrix\nA1\nA2\nA3\nA4\nA5\nA6\ndimension\n30 \t 35\n35 \t 15\n15 \t 5\n5 \t 10\n10 \t 20\n20 \t 25\nThe tables are rotated so that the main diagonal runs horizontally. The m table uses only the main\ndiagonal and upper triangle, and the s table uses only the upper triangle. The minimum number of",
    "parent_0e8884b6-d935-4043-ae6e-95a0bf3c6504": "ing matrix dimensions:\nmatrix\nA1\nA2\nA3\nA4\nA5\nA6\ndimension\n30 \t 35\n35 \t 15\n15 \t 5\n5 \t 10\n10 \t 20\n20 \t 25\nThe tables are rotated so that the main diagonal runs horizontally. The m table uses only the main\ndiagonal and upper triangle, and the s table uses only the upper triangle. The minimum number of\nscalar multiplications to multiply the 6 matrices is mŒ1; 6\u0002 D 15,125. Of the darker entries, the pairs\nthat have the same shading are taken together in line 10 when computing\nmŒ2; 5\u0002 D min\n8\nˆ<\nˆ:\nmŒ2; 2\u0002 C mŒ3; 5\u0002 C p1p2p5 D 0 C 2500 C 35 \u0003 15 \u0003 20\nD 13,000 ;\nmŒ2; 3\u0002 C mŒ4; 5\u0002 C p1p3p5 D 2625 C 1000 C 35 \u0003 5 \u0003 20 D 7125 ;\nmŒ2; 4\u0002 C mŒ5; 5\u0002 C p1p4p5 D 4375 C 0 C 35 \u0003 10 \u0003 20\nD 11,375\nD 7125 :\nThe algorithm ﬁrst computes mŒi; i\u0002 D 0 for i D 1; 2; : : : ; n (the minimum\ncosts for chains of length 1) in lines 3–4. It then uses recurrence (15.7) to compute\nmŒi; i C 1\u0002 for i D 1; 2; : : : ; n \u0005 1 (the minimum costs for chains of length l D 2)\nduring the ﬁrst execution of the for loop in lines 5–13. The second time through the\nloop, it computes mŒi; iC2\u0002 for i D 1; 2; : : : ; n\u00052 (the minimum costs for chains of\nlength l D 3), and so forth. At each step, the mŒi; j \u0002 cost computed in lines 10–13\ndepends only on table entries mŒi; k\u0002 and mŒk C 1; j \u0002 already computed.\nFigure 15.5 illustrates this procedure on a chain of n D 6 matrices.\nSince\nwe have deﬁned mŒi; j \u0002 only for i \u0002 j , only the portion of the table m strictly\nabove the main diagonal is used. The ﬁgure shows the table rotated to make the\nmain diagonal run horizontally. The matrix chain is listed along the bottom. Us-\ning this layout, we can ﬁnd the minimum cost mŒi; j \u0002 for multiplying a subchain\nAiAiC1 \u0003 \u0003 \u0003 Aj of matrices at the intersection of lines running northeast from Ai and\n15.2\nMatrix-chain multiplication\n377\nnorthwest from Aj. Each horizontal row in the table contains the entries for matrix\nchains of the same length. MATRIX-CHAIN-ORDER computes the rows from bot-",
    "parent_6940fc84-449c-4e17-8875-90bf98736735": "AiAiC1 \u0003 \u0003 \u0003 Aj of matrices at the intersection of lines running northeast from Ai and\n15.2\nMatrix-chain multiplication\n377\nnorthwest from Aj. Each horizontal row in the table contains the entries for matrix\nchains of the same length. MATRIX-CHAIN-ORDER computes the rows from bot-\ntom to top and from left to right within each row. It computes each entry mŒi; j \u0002\nusing the products pi\u00031pkpj for k D i; i C 1; : : : ; j \u0005 1 and all entries southwest\nand southeast from mŒi; j \u0002.\nA simple inspection of the nested loop structure of MATRIX-CHAIN-ORDER\nyields a running time of O.n3/ for the algorithm. The loops are nested three deep,\nand each loop index (l, i, and k) takes on at most n\u00051 values. Exercise 15.2-5 asks\nyou to show that the running time of this algorithm is in fact also \u0004.n3/. The al-\ngorithm requires ‚.n2/ space to store the m and s tables. Thus, MATRIX-CHAIN-\nORDER is much more efﬁcient than the exponential-time method of enumerating\nall possible parenthesizations and checking each one.\nStep 4: Constructing an optimal solution\nAlthough MATRIX-CHAIN-ORDER determines the optimal number of scalar mul-\ntiplications needed to compute a matrix-chain product, it does not directly show\nhow to multiply the matrices. The table sŒ1 : : n \u0005 1; 2 : : n\u0002 gives us the informa-\ntion we need to do so. Each entry sŒi; j \u0002 records a value of k such that an op-\ntimal parenthesization of AiAiC1 \u0003 \u0003 \u0003 Aj splits the product between Ak and AkC1.\nThus, we know that the ﬁnal matrix multiplication in computing A1::n optimally\nis A1::sŒ1;n\u0004AsŒ1;n\u0004C1::n. We can determine the earlier matrix multiplications recur-\nsively, since sŒ1; sŒ1; n\u0002\u0002 determines the last matrix multiplication when computing\nA1::sŒ1;n\u0004 and sŒsŒ1; n\u0002 C 1; n\u0002 determines the last matrix multiplication when com-\nputing AsŒ1;n\u0004C1::n. The following recursive procedure prints an optimal parenthe-\nsization of hAi; AiC1; : : : ; Aji, given the s table computed by MATRIX-CHAIN-",
    "parent_a692c968-4bea-4d1d-960f-da56d5bba97f": "A1::sŒ1;n\u0004 and sŒsŒ1; n\u0002 C 1; n\u0002 determines the last matrix multiplication when com-\nputing AsŒ1;n\u0004C1::n. The following recursive procedure prints an optimal parenthe-\nsization of hAi; AiC1; : : : ; Aji, given the s table computed by MATRIX-CHAIN-\nORDER and the indices i and j . The initial call PRINT-OPTIMAL-PARENS.s; 1; n/\nprints an optimal parenthesization of hA1; A2; : : : ; Ani.\nPRINT-OPTIMAL-PARENS.s; i; j /\n1\nif i == j\n2\nprint “A”i\n3\nelse print “(”\n4\nPRINT-OPTIMAL-PARENS.s; i; sŒi; j \u0002/\n5\nPRINT-OPTIMAL-PARENS.s; sŒi; j \u0002 C 1; j /\n6\nprint “)”\nIn the example of Figure 15.5, the call PRINT-OPTIMAL-PARENS.s; 1; 6/ prints\nthe parenthesization ..A1.A2A3//..A4A5/A6//.\n378\nChapter 15\nDynamic Programming\nExercises\n15.2-1\nFind an optimal parenthesization of a matrix-chain product whose sequence of\ndimensions is h5; 10; 3; 12; 5; 50; 6i.\n15.2-2\nGive a recursive algorithm MATRIX-CHAIN-MULTIPLY.A; s; i; j / that actually\nperforms the optimal matrix-chain multiplication, given the sequence of matrices\nhA1; A2; : : : ; Ani, the s table computed by MATRIX-CHAIN-ORDER, and the in-\ndices i and j . (The initial call would be MATRIX-CHAIN-MULTIPLY.A; s; 1; n/.)\n15.2-3\nUse the substitution method to show that the solution to the recurrence (15.6)\nis \u0004.2n/.\n15.2-4\nDescribe the subproblem graph for matrix-chain multiplication with an input chain\nof length n. How many vertices does it have? How many edges does it have, and\nwhich edges are they?\n15.2-5\nLet R.i; j / be the number of times that table entry mŒi; j \u0002 is referenced while\ncomputing other table entries in a call of MATRIX-CHAIN-ORDER. Show that the\ntotal number of references for the entire table is\nn\nX\niD1\nn\nX\njDi\nR.i; j / D n3 \u0005 n\n3\n:\n(Hint: You may ﬁnd equation (A.3) useful.)\n15.2-6\nShow that a full parenthesization of an n-element expression has exactly n\u00051 pairs\nof parentheses.\n15.3\nElements of dynamic programming\nAlthough we have just worked through two examples of the dynamic-programming",
    "parent_f2e41328-4f30-43bf-b37f-6214bd20b458": "X\niD1\nn\nX\njDi\nR.i; j / D n3 \u0005 n\n3\n:\n(Hint: You may ﬁnd equation (A.3) useful.)\n15.2-6\nShow that a full parenthesization of an n-element expression has exactly n\u00051 pairs\nof parentheses.\n15.3\nElements of dynamic programming\nAlthough we have just worked through two examples of the dynamic-programming\nmethod, you might still be wondering just when the method applies. From an en-\ngineering perspective, when should we look for a dynamic-programming solution\nto a problem? In this section, we examine the two key ingredients that an opti-\n15.3\nElements of dynamic programming\n379\nmization problem must have in order for dynamic programming to apply: optimal\nsubstructure and overlapping subproblems. We also revisit and discuss more fully\nhow memoization might help us take advantage of the overlapping-subproblems\nproperty in a top-down recursive approach.\nOptimal substructure\nThe ﬁrst step in solving an optimization problem by dynamic programming is to\ncharacterize the structure of an optimal solution. Recall that a problem exhibits\noptimal substructure if an optimal solution to the problem contains within it opti-\nmal solutions to subproblems. Whenever a problem exhibits optimal substructure,\nwe have a good clue that dynamic programming might apply. (As Chapter 16 dis-\ncusses, it also might mean that a greedy strategy applies, however.) In dynamic\nprogramming, we build an optimal solution to the problem from optimal solutions\nto subproblems. Consequently, we must take care to ensure that the range of sub-\nproblems we consider includes those used in an optimal solution.\nWe discovered optimal substructure in both of the problems we have examined\nin this chapter so far. In Section 15.1, we observed that the optimal way of cut-\nting up a rod of length n (if we make any cuts at all) involves optimally cutting\nup the two pieces resulting from the ﬁrst cut. In Section 15.2, we observed that\nan optimal parenthesization of AiAiC1 \u0003 \u0003 \u0003 Aj that splits the product between Ak",
    "parent_6ec5c4b9-7e1a-4b3a-9040-f4334795e26c": "ting up a rod of length n (if we make any cuts at all) involves optimally cutting\nup the two pieces resulting from the ﬁrst cut. In Section 15.2, we observed that\nan optimal parenthesization of AiAiC1 \u0003 \u0003 \u0003 Aj that splits the product between Ak\nand AkC1 contains within it optimal solutions to the problems of parenthesizing\nAiAiC1 \u0003 \u0003 \u0003 Ak and AkC1AkC2 \u0003 \u0003 \u0003 Aj.\nYou will ﬁnd yourself following a common pattern in discovering optimal sub-\nstructure:\n1. You show that a solution to the problem consists of making a choice, such as\nchoosing an initial cut in a rod or choosing an index at which to split the matrix\nchain. Making this choice leaves one or more subproblems to be solved.\n2. You suppose that for a given problem, you are given the choice that leads to an\noptimal solution. You do not concern yourself yet with how to determine this\nchoice. You just assume that it has been given to you.\n3. Given this choice, you determine which subproblems ensue and how to best\ncharacterize the resulting space of subproblems.\n4. You show that the solutions to the subproblems used within an optimal solution\nto the problem must themselves be optimal by using a “cut-and-paste” tech-\nnique. You do so by supposing that each of the subproblem solutions is not\noptimal and then deriving a contradiction. In particular, by “cutting out” the\nnonoptimal solution to each subproblem and “pasting in” the optimal one, you\nshow that you can get a better solution to the original problem, thus contradict-\ning your supposition that you already had an optimal solution. If an optimal\n380\nChapter 15\nDynamic Programming\nsolution gives rise to more than one subproblem, they are typically so similar\nthat you can modify the cut-and-paste argument for one to apply to the others\nwith little effort.\nTo characterize the space of subproblems, a good rule of thumb says to try to\nkeep the space as simple as possible and then expand it as necessary. For example,",
    "parent_02e50a39-3890-4ceb-9f24-08d23a8a5cef": "that you can modify the cut-and-paste argument for one to apply to the others\nwith little effort.\nTo characterize the space of subproblems, a good rule of thumb says to try to\nkeep the space as simple as possible and then expand it as necessary. For example,\nthe space of subproblems that we considered for the rod-cutting problem contained\nthe problems of optimally cutting up a rod of length i for each size i. This sub-\nproblem space worked well, and we had no need to try a more general space of\nsubproblems.\nConversely, suppose that we had tried to constrain our subproblem space for\nmatrix-chain multiplication to matrix products of the form A1A2 \u0003 \u0003 \u0003 Aj. As before,\nan optimal parenthesization must split this product between Ak and AkC1 for some\n1 \u0002 k < j . Unless we could guarantee that k always equals j \u0005 1, we would ﬁnd\nthat we had subproblems of the form A1A2 \u0003 \u0003 \u0003 Ak and AkC1AkC2 \u0003 \u0003 \u0003 Aj, and that\nthe latter subproblem is not of the form A1A2 \u0003 \u0003 \u0003 Aj. For this problem, we needed\nto allow our subproblems to vary at “both ends,” that is, to allow both i and j to\nvary in the subproblem AiAiC1 \u0003 \u0003 \u0003 Aj.\nOptimal substructure varies across problem domains in two ways:\n1. how many subproblems an optimal solution to the original problem uses, and\n2. how many choices we have in determining which subproblem(s) to use in an\noptimal solution.\nIn the rod-cutting problem, an optimal solution for cutting up a rod of size n\nuses just one subproblem (of size n \u0005 i), but we must consider n choices for i\nin order to determine which one yields an optimal solution. Matrix-chain mul-\ntiplication for the subchain AiAiC1 \u0003 \u0003 \u0003 Aj serves as an example with two sub-\nproblems and j \u0005 i choices. For a given matrix Ak at which we split the prod-\nuct, we have two subproblems—parenthesizing AiAiC1 \u0003 \u0003 \u0003 Ak and parenthesizing\nAkC1AkC2 \u0003 \u0003 \u0003 Aj—and we must solve both of them optimally. Once we determine\nthe optimal solutions to subproblems, we choose from among j \u0005 i candidates for",
    "parent_7ef28edb-22e0-4a18-9a7a-51b0c9639c9a": "uct, we have two subproblems—parenthesizing AiAiC1 \u0003 \u0003 \u0003 Ak and parenthesizing\nAkC1AkC2 \u0003 \u0003 \u0003 Aj—and we must solve both of them optimally. Once we determine\nthe optimal solutions to subproblems, we choose from among j \u0005 i candidates for\nthe index k.\nInformally, the running time of a dynamic-programming algorithm depends on\nthe product of two factors: the number of subproblems overall and how many\nchoices we look at for each subproblem. In rod cutting, we had ‚.n/ subproblems\noverall, and at most n choices to examine for each, yielding an O.n2/ running time.\nMatrix-chain multiplication had ‚.n2/ subproblems overall, and in each we had at\nmost n \u0005 1 choices, giving an O.n3/ running time (actually, a ‚.n3/ running time,\nby Exercise 15.2-5).\nUsually, the subproblem graph gives an alternative way to perform the same\nanalysis. Each vertex corresponds to a subproblem, and the choices for a sub-\n15.3\nElements of dynamic programming\n381\nproblem are the edges incident to that subproblem. Recall that in rod cutting,\nthe subproblem graph had n vertices and at most n edges per vertex, yielding an\nO.n2/ running time. For matrix-chain multiplication, if we were to draw the sub-\nproblem graph, it would have ‚.n2/ vertices and each vertex would have degree at\nmost n \u0005 1, giving a total of O.n3/ vertices and edges.\nDynamic programming often uses optimal substructure in a bottom-up fashion.\nThat is, we ﬁrst ﬁnd optimal solutions to subproblems and, having solved the sub-\nproblems, we ﬁnd an optimal solution to the problem. Finding an optimal solu-\ntion to the problem entails making a choice among subproblems as to which we\nwill use in solving the problem. The cost of the problem solution is usually the\nsubproblem costs plus a cost that is directly attributable to the choice itself. In\nrod cutting, for example, ﬁrst we solved the subproblems of determining optimal\nways to cut up rods of length i for i D 0; 1; : : : ; n \u0005 1, and then we determined",
    "parent_0a511db0-7a19-4e90-834f-47c90b8a68c5": "subproblem costs plus a cost that is directly attributable to the choice itself. In\nrod cutting, for example, ﬁrst we solved the subproblems of determining optimal\nways to cut up rods of length i for i D 0; 1; : : : ; n \u0005 1, and then we determined\nwhich such subproblem yielded an optimal solution for a rod of length n, using\nequation (15.2). The cost attributable to the choice itself is the term pi in equa-\ntion (15.2). In matrix-chain multiplication, we determined optimal parenthesiza-\ntions of subchains of AiAiC1 \u0003 \u0003 \u0003 Aj, and then we chose the matrix Ak at which to\nsplit the product. The cost attributable to the choice itself is the term pi\u00031pkpj.\nIn Chapter 16, we shall examine “greedy algorithms,” which have many similar-\nities to dynamic programming. In particular, problems to which greedy algorithms\napply have optimal substructure. One major difference between greedy algorithms\nand dynamic programming is that instead of ﬁrst ﬁnding optimal solutions to sub-\nproblems and then making an informed choice, greedy algorithms ﬁrst make a\n“greedy” choice—the choice that looks best at the time—and then solve a resulting\nsubproblem, without bothering to solve all possible related smaller subproblems.\nSurprisingly, in some cases this strategy works!\nSubtleties\nYou should be careful not to assume that optimal substructure applies when it does\nnot. Consider the following two problems in which we are given a directed graph\nG D .V; E/ and vertices u; \u0003 2 V .\nUnweighted shortest path:3 Find a path from u to \u0003 consisting of the fewest\nedges. Such a path must be simple, since removing a cycle from a path pro-\nduces a path with fewer edges.\n3We use the term “unweighted” to distinguish this problem from that of ﬁnding shortest paths with\nweighted edges, which we shall see in Chapters 24 and 25. We can use the breadth-ﬁrst search\ntechnique of Chapter 22 to solve the unweighted problem.\n382\nChapter 15\nDynamic Programming\nq\nr\ns\nt\nFigure 15.6",
    "parent_b1a1363a-8090-4014-b5ee-d66d487f780f": "weighted edges, which we shall see in Chapters 24 and 25. We can use the breadth-ﬁrst search\ntechnique of Chapter 22 to solve the unweighted problem.\n382\nChapter 15\nDynamic Programming\nq\nr\ns\nt\nFigure 15.6\nA directed graph showing that the problem of ﬁnding a longest simple path in an\nunweighted directed graph does not have optimal substructure. The path q ! r ! t is a longest\nsimple path from q to t, but the subpath q ! r is not a longest simple path from q to r, nor is the\nsubpath r ! t a longest simple path from r to t.\nUnweighted longest simple path: Find a simple path from u to \u0003 consisting of\nthe most edges. We need to include the requirement of simplicity because other-\nwise we can traverse a cycle as many times as we like to create paths with an\narbitrarily large number of edges.\nThe unweighted shortest-path problem exhibits optimal substructure, as follows.\nSuppose that u ¤ \u0003, so that the problem is nontrivial. Then, any path p from u\nto \u0003 must contain an intermediate vertex, say w. (Note that w may be u or \u0003.)\nThus, we can decompose the path u\np; \u0003 into subpaths u\np1\n; w\np2\n; \u0003. Clearly, the\nnumber of edges in p equals the number of edges in p1 plus the number of edges\nin p2. We claim that if p is an optimal (i.e., shortest) path from u to \u0003, then p1\nmust be a shortest path from u to w. Why? We use a “cut-and-paste” argument:\nif there were another path, say p0\n1, from u to w with fewer edges than p1, then we\ncould cut out p1 and paste in p0\n1 to produce a path u\np0\n1\n; w\np2\n; \u0003 with fewer edges\nthan p, thus contradicting p’s optimality. Symmetrically, p2 must be a shortest\npath from w to \u0003. Thus, we can ﬁnd a shortest path from u to \u0003 by considering\nall intermediate vertices w, ﬁnding a shortest path from u to w and a shortest path\nfrom w to \u0003, and choosing an intermediate vertex w that yields the overall shortest\npath. In Section 25.2, we use a variant of this observation of optimal substructure",
    "parent_19760824-bfff-43c5-8a6e-3311e8454af8": "all intermediate vertices w, ﬁnding a shortest path from u to w and a shortest path\nfrom w to \u0003, and choosing an intermediate vertex w that yields the overall shortest\npath. In Section 25.2, we use a variant of this observation of optimal substructure\nto ﬁnd a shortest path between every pair of vertices on a weighted, directed graph.\nYou might be tempted to assume that the problem of ﬁnding an unweighted\nlongest simple path exhibits optimal substructure as well. After all, if we decom-\npose a longest simple path u\np; \u0003 into subpaths u\np1\n; w\np2\n; \u0003, then mustn’t p1\nbe a longest simple path from u to w, and mustn’t p2 be a longest simple path\nfrom w to \u0003? The answer is no! Figure 15.6 supplies an example. Consider the\npath q ! r ! t, which is a longest simple path from q to t. Is q ! r a longest\nsimple path from q to r? No, for the path q ! s ! t ! r is a simple path\nthat is longer. Is r ! t a longest simple path from r to t? No again, for the path\nr ! q ! s ! t is a simple path that is longer.\n15.3\nElements of dynamic programming\n383\nThis example shows that for longest simple paths, not only does the problem\nlack optimal substructure, but we cannot necessarily assemble a “legal” solution\nto the problem from solutions to subproblems. If we combine the longest simple\npaths q ! s ! t ! r and r ! q ! s ! t, we get the path q ! s ! t ! r !\nq ! s ! t, which is not simple. Indeed, the problem of ﬁnding an unweighted\nlongest simple path does not appear to have any sort of optimal substructure. No\nefﬁcient dynamic-programming algorithm for this problem has ever been found. In\nfact, this problem is NP-complete, which—as we shall see in Chapter 34—means\nthat we are unlikely to ﬁnd a way to solve it in polynomial time.\nWhy is the substructure of a longest simple path so different from that of a short-\nest path? Although a solution to a problem for both longest and shortest paths uses\ntwo subproblems, the subproblems in ﬁnding the longest simple path are not inde-",
    "parent_3b63bf86-1577-42b0-85ef-dd17e8876926": "Why is the substructure of a longest simple path so different from that of a short-\nest path? Although a solution to a problem for both longest and shortest paths uses\ntwo subproblems, the subproblems in ﬁnding the longest simple path are not inde-\npendent, whereas for shortest paths they are. What do we mean by subproblems\nbeing independent? We mean that the solution to one subproblem does not affect\nthe solution to another subproblem of the same problem. For the example of Fig-\nure 15.6, we have the problem of ﬁnding a longest simple path from q to t with two\nsubproblems: ﬁnding longest simple paths from q to r and from r to t. For the ﬁrst\nof these subproblems, we choose the path q ! s ! t ! r, and so we have also\nused the vertices s and t. We can no longer use these vertices in the second sub-\nproblem, since the combination of the two solutions to subproblems would yield a\npath that is not simple. If we cannot use vertex t in the second problem, then we\ncannot solve it at all, since t is required to be on the path that we ﬁnd, and it is\nnot the vertex at which we are “splicing” together the subproblem solutions (that\nvertex being r). Because we use vertices s and t in one subproblem solution, we\ncannot use them in the other subproblem solution. We must use at least one of them\nto solve the other subproblem, however, and we must use both of them to solve it\noptimally. Thus, we say that these subproblems are not independent. Looked at\nanother way, using resources in solving one subproblem (those resources being\nvertices) renders them unavailable for the other subproblem.\nWhy, then, are the subproblems independent for ﬁnding a shortest path? The\nanswer is that by nature, the subproblems do not share resources. We claim that\nif a vertex w is on a shortest path p from u to \u0003, then we can splice together any\nshortest path u\np1\n; w and any shortest path w\np2\n; \u0003 to produce a shortest path from u",
    "parent_f090ad36-ab59-433e-9bc8-33e11bc43d5a": "answer is that by nature, the subproblems do not share resources. We claim that\nif a vertex w is on a shortest path p from u to \u0003, then we can splice together any\nshortest path u\np1\n; w and any shortest path w\np2\n; \u0003 to produce a shortest path from u\nto \u0003. We are assured that, other than w, no vertex can appear in both paths p1\nand p2. Why? Suppose that some vertex x ¤ w appears in both p1 and p2, so that\nwe can decompose p1 as u\npux\n; x ; w and p2 as w ; x\npx\u0002\n; \u0003. By the optimal\nsubstructure of this problem, path p has as many edges as p1 and p2 together; let’s\nsay that p has e edges. Now let us construct a path p0 D u\npux\n; x\npx\u0002\n; \u0003 from u to \u0003.\nBecause we have excised the paths from x to w and from w to x, each of which\ncontains at least one edge, path p0 contains at most e \u0005 2 edges, which contradicts\n384\nChapter 15\nDynamic Programming\nthe assumption that p is a shortest path. Thus, we are assured that the subproblems\nfor the shortest-path problem are independent.\nBoth problems examined in Sections 15.1 and 15.2 have independent subprob-\nlems. In matrix-chain multiplication, the subproblems are multiplying subchains\nAiAiC1 \u0003 \u0003 \u0003 Ak and AkC1AkC2 \u0003 \u0003 \u0003 Aj. These subchains are disjoint, so that no ma-\ntrix could possibly be included in both of them. In rod cutting, to determine the\nbest way to cut up a rod of length n, we look at the best ways of cutting up rods\nof length i for i D 0; 1; : : : ; n \u0005 1. Because an optimal solution to the length-n\nproblem includes just one of these subproblem solutions (after we have cut off the\nﬁrst piece), independence of subproblems is not an issue.\nOverlapping subproblems\nThe second ingredient that an optimization problem must have for dynamic pro-\ngramming to apply is that the space of subproblems must be “small” in the sense\nthat a recursive algorithm for the problem solves the same subproblems over and\nover, rather than always generating new subproblems. Typically, the total number",
    "parent_230ca5de-aa48-4073-bb52-cdca06d98013": "gramming to apply is that the space of subproblems must be “small” in the sense\nthat a recursive algorithm for the problem solves the same subproblems over and\nover, rather than always generating new subproblems. Typically, the total number\nof distinct subproblems is a polynomial in the input size. When a recursive algo-\nrithm revisits the same problem repeatedly, we say that the optimization problem\nhas overlapping subproblems.4 In contrast, a problem for which a divide-and-\nconquer approach is suitable usually generates brand-new problems at each step\nof the recursion. Dynamic-programming algorithms typically take advantage of\noverlapping subproblems by solving each subproblem once and then storing the\nsolution in a table where it can be looked up when needed, using constant time per\nlookup.\nIn Section 15.1, we brieﬂy examined how a recursive solution to rod cut-\nting makes exponentially many calls to ﬁnd solutions of smaller subproblems.\nOur dynamic-programming solution takes an exponential-time recursive algorithm\ndown to quadratic time.\nTo illustrate the overlapping-subproblems property in greater detail, let us re-\nexamine the matrix-chain multiplication problem. Referring back to Figure 15.5,\nobserve that MATRIX-CHAIN-ORDER repeatedly looks up the solution to subprob-\nlems in lower rows when solving subproblems in higher rows. For example, it\nreferences entry mŒ3; 4\u0002 four times: during the computations of mŒ2; 4\u0002, mŒ1; 4\u0002,\n4It may seem strange that dynamic programming relies on subproblems being both independent\nand overlapping. Although these requirements may sound contradictory, they describe two different\nnotions, rather than two points on the same axis. Two subproblems of the same problem are inde-\npendent if they do not share resources. Two subproblems are overlapping if they are really the same\nsubproblem that occurs as a subproblem of different problems.\n15.3\nElements of dynamic programming\n385\n1..4\n1..1\n2..4\n1..2\n3..4\n1..3\n4..4\n2..2\n3..4\n2..3\n4..4",
    "parent_dbac6b80-5984-416f-8de4-f84c722c8e8c": "pendent if they do not share resources. Two subproblems are overlapping if they are really the same\nsubproblem that occurs as a subproblem of different problems.\n15.3\nElements of dynamic programming\n385\n1..4\n1..1\n2..4\n1..2\n3..4\n1..3\n4..4\n2..2\n3..4\n2..3\n4..4\n1..1\n2..2\n3..3\n4..4\n1..1\n2..3\n1..2\n3..3\n3..3\n4..4\n2..2\n3..3\n2..2\n3..3\n1..1\n2..2\nFigure 15.7\nThe recursion tree for the computation of RECURSIVE-MATRIX-CHAIN.p; 1; 4/.\nEach node contains the parameters i and j. The computations performed in a shaded subtree are\nreplaced by a single table lookup in MEMOIZED-MATRIX-CHAIN.\nmŒ3; 5\u0002, and mŒ3; 6\u0002. If we were to recompute mŒ3; 4\u0002 each time, rather than just\nlooking it up, the running time would increase dramatically. To see how, consider\nthe following (inefﬁcient) recursive procedure that determines mŒi; j \u0002, the mini-\nmum number of scalar multiplications needed to compute the matrix-chain product\nAi::j D AiAiC1 \u0003 \u0003 \u0003 Aj. The procedure is based directly on the recurrence (15.7).\nRECURSIVE-MATRIX-CHAIN.p; i; j /\n1\nif i == j\n2\nreturn 0\n3\nmŒi; j \u0002 D 1\n4\nfor k D i to j \u0005 1\n5\nq D RECURSIVE-MATRIX-CHAIN.p; i; k/\nC RECURSIVE-MATRIX-CHAIN.p; k C 1; j /\nC pi\u00031pkpj\n6\nif q < mŒi; j \u0002\n7\nmŒi; j \u0002 D q\n8\nreturn mŒi; j \u0002\nFigure 15.7 shows the recursion tree produced by the call RECURSIVE-MATRIX-\nCHAIN.p; 1; 4/. Each node is labeled by the values of the parameters i and j .\nObserve that some pairs of values occur many times.\nIn fact, we can show that the time to compute mŒ1; n\u0002 by this recursive proce-\ndure is at least exponential in n. Let T .n/ denote the time taken by RECURSIVE-\nMATRIX-CHAIN to compute an optimal parenthesization of a chain of n matrices.\nBecause the execution of lines 1–2 and of lines 6–7 each take at least unit time, as\n386\nChapter 15\nDynamic Programming\ndoes the multiplication in line 5, inspection of the procedure yields the recurrence\nT .1/\n\u0006\n1 ;\nT .n/\n\u0006\n1 C\nn\u00031\nX\nkD1\n.T .k/ C T .n \u0005 k/ C 1/\nfor n > 1 :",
    "parent_3c5a133b-9d9a-47c1-b450-5f27130c9c95": "Because the execution of lines 1–2 and of lines 6–7 each take at least unit time, as\n386\nChapter 15\nDynamic Programming\ndoes the multiplication in line 5, inspection of the procedure yields the recurrence\nT .1/\n\u0006\n1 ;\nT .n/\n\u0006\n1 C\nn\u00031\nX\nkD1\n.T .k/ C T .n \u0005 k/ C 1/\nfor n > 1 :\nNoting that for i D 1; 2; : : : ; n \u0005 1, each term T .i/ appears once as T .k/ and once\nas T .n \u0005 k/, and collecting the n \u0005 1 1s in the summation together with the 1 out\nfront, we can rewrite the recurrence as\nT .n/ \u0006 2\nn\u00031\nX\niD1\nT .i/ C n :\n(15.8)\nWe shall prove that T .n/ D \u0004.2n/ using the substitution method. Speciﬁ-\ncally, we shall show that T .n/ \u0006 2n\u00031 for all n \u0006 1. The basis is easy, since\nT .1/ \u0006 1 D 20. Inductively, for n \u0006 2 we have\nT .n/\n\u0006\n2\nn\u00031\nX\niD1\n2i\u00031 C n\nD\n2\nn\u00032\nX\niD0\n2i C n\nD\n2.2n\u00031 \u0005 1/ C n\n(by equation (A.5))\nD\n2n \u0005 2 C n\n\u0006\n2n\u00031 ;\nwhich completes the proof. Thus, the total amount of work performed by the call\nRECURSIVE-MATRIX-CHAIN.p; 1; n/ is at least exponential in n.\nCompare this top-down, recursive algorithm (without memoization) with the\nbottom-up dynamic-programming algorithm. The latter is more efﬁcient because\nit takes advantage of the overlapping-subproblems property. Matrix-chain mul-\ntiplication has only ‚.n2/ distinct subproblems, and the dynamic-programming\nalgorithm solves each exactly once. The recursive algorithm, on the other hand,\nmust again solve each subproblem every time it reappears in the recursion tree.\nWhenever a recursion tree for the natural recursive solution to a problem contains\nthe same subproblem repeatedly, and the total number of distinct subproblems is\nsmall, dynamic programming can improve efﬁciency, sometimes dramatically.\n15.3\nElements of dynamic programming\n387\nReconstructing an optimal solution\nAs a practical matter, we often store which choice we made in each subproblem in\na table so that we do not have to reconstruct this information from the costs that we\nstored.",
    "parent_a66d4b9e-e67d-45a1-acf7-c6c5ebd687e6": "15.3\nElements of dynamic programming\n387\nReconstructing an optimal solution\nAs a practical matter, we often store which choice we made in each subproblem in\na table so that we do not have to reconstruct this information from the costs that we\nstored.\nFor matrix-chain multiplication, the table sŒi; j \u0002 saves us a signiﬁcant amount of\nwork when reconstructing an optimal solution. Suppose that we did not maintain\nthe sŒi; j \u0002 table, having ﬁlled in only the table mŒi; j \u0002 containing optimal subprob-\nlem costs. We choose from among j \u0005 i possibilities when we determine which\nsubproblems to use in an optimal solution to parenthesizing AiAiC1 \u0003 \u0003 \u0003 Aj, and\nj \u0005 i is not a constant. Therefore, it would take ‚.j \u0005 i/ D !.1/ time to recon-\nstruct which subproblems we chose for a solution to a given problem. By storing\nin sŒi; j \u0002 the index of the matrix at which we split the product AiAiC1 \u0003 \u0003 \u0003 Aj, we\ncan reconstruct each choice in O.1/ time.\nMemoization\nAs we saw for the rod-cutting problem, there is an alternative approach to dy-\nnamic programming that often offers the efﬁciency of the bottom-up dynamic-\nprogramming approach while maintaining a top-down strategy.\nThe idea is to\nmemoize the natural, but inefﬁcient, recursive algorithm. As in the bottom-up ap-\nproach, we maintain a table with subproblem solutions, but the control structure\nfor ﬁlling in the table is more like the recursive algorithm.\nA memoized recursive algorithm maintains an entry in a table for the solution to\neach subproblem. Each table entry initially contains a special value to indicate that\nthe entry has yet to be ﬁlled in. When the subproblem is ﬁrst encountered as the\nrecursive algorithm unfolds, its solution is computed and then stored in the table.\nEach subsequent time that we encounter this subproblem, we simply look up the\nvalue stored in the table and return it.5\nHere is a memoized version of RECURSIVE-MATRIX-CHAIN. Note where it",
    "parent_8d06fa03-402e-4a85-8464-82ddb9a9ac16": "recursive algorithm unfolds, its solution is computed and then stored in the table.\nEach subsequent time that we encounter this subproblem, we simply look up the\nvalue stored in the table and return it.5\nHere is a memoized version of RECURSIVE-MATRIX-CHAIN. Note where it\nresembles the memoized top-down method for the rod-cutting problem.\n5This approach presupposes that we know the set of all possible subproblem parameters and that we\nhave established the relationship between table positions and subproblems. Another, more general,\napproach is to memoize by using hashing with the subproblem parameters as keys.\n388\nChapter 15\nDynamic Programming\nMEMOIZED-MATRIX-CHAIN.p/\n1\nn D p:length \u0005 1\n2\nlet mŒ1 : : n; 1 : : n\u0002 be a new table\n3\nfor i D 1 to n\n4\nfor j D i to n\n5\nmŒi; j \u0002 D 1\n6\nreturn LOOKUP-CHAIN.m; p; 1; n/\nLOOKUP-CHAIN.m; p; i; j /\n1\nif mŒi; j \u0002 < 1\n2\nreturn mŒi; j \u0002\n3\nif i == j\n4\nmŒi; j \u0002 D 0\n5\nelse for k D i to j \u0005 1\n6\nq D LOOKUP-CHAIN.m; p; i; k/\nC LOOKUP-CHAIN.m; p; k C 1; j / C pi\u00031pkpj\n7\nif q < mŒi; j \u0002\n8\nmŒi; j \u0002 D q\n9\nreturn mŒi; j \u0002\nThe MEMOIZED-MATRIX-CHAIN procedure, like MATRIX-CHAIN-ORDER,\nmaintains a table mŒ1 : : n; 1 : : n\u0002 of computed values of mŒi; j \u0002, the minimum num-\nber of scalar multiplications needed to compute the matrix Ai::j. Each table entry\ninitially contains the value 1 to indicate that the entry has yet to be ﬁlled in. Upon\ncalling LOOKUP-CHAIN.m; p; i; j /, if line 1 ﬁnds that mŒi; j \u0002 < 1, then the pro-\ncedure simply returns the previously computed cost mŒi; j \u0002 in line 2. Otherwise,\nthe cost is computed as in RECURSIVE-MATRIX-CHAIN, stored in mŒi; j \u0002, and\nreturned. Thus, LOOKUP-CHAIN.m; p; i; j / always returns the value of mŒi; j \u0002,\nbut it computes it only upon the ﬁrst call of LOOKUP-CHAIN with these speciﬁc\nvalues of i and j .\nFigure 15.7 illustrates how MEMOIZED-MATRIX-CHAIN saves time compared\nwith RECURSIVE-MATRIX-CHAIN. Shaded subtrees represent values that it looks\nup rather than recomputes.",
    "parent_fcd83eea-3240-4d21-a6d4-d1f664bc9289": "but it computes it only upon the ﬁrst call of LOOKUP-CHAIN with these speciﬁc\nvalues of i and j .\nFigure 15.7 illustrates how MEMOIZED-MATRIX-CHAIN saves time compared\nwith RECURSIVE-MATRIX-CHAIN. Shaded subtrees represent values that it looks\nup rather than recomputes.\nLike the bottom-up dynamic-programming algorithm MATRIX-CHAIN-ORDER,\nthe procedure MEMOIZED-MATRIX-CHAIN runs in O.n3/ time.\nLine 5 of\nMEMOIZED-MATRIX-CHAIN executes ‚.n2/ times. We can categorize the calls\nof LOOKUP-CHAIN into two types:\n1. calls in which mŒi; j \u0002 D 1, so that lines 3–9 execute, and\n2. calls in which mŒi; j \u0002 < 1, so that LOOKUP-CHAIN simply returns in line 2.\n15.3\nElements of dynamic programming\n389\nThere are ‚.n2/ calls of the ﬁrst type, one per table entry. All calls of the sec-\nond type are made as recursive calls by calls of the ﬁrst type. Whenever a given\ncall of LOOKUP-CHAIN makes recursive calls, it makes O.n/ of them. There-\nfore, there are O.n3/ calls of the second type in all. Each call of the second type\ntakes O.1/ time, and each call of the ﬁrst type takes O.n/ time plus the time spent\nin its recursive calls. The total time, therefore, is O.n3/. Memoization thus turns\nan \u0004.2n/-time algorithm into an O.n3/-time algorithm.\nIn summary, we can solve the matrix-chain multiplication problem by either a\ntop-down, memoized dynamic-programming algorithm or a bottom-up dynamic-\nprogramming algorithm in O.n3/ time.\nBoth methods take advantage of the\noverlapping-subproblems property. There are only ‚.n2/ distinct subproblems in\ntotal, and either of these methods computes the solution to each subproblem only\nonce. Without memoization, the natural recursive algorithm runs in exponential\ntime, since solved subproblems are repeatedly solved.\nIn general practice, if all subproblems must be solved at least once, a bottom-up\ndynamic-programming algorithm usually outperforms the corresponding top-down\nmemoized algorithm by a constant factor, because the bottom-up algorithm has no",
    "parent_66721d74-f614-47a4-a7fc-268b9b0b4f68": "time, since solved subproblems are repeatedly solved.\nIn general practice, if all subproblems must be solved at least once, a bottom-up\ndynamic-programming algorithm usually outperforms the corresponding top-down\nmemoized algorithm by a constant factor, because the bottom-up algorithm has no\noverhead for recursion and less overhead for maintaining the table. Moreover, for\nsome problems we can exploit the regular pattern of table accesses in the dynamic-\nprogramming algorithm to reduce time or space requirements even further. Alter-\nnatively, if some subproblems in the subproblem space need not be solved at all,\nthe memoized solution has the advantage of solving only those subproblems that\nare deﬁnitely required.\nExercises\n15.3-1\nWhich is a more efﬁcient way to determine the optimal number of multiplications\nin a matrix-chain multiplication problem: enumerating all the ways of parenthesiz-\ning the product and computing the number of multiplications for each, or running\nRECURSIVE-MATRIX-CHAIN? Justify your answer.\n15.3-2\nDraw the recursion tree for the MERGE-SORT procedure from Section 2.3.1 on an\narray of 16 elements. Explain why memoization fails to speed up a good divide-\nand-conquer algorithm such as MERGE-SORT.\n15.3-3\nConsider a variant of the matrix-chain multiplication problem in which the goal is\nto parenthesize the sequence of matrices so as to maximize, rather than minimize,\n390\nChapter 15\nDynamic Programming\nthe number of scalar multiplications. Does this problem exhibit optimal substruc-\nture?\n15.3-4\nAs stated, in dynamic programming we ﬁrst solve the subproblems and then choose\nwhich of them to use in an optimal solution to the problem. Professor Capulet\nclaims that we do not always need to solve all the subproblems in order to ﬁnd an\noptimal solution. She suggests that we can ﬁnd an optimal solution to the matrix-\nchain multiplication problem by always choosing the matrix Ak at which to split",
    "parent_683c8012-f91f-4970-a4ae-d643015fa134": "claims that we do not always need to solve all the subproblems in order to ﬁnd an\noptimal solution. She suggests that we can ﬁnd an optimal solution to the matrix-\nchain multiplication problem by always choosing the matrix Ak at which to split\nthe subproduct AiAiC1 \u0003 \u0003 \u0003 Aj (by selecting k to minimize the quantity pi\u00031pkpj)\nbefore solving the subproblems. Find an instance of the matrix-chain multiplica-\ntion problem for which this greedy approach yields a suboptimal solution.\n15.3-5\nSuppose that in the rod-cutting problem of Section 15.1, we also had limit li on the\nnumber of pieces of length i that we are allowed to produce, for i D 1; 2; : : : ; n.\nShow that the optimal-substructure property described in Section 15.1 no longer\nholds.\n15.3-6\nImagine that you wish to exchange one currency for another. You realize that\ninstead of directly exchanging one currency for another, you might be better off\nmaking a series of trades through other currencies, winding up with the currency\nyou want. Suppose that you can trade n different currencies, numbered 1; 2; : : : ; n,\nwhere you start with currency 1 and wish to wind up with currency n. You are\ngiven, for each pair of currencies i and j , an exchange rate rij, meaning that if\nyou start with d units of currency i, you can trade for drij units of currency j .\nA sequence of trades may entail a commission, which depends on the number of\ntrades you make. Let ck be the commission that you are charged when you make k\ntrades. Show that, if ck D 0 for all k D 1; 2; : : : ; n, then the problem of ﬁnding the\nbest sequence of exchanges from currency 1 to currency n exhibits optimal sub-\nstructure. Then show that if commissions ck are arbitrary values, then the problem\nof ﬁnding the best sequence of exchanges from currency 1 to currency n does not\nnecessarily exhibit optimal substructure.\n15.4\nLongest common subsequence\nBiological applications often need to compare the DNA of two (or more) dif-\nferent organisms.",
    "parent_56e9f330-619c-44cf-b7c1-97fb5c6575f7": "of ﬁnding the best sequence of exchanges from currency 1 to currency n does not\nnecessarily exhibit optimal substructure.\n15.4\nLongest common subsequence\nBiological applications often need to compare the DNA of two (or more) dif-\nferent organisms.\nA strand of DNA consists of a string of molecules called\n15.4\nLongest common subsequence\n391\nbases, where the possible bases are adenine, guanine, cytosine, and thymine.\nRepresenting each of these bases by its initial letter, we can express a strand\nof DNA as a string over the ﬁnite set fA; C; G; Tg.\n(See Appendix C for\nthe deﬁnition of a string.)\nFor example, the DNA of one organism may be\nS1 D ACCGGTCGAGTGCGCGGAAGCCGGCCGAA, and the DNA of another organ-\nism may be S2 D GTCGTTCGGAATGCCGTTGCTCTGTAAA. One reason to com-\npare two strands of DNA is to determine how “similar” the two strands are, as some\nmeasure of how closely related the two organisms are. We can, and do, deﬁne sim-\nilarity in many different ways. For example, we can say that two DNA strands are\nsimilar if one is a substring of the other. (Chapter 32 explores algorithms to solve\nthis problem.) In our example, neither S1 nor S2 is a substring of the other. Alter-\nnatively, we could say that two strands are similar if the number of changes needed\nto turn one into the other is small. (Problem 15-5 looks at this notion.) Yet another\nway to measure the similarity of strands S1 and S2 is by ﬁnding a third strand S3\nin which the bases in S3 appear in each of S1 and S2; these bases must appear\nin the same order, but not necessarily consecutively. The longer the strand S3 we\ncan ﬁnd, the more similar S1 and S2 are. In our example, the longest strand S3 is\nGTCGTCGGAAGCCGGCCGAA.\nWe formalize this last notion of similarity as the longest-common-subsequence\nproblem. A subsequence of a given sequence is just the given sequence with zero or\nmore elements left out. Formally, given a sequence X D hx1; x2; : : : ; xmi, another",
    "parent_a4894626-f6e9-4ae0-baea-23d69c379fdf": "GTCGTCGGAAGCCGGCCGAA.\nWe formalize this last notion of similarity as the longest-common-subsequence\nproblem. A subsequence of a given sequence is just the given sequence with zero or\nmore elements left out. Formally, given a sequence X D hx1; x2; : : : ; xmi, another\nsequence Z D h´1; ´2; : : : ; ´ki is a subsequence of X if there exists a strictly\nincreasing sequence hi1;i2;: : : ;iki of indices of X such that for all j D 1; 2; : : : ; k,\nwe have xij D ´j. For example, Z D hB; C; D; Bi is a subsequence of X D\nhA; B; C; B; D; A; Bi with corresponding index sequence h2; 3; 5; 7i.\nGiven two sequences X and Y , we say that a sequence Z is a common sub-\nsequence of X and Y if Z is a subsequence of both X and Y . For example, if\nX D hA;B;C;B;D;A;Bi and Y D hB;D;C;A;B;Ai, the sequence hB;C;Ai is\na common subsequence of both X and Y . The sequence hB; C; Ai is not a longest\ncommon subsequence (LCS) of X and Y , however, since it has length 3 and the\nsequence hB; C; B; Ai, which is also common to both X and Y , has length 4. The\nsequence hB; C; B; Ai is an LCS of X and Y , as is the sequence hB; D; A; Bi,\nsince X and Y have no common subsequence of length 5 or greater.\nIn the longest-common-subsequence problem, we are given two sequences\nX D hx1; x2; : : : ; xmi and Y D hy1; y2; : : : ; yni and wish to ﬁnd a maximum-\nlength common subsequence of X and Y . This section shows how to efﬁciently\nsolve the LCS problem using dynamic programming.\n392\nChapter 15\nDynamic Programming\nStep 1: Characterizing a longest common subsequence\nIn a brute-force approach to solving the LCS problem, we would enumerate all\nsubsequences of X and check each subsequence to see whether it is also a subse-\nquence of Y , keeping track of the longest subsequence we ﬁnd. Each subsequence\nof X corresponds to a subset of the indices f1; 2; : : : ; mg of X. Because X has 2m\nsubsequences, this approach requires exponential time, making it impractical for\nlong sequences.",
    "parent_546b7dbd-c25b-4a46-ad18-e05aae4a4d25": "quence of Y , keeping track of the longest subsequence we ﬁnd. Each subsequence\nof X corresponds to a subset of the indices f1; 2; : : : ; mg of X. Because X has 2m\nsubsequences, this approach requires exponential time, making it impractical for\nlong sequences.\nThe LCS problem has an optimal-substructure property, however, as the follow-\ning theorem shows. As we shall see, the natural classes of subproblems corre-\nspond to pairs of “preﬁxes” of the two input sequences. To be precise, given a\nsequence X D hx1;x2;: : : ;xmi, we deﬁne the ith preﬁx of X, for i D 0; 1; : : : ; m,\nas Xi D hx1; x2; : : : ; xii. For example, if X D hA; B; C; B; D; A; Bi, then\nX4 D hA; B; C; Bi and X0 is the empty sequence.\nTheorem 15.1 (Optimal substructure of an LCS)\nLet X D hx1; x2; : : : ; xmi and Y D hy1; y2; : : : ; yni be sequences, and let Z D\nh´1; ´2; : : : ; ´ki be any LCS of X and Y .\n1. If xm D yn, then ´k D xm D yn and Zk\u00031 is an LCS of Xm\u00031 and Yn\u00031.\n2. If xm ¤ yn, then ´k ¤ xm implies that Z is an LCS of Xm\u00031 and Y .\n3. If xm ¤ yn, then ´k ¤ yn implies that Z is an LCS of X and Yn\u00031.\nProof\n(1) If ´k ¤ xm, then we could append xm D yn to Z to obtain a common\nsubsequence of X and Y of length k C 1, contradicting the supposition that Z is\na longest common subsequence of X and Y . Thus, we must have ´k D xm D yn.\nNow, the preﬁx Zk\u00031 is a length-.k \u0005 1/ common subsequence of Xm\u00031 and Yn\u00031.\nWe wish to show that it is an LCS. Suppose for the purpose of contradiction\nthat there exists a common subsequence W of Xm\u00031 and Yn\u00031 with length greater\nthan k \u0005 1. Then, appending xm D yn to W produces a common subsequence of\nX and Y whose length is greater than k, which is a contradiction.\n(2) If ´k ¤ xm, then Z is a common subsequence of Xm\u00031 and Y . If there were a\ncommon subsequence W of Xm\u00031 and Y with length greater than k, then W would\nalso be a common subsequence of Xm and Y , contradicting the assumption that Z\nis an LCS of X and Y .\n(3) The proof is symmetric to (2).",
    "parent_18d53acb-12a8-4331-bb48-64ab5f31e214": "(2) If ´k ¤ xm, then Z is a common subsequence of Xm\u00031 and Y . If there were a\ncommon subsequence W of Xm\u00031 and Y with length greater than k, then W would\nalso be a common subsequence of Xm and Y , contradicting the assumption that Z\nis an LCS of X and Y .\n(3) The proof is symmetric to (2).\nThe way that Theorem 15.1 characterizes longest common subsequences tells\nus that an LCS of two sequences contains within it an LCS of preﬁxes of the two\nsequences. Thus, the LCS problem has an optimal-substructure property. A recur-\n15.4\nLongest common subsequence\n393\nsive solution also has the overlapping-subproblems property, as we shall see in a\nmoment.\nStep 2: A recursive solution\nTheorem 15.1 implies that we should examine either one or two subproblems when\nﬁnding an LCS of X D hx1; x2; : : : ; xmi and Y D hy1; y2; : : : ; yni. If xm D yn,\nwe must ﬁnd an LCS of Xm\u00031 and Yn\u00031. Appending xm D yn to this LCS yields\nan LCS of X and Y . If xm ¤ yn, then we must solve two subproblems: ﬁnding an\nLCS of Xm\u00031 and Y and ﬁnding an LCS of X and Yn\u00031. Whichever of these two\nLCSs is longer is an LCS of X and Y . Because these cases exhaust all possibilities,\nwe know that one of the optimal subproblem solutions must appear within an LCS\nof X and Y .\nWe can readily see the overlapping-subproblems property in the LCS problem.\nTo ﬁnd an LCS of X and Y , we may need to ﬁnd the LCSs of X and Yn\u00031 and\nof Xm\u00031 and Y . But each of these subproblems has the subsubproblem of ﬁnding\nan LCS of Xm\u00031 and Yn\u00031. Many other subproblems share subsubproblems.\nAs in the matrix-chain multiplication problem, our recursive solution to the LCS\nproblem involves establishing a recurrence for the value of an optimal solution.\nLet us deﬁne cŒi; j \u0002 to be the length of an LCS of the sequences Xi and Yj. If\neither i D 0 or j D 0, one of the sequences has length 0, and so the LCS has\nlength 0. The optimal substructure of the LCS problem gives the recursive formula\ncŒi; j \u0002 D\n\u0002\n0\nif i D 0 or j D 0 ;\ncŒi \u0005 1; j \u0005 1\u0002 C 1",
    "parent_d0760848-6f8f-4396-bc8c-c141909180e5": "Let us deﬁne cŒi; j \u0002 to be the length of an LCS of the sequences Xi and Yj. If\neither i D 0 or j D 0, one of the sequences has length 0, and so the LCS has\nlength 0. The optimal substructure of the LCS problem gives the recursive formula\ncŒi; j \u0002 D\n\u0002\n0\nif i D 0 or j D 0 ;\ncŒi \u0005 1; j \u0005 1\u0002 C 1\nif i; j > 0 and xi D yj ;\nmax.cŒi; j \u0005 1\u0002; cŒi \u0005 1; j \u0002/\nif i; j > 0 and xi ¤ yj :\n(15.9)\nObserve that in this recursive formulation, a condition in the problem restricts\nwhich subproblems we may consider. When xi D yj, we can and should consider\nthe subproblem of ﬁnding an LCS of Xi\u00031 and Yj\u00031. Otherwise, we instead con-\nsider the two subproblems of ﬁnding an LCS of Xi and Yj\u00031 and of Xi\u00031 and Yj. In\nthe previous dynamic-programming algorithms we have examined—for rod cutting\nand matrix-chain multiplication—we ruled out no subproblems due to conditions\nin the problem. Finding an LCS is not the only dynamic-programming algorithm\nthat rules out subproblems based on conditions in the problem. For example, the\nedit-distance problem (see Problem 15-5) has this characteristic.\nStep 3: Computing the length of an LCS\nBased on equation (15.9), we could easily write an exponential-time recursive al-\ngorithm to compute the length of an LCS of two sequences. Since the LCS problem\n394\nChapter 15\nDynamic Programming\nhas only ‚.mn/ distinct subproblems, however, we can use dynamic programming\nto compute the solutions bottom up.\nProcedure LCS-LENGTH takes two sequences X D hx1; x2; : : : ; xmi and\nY D hy1;y2;: : : ;yni as inputs. It stores the cŒi; j \u0002 values in a table cŒ0 : : m; 0 : : n\u0002,\nand it computes the entries in row-major order. (That is, the procedure ﬁlls in the\nﬁrst row of c from left to right, then the second row, and so on.) The procedure also\nmaintains the table bŒ1 : : m; 1 : : n\u0002 to help us construct an optimal solution. Intu-\nitively, bŒi; j \u0002 points to the table entry corresponding to the optimal subproblem",
    "parent_14ab04aa-f904-4543-b0d0-9ce3ea93ce57": "ﬁrst row of c from left to right, then the second row, and so on.) The procedure also\nmaintains the table bŒ1 : : m; 1 : : n\u0002 to help us construct an optimal solution. Intu-\nitively, bŒi; j \u0002 points to the table entry corresponding to the optimal subproblem\nsolution chosen when computing cŒi; j \u0002. The procedure returns the b and c tables;\ncŒm; n\u0002 contains the length of an LCS of X and Y .\nLCS-LENGTH.X; Y /\n1\nm D X:length\n2\nn D Y:length\n3\nlet bŒ1 : : m; 1 : : n\u0002 and cŒ0 : : m; 0 : : n\u0002 be new tables\n4\nfor i D 1 to m\n5\ncŒi; 0\u0002 D 0\n6\nfor j D 0 to n\n7\ncŒ0; j \u0002 D 0\n8\nfor i D 1 to m\n9\nfor j D 1 to n\n10\nif xi == yj\n11\ncŒi; j \u0002 D cŒi \u0005 1; j \u0005 1\u0002 C 1\n12\nbŒi; j \u0002 D “-”\n13\nelseif cŒi \u0005 1; j \u0002 \u0006 cŒi; j \u0005 1\u0002\n14\ncŒi; j \u0002 D cŒi \u0005 1; j \u0002\n15\nbŒi; j \u0002 D “\"”\n16\nelse cŒi; j \u0002 D cŒi; j \u0005 1\u0002\n17\nbŒi; j \u0002 D “ ”\n18\nreturn c and b\nFigure 15.8 shows the tables produced by LCS-LENGTH on the sequences X D\nhA; B; C; B; D; A; Bi and Y D hB; D; C; A; B; Ai. The running time of the\nprocedure is ‚.mn/, since each table entry takes ‚.1/ time to compute.\nStep 4: Constructing an LCS\nThe b table returned by LCS-LENGTH enables us to quickly construct an LCS of\nX D hx1; x2; : : : ; xmi and Y D hy1; y2; : : : ; yni. We simply begin at bŒm; n\u0002 and\ntrace through the table by following the arrows. Whenever we encounter a “-” in\nentry bŒi; j \u0002, it implies that xi D yj is an element of the LCS that LCS-LENGTH\n15.4\nLongest common subsequence\n395\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n2\n2\n0\n1\n1\n2\n2\n2\n0\n1\n1\n2\n2\n3\n0\n1\n2\n2\n2\n3\n3\n0\n1\n2\n2\n3\n3\n0\n1\n2\n2\n3\n4\n4\n1\n2\n3\n4\nB\nD\nC\nA\nB\nA\n1\n2\n3\n4\n5\n6\n0\nA\nB\nC\nB\nD\nA\nB\n1\n2\n3\n4\n5\n6\n7\n0\nj\ni\nxi\nyj\nFigure 15.8\nThe c and b tables computed by LCS-LENGTH on the sequences X D hA; B; C; B;\nD;A;Bi and Y D hB;D;C;A;B;Ai. The square in row i and column j contains the value of cŒi; j\u0002\nand the appropriate arrow for the value of bŒi; j\u0002. The entry 4 in cŒ7; 6\u0002—the lower right-hand corner\nof the table—is the length of an LCS hB; C; B; Ai of X and Y . For i; j > 0, entry cŒi; j\u0002 depends",
    "parent_642c453f-4f05-4a5e-830a-4f33e1494442": "D;A;Bi and Y D hB;D;C;A;B;Ai. The square in row i and column j contains the value of cŒi; j\u0002\nand the appropriate arrow for the value of bŒi; j\u0002. The entry 4 in cŒ7; 6\u0002—the lower right-hand corner\nof the table—is the length of an LCS hB; C; B; Ai of X and Y . For i; j > 0, entry cŒi; j\u0002 depends\nonly on whether xi D yj and the values in entries cŒi \u0005 1; j\u0002, cŒi; j \u0005 1\u0002, and cŒi \u0005 1; j \u0005 1\u0002, which\nare computed before cŒi; j\u0002. To reconstruct the elements of an LCS, follow the bŒi; j\u0002 arrows from\nthe lower right-hand corner; the sequence is shaded. Each “-” on the shaded sequence corresponds\nto an entry (highlighted) for which xi D yj is a member of an LCS.\nfound. With this method, we encounter the elements of this LCS in reverse order.\nThe following recursive procedure prints out an LCS of X and Y in the proper,\nforward order. The initial call is PRINT-LCS.b; X; X:length; Y:length/.\nPRINT-LCS.b; X; i; j /\n1\nif i == 0 or j == 0\n2\nreturn\n3\nif bŒi; j \u0002 == “-”\n4\nPRINT-LCS.b; X; i \u0005 1; j \u0005 1/\n5\nprint xi\n6\nelseif bŒi; j \u0002 == “\"”\n7\nPRINT-LCS.b; X; i \u0005 1; j /\n8\nelse PRINT-LCS.b; X; i; j \u0005 1/\nFor the b table in Figure 15.8, this procedure prints BCBA. The procedure takes\ntime O.m C n/, since it decrements at least one of i and j in each recursive call.\n396\nChapter 15\nDynamic Programming\nImproving the code\nOnce you have developed an algorithm, you will often ﬁnd that you can improve\non the time or space it uses. Some changes can simplify the code and improve\nconstant factors but otherwise yield no asymptotic improvement in performance.\nOthers can yield substantial asymptotic savings in time and space.\nIn the LCS algorithm, for example, we can eliminate the b table altogether. Each\ncŒi; j \u0002 entry depends on only three other c table entries: cŒi \u0005 1; j \u0005 1\u0002, cŒi \u0005 1; j \u0002,\nand cŒi; j \u0005 1\u0002. Given the value of cŒi; j \u0002, we can determine in O.1/ time which of\nthese three values was used to compute cŒi; j \u0002, without inspecting table b. Thus, we",
    "parent_f364e6ce-bfe0-44e2-82ce-a51e0e8a747a": "cŒi; j \u0002 entry depends on only three other c table entries: cŒi \u0005 1; j \u0005 1\u0002, cŒi \u0005 1; j \u0002,\nand cŒi; j \u0005 1\u0002. Given the value of cŒi; j \u0002, we can determine in O.1/ time which of\nthese three values was used to compute cŒi; j \u0002, without inspecting table b. Thus, we\ncan reconstruct an LCS in O.mCn/ time using a procedure similar to PRINT-LCS.\n(Exercise 15.4-2 asks you to give the pseudocode.) Although we save ‚.mn/ space\nby this method, the auxiliary space requirement for computing an LCS does not\nasymptotically decrease, since we need ‚.mn/ space for the c table anyway.\nWe can, however, reduce the asymptotic space requirements for LCS-LENGTH,\nsince it needs only two rows of table c at a time: the row being computed and the\nprevious row. (In fact, as Exercise 15.4-4 asks you to show, we can use only slightly\nmore than the space for one row of c to compute the length of an LCS.) This\nimprovement works if we need only the length of an LCS; if we need to reconstruct\nthe elements of an LCS, the smaller table does not keep enough information to\nretrace our steps in O.m C n/ time.\nExercises\n15.4-1\nDetermine an LCS of h1; 0; 0; 1; 0; 1; 0; 1i and h0; 1; 0; 1; 1; 0; 1; 1; 0i.\n15.4-2\nGive pseudocode to reconstruct an LCS from the completed c table and the original\nsequences X D hx1; x2; : : : ; xmi and Y D hy1; y2; : : : ; yni in O.m C n/ time,\nwithout using the b table.\n15.4-3\nGive a memoized version of LCS-LENGTH that runs in O.mn/ time.\n15.4-4\nShow how to compute the length of an LCS using only 2\u0003min.m; n/ entries in the c\ntable plus O.1/ additional space. Then show how to do the same thing, but using\nmin.m; n/ entries plus O.1/ additional space.\n15.5\nOptimal binary search trees\n397\n15.4-5\nGive an O.n2/-time algorithm to ﬁnd the longest monotonically increasing subse-\nquence of a sequence of n numbers.\n15.4-6\n?\nGive an O.n lg n/-time algorithm to ﬁnd the longest monotonically increasing sub-\nsequence of a sequence of n numbers. (Hint: Observe that the last element of a",
    "parent_2c0818dd-ebf6-45ec-b11e-bb228d4fde35": "397\n15.4-5\nGive an O.n2/-time algorithm to ﬁnd the longest monotonically increasing subse-\nquence of a sequence of n numbers.\n15.4-6\n?\nGive an O.n lg n/-time algorithm to ﬁnd the longest monotonically increasing sub-\nsequence of a sequence of n numbers. (Hint: Observe that the last element of a\ncandidate subsequence of length i is at least as large as the last element of a can-\ndidate subsequence of length i \u0005 1. Maintain candidate subsequences by linking\nthem through the input sequence.)\n15.5\nOptimal binary search trees\nSuppose that we are designing a program to translate text from English to French.\nFor each occurrence of each English word in the text, we need to look up its French\nequivalent. We could perform these lookup operations by building a binary search\ntree with n English words as keys and their French equivalents as satellite data.\nBecause we will search the tree for each individual word in the text, we want the\ntotal time spent searching to be as low as possible. We could ensure an O.lg n/\nsearch time per occurrence by using a red-black tree or any other balanced binary\nsearch tree. Words appear with different frequencies, however, and a frequently\nused word such as the may appear far from the root while a rarely used word such\nas machicolation appears near the root. Such an organization would slow down the\ntranslation, since the number of nodes visited when searching for a key in a binary\nsearch tree equals one plus the depth of the node containing the key. We want\nwords that occur frequently in the text to be placed nearer the root.6 Moreover,\nsome words in the text might have no French translation,7 and such words would\nnot appear in the binary search tree at all. How do we organize a binary search tree\nso as to minimize the number of nodes visited in all searches, given that we know\nhow often each word occurs?\nWhat we need is known as an optimal binary search tree. Formally, we are",
    "parent_af69f717-5e21-413e-808c-f72c78d79c89": "not appear in the binary search tree at all. How do we organize a binary search tree\nso as to minimize the number of nodes visited in all searches, given that we know\nhow often each word occurs?\nWhat we need is known as an optimal binary search tree. Formally, we are\ngiven a sequence K D hk1; k2; : : : ; kni of n distinct keys in sorted order (so that\nk1 < k2 < \u0003 \u0003 \u0003 < kn), and we wish to build a binary search tree from these keys.\nFor each key ki, we have a probability pi that a search will be for ki. Some\nsearches may be for values not in K, and so we also have n C 1 “dummy keys”\n6If the subject of the text is castle architecture, we might want machicolation to appear near the root.\n7Yes, machicolation has a French counterpart: mˆachicoulis.\n398\nChapter 15\nDynamic Programming\nk2\nk1\nk4\nk3\nk5\nd0\nd1\nd2\nd3\nd4\nd5\n(a)\nk2\nk1\nk4\nk3\nk5\nd0\nd1\nd2\nd3\nd4\nd5\n(b)\nFigure 15.9\nTwo binary search trees for a set of n D 5 keys with the following probabilities:\ni\n0\n1\n2\n3\n4\n5\npi\n0.15\n0.10\n0.05\n0.10\n0.20\nqi\n0.05\n0.10\n0.05\n0.05\n0.05\n0.10\n(a) A binary search tree with expected search cost 2.80. (b) A binary search tree with expected search\ncost 2.75. This tree is optimal.\nd0; d1; d2; : : : ; dn representing values not in K. In particular, d0 represents all val-\nues less than k1, dn represents all values greater than kn, and for i D 1; 2; : : : ; n\u00051,\nthe dummy key di represents all values between ki and kiC1. For each dummy\nkey di, we have a probability qi that a search will correspond to di. Figure 15.9\nshows two binary search trees for a set of n D 5 keys. Each key ki is an internal\nnode, and each dummy key di is a leaf. Every search is either successful (ﬁnding\nsome key ki) or unsuccessful (ﬁnding some dummy key di), and so we have\nn\nX\niD1\npi C\nn\nX\niD0\nqi D 1 :\n(15.10)\nBecause we have probabilities of searches for each key and each dummy key,\nwe can determine the expected cost of a search in a given binary search tree T . Let",
    "parent_4a037b50-1553-4051-8f1a-5ab024592a11": "some key ki) or unsuccessful (ﬁnding some dummy key di), and so we have\nn\nX\niD1\npi C\nn\nX\niD0\nqi D 1 :\n(15.10)\nBecause we have probabilities of searches for each key and each dummy key,\nwe can determine the expected cost of a search in a given binary search tree T . Let\nus assume that the actual cost of a search equals the number of nodes examined,\ni.e., the depth of the node found by the search in T , plus 1. Then the expected cost\nof a search in T is\nE Œsearch cost in T \u0002 D\nn\nX\niD1\n.depthT .ki/ C 1/ \u0003 pi C\nn\nX\niD0\n.depthT .di/ C 1/ \u0003 qi\nD 1 C\nn\nX\niD1\ndepthT .ki/ \u0003 pi C\nn\nX\niD0\ndepthT .di/ \u0003 qi ;\n(15.11)\n15.5\nOptimal binary search trees\n399\nwhere depthT denotes a node’s depth in the tree T . The last equality follows from\nequation (15.10). In Figure 15.9(a), we can calculate the expected search cost node\nby node:\nnode\ndepth\nprobability\ncontribution\nk1\n1\n0.15\n0.30\nk2\n0\n0.10\n0.10\nk3\n2\n0.05\n0.15\nk4\n1\n0.10\n0.20\nk5\n2\n0.20\n0.60\nd0\n2\n0.05\n0.15\nd1\n2\n0.10\n0.30\nd2\n3\n0.05\n0.20\nd3\n3\n0.05\n0.20\nd4\n3\n0.05\n0.20\nd5\n3\n0.10\n0.40\nTotal\n2.80\nFor a given set of probabilities, we wish to construct a binary search tree whose\nexpected search cost is smallest. We call such a tree an optimal binary search tree.\nFigure 15.9(b) shows an optimal binary search tree for the probabilities given in\nthe ﬁgure caption; its expected cost is 2.75. This example shows that an optimal\nbinary search tree is not necessarily a tree whose overall height is smallest. Nor\ncan we necessarily construct an optimal binary search tree by always putting the\nkey with the greatest probability at the root. Here, key k5 has the greatest search\nprobability of any key, yet the root of the optimal binary search tree shown is k2.\n(The lowest expected cost of any binary search tree with k5 at the root is 2.85.)\nAs with matrix-chain multiplication, exhaustive checking of all possibilities fails\nto yield an efﬁcient algorithm. We can label the nodes of any n-node binary tree",
    "parent_48d72ea3-84fc-481c-99a2-5ba91653b2cb": "(The lowest expected cost of any binary search tree with k5 at the root is 2.85.)\nAs with matrix-chain multiplication, exhaustive checking of all possibilities fails\nto yield an efﬁcient algorithm. We can label the nodes of any n-node binary tree\nwith the keys k1; k2; : : : ; kn to construct a binary search tree, and then add in the\ndummy keys as leaves. In Problem 12-4, we saw that the number of binary trees\nwith n nodes is \u0004.4n=n3=2/, and so we would have to examine an exponential\nnumber of binary search trees in an exhaustive search. Not surprisingly, we shall\nsolve this problem with dynamic programming.\nStep 1: The structure of an optimal binary search tree\nTo characterize the optimal substructure of optimal binary search trees, we start\nwith an observation about subtrees. Consider any subtree of a binary search tree.\nIt must contain keys in a contiguous range ki; : : : ; kj, for some 1 \u0002 i \u0002 j \u0002 n.\nIn addition, a subtree that contains keys ki; : : : ; kj must also have as its leaves the\ndummy keys di\u00031; : : : ; dj .\nNow we can state the optimal substructure: if an optimal binary search tree T\nhas a subtree T 0 containing keys ki; : : : ; kj, then this subtree T 0 must be optimal as\n400\nChapter 15\nDynamic Programming\nwell for the subproblem with keys ki; : : : ; kj and dummy keys di\u00031; : : : ; dj. The\nusual cut-and-paste argument applies. If there were a subtree T 00 whose expected\ncost is lower than that of T 0, then we could cut T 0 out of T and paste in T 00,\nresulting in a binary search tree of lower expected cost than T , thus contradicting\nthe optimality of T .\nWe need to use the optimal substructure to show that we can construct an opti-\nmal solution to the problem from optimal solutions to subproblems. Given keys\nki; : : : ; kj , one of these keys, say kr (i \u0002 r \u0002 j ), is the root of an optimal\nsubtree containing these keys. The left subtree of the root kr contains the keys",
    "parent_3e59f9b8-a064-4981-aa65-85986c6633a4": "mal solution to the problem from optimal solutions to subproblems. Given keys\nki; : : : ; kj , one of these keys, say kr (i \u0002 r \u0002 j ), is the root of an optimal\nsubtree containing these keys. The left subtree of the root kr contains the keys\nki; : : : ; kr\u00031 (and dummy keys di\u00031; : : : ; dr\u00031), and the right subtree contains the\nkeys krC1; : : : ; kj (and dummy keys dr; : : : ; dj). As long as we examine all candi-\ndate roots kr, where i \u0002 r \u0002 j , and we determine all optimal binary search trees\ncontaining ki; : : : ; kr\u00031 and those containing krC1; : : : ; kj , we are guaranteed that\nwe will ﬁnd an optimal binary search tree.\nThere is one detail worth noting about “empty” subtrees. Suppose that in a\nsubtree with keys ki; : : : ; kj, we select ki as the root. By the above argument, ki’s\nleft subtree contains the keys ki; : : : ; ki\u00031. We interpret this sequence as containing\nno keys. Bear in mind, however, that subtrees also contain dummy keys. We adopt\nthe convention that a subtree containing keys ki; : : : ; ki\u00031 has no actual keys but\ndoes contain the single dummy key di\u00031. Symmetrically, if we select kj as the root,\nthen kj’s right subtree contains the keys kjC1; : : : ; kj ; this right subtree contains\nno actual keys, but it does contain the dummy key dj.\nStep 2: A recursive solution\nWe are ready to deﬁne the value of an optimal solution recursively. We pick our\nsubproblem domain as ﬁnding an optimal binary search tree containing the keys\nki; : : : ; kj , where i \u0006 1, j \u0002 n, and j \u0006 i \u0005 1. (When j D i \u0005 1, there\nare no actual keys; we have just the dummy key di\u00031.) Let us deﬁne eŒi; j \u0002 as\nthe expected cost of searching an optimal binary search tree containing the keys\nki; : : : ; kj . Ultimately, we wish to compute eŒ1; n\u0002.\nThe easy case occurs when j D i \u0005 1. Then we have just the dummy key di\u00031.\nThe expected search cost is eŒi; i \u0005 1\u0002 D qi\u00031.\nWhen j \u0006 i, we need to select a root kr from among ki; : : : ; kj and then make an",
    "parent_50c1f305-5696-4b32-a272-d72c1ea6762c": "ki; : : : ; kj . Ultimately, we wish to compute eŒ1; n\u0002.\nThe easy case occurs when j D i \u0005 1. Then we have just the dummy key di\u00031.\nThe expected search cost is eŒi; i \u0005 1\u0002 D qi\u00031.\nWhen j \u0006 i, we need to select a root kr from among ki; : : : ; kj and then make an\noptimal binary search tree with keys ki; : : : ; kr\u00031 as its left subtree and an optimal\nbinary search tree with keys krC1; : : : ; kj as its right subtree. What happens to the\nexpected search cost of a subtree when it becomes a subtree of a node? The depth\nof each node in the subtree increases by 1. By equation (15.11), the expected search\ncost of this subtree increases by the sum of all the probabilities in the subtree. For\na subtree with keys ki; : : : ; kj , let us denote this sum of probabilities as\n15.5\nOptimal binary search trees\n401\nw.i; j / D\nj\nX\nlDi\npl C\nj\nX\nlDi\u00031\nql :\n(15.12)\nThus, if kr is the root of an optimal subtree containing keys ki; : : : ; kj, we have\neŒi; j \u0002 D pr C .eŒi; r \u0005 1\u0002 C w.i; r \u0005 1// C .eŒr C 1; j \u0002 C w.r C 1; j // :\nNoting that\nw.i; j / D w.i; r \u0005 1/ C pr C w.r C 1; j / ;\nwe rewrite eŒi; j \u0002 as\neŒi; j \u0002 D eŒi; r \u0005 1\u0002 C eŒr C 1; j \u0002 C w.i; j / :\n(15.13)\nThe recursive equation (15.13) assumes that we know which node kr to use as\nthe root. We choose the root that gives the lowest expected search cost, giving us\nour ﬁnal recursive formulation:\neŒi; j \u0002 D\n(\nqi\u00031\nif j D i \u0005 1 ;\nmin\ni\u0005r\u0005j feŒi; r \u0005 1\u0002 C eŒr C 1; j \u0002 C w.i; j /g if i \u0002 j :\n(15.14)\nThe eŒi; j \u0002 values give the expected search costs in optimal binary search trees.\nTo help us keep track of the structure of optimal binary search trees, we deﬁne\nrootŒi; j \u0002, for 1 \u0002 i \u0002 j \u0002 n, to be the index r for which kr is the root of an\noptimal binary search tree containing keys ki; : : : ; kj . Although we will see how\nto compute the values of rootŒi; j \u0002, we leave the construction of an optimal binary\nsearch tree from these values as Exercise 15.5-1.\nStep 3: Computing the expected search cost of an optimal binary search tree",
    "parent_5de9f5b3-f199-4620-b158-5d14a57114cc": "optimal binary search tree containing keys ki; : : : ; kj . Although we will see how\nto compute the values of rootŒi; j \u0002, we leave the construction of an optimal binary\nsearch tree from these values as Exercise 15.5-1.\nStep 3: Computing the expected search cost of an optimal binary search tree\nAt this point, you may have noticed some similarities between our characterizations\nof optimal binary search trees and matrix-chain multiplication. For both problem\ndomains, our subproblems consist of contiguous index subranges. A direct, recur-\nsive implementation of equation (15.14) would be as inefﬁcient as a direct, recur-\nsive matrix-chain multiplication algorithm. Instead, we store the eŒi; j \u0002 values in a\ntable eŒ1 : : nC1; 0 : : n\u0002. The ﬁrst index needs to run to nC1 rather than n because\nin order to have a subtree containing only the dummy key dn, we need to compute\nand store eŒn C 1; n\u0002. The second index needs to start from 0 because in order to\nhave a subtree containing only the dummy key d0, we need to compute and store\neŒ1; 0\u0002. We use only the entries eŒi; j \u0002 for which j \u0006 i \u0005 1. We also use a table\nrootŒi; j \u0002, for recording the root of the subtree containing keys ki; : : : ; kj . This\ntable uses only the entries for which 1 \u0002 i \u0002 j \u0002 n.\nWe will need one other table for efﬁciency. Rather than compute the value\nof w.i; j / from scratch every time we are computing eŒi; j \u0002—which would take\n402\nChapter 15\nDynamic Programming\n‚.j \u0005 i/ additions—we store these values in a table wŒ1 : : n C 1; 0 : : n\u0002. For the\nbase case, we compute wŒi; i \u0005 1\u0002 D qi\u00031 for 1 \u0002 i \u0002 n C 1. For j \u0006 i, we\ncompute\nwŒi; j \u0002 D wŒi; j \u0005 1\u0002 C pj C qj :\n(15.15)\nThus, we can compute the ‚.n2/ values of wŒi; j \u0002 in ‚.1/ time each.\nThe pseudocode that follows takes as inputs the probabilities p1; : : : ; pn and\nq0; : : : ; qn and the size n, and it returns the tables e and root.\nOPTIMAL-BST.p; q; n/\n1\nlet eŒ1 : : n C 1; 0 : : n\u0002, wŒ1 : : n C 1; 0 : : n\u0002,\nand rootŒ1 : : n; 1 : : n\u0002 be new tables\n2",
    "parent_cc1d5824-cf84-4e5a-b1a8-aa51a2c1b7e0": "The pseudocode that follows takes as inputs the probabilities p1; : : : ; pn and\nq0; : : : ; qn and the size n, and it returns the tables e and root.\nOPTIMAL-BST.p; q; n/\n1\nlet eŒ1 : : n C 1; 0 : : n\u0002, wŒ1 : : n C 1; 0 : : n\u0002,\nand rootŒ1 : : n; 1 : : n\u0002 be new tables\n2\nfor i D 1 to n C 1\n3\neŒi; i \u0005 1\u0002 D qi\u00031\n4\nwŒi; i \u0005 1\u0002 D qi\u00031\n5\nfor l D 1 to n\n6\nfor i D 1 to n \u0005 l C 1\n7\nj D i C l \u0005 1\n8\neŒi; j \u0002 D 1\n9\nwŒi; j \u0002 D wŒi; j \u0005 1\u0002 C pj C qj\n10\nfor r D i to j\n11\nt D eŒi; r \u0005 1\u0002 C eŒr C 1; j \u0002 C wŒi; j \u0002\n12\nif t < eŒi; j \u0002\n13\neŒi; j \u0002 D t\n14\nrootŒi; j \u0002 D r\n15\nreturn e and root\nFrom the description above and the similarity to the MATRIX-CHAIN-ORDER pro-\ncedure in Section 15.2, you should ﬁnd the operation of this procedure to be fairly\nstraightforward.\nThe for loop of lines 2–4 initializes the values of eŒi; i \u0005 1\u0002\nand wŒi; i \u0005 1\u0002. The for loop of lines 5–14 then uses the recurrences (15.14)\nand (15.15) to compute eŒi; j \u0002 and wŒi; j \u0002 for all 1 \u0002 i \u0002 j \u0002 n. In the ﬁrst itera-\ntion, when l D 1, the loop computes eŒi; i\u0002 and wŒi; i\u0002 for i D 1; 2; : : : ; n. The sec-\nond iteration, with l D 2, computes eŒi; iC1\u0002 and wŒi; iC1\u0002 for i D 1; 2; : : : ; n\u00051,\nand so forth. The innermost for loop, in lines 10–14, tries each candidate index r\nto determine which key kr to use as the root of an optimal binary search tree con-\ntaining keys ki; : : : ; kj . This for loop saves the current value of the index r in\nrootŒi; j \u0002 whenever it ﬁnds a better key to use as the root.\nFigure 15.10 shows the tables eŒi; j \u0002, wŒi; j \u0002, and rootŒi; j \u0002 computed by the\nprocedure OPTIMAL-BST on the key distribution shown in Figure 15.9. As in the\nmatrix-chain multiplication example of Figure 15.5, the tables are rotated to make\n15.5\nOptimal binary search trees\n403\n2.75\n1.75\n1.25\n0.90\n0.45\n0.05\n2.00\n1.20\n0.70\n0.40\n0.10\n1.30\n0.60\n0.25\n0.05\n0.90\n0.30\n0.05\n0.50\n0.05\n0.10\ne\n0\n1\n2\n3\n4\n5\n6\n5\n4\n3\n2\n1\nj\ni\n1.00\n0.70\n0.55\n0.45\n0.30\n0.05\n0.80\n0.50\n0.35\n0.25\n0.10\n0.60\n0.30\n0.15\n0.05\n0.50\n0.20\n0.05\n0.35\n0.05\n0.10\nw\n0",
    "parent_f27fab33-282d-42a0-8c84-2685d005a42b": "15.5\nOptimal binary search trees\n403\n2.75\n1.75\n1.25\n0.90\n0.45\n0.05\n2.00\n1.20\n0.70\n0.40\n0.10\n1.30\n0.60\n0.25\n0.05\n0.90\n0.30\n0.05\n0.50\n0.05\n0.10\ne\n0\n1\n2\n3\n4\n5\n6\n5\n4\n3\n2\n1\nj\ni\n1.00\n0.70\n0.55\n0.45\n0.30\n0.05\n0.80\n0.50\n0.35\n0.25\n0.10\n0.60\n0.30\n0.15\n0.05\n0.50\n0.20\n0.05\n0.35\n0.05\n0.10\nw\n0\n1\n2\n3\n4\n5\n6\n5\n4\n3\n2\n1\nj\ni\n2\n2\n2\n1\n1\n4\n2\n2\n2\n5\n4\n3\n5\n4\n5\nroot\n1\n2\n3\n4\n5\n5\n4\n3\n2\n1\nj\ni\nFigure 15.10\nThe tables eŒi; j\u0002, wŒi; j\u0002, and rootŒi; j\u0002 computed by OPTIMAL-BST on the key\ndistribution shown in Figure 15.9. The tables are rotated so that the diagonals run horizontally.\nthe diagonals run horizontally. OPTIMAL-BST computes the rows from bottom to\ntop and from left to right within each row.\nThe OPTIMAL-BST procedure takes ‚.n3/ time, just like MATRIX-CHAIN-\nORDER. We can easily see that its running time is O.n3/, since its for loops are\nnested three deep and each loop index takes on at most n values. The loop indices in\nOPTIMAL-BST do not have exactly the same bounds as those in MATRIX-CHAIN-\nORDER, but they are within at most 1 in all directions. Thus, like MATRIX-CHAIN-\nORDER, the OPTIMAL-BST procedure takes \u0004.n3/ time.\nExercises\n15.5-1\nWrite pseudocode for the procedure CONSTRUCT-OPTIMAL-BST.root/ which,\ngiven the table root, outputs the structure of an optimal binary search tree. For the\nexample in Figure 15.10, your procedure should print out the structure\n404\nChapter 15\nDynamic Programming\nk2 is the root\nk1 is the left child of k2\nd0 is the left child of k1\nd1 is the right child of k1\nk5 is the right child of k2\nk4 is the left child of k5\nk3 is the left child of k4\nd2 is the left child of k3\nd3 is the right child of k3\nd4 is the right child of k4\nd5 is the right child of k5\ncorresponding to the optimal binary search tree shown in Figure 15.9(b).\n15.5-2\nDetermine the cost and structure of an optimal binary search tree for a set of n D 7\nkeys with the following probabilities:\ni\n0\n1\n2\n3\n4\n5\n6\n7\npi\n0.04\n0.06\n0.08\n0.02\n0.10\n0.12\n0.14\nqi\n0.06\n0.06\n0.06\n0.06\n0.05\n0.05\n0.05\n0.05\n15.5-3",
    "parent_987e58ba-beac-463d-9964-586360503ae7": "15.5-2\nDetermine the cost and structure of an optimal binary search tree for a set of n D 7\nkeys with the following probabilities:\ni\n0\n1\n2\n3\n4\n5\n6\n7\npi\n0.04\n0.06\n0.08\n0.02\n0.10\n0.12\n0.14\nqi\n0.06\n0.06\n0.06\n0.06\n0.05\n0.05\n0.05\n0.05\n15.5-3\nSuppose that instead of maintaining the table wŒi; j \u0002, we computed the value\nof w.i; j / directly from equation (15.12) in line 9 of OPTIMAL-BST and used this\ncomputed value in line 11. How would this change affect the asymptotic running\ntime of OPTIMAL-BST?\n15.5-4\n?\nKnuth [212] has shown that there are always roots of optimal subtrees such that\nrootŒi; j \u0005 1\u0002 \u0002 rootŒi; j \u0002 \u0002 rootŒi C 1; j \u0002 for all 1 \u0002 i < j \u0002 n. Use this fact to\nmodify the OPTIMAL-BST procedure to run in ‚.n2/ time.\nProblems\n15-1\nLongest simple path in a directed acyclic graph\nSuppose that we are given a directed acyclic graph G D .V; E/ with real-\nvalued edge weights and two distinguished vertices s and t. Describe a dynamic-\nprogramming approach for ﬁnding a longest weighted simple path from s to t.\nWhat does the subproblem graph look like? What is the efﬁciency of your algo-\nrithm?\nProblems for Chapter 15\n405\n(a)\n(b)\nFigure 15.11\nSeven points in the plane, shown on a unit grid. (a) The shortest closed tour, with\nlength approximately 24:89. This tour is not bitonic. (b) The shortest bitonic tour for the same set of\npoints. Its length is approximately 25:58.\n15-2\nLongest palindrome subsequence\nA palindrome is a nonempty string over some alphabet that reads the same for-\nward and backward. Examples of palindromes are all strings of length 1, civic,\nracecar, and aibohphobia (fear of palindromes).\nGive an efﬁcient algorithm to ﬁnd the longest palindrome that is a subsequence\nof a given input string. For example, given the input character, your algorithm\nshould return carac. What is the running time of your algorithm?\n15-3\nBitonic euclidean traveling-salesman problem\nIn the euclidean traveling-salesman problem, we are given a set of n points in",
    "parent_cae8e962-2fb2-4095-9c46-c55f3a9c0d2c": "of a given input string. For example, given the input character, your algorithm\nshould return carac. What is the running time of your algorithm?\n15-3\nBitonic euclidean traveling-salesman problem\nIn the euclidean traveling-salesman problem, we are given a set of n points in\nthe plane, and we wish to ﬁnd the shortest closed tour that connects all n points.\nFigure 15.11(a) shows the solution to a 7-point problem. The general problem is\nNP-hard, and its solution is therefore believed to require more than polynomial\ntime (see Chapter 34).\nJ. L. Bentley has suggested that we simplify the problem by restricting our at-\ntention to bitonic tours, that is, tours that start at the leftmost point, go strictly\nrightward to the rightmost point, and then go strictly leftward back to the starting\npoint. Figure 15.11(b) shows the shortest bitonic tour of the same 7 points. In this\ncase, a polynomial-time algorithm is possible.\nDescribe an O.n2/-time algorithm for determining an optimal bitonic tour. You\nmay assume that no two points have the same x-coordinate and that all operations\non real numbers take unit time. (Hint: Scan left to right, maintaining optimal pos-\nsibilities for the two parts of the tour.)\n15-4\nPrinting neatly\nConsider the problem of neatly printing a paragraph with a monospaced font (all\ncharacters having the same width) on a printer. The input text is a sequence of n\n406\nChapter 15\nDynamic Programming\nwords of lengths l1; l2; : : : ; ln, measured in characters. We want to print this para-\ngraph neatly on a number of lines that hold a maximum of M characters each. Our\ncriterion of “neatness” is as follows. If a given line contains words i through j ,\nwhere i \u0002 j , and we leave exactly one space between words, the number of extra\nspace characters at the end of the line is M \u0005 j C i \u0005 Pj\nkDi lk, which must be\nnonnegative so that the words ﬁt on the line. We wish to minimize the sum, over",
    "parent_83dfcbc2-b5a9-49de-9125-8ae0e506a7d9": "where i \u0002 j , and we leave exactly one space between words, the number of extra\nspace characters at the end of the line is M \u0005 j C i \u0005 Pj\nkDi lk, which must be\nnonnegative so that the words ﬁt on the line. We wish to minimize the sum, over\nall lines except the last, of the cubes of the numbers of extra space characters at the\nends of lines. Give a dynamic-programming algorithm to print a paragraph of n\nwords neatly on a printer. Analyze the running time and space requirements of\nyour algorithm.\n15-5\nEdit distance\nIn order to transform one source string of text xŒ1 : : m\u0002 to a target string yŒ1 : : n\u0002,\nwe can perform various transformation operations. Our goal is, given x and y,\nto produce a series of transformations that change x to y.\nWe use an ar-\nray ´—assumed to be large enough to hold all the characters it will need—to hold\nthe intermediate results. Initially, ´ is empty, and at termination, we should have\n´Œj \u0002 D yŒj \u0002 for j D 1; 2; : : : ; n. We maintain current indices i into x and j into ´,\nand the operations are allowed to alter ´ and these indices. Initially, i D j D 1.\nWe are required to examine every character in x during the transformation, which\nmeans that at the end of the sequence of transformation operations, we must have\ni D m C 1.\nWe may choose from among six transformation operations:\nCopy a character from x to ´ by setting ´Œj \u0002 D xŒi\u0002 and then incrementing both i\nand j . This operation examines xŒi\u0002.\nReplace a character from x by another character c, by setting ´Œj \u0002 D c, and then\nincrementing both i and j . This operation examines xŒi\u0002.\nDelete a character from x by incrementing i but leaving j alone. This operation\nexamines xŒi\u0002.\nInsert the character c into ´ by setting ´Œj \u0002 D c and then incrementing j , but\nleaving i alone. This operation examines no characters of x.\nTwiddle (i.e., exchange) the next two characters by copying them from x to ´ but\nin the opposite order; we do so by setting ´Œj \u0002 D xŒi C 1\u0002 and ´Œj C 1\u0002 D xŒi\u0002",
    "parent_a2c1dc7e-64e0-4294-a9f8-5b0d06c8ff86": "leaving i alone. This operation examines no characters of x.\nTwiddle (i.e., exchange) the next two characters by copying them from x to ´ but\nin the opposite order; we do so by setting ´Œj \u0002 D xŒi C 1\u0002 and ´Œj C 1\u0002 D xŒi\u0002\nand then setting i D i C 2 and j D j C 2. This operation examines xŒi\u0002\nand xŒi C 1\u0002.\nKill the remainder of x by setting i D m C 1. This operation examines all char-\nacters in x that have not yet been examined. This operation, if performed, must\nbe the ﬁnal operation.\nProblems for Chapter 15\n407\nAs an example, one way to transform the source string algorithm to the target\nstring altruistic is to use the following sequence of operations, where the\nunderlined characters are xŒi\u0002 and ´Œj \u0002 after the operation:\nOperation\nx\n´\ninitial strings\nalgorithm\ncopy\nalgorithm\na\ncopy\nalgorithm\nal\nreplace by t\nalgorithm\nalt\ndelete\nalgorithm\nalt\ncopy\nalgorithm\naltr\ninsert u\nalgorithm\naltru\ninsert i\nalgorithm\naltrui\ninsert s\nalgorithm\naltruis\ntwiddle\nalgorithm\naltruisti\ninsert c\nalgorithm\naltruistic\nkill\nalgorithm\naltruistic\nNote that there are several other sequences of transformation operations that trans-\nform algorithm to altruistic.\nEach of the transformation operations has an associated cost. The cost of an\noperation depends on the speciﬁc application, but we assume that each operation’s\ncost is a constant that is known to us. We also assume that the individual costs of\nthe copy and replace operations are less than the combined costs of the delete and\ninsert operations; otherwise, the copy and replace operations would not be used.\nThe cost of a given sequence of transformation operations is the sum of the costs\nof the individual operations in the sequence. For the sequence above, the cost of\ntransforming algorithm to altruistic is\n.3 \u0003 cost.copy// C cost.replace/ C cost.delete/ C .4 \u0003 cost.insert//\nC cost.twiddle/ C cost.kill/ :\na. Given two sequences xŒ1 : : m\u0002 and yŒ1 : : n\u0002 and set of transformation-operation",
    "parent_8f6f2258-c20b-483a-832a-1aff548ed168": "transforming algorithm to altruistic is\n.3 \u0003 cost.copy// C cost.replace/ C cost.delete/ C .4 \u0003 cost.insert//\nC cost.twiddle/ C cost.kill/ :\na. Given two sequences xŒ1 : : m\u0002 and yŒ1 : : n\u0002 and set of transformation-operation\ncosts, the edit distance from x to y is the cost of the least expensive operation\nsequence that transforms x to y. Describe a dynamic-programming algorithm\nthat ﬁnds the edit distance from xŒ1 : : m\u0002 to yŒ1 : : n\u0002 and prints an optimal op-\neration sequence. Analyze the running time and space requirements of your\nalgorithm.\nThe edit-distance problem generalizes the problem of aligning two DNA sequences\n(see, for example, Setubal and Meidanis [310, Section 3.2]). There are several\nmethods for measuring the similarity of two DNA sequences by aligning them.\nOne such method to align two sequences x and y consists of inserting spaces at\n408\nChapter 15\nDynamic Programming\narbitrary locations in the two sequences (including at either end) so that the result-\ning sequences x0 and y0 have the same length but do not have a space in the same\nposition (i.e., for no position j are both x0Œj \u0002 and y0Œj \u0002 a space). Then we assign a\n“score” to each position. Position j receives a score as follows:\n\u0002\nC1 if x0Œj \u0002 D y0Œj \u0002 and neither is a space,\n\u0002\n\u00051 if x0Œj \u0002 ¤ y0Œj \u0002 and neither is a space,\n\u0002\n\u00052 if either x0Œj \u0002 or y0Œj \u0002 is a space.\nThe score for the alignment is the sum of the scores of the individual positions. For\nexample, given the sequences x D GATCGGCAT and y D CAATGTGAATC, one\nalignment is\nG ATCG GCAT\nCAAT GTGAATC\n-*++*+*+-++*\nA + under a position indicates a score of C1 for that position, a - indicates a score\nof \u00051, and a * indicates a score of \u00052, so that this alignment has a total score of\n6 \u0003 1 \u0005 2 \u0003 1 \u0005 4 \u0003 2 D \u00054.\nb. Explain how to cast the problem of ﬁnding an optimal alignment as an edit\ndistance problem using a subset of the transformation operations copy, replace,\ndelete, insert, twiddle, and kill.\n15-6\nPlanning a company party",
    "parent_b292faf1-afcf-4304-a57e-0b4c94f3ec96": "6 \u0003 1 \u0005 2 \u0003 1 \u0005 4 \u0003 2 D \u00054.\nb. Explain how to cast the problem of ﬁnding an optimal alignment as an edit\ndistance problem using a subset of the transformation operations copy, replace,\ndelete, insert, twiddle, and kill.\n15-6\nPlanning a company party\nProfessor Stewart is consulting for the president of a corporation that is planning\na company party. The company has a hierarchical structure; that is, the supervisor\nrelation forms a tree rooted at the president. The personnel ofﬁce has ranked each\nemployee with a conviviality rating, which is a real number. In order to make the\nparty fun for all attendees, the president does not want both an employee and his\nor her immediate supervisor to attend.\nProfessor Stewart is given the tree that describes the structure of the corporation,\nusing the left-child, right-sibling representation described in Section 10.4. Each\nnode of the tree holds, in addition to the pointers, the name of an employee and\nthat employee’s conviviality ranking. Describe an algorithm to make up a guest\nlist that maximizes the sum of the conviviality ratings of the guests. Analyze the\nrunning time of your algorithm.\n15-7\nViterbi algorithm\nWe can use dynamic programming on a directed graph G D .V; E/ for speech\nrecognition. Each edge .u; \u0003/ 2 E is labeled with a sound \t.u; \u0003/ from a ﬁ-\nnite set † of sounds. The labeled graph is a formal model of a person speaking\nProblems for Chapter 15\n409\na restricted language. Each path in the graph starting from a distinguished ver-\ntex \u00030 2 V corresponds to a possible sequence of sounds produced by the model.\nWe deﬁne the label of a directed path to be the concatenation of the labels of the\nedges on that path.\na. Describe an efﬁcient algorithm that, given an edge-labeled graph G with dis-\ntinguished vertex \u00030 and a sequence s D h\t1; \t2; : : : ; \tki of sounds from †,\nreturns a path in G that begins at \u00030 and has s as its label, if any such path exists.",
    "parent_e136ecea-8b69-4938-8dc1-f09d1134af3e": "edges on that path.\na. Describe an efﬁcient algorithm that, given an edge-labeled graph G with dis-\ntinguished vertex \u00030 and a sequence s D h\t1; \t2; : : : ; \tki of sounds from †,\nreturns a path in G that begins at \u00030 and has s as its label, if any such path exists.\nOtherwise, the algorithm should return NO-SUCH-PATH. Analyze the running\ntime of your algorithm. (Hint: You may ﬁnd concepts from Chapter 22 useful.)\nNow, suppose that every edge .u; \u0003/ 2 E has an associated nonnegative proba-\nbility p.u; \u0003/ of traversing the edge .u; \u0003/ from vertex u and thus producing the\ncorresponding sound. The sum of the probabilities of the edges leaving any vertex\nequals 1. The probability of a path is deﬁned to be the product of the probabil-\nities of its edges. We can view the probability of a path beginning at \u00030 as the\nprobability that a “random walk” beginning at \u00030 will follow the speciﬁed path,\nwhere we randomly choose which edge to take leaving a vertex u according to the\nprobabilities of the available edges leaving u.\nb. Extend your answer to part (a) so that if a path is returned, it is a most prob-\nable path starting at \u00030 and having label s. Analyze the running time of your\nalgorithm.\n15-8\nImage compression by seam carving\nWe are given a color picture consisting of an m \t n array AŒ1 : : m; 1 : : n\u0002 of pixels,\nwhere each pixel speciﬁes a triple of red, green, and blue (RGB) intensities. Sup-\npose that we wish to compress this picture slightly. Speciﬁcally, we wish to remove\none pixel from each of the m rows, so that the whole picture becomes one pixel\nnarrower. To avoid disturbing visual effects, however, we require that the pixels\nremoved in two adjacent rows be in the same or adjacent columns; the pixels re-\nmoved form a “seam” from the top row to the bottom row where successive pixels\nin the seam are adjacent vertically or diagonally.\na. Show that the number of such possible seams grows at least exponentially in m,\nassuming that n > 1.",
    "parent_fc1222e7-1773-43f7-a503-7f9c144d53f0": "moved form a “seam” from the top row to the bottom row where successive pixels\nin the seam are adjacent vertically or diagonally.\na. Show that the number of such possible seams grows at least exponentially in m,\nassuming that n > 1.\nb. Suppose now that along with each pixel AŒi; j \u0002, we have calculated a real-\nvalued disruption measure dŒi; j \u0002, indicating how disruptive it would be to\nremove pixel AŒi; j \u0002. Intuitively, the lower a pixel’s disruption measure, the\nmore similar the pixel is to its neighbors. Suppose further that we deﬁne the\ndisruption measure of a seam to be the sum of the disruption measures of its\npixels.\n410\nChapter 15\nDynamic Programming\nGive an algorithm to ﬁnd a seam with the lowest disruption measure. How\nefﬁcient is your algorithm?\n15-9\nBreaking a string\nA certain string-processing language allows a programmer to break a string into\ntwo pieces. Because this operation copies the string, it costs n time units to break\na string of n characters into two pieces. Suppose a programmer wants to break\na string into many pieces. The order in which the breaks occur can affect the\ntotal amount of time used. For example, suppose that the programmer wants to\nbreak a 20-character string after characters 2, 8, and 10 (numbering the characters\nin ascending order from the left-hand end, starting from 1). If she programs the\nbreaks to occur in left-to-right order, then the ﬁrst break costs 20 time units, the\nsecond break costs 18 time units (breaking the string from characters 3 to 20 at\ncharacter 8), and the third break costs 12 time units, totaling 50 time units. If she\nprograms the breaks to occur in right-to-left order, however, then the ﬁrst break\ncosts 20 time units, the second break costs 10 time units, and the third break costs\n8 time units, totaling 38 time units. In yet another order, she could break ﬁrst at 8\n(costing 20), then break the left piece at 2 (costing 8), and ﬁnally the right piece\nat 10 (costing 12), for a total cost of 40.",
    "parent_c4951066-1611-41ed-9745-05bd2df50c93": "costs 20 time units, the second break costs 10 time units, and the third break costs\n8 time units, totaling 38 time units. In yet another order, she could break ﬁrst at 8\n(costing 20), then break the left piece at 2 (costing 8), and ﬁnally the right piece\nat 10 (costing 12), for a total cost of 40.\nDesign an algorithm that, given the numbers of characters after which to break,\ndetermines a least-cost way to sequence those breaks. More formally, given a\nstring S with n characters and an array LŒ1 : : m\u0002 containing the break points, com-\npute the lowest cost for a sequence of breaks, along with a sequence of breaks that\nachieves this cost.\n15-10\nPlanning an investment strategy\nYour knowledge of algorithms helps you obtain an exciting job with the Acme\nComputer Company, along with a $10,000 signing bonus. You decide to invest\nthis money with the goal of maximizing your return at the end of 10 years. You\ndecide to use the Amalgamated Investment Company to manage your investments.\nAmalgamated Investments requires you to observe the following rules. It offers n\ndifferent investments, numbered 1 through n. In each year j , investment i provides\na return rate of rij. In other words, if you invest d dollars in investment i in year j ,\nthen at the end of year j , you have drij dollars. The return rates are guaranteed,\nthat is, you are given all the return rates for the next 10 years for each investment.\nYou make investment decisions only once per year. At the end of each year, you\ncan leave the money made in the previous year in the same investments, or you\ncan shift money to other investments, by either shifting money between existing\ninvestments or moving money to a new investement. If you do not move your\nmoney between two consecutive years, you pay a fee of f1 dollars, whereas if you\nswitch your money, you pay a fee of f2 dollars, where f2 > f1.\nProblems for Chapter 15\n411\na. The problem, as stated, allows you to invest your money in multiple investments",
    "parent_a59f00f4-3202-417b-9a21-88af126b5b07": "money between two consecutive years, you pay a fee of f1 dollars, whereas if you\nswitch your money, you pay a fee of f2 dollars, where f2 > f1.\nProblems for Chapter 15\n411\na. The problem, as stated, allows you to invest your money in multiple investments\nin each year. Prove that there exists an optimal investment strategy that, in\neach year, puts all the money into a single investment. (Recall that an optimal\ninvestment strategy maximizes the amount of money after 10 years and is not\nconcerned with any other objectives, such as minimizing risk.)\nb. Prove that the problem of planning your optimal investment strategy exhibits\noptimal substructure.\nc. Design an algorithm that plans your optimal investment strategy. What is the\nrunning time of your algorithm?\nd. Suppose that Amalgamated Investments imposed the additional restriction that,\nat any point, you can have no more than $15,000 in any one investment. Show\nthat the problem of maximizing your income at the end of 10 years no longer\nexhibits optimal substructure.\n15-11\nInventory planning\nThe Rinky Dink Company makes machines that resurface ice rinks. The demand\nfor such products varies from month to month, and so the company needs to de-\nvelop a strategy to plan its manufacturing given the ﬂuctuating, but predictable,\ndemand. The company wishes to design a plan for the next n months. For each\nmonth i, the company knows the demand di, that is, the number of machines that\nit will sell. Let D D Pn\niD1 di be the total demand over the next n months. The\ncompany keeps a full-time staff who provide labor to manufacture up to m ma-\nchines per month. If the company needs to make more than m machines in a given\nmonth, it can hire additional, part-time labor, at a cost that works out to c dollars\nper machine. Furthermore, if, at the end of a month, the company is holding any\nunsold machines, it must pay inventory costs. The cost for holding j machines is",
    "parent_a28ed121-5da7-4111-8036-65be90a6a928": "month, it can hire additional, part-time labor, at a cost that works out to c dollars\nper machine. Furthermore, if, at the end of a month, the company is holding any\nunsold machines, it must pay inventory costs. The cost for holding j machines is\ngiven as a function h.j / for j D 1; 2; : : : ; D, where h.j / \u0006 0 for 1 \u0002 j \u0002 D and\nh.j / \u0002 h.j C 1/ for 1 \u0002 j \u0002 D \u0005 1.\nGive an algorithm that calculates a plan for the company that minimizes its costs\nwhile fulﬁlling all the demand. The running time should be polyomial in n and D.\n15-12\nSigning free-agent baseball players\nSuppose that you are the general manager for a major-league baseball team. During\nthe off-season, you need to sign some free-agent players for your team. The team\nowner has given you a budget of $X to spend on free agents. You are allowed to\nspend less than $X altogether, but the owner will ﬁre you if you spend any more\nthan $X.\n412\nChapter 15\nDynamic Programming\nYou are considering N different positions, and for each position, P free-agent\nplayers who play that position are available.8 Because you do not want to overload\nyour roster with too many players at any position, for each position you may sign\nat most one free agent who plays that position. (If you do not sign any players at a\nparticular position, then you plan to stick with the players you already have at that\nposition.)\nTo determine how valuable a player is going to be, you decide to use a sabermet-\nric statistic9 known as “VORP,” or “value over replacement player.” A player with\na higher VORP is more valuable than a player with a lower VORP. A player with a\nhigher VORP is not necessarily more expensive to sign than a player with a lower\nVORP, because factors other than a player’s value determine how much it costs to\nsign him.\nFor each available free-agent player, you have three pieces of information:\n\u0002\nthe player’s position,\n\u0002\nthe amount of money it will cost to sign the player, and\n\u0002\nthe player’s VORP.",
    "parent_6ce2d93b-c59c-4d30-ac79-37d7da83ee27": "VORP, because factors other than a player’s value determine how much it costs to\nsign him.\nFor each available free-agent player, you have three pieces of information:\n\u0002\nthe player’s position,\n\u0002\nthe amount of money it will cost to sign the player, and\n\u0002\nthe player’s VORP.\nDevise an algorithm that maximizes the total VORP of the players you sign while\nspending no more than $X altogether. You may assume that each player signs for a\nmultiple of $100,000. Your algorithm should output the total VORP of the players\nyou sign, the total amount of money you spend, and a list of which players you\nsign. Analyze the running time and space requirement of your algorithm.\nChapter notes\nR. Bellman began the systematic study of dynamic programming in 1955. The\nword “programming,” both here and in linear programming, refers to using a tab-\nular solution method. Although optimization techniques incorporating elements of\ndynamic programming were known earlier, Bellman provided the area with a solid\nmathematical basis [37].\n8Although there are nine positions on a baseball team, N is not necesarily equal to 9 because some\ngeneral managers have particular ways of thinking about positions. For example, a general manager\nmight consider right-handed pitchers and left-handed pitchers to be separate “positions,” as well as\nstarting pitchers, long relief pitchers (relief pitchers who can pitch several innings), and short relief\npitchers (relief pitchers who normally pitch at most only one inning).\n9Sabermetrics is the application of statistical analysis to baseball records. It provides several ways\nto compare the relative values of individual players.\nNotes for Chapter 15\n413\nGalil and Park [125] classify dynamic-programming algorithms according to the\nsize of the table and the number of other table entries each entry depends on. They\ncall a dynamic-programming algorithm tD=eD if its table size is O.nt/ and each\nentry depends on O.ne/ other entries. For example, the matrix-chain multiplication",
    "parent_113b6ec8-a785-4333-a571-4e96c8e6fb6b": "size of the table and the number of other table entries each entry depends on. They\ncall a dynamic-programming algorithm tD=eD if its table size is O.nt/ and each\nentry depends on O.ne/ other entries. For example, the matrix-chain multiplication\nalgorithm in Section 15.2 would be 2D=1D, and the longest-common-subsequence\nalgorithm in Section 15.4 would be 2D=0D.\nHu and Shing [182, 183] give an O.n lg n/-time algorithm for the matrix-chain\nmultiplication problem.\nThe O.mn/-time algorithm for the longest-common-subsequence problem ap-\npears to be a folk algorithm. Knuth [70] posed the question of whether subquadratic\nalgorithms for the LCS problem exist. Masek and Paterson [244] answered this\nquestion in the afﬁrmative by giving an algorithm that runs in O.mn= lg n/ time,\nwhere n \u0002 m and the sequences are drawn from a set of bounded size. For the\nspecial case in which no element appears more than once in an input sequence,\nSzymanski [326] shows how to solve the problem in O..n C m/ lg.n C m// time.\nMany of these results extend to the problem of computing string edit distances\n(Problem 15-5).\nAn early paper on variable-length binary encodings by Gilbert and Moore [133]\nhad applications to constructing optimal binary search trees for the case in which all\nprobabilities pi are 0; this paper contains an O.n3/-time algorithm. Aho, Hopcroft,\nand Ullman [5] present the algorithm from Section 15.5. Exercise 15.5-4 is due to\nKnuth [212]. Hu and Tucker [184] devised an algorithm for the case in which all\nprobabilities pi are 0 that uses O.n2/ time and O.n/ space; subsequently, Knuth\n[211] reduced the time to O.n lg n/.\nProblem 15-8 is due to Avidan and Shamir [27], who have posted on the Web a\nwonderful video illustrating this image-compression technique.\n16\nGreedy Algorithms\nAlgorithms for optimization problems typically go through a sequence of steps,\nwith a set of choices at each step. For many optimization problems, using dynamic",
    "parent_3a7b0347-81da-44d3-b6e8-5c1c3aa5cfea": "wonderful video illustrating this image-compression technique.\n16\nGreedy Algorithms\nAlgorithms for optimization problems typically go through a sequence of steps,\nwith a set of choices at each step. For many optimization problems, using dynamic\nprogramming to determine the best choices is overkill; simpler, more efﬁcient al-\ngorithms will do. A greedy algorithm always makes the choice that looks best at\nthe moment. That is, it makes a locally optimal choice in the hope that this choice\nwill lead to a globally optimal solution. This chapter explores optimization prob-\nlems for which greedy algorithms provide optimal solutions. Before reading this\nchapter, you should read about dynamic programming in Chapter 15, particularly\nSection 15.3.\nGreedy algorithms do not always yield optimal solutions, but for many problems\nthey do. We shall ﬁrst examine, in Section 16.1, a simple but nontrivial problem,\nthe activity-selection problem, for which a greedy algorithm efﬁciently computes\nan optimal solution. We shall arrive at the greedy algorithm by ﬁrst consider-\ning a dynamic-programming approach and then showing that we can always make\ngreedy choices to arrive at an optimal solution. Section 16.2 reviews the basic\nelements of the greedy approach, giving a direct approach for proving greedy al-\ngorithms correct. Section 16.3 presents an important application of greedy tech-\nniques: designing data-compression (Huffman) codes. In Section 16.4, we inves-\ntigate some of the theory underlying combinatorial structures called “matroids,”\nfor which a greedy algorithm always produces an optimal solution. Finally, Sec-\ntion 16.5 applies matroids to solve a problem of scheduling unit-time tasks with\ndeadlines and penalties.\nThe greedy method is quite powerful and works well for a wide range of prob-\nlems. Later chapters will present many algorithms that we can view as applica-\ntions of the greedy method, including minimum-spanning-tree algorithms (Chap-",
    "parent_6d81d86e-6f39-42a9-8b74-cd20b9f0672f": "deadlines and penalties.\nThe greedy method is quite powerful and works well for a wide range of prob-\nlems. Later chapters will present many algorithms that we can view as applica-\ntions of the greedy method, including minimum-spanning-tree algorithms (Chap-\nter 23), Dijkstra’s algorithm for shortest paths from a single source (Chapter 24),\nand Chv´atal’s greedy set-covering heuristic (Chapter 35). Minimum-spanning-tree\nalgorithms furnish a classic example of the greedy method. Although you can read\n16.1\nAn activity-selection problem\n415\nthis chapter and Chapter 23 independently of each other, you might ﬁnd it useful\nto read them together.\n16.1\nAn activity-selection problem\nOur ﬁrst example is the problem of scheduling several competing activities that re-\nquire exclusive use of a common resource, with a goal of selecting a maximum-size\nset of mutually compatible activities. Suppose we have a set S D fa1; a2; : : : ; ang\nof n proposed activities that wish to use a resource, such as a lecture hall, which\ncan serve only one activity at a time. Each activity ai has a start time si and a ﬁnish\ntime fi, where 0 \u0002 si < fi < 1. If selected, activity ai takes place during the\nhalf-open time interval Œsi; fi/. Activities ai and aj are compatible if the intervals\nŒsi; fi/ and Œsj; fj/ do not overlap. That is, ai and aj are compatible if si \u0006 fj\nor sj \u0006 fi. In the activity-selection problem, we wish to select a maximum-size\nsubset of mutually compatible activities. We assume that the activities are sorted\nin monotonically increasing order of ﬁnish time:\nf1 \u0002 f2 \u0002 f3 \u0002 \u0003 \u0003 \u0003 \u0002 fn\u00031 \u0002 fn :\n(16.1)\n(We shall see later the advantage that this assumption provides.) For example,\nconsider the following set S of activities:\ni\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nsi\n1\n3\n0\n5\n3\n5\n6\n8\n8\n2\n12\nfi\n4\n5\n6\n7\n9\n9\n10\n11\n12\n14\n16\nFor this example, the subset fa3; a9; a11g consists of mutually compatible activities.\nIt is not a maximum subset, however, since the subset fa1; a4; a8; a11g is larger. In",
    "parent_a80ccdf7-92c2-4a13-aa28-e9589580d57b": "consider the following set S of activities:\ni\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nsi\n1\n3\n0\n5\n3\n5\n6\n8\n8\n2\n12\nfi\n4\n5\n6\n7\n9\n9\n10\n11\n12\n14\n16\nFor this example, the subset fa3; a9; a11g consists of mutually compatible activities.\nIt is not a maximum subset, however, since the subset fa1; a4; a8; a11g is larger. In\nfact, fa1; a4; a8; a11g is a largest subset of mutually compatible activities; another\nlargest subset is fa2; a4; a9; a11g.\nWe shall solve this problem in several steps.\nWe start by thinking about a\ndynamic-programming solution, in which we consider several choices when deter-\nmining which subproblems to use in an optimal solution. We shall then observe that\nwe need to consider only one choice—the greedy choice—and that when we make\nthe greedy choice, only one subproblem remains. Based on these observations, we\nshall develop a recursive greedy algorithm to solve the activity-scheduling prob-\nlem. We shall complete the process of developing a greedy solution by converting\nthe recursive algorithm to an iterative one. Although the steps we shall go through\nin this section are slightly more involved than is typical when developing a greedy\nalgorithm, they illustrate the relationship between greedy algorithms and dynamic\nprogramming.\n416\nChapter 16\nGreedy Algorithms\nThe optimal substructure of the activity-selection problem\nWe can easily verify that the activity-selection problem exhibits optimal substruc-\nture. Let us denote by Sij the set of activities that start after activity ai ﬁnishes and\nthat ﬁnish before activity aj starts. Suppose that we wish to ﬁnd a maximum set of\nmutually compatible activities in Sij , and suppose further that such a maximum set\nis Aij, which includes some activity ak. By including ak in an optimal solution, we\nare left with two subproblems: ﬁnding mutually compatible activities in the set Sik\n(activities that start after activity ai ﬁnishes and that ﬁnish before activity ak starts)",
    "parent_a19c3021-dec7-4304-908b-72201a14a0b4": "is Aij, which includes some activity ak. By including ak in an optimal solution, we\nare left with two subproblems: ﬁnding mutually compatible activities in the set Sik\n(activities that start after activity ai ﬁnishes and that ﬁnish before activity ak starts)\nand ﬁnding mutually compatible activities in the set Skj (activities that start after\nactivity ak ﬁnishes and that ﬁnish before activity aj starts). Let Aik D Aij \\ Sik\nand Akj D Aij \\ Skj , so that Aik contains the activities in Aij that ﬁnish before ak\nstarts and Akj contains the activities in Aij that start after ak ﬁnishes. Thus, we\nhave Aij D Aik [ fakg [ Akj, and so the maximum-size set Aij of mutually com-\npatible activities in Sij consists of jAijj D jAikj C jAkjj C 1 activities.\nThe usual cut-and-paste argument shows that the optimal solution Aij must also\ninclude optimal solutions to the two subproblems for Sik and Skj . If we could\nﬁnd a set A0\nkj of mutually compatible activities in Skj where jA0\nkjj > jAkjj, then\nwe could use A0\nkj, rather than Akj, in a solution to the subproblem for Sij. We\nwould have constructed a set of jAikj C jA0\nkjj C 1 > jAikj C jAkjj C 1 D jAijj\nmutually compatible activities, which contradicts the assumption that Aij is an\noptimal solution. A symmetric argument applies to the activities in Sik.\nThis way of characterizing optimal substructure suggests that we might solve\nthe activity-selection problem by dynamic programming. If we denote the size of\nan optimal solution for the set Sij by cŒi; j \u0002, then we would have the recurrence\ncŒi; j \u0002 D cŒi; k\u0002 C cŒk; j \u0002 C 1 :\nOf course, if we did not know that an optimal solution for the set Sij includes\nactivity ak, we would have to examine all activities in Sij to ﬁnd which one to\nchoose, so that\ncŒi; j \u0002 D\n( 0\nif Sij D ; ;\nmax\nak2Sij fcŒi; k\u0002 C cŒk; j \u0002 C 1g\nif Sij ¤ ; :\n(16.2)\nWe could then develop a recursive algorithm and memoize it, or we could work",
    "parent_8f3095c3-86d7-4511-b111-9ef8a81704f2": "activity ak, we would have to examine all activities in Sij to ﬁnd which one to\nchoose, so that\ncŒi; j \u0002 D\n( 0\nif Sij D ; ;\nmax\nak2Sij fcŒi; k\u0002 C cŒk; j \u0002 C 1g\nif Sij ¤ ; :\n(16.2)\nWe could then develop a recursive algorithm and memoize it, or we could work\nbottom-up and ﬁll in table entries as we go along. But we would be overlooking\nanother important characteristic of the activity-selection problem that we can use\nto great advantage.\n16.1\nAn activity-selection problem\n417\nMaking the greedy choice\nWhat if we could choose an activity to add to our optimal solution without having\nto ﬁrst solve all the subproblems? That could save us from having to consider all\nthe choices inherent in recurrence (16.2). In fact, for the activity-selection problem,\nwe need consider only one choice: the greedy choice.\nWhat do we mean by the greedy choice for the activity-selection problem? Intu-\nition suggests that we should choose an activity that leaves the resource available\nfor as many other activities as possible. Now, of the activities we end up choos-\ning, one of them must be the ﬁrst one to ﬁnish. Our intuition tells us, therefore,\nto choose the activity in S with the earliest ﬁnish time, since that would leave the\nresource available for as many of the activities that follow it as possible. (If more\nthan one activity in S has the earliest ﬁnish time, then we can choose any such\nactivity.) In other words, since the activities are sorted in monotonically increasing\norder by ﬁnish time, the greedy choice is activity a1. Choosing the ﬁrst activity\nto ﬁnish is not the only way to think of making a greedy choice for this problem;\nExercise 16.1-3 asks you to explore other possibilities.\nIf we make the greedy choice, we have only one remaining subproblem to solve:\nﬁnding activities that start after a1 ﬁnishes. Why don’t we have to consider ac-\ntivities that ﬁnish before a1 starts? We have that s1 < f1, and f1 is the earliest",
    "parent_8aa99f1c-da9a-45a2-a308-4b5f557c6e2a": "Exercise 16.1-3 asks you to explore other possibilities.\nIf we make the greedy choice, we have only one remaining subproblem to solve:\nﬁnding activities that start after a1 ﬁnishes. Why don’t we have to consider ac-\ntivities that ﬁnish before a1 starts? We have that s1 < f1, and f1 is the earliest\nﬁnish time of any activity, and therefore no activity can have a ﬁnish time less than\nor equal to s1. Thus, all activities that are compatible with activity a1 must start\nafter a1 ﬁnishes.\nFurthermore, we have already established that the activity-selection problem ex-\nhibits optimal substructure. Let Sk D fai 2 S W si \u0006 fkg be the set of activities that\nstart after activity ak ﬁnishes. If we make the greedy choice of activity a1, then S1\nremains as the only subproblem to solve.1 Optimal substructure tells us that if a1\nis in the optimal solution, then an optimal solution to the original problem consists\nof activity a1 and all the activities in an optimal solution to the subproblem S1.\nOne big question remains: is our intuition correct? Is the greedy choice—in\nwhich we choose the ﬁrst activity to ﬁnish—always part of some optimal solution?\nThe following theorem shows that it is.\n1We sometimes refer to the sets Sk as subproblems rather than as just sets of activities. It will always\nbe clear from the context whether we are referring to Sk as a set of activities or as a subproblem\nwhose input is that set.\n418\nChapter 16\nGreedy Algorithms\nTheorem 16.1\nConsider any nonempty subproblem Sk, and let am be an activity in Sk with the\nearliest ﬁnish time. Then am is included in some maximum-size subset of mutually\ncompatible activities of Sk.\nProof\nLet Ak be a maximum-size subset of mutually compatible activities in Sk,\nand let aj be the activity in Ak with the earliest ﬁnish time. If aj D am, we are\ndone, since we have shown that am is in some maximum-size subset of mutually\ncompatible activities of Sk. If aj ¤ am, let the set A0\nk D Ak \u0005 fajg [ famg be Ak",
    "parent_b2497a65-0ef3-4563-b52f-d84ef89d6987": "and let aj be the activity in Ak with the earliest ﬁnish time. If aj D am, we are\ndone, since we have shown that am is in some maximum-size subset of mutually\ncompatible activities of Sk. If aj ¤ am, let the set A0\nk D Ak \u0005 fajg [ famg be Ak\nbut substituting am for aj. The activities in A0\nk are disjoint, which follows because\nthe activities in Ak are disjoint, aj is the ﬁrst activity in Ak to ﬁnish, and fm \u0002 fj.\nSince jA0\nkj D jAkj, we conclude that A0\nk is a maximum-size subset of mutually\ncompatible activities of Sk, and it includes am.\nThus, we see that although we might be able to solve the activity-selection prob-\nlem with dynamic programming, we don’t need to. (Besides, we have not yet\nexamined whether the activity-selection problem even has overlapping subprob-\nlems.) Instead, we can repeatedly choose the activity that ﬁnishes ﬁrst, keep only\nthe activities compatible with this activity, and repeat until no activities remain.\nMoreover, because we always choose the activity with the earliest ﬁnish time, the\nﬁnish times of the activities we choose must strictly increase. We can consider\neach activity just once overall, in monotonically increasing order of ﬁnish times.\nAn algorithm to solve the activity-selection problem does not need to work\nbottom-up, like a table-based dynamic-programming algorithm. Instead, it can\nwork top-down, choosing an activity to put into the optimal solution and then solv-\ning the subproblem of choosing activities from those that are compatible with those\nalready chosen. Greedy algorithms typically have this top-down design: make a\nchoice and then solve a subproblem, rather than the bottom-up technique of solving\nsubproblems before making a choice.\nA recursive greedy algorithm\nNow that we have seen how to bypass the dynamic-programming approach and in-\nstead use a top-down, greedy algorithm, we can write a straightforward, recursive\nprocedure to solve the activity-selection problem. The procedure RECURSIVE-",
    "parent_754563d2-50f1-4c11-ae83-66337a2465ee": "subproblems before making a choice.\nA recursive greedy algorithm\nNow that we have seen how to bypass the dynamic-programming approach and in-\nstead use a top-down, greedy algorithm, we can write a straightforward, recursive\nprocedure to solve the activity-selection problem. The procedure RECURSIVE-\nACTIVITY-SELECTOR takes the start and ﬁnish times of the activities, represented\nas arrays s and f ,2 the index k that deﬁnes the subproblem Sk it is to solve, and\n2Because the pseudocode takes s and f as arrays, it indexes into them with square brackets rather\nthan subscripts.\n16.1\nAn activity-selection problem\n419\nthe size n of the original problem. It returns a maximum-size set of mutually com-\npatible activities in Sk. We assume that the n input activities are already ordered\nby monotonically increasing ﬁnish time, according to equation (16.1). If not, we\ncan sort them into this order in O.n lg n/ time, breaking ties arbitrarily. In order\nto start, we add the ﬁctitious activity a0 with f0 D 0, so that subproblem S0 is\nthe entire set of activities S. The initial call, which solves the entire problem, is\nRECURSIVE-ACTIVITY-SELECTOR.s; f; 0; n/.\nRECURSIVE-ACTIVITY-SELECTOR.s; f; k; n/\n1\nm D k C 1\n2\nwhile m \u0002 n and sŒm\u0002 < f Œk\u0002\n// ﬁnd the ﬁrst activity in Sk to ﬁnish\n3\nm D m C 1\n4\nif m \u0002 n\n5\nreturn famg [ RECURSIVE-ACTIVITY-SELECTOR.s; f; m; n/\n6\nelse return ;\nFigure 16.1 shows the operation of the algorithm.\nIn a given recursive call\nRECURSIVE-ACTIVITY-SELECTOR.s; f; k; n/, the while loop of lines 2–3 looks\nfor the ﬁrst activity in Sk to ﬁnish. The loop examines akC1; akC2; : : : ; an, un-\ntil it ﬁnds the ﬁrst activity am that is compatible with ak; such an activity has\nsm \u0006 fk. If the loop terminates because it ﬁnds such an activity, line 5 returns\nthe union of famg and the maximum-size subset of Sm returned by the recursive\ncall RECURSIVE-ACTIVITY-SELECTOR.s; f; m; n/. Alternatively, the loop may",
    "parent_f6928192-5d86-4723-86e1-4a96a59d7920": "sm \u0006 fk. If the loop terminates because it ﬁnds such an activity, line 5 returns\nthe union of famg and the maximum-size subset of Sm returned by the recursive\ncall RECURSIVE-ACTIVITY-SELECTOR.s; f; m; n/. Alternatively, the loop may\nterminate because m > n, in which case we have examined all activities in Sk\nwithout ﬁnding one that is compatible with ak. In this case, Sk D ;, and so the\nprocedure returns ; in line 6.\nAssuming that the activities have already been sorted by ﬁnish times, the running\ntime of the call RECURSIVE-ACTIVITY-SELECTOR.s; f; 0; n/ is ‚.n/, which we\ncan see as follows. Over all recursive calls, each activity is examined exactly once\nin the while loop test of line 2. In particular, activity ai is examined in the last call\nmade in which k < i.\nAn iterative greedy algorithm\nWe easily can convert our recursive procedure to an iterative one. The procedure\nRECURSIVE-ACTIVITY-SELECTOR is almost “tail recursive” (see Problem 7-4):\nit ends with a recursive call to itself followed by a union operation. It is usually a\nstraightforward task to transform a tail-recursive procedure to an iterative form; in\nfact, some compilers for certain programming languages perform this task automat-\nically. As written, RECURSIVE-ACTIVITY-SELECTOR works for subproblems Sk,\ni.e., subproblems that consist of the last activities to ﬁnish.\n420\nChapter 16\nGreedy Algorithms\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\ntime\n2\n3\n5\n3\n0\n6\n4\n5\n7\n5\n3\n9\n6\n5\n9\n7\n6\n10\n8\n8\n11\n9\n8\n12\n10\n2\n14\n11\n12\n16\n1\n1\n4\nk\nsk\nfk\na1\na2\na1\na3\na1\na4\na1\na4\na5\na1\na4\na6\na1\na4\na7\na1\na4\na8\na1\na4\na8\na9\na1\na4\na8\na10\na1\na4\na8\na11\na1\na4\na8\na11\n0\n–\n0\na1\na0\na0\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 0, 11)\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 1, 11)\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 4, 11)\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 8, 11)\nm = 1\nm = 4\nm = 8\nm = 11\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 11, 11)\n15\n16\nFigure 16.1\nThe operation of RECURSIVE-ACTIVITY-SELECTOR on the 11 activities given ear-",
    "parent_a2c212f8-126b-44f5-a17c-90d6ffed18f1": "RECURSIVE-ACTIVITY-SELECTOR(s, f, 1, 11)\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 4, 11)\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 8, 11)\nm = 1\nm = 4\nm = 8\nm = 11\nRECURSIVE-ACTIVITY-SELECTOR(s, f, 11, 11)\n15\n16\nFigure 16.1\nThe operation of RECURSIVE-ACTIVITY-SELECTOR on the 11 activities given ear-\nlier. Activities considered in each recursive call appear between horizontal lines. The ﬁctitious\nactivity a0 ﬁnishes at time 0, and the initial call RECURSIVE-ACTIVITY-SELECTOR.s; f; 0; 11/, se-\nlects activity a1. In each recursive call, the activities that have already been selected are shaded,\nand the activity shown in white is being considered. If the starting time of an activity occurs before\nthe ﬁnish time of the most recently added activity (the arrow between them points left), it is re-\njected. Otherwise (the arrow points directly up or to the right), it is selected. The last recursive call,\nRECURSIVE-ACTIVITY-SELECTOR.s; f; 11; 11/, returns ;. The resulting set of selected activities is\nfa1; a4; a8; a11g.\n16.1\nAn activity-selection problem\n421\nThe procedure GREEDY-ACTIVITY-SELECTOR is an iterative version of the pro-\ncedure RECURSIVE-ACTIVITY-SELECTOR. It also assumes that the input activi-\nties are ordered by monotonically increasing ﬁnish time. It collects selected activ-\nities into a set A and returns this set when it is done.\nGREEDY-ACTIVITY-SELECTOR.s; f /\n1\nn D s:length\n2\nA D fa1g\n3\nk D 1\n4\nfor m D 2 to n\n5\nif sŒm\u0002 \u0006 f Œk\u0002\n6\nA D A [ famg\n7\nk D m\n8\nreturn A\nThe procedure works as follows. The variable k indexes the most recent addition\nto A, corresponding to the activity ak in the recursive version. Since we consider\nthe activities in order of monotonically increasing ﬁnish time, fk is always the\nmaximum ﬁnish time of any activity in A. That is,\nfk D max ffi W ai 2 Ag :\n(16.3)\nLines 2–3 select activity a1, initialize A to contain just this activity, and initialize k\nto index this activity. The for loop of lines 4–7 ﬁnds the earliest activity in Sk to",
    "parent_a71d0dde-945e-4270-887c-96371f90e440": "maximum ﬁnish time of any activity in A. That is,\nfk D max ffi W ai 2 Ag :\n(16.3)\nLines 2–3 select activity a1, initialize A to contain just this activity, and initialize k\nto index this activity. The for loop of lines 4–7 ﬁnds the earliest activity in Sk to\nﬁnish. The loop considers each activity am in turn and adds am to A if it is compat-\nible with all previously selected activities; such an activity is the earliest in Sk to\nﬁnish. To see whether activity am is compatible with every activity currently in A,\nit sufﬁces by equation (16.3) to check (in line 5) that its start time sm is not earlier\nthan the ﬁnish time fk of the activity most recently added to A. If activity am is\ncompatible, then lines 6–7 add activity am to A and set k to m. The set A returned\nby the call GREEDY-ACTIVITY-SELECTOR.s; f / is precisely the set returned by\nthe call RECURSIVE-ACTIVITY-SELECTOR.s; f; 0; n/.\nLike the recursive version, GREEDY-ACTIVITY-SELECTOR schedules a set of n\nactivities in ‚.n/ time, assuming that the activities were already sorted initially by\ntheir ﬁnish times.\nExercises\n16.1-1\nGive a dynamic-programming algorithm for the activity-selection problem, based\non recurrence (16.2). Have your algorithm compute the sizes cŒi; j \u0002 as deﬁned\nabove and also produce the maximum-size subset of mutually compatible activities.\n422\nChapter 16\nGreedy Algorithms\nAssume that the inputs have been sorted as in equation (16.1). Compare the running\ntime of your solution to the running time of GREEDY-ACTIVITY-SELECTOR.\n16.1-2\nSuppose that instead of always selecting the ﬁrst activity to ﬁnish, we instead select\nthe last activity to start that is compatible with all previously selected activities. De-\nscribe how this approach is a greedy algorithm, and prove that it yields an optimal\nsolution.\n16.1-3\nNot just any greedy approach to the activity-selection problem produces a max-\nimum-size set of mutually compatible activities. Give an example to show that",
    "parent_dca8db6b-3b74-48ff-8921-c22322127d3c": "scribe how this approach is a greedy algorithm, and prove that it yields an optimal\nsolution.\n16.1-3\nNot just any greedy approach to the activity-selection problem produces a max-\nimum-size set of mutually compatible activities. Give an example to show that\nthe approach of selecting the activity of least duration from among those that are\ncompatible with previously selected activities does not work. Do the same for\nthe approaches of always selecting the compatible activity that overlaps the fewest\nother remaining activities and always selecting the compatible remaining activity\nwith the earliest start time.\n16.1-4\nSuppose that we have a set of activities to schedule among a large number of lecture\nhalls, where any activity can take place in any lecture hall. We wish to schedule\nall the activities using as few lecture halls as possible. Give an efﬁcient greedy\nalgorithm to determine which activity should use which lecture hall.\n(This problem is also known as the interval-graph coloring problem. We can\ncreate an interval graph whose vertices are the given activities and whose edges\nconnect incompatible activities. The smallest number of colors required to color\nevery vertex so that no two adjacent vertices have the same color corresponds to\nﬁnding the fewest lecture halls needed to schedule all of the given activities.)\n16.1-5\nConsider a modiﬁcation to the activity-selection problem in which each activity ai\nhas, in addition to a start and ﬁnish time, a value \u0003i. The objective is no longer\nto maximize the number of activities scheduled, but instead to maximize the total\nvalue of the activities scheduled. That is, we wish to choose a set A of compatible\nactivities such that P\nak2A \u0003k is maximized. Give a polynomial-time algorithm for\nthis problem.\n16.2\nElements of the greedy strategy\n423\n16.2\nElements of the greedy strategy\nA greedy algorithm obtains an optimal solution to a problem by making a sequence",
    "parent_b494755e-ef7b-494f-a195-b4a06d599dc4": "activities such that P\nak2A \u0003k is maximized. Give a polynomial-time algorithm for\nthis problem.\n16.2\nElements of the greedy strategy\n423\n16.2\nElements of the greedy strategy\nA greedy algorithm obtains an optimal solution to a problem by making a sequence\nof choices. At each decision point, the algorithm makes choice that seems best at\nthe moment. This heuristic strategy does not always produce an optimal solution,\nbut as we saw in the activity-selection problem, sometimes it does. This section\ndiscusses some of the general properties of greedy methods.\nThe process that we followed in Section 16.1 to develop a greedy algorithm was\na bit more involved than is typical. We went through the following steps:\n1. Determine the optimal substructure of the problem.\n2. Develop a recursive solution. (For the activity-selection problem, we formu-\nlated recurrence (16.2), but we bypassed developing a recursive algorithm based\non this recurrence.)\n3. Show that if we make the greedy choice, then only one subproblem remains.\n4. Prove that it is always safe to make the greedy choice. (Steps 3 and 4 can occur\nin either order.)\n5. Develop a recursive algorithm that implements the greedy strategy.\n6. Convert the recursive algorithm to an iterative algorithm.\nIn going through these steps, we saw in great detail the dynamic-programming un-\nderpinnings of a greedy algorithm. For example, in the activity-selection problem,\nwe ﬁrst deﬁned the subproblems Sij, where both i and j varied. We then found\nthat if we always made the greedy choice, we could restrict the subproblems to be\nof the form Sk.\nAlternatively, we could have fashioned our optimal substructure with a greedy\nchoice in mind, so that the choice leaves just one subproblem to solve. In the\nactivity-selection problem, we could have started by dropping the second subscript\nand deﬁning subproblems of the form Sk. Then, we could have proven that a greedy",
    "parent_e4038cd4-a0bf-487e-ad1d-57197b96aaf5": "choice in mind, so that the choice leaves just one subproblem to solve. In the\nactivity-selection problem, we could have started by dropping the second subscript\nand deﬁning subproblems of the form Sk. Then, we could have proven that a greedy\nchoice (the ﬁrst activity am to ﬁnish in Sk), combined with an optimal solution to\nthe remaining set Sm of compatible activities, yields an optimal solution to Sk.\nMore generally, we design greedy algorithms according to the following sequence\nof steps:\n1. Cast the optimization problem as one in which we make a choice and are left\nwith one subproblem to solve.\n2. Prove that there is always an optimal solution to the original problem that makes\nthe greedy choice, so that the greedy choice is always safe.\n424\nChapter 16\nGreedy Algorithms\n3. Demonstrate optimal substructure by showing that, having made the greedy\nchoice, what remains is a subproblem with the property that if we combine an\noptimal solution to the subproblem with the greedy choice we have made, we\narrive at an optimal solution to the original problem.\nWe shall use this more direct process in later sections of this chapter. Neverthe-\nless, beneath every greedy algorithm, there is almost always a more cumbersome\ndynamic-programming solution.\nHow can we tell whether a greedy algorithm will solve a particular optimization\nproblem? No way works all the time, but the greedy-choice property and optimal\nsubstructure are the two key ingredients. If we can demonstrate that the problem\nhas these properties, then we are well on the way to developing a greedy algorithm\nfor it.\nGreedy-choice property\nThe ﬁrst key ingredient is the greedy-choice property: we can assemble a globally\noptimal solution by making locally optimal (greedy) choices. In other words, when\nwe are considering which choice to make, we make the choice that looks best in\nthe current problem, without considering results from subproblems.\nHere is where greedy algorithms differ from dynamic programming. In dynamic",
    "parent_a7a4efa4-dcdb-4461-8a67-deb540d40c40": "we are considering which choice to make, we make the choice that looks best in\nthe current problem, without considering results from subproblems.\nHere is where greedy algorithms differ from dynamic programming. In dynamic\nprogramming, we make a choice at each step, but the choice usually depends on the\nsolutions to subproblems. Consequently, we typically solve dynamic-programming\nproblems in a bottom-up manner, progressing from smaller subproblems to larger\nsubproblems. (Alternatively, we can solve them top down, but memoizing. Of\ncourse, even though the code works top down, we still must solve the subprob-\nlems before making a choice.) In a greedy algorithm, we make whatever choice\nseems best at the moment and then solve the subproblem that remains. The choice\nmade by a greedy algorithm may depend on choices so far, but it cannot depend on\nany future choices or on the solutions to subproblems. Thus, unlike dynamic pro-\ngramming, which solves the subproblems before making the ﬁrst choice, a greedy\nalgorithm makes its ﬁrst choice before solving any subproblems.\nA dynamic-\nprogramming algorithm proceeds bottom up, whereas a greedy strategy usually\nprogresses in a top-down fashion, making one greedy choice after another, reduc-\ning each given problem instance to a smaller one.\nOf course, we must prove that a greedy choice at each step yields a globally\noptimal solution. Typically, as in the case of Theorem 16.1, the proof examines\na globally optimal solution to some subproblem. It then shows how to modify\nthe solution to substitute the greedy choice for some other choice, resulting in one\nsimilar, but smaller, subproblem.\nWe can usually make the greedy choice more efﬁciently than when we have to\nconsider a wider set of choices. For example, in the activity-selection problem, as-\n16.2\nElements of the greedy strategy\n425\nsuming that we had already sorted the activities in monotonically increasing order",
    "parent_e9923fa3-59ae-443b-a321-06cebc43d20f": "We can usually make the greedy choice more efﬁciently than when we have to\nconsider a wider set of choices. For example, in the activity-selection problem, as-\n16.2\nElements of the greedy strategy\n425\nsuming that we had already sorted the activities in monotonically increasing order\nof ﬁnish times, we needed to examine each activity just once. By preprocessing the\ninput or by using an appropriate data structure (often a priority queue), we often\ncan make greedy choices quickly, thus yielding an efﬁcient algorithm.\nOptimal substructure\nA problem exhibits optimal substructure if an optimal solution to the problem\ncontains within it optimal solutions to subproblems. This property is a key in-\ngredient of assessing the applicability of dynamic programming as well as greedy\nalgorithms. As an example of optimal substructure, recall how we demonstrated in\nSection 16.1 that if an optimal solution to subproblem Sij includes an activity ak,\nthen it must also contain optimal solutions to the subproblems Sik and Skj . Given\nthis optimal substructure, we argued that if we knew which activity to use as ak, we\ncould construct an optimal solution to Sij by selecting ak along with all activities\nin optimal solutions to the subproblems Sik and Skj . Based on this observation of\noptimal substructure, we were able to devise the recurrence (16.2) that described\nthe value of an optimal solution.\nWe usually use a more direct approach regarding optimal substructure when\napplying it to greedy algorithms. As mentioned above, we have the luxury of\nassuming that we arrived at a subproblem by having made the greedy choice in\nthe original problem. All we really need to do is argue that an optimal solution to\nthe subproblem, combined with the greedy choice already made, yields an optimal\nsolution to the original problem. This scheme implicitly uses induction on the\nsubproblems to prove that making the greedy choice at every step produces an\noptimal solution.\nGreedy versus dynamic programming",
    "parent_e4f41faa-7d9f-4c9a-a841-7e8d932f6eea": "the subproblem, combined with the greedy choice already made, yields an optimal\nsolution to the original problem. This scheme implicitly uses induction on the\nsubproblems to prove that making the greedy choice at every step produces an\noptimal solution.\nGreedy versus dynamic programming\nBecause both the greedy and dynamic-programming strategies exploit optimal sub-\nstructure, you might be tempted to generate a dynamic-programming solution to a\nproblem when a greedy solution sufﬁces or, conversely, you might mistakenly think\nthat a greedy solution works when in fact a dynamic-programming solution is re-\nquired. To illustrate the subtleties between the two techniques, let us investigate\ntwo variants of a classical optimization problem.\nThe 0-1 knapsack problem is the following. A thief robbing a store ﬁnds n\nitems. The ith item is worth \u0003i dollars and weighs wi pounds, where \u0003i and wi are\nintegers. The thief wants to take as valuable a load as possible, but he can carry at\nmost W pounds in his knapsack, for some integer W . Which items should he take?\n(We call this the 0-1 knapsack problem because for each item, the thief must either\n426\nChapter 16\nGreedy Algorithms\ntake it or leave it behind; he cannot take a fractional amount of an item or take an\nitem more than once.)\nIn the fractional knapsack problem, the setup is the same, but the thief can take\nfractions of items, rather than having to make a binary (0-1) choice for each item.\nYou can think of an item in the 0-1 knapsack problem as being like a gold ingot\nand an item in the fractional knapsack problem as more like gold dust.\nBoth knapsack problems exhibit the optimal-substructure property. For the 0-1\nproblem, consider the most valuable load that weighs at most W pounds. If we\nremove item j from this load, the remaining load must be the most valuable load\nweighing at most W \u0005 wj that the thief can take from the n \u0005 1 original items\nexcluding j . For the comparable fractional problem, consider that if we remove",
    "parent_9e108981-5589-40d1-9d49-6ebce8608795": "remove item j from this load, the remaining load must be the most valuable load\nweighing at most W \u0005 wj that the thief can take from the n \u0005 1 original items\nexcluding j . For the comparable fractional problem, consider that if we remove\na weight w of one item j from the optimal load, the remaining load must be the\nmost valuable load weighing at most W \u0005 w that the thief can take from the n \u0005 1\noriginal items plus wj \u0005 w pounds of item j .\nAlthough the problems are similar, we can solve the fractional knapsack problem\nby a greedy strategy, but we cannot solve the 0-1 problem by such a strategy. To\nsolve the fractional problem, we ﬁrst compute the value per pound \u0003i=wi for each\nitem. Obeying a greedy strategy, the thief begins by taking as much as possible of\nthe item with the greatest value per pound. If the supply of that item is exhausted\nand he can still carry more, he takes as much as possible of the item with the next\ngreatest value per pound, and so forth, until he reaches his weight limit W . Thus,\nby sorting the items by value per pound, the greedy algorithm runs in O.n lg n/\ntime. We leave the proof that the fractional knapsack problem has the greedy-\nchoice property as Exercise 16.2-1.\nTo see that this greedy strategy does not work for the 0-1 knapsack problem,\nconsider the problem instance illustrated in Figure 16.2(a). This example has 3\nitems and a knapsack that can hold 50 pounds. Item 1 weighs 10 pounds and\nis worth 60 dollars. Item 2 weighs 20 pounds and is worth 100 dollars. Item 3\nweighs 30 pounds and is worth 120 dollars. Thus, the value per pound of item 1 is\n6 dollars per pound, which is greater than the value per pound of either item 2 (5\ndollars per pound) or item 3 (4 dollars per pound). The greedy strategy, therefore,\nwould take item 1 ﬁrst. As you can see from the case analysis in Figure 16.2(b),\nhowever, the optimal solution takes items 2 and 3, leaving item 1 behind. The two\npossible solutions that take item 1 are both suboptimal.",
    "parent_1a39ddbc-7702-40e4-aafe-10f75e90e47b": "would take item 1 ﬁrst. As you can see from the case analysis in Figure 16.2(b),\nhowever, the optimal solution takes items 2 and 3, leaving item 1 behind. The two\npossible solutions that take item 1 are both suboptimal.\nFor the comparable fractional problem, however, the greedy strategy, which\ntakes item 1 ﬁrst, does yield an optimal solution, as shown in Figure 16.2(c). Tak-\ning item 1 doesn’t work in the 0-1 problem because the thief is unable to ﬁll his\nknapsack to capacity, and the empty space lowers the effective value per pound of\nhis load. In the 0-1 problem, when we consider whether to include an item in the\nknapsack, we must compare the solution to the subproblem that includes the item\nwith the solution to the subproblem that excludes the item before we can make the\n16.2\nElements of the greedy strategy\n427\n10\n$60\nitem 1\n20\n$100\nitem 2\n30\n$120\nitem 3\n50\nknapsack\n(a)\n+\n$120\n$100\n= $220\n+\n$60\n$100\n= $160\n+\n$60\n$120\n= $180\n(b)\n+\n$60\n$100\n= $240\n$80\n+\n(c)\n20\n30\n10\n20\n10\n30\n10\n20\n20\n30\nFigure 16.2\nAn example showing that the greedy strategy does not work for the 0-1 knapsack\nproblem. (a) The thief must select a subset of the three items shown whose weight must not exceed\n50 pounds. (b) The optimal subset includes items 2 and 3. Any solution with item 1 is suboptimal,\neven though item 1 has the greatest value per pound. (c) For the fractional knapsack problem, taking\nthe items in order of greatest value per pound yields an optimal solution.\nchoice. The problem formulated in this way gives rise to many overlapping sub-\nproblems—a hallmark of dynamic programming, and indeed, as Exercise 16.2-2\nasks you to show, we can use dynamic programming to solve the 0-1 problem.\nExercises\n16.2-1\nProve that the fractional knapsack problem has the greedy-choice property.\n16.2-2\nGive a dynamic-programming solution to the 0-1 knapsack problem that runs in\nO.n W / time, where n is the number of items and W is the maximum weight of\nitems that the thief can put in his knapsack.",
    "parent_cfc8bfc5-b7ef-4fb3-a4ae-467913402170": "Exercises\n16.2-1\nProve that the fractional knapsack problem has the greedy-choice property.\n16.2-2\nGive a dynamic-programming solution to the 0-1 knapsack problem that runs in\nO.n W / time, where n is the number of items and W is the maximum weight of\nitems that the thief can put in his knapsack.\n16.2-3\nSuppose that in a 0-1 knapsack problem, the order of the items when sorted by\nincreasing weight is the same as their order when sorted by decreasing value. Give\nan efﬁcient algorithm to ﬁnd an optimal solution to this variant of the knapsack\nproblem, and argue that your algorithm is correct.\n16.2-4\nProfessor Gekko has always dreamed of inline skating across North Dakota. He\nplans to cross the state on highway U.S. 2, which runs from Grand Forks, on the\neastern border with Minnesota, to Williston, near the western border with Montana.\n428\nChapter 16\nGreedy Algorithms\nThe professor can carry two liters of water, and he can skate m miles before running\nout of water. (Because North Dakota is relatively ﬂat, the professor does not have\nto worry about drinking water at a greater rate on uphill sections than on ﬂat or\ndownhill sections.) The professor will start in Grand Forks with two full liters of\nwater. His ofﬁcial North Dakota state map shows all the places along U.S. 2 at\nwhich he can reﬁll his water and the distances between these locations.\nThe professor’s goal is to minimize the number of water stops along his route\nacross the state. Give an efﬁcient method by which he can determine which water\nstops he should make. Prove that your strategy yields an optimal solution, and give\nits running time.\n16.2-5\nDescribe an efﬁcient algorithm that, given a set fx1; x2; : : : ; xng of points on the\nreal line, determines the smallest set of unit-length closed intervals that contains\nall of the given points. Argue that your algorithm is correct.\n16.2-6\n?\nShow how to solve the fractional knapsack problem in O.n/ time.\n16.2-7",
    "parent_8719c79a-86d0-4331-8495-a67c3e997215": "real line, determines the smallest set of unit-length closed intervals that contains\nall of the given points. Argue that your algorithm is correct.\n16.2-6\n?\nShow how to solve the fractional knapsack problem in O.n/ time.\n16.2-7\nSuppose you are given two sets A and B, each containing n positive integers. You\ncan choose to reorder each set however you like. After reordering, let ai be the ith\nelement of set A, and let bi be the ith element of set B. You then receive a payoff\nof Qn\niD1 ai\nbi. Give an algorithm that will maximize your payoff. Prove that your\nalgorithm maximizes the payoff, and state its running time.\n16.3\nHuffman codes\nHuffman codes compress data very effectively: savings of 20% to 90% are typical,\ndepending on the characteristics of the data being compressed. We consider the\ndata to be a sequence of characters. Huffman’s greedy algorithm uses a table giving\nhow often each character occurs (i.e., its frequency) to build up an optimal way of\nrepresenting each character as a binary string.\nSuppose we have a 100,000-character data ﬁle that we wish to store compactly.\nWe observe that the characters in the ﬁle occur with the frequencies given by Fig-\nure 16.3. That is, only 6 different characters appear, and the character a occurs\n45,000 times.\nWe have many options for how to represent such a ﬁle of information. Here,\nwe consider the problem of designing a binary character code (or code for short)\n16.3\nHuffman codes\n429\na\nb\nc\nd\ne\nf\nFrequency (in thousands)\n45\n13\n12\n16\n9\n5\nFixed-length codeword\n000\n001\n010\n011\n100\n101\nVariable-length codeword\n0\n101\n100\n111\n1101\n1100\nFigure 16.3\nA character-coding problem. A data ﬁle of 100,000 characters contains only the char-\nacters a–f, with the frequencies indicated. If we assign each character a 3-bit codeword, we can\nencode the ﬁle in 300,000 bits. Using the variable-length code shown, we can encode the ﬁle in only\n224,000 bits.\nin which each character is represented by a unique binary string, which we call a",
    "parent_828e7a9a-10fc-46bb-8e40-46d454cb6b7a": "acters a–f, with the frequencies indicated. If we assign each character a 3-bit codeword, we can\nencode the ﬁle in 300,000 bits. Using the variable-length code shown, we can encode the ﬁle in only\n224,000 bits.\nin which each character is represented by a unique binary string, which we call a\ncodeword. If we use a ﬁxed-length code, we need 3 bits to represent 6 characters:\na = 000, b = 001, . . . , f = 101. This method requires 300,000 bits to code the\nentire ﬁle. Can we do better?\nA variable-length code can do considerably better than a ﬁxed-length code, by\ngiving frequent characters short codewords and infrequent characters long code-\nwords. Figure 16.3 shows such a code; here the 1-bit string 0 represents a, and the\n4-bit string 1100 represents f. This code requires\n.45 \u0003 1 C 13 \u0003 3 C 12 \u0003 3 C 16 \u0003 3 C 9 \u0003 4 C 5 \u0003 4/ \u0003 1,000 D 224,000 bits\nto represent the ﬁle, a savings of approximately 25%. In fact, this is an optimal\ncharacter code for this ﬁle, as we shall see.\nPreﬁx codes\nWe consider here only codes in which no codeword is also a preﬁx of some other\ncodeword. Such codes are called preﬁx codes.3 Although we won’t prove it here, a\npreﬁx code can always achieve the optimal data compression among any character\ncode, and so we suffer no loss of generality by restricting our attention to preﬁx\ncodes.\nEncoding is always simple for any binary character code; we just concatenate the\ncodewords representing each character of the ﬁle. For example, with the variable-\nlength preﬁx code of Figure 16.3, we code the 3-character ﬁle abc as 0\u0003101\u0003100 D\n0101100, where “\u0003” denotes concatenation.\nPreﬁx codes are desirable because they simplify decoding. Since no codeword\nis a preﬁx of any other, the codeword that begins an encoded ﬁle is unambiguous.\nWe can simply identify the initial codeword, translate it back to the original char-\n3Perhaps “preﬁx-free codes” would be a better name, but the term “preﬁx codes” is standard in the\nliterature.\n430\nChapter 16\nGreedy Algorithms\na:45",
    "parent_586b1da6-2e12-4737-8b56-ca2edd40c4d0": "We can simply identify the initial codeword, translate it back to the original char-\n3Perhaps “preﬁx-free codes” would be a better name, but the term “preﬁx codes” is standard in the\nliterature.\n430\nChapter 16\nGreedy Algorithms\na:45\nb:13\nc:12\nd:16\ne:9\nf:5\n58\n28\n14\n86\n14\n100\n0\n1\n0\n1\n0\n1\n0\n1\n0\n0\n1\ne:9\nf:5\n14\n0\n1\nc:12\nb:13\n25\n0\n1\nd:16\n30\n0\n1\n55\n0\n1\na:45\n100\n0\n1\n(a)\n(b)\nFigure 16.4\nTrees corresponding to the coding schemes in Figure 16.3. Each leaf is labeled with\na character and its frequency of occurrence. Each internal node is labeled with the sum of the fre-\nquencies of the leaves in its subtree. (a) The tree corresponding to the ﬁxed-length code a = 000, . . . ,\nf = 101. (b) The tree corresponding to the optimal preﬁx code a = 0, b = 101, . . . , f = 1100.\nacter, and repeat the decoding process on the remainder of the encoded ﬁle. In our\nexample, the string 001011101 parses uniquely as 0 \u0003 0 \u0003 101 \u0003 1101, which decodes\nto aabe.\nThe decoding process needs a convenient representation for the preﬁx code so\nthat we can easily pick off the initial codeword. A binary tree whose leaves are\nthe given characters provides one such representation.\nWe interpret the binary\ncodeword for a character as the simple path from the root to that character, where 0\nmeans “go to the left child” and 1 means “go to the right child.” Figure 16.4 shows\nthe trees for the two codes of our example. Note that these are not binary search\ntrees, since the leaves need not appear in sorted order and internal nodes do not\ncontain character keys.\nAn optimal code for a ﬁle is always represented by a full binary tree, in which\nevery nonleaf node has two children (see Exercise 16.3-2). The ﬁxed-length code\nin our example is not optimal since its tree, shown in Figure 16.4(a), is not a full bi-\nnary tree: it contains codewords beginning 10. . . , but none beginning 11. . . . Since\nwe can now restrict our attention to full binary trees, we can say that if C is the",
    "parent_bdddc14f-9d1f-44a2-beb0-5a754d86c461": "in our example is not optimal since its tree, shown in Figure 16.4(a), is not a full bi-\nnary tree: it contains codewords beginning 10. . . , but none beginning 11. . . . Since\nwe can now restrict our attention to full binary trees, we can say that if C is the\nalphabet from which the characters are drawn and all character frequencies are pos-\nitive, then the tree for an optimal preﬁx code has exactly jCj leaves, one for each\nletter of the alphabet, and exactly jCj \u0005 1 internal nodes (see Exercise B.5-3).\nGiven a tree T corresponding to a preﬁx code, we can easily compute the number\nof bits required to encode a ﬁle. For each character c in the alphabet C, let the\nattribute c:freq denote the frequency of c in the ﬁle and let dT .c/ denote the depth\n16.3\nHuffman codes\n431\nof c’s leaf in the tree. Note that dT .c/ is also the length of the codeword for\ncharacter c. The number of bits required to encode a ﬁle is thus\nB.T / D\nX\nc2C\nc:freq \u0003 dT .c/ ;\n(16.4)\nwhich we deﬁne as the cost of the tree T .\nConstructing a Huffman code\nHuffman invented a greedy algorithm that constructs an optimal preﬁx code called\na Huffman code. In line with our observations in Section 16.2, its proof of cor-\nrectness relies on the greedy-choice property and optimal substructure. Rather\nthan demonstrating that these properties hold and then developing pseudocode, we\npresent the pseudocode ﬁrst. Doing so will help clarify how the algorithm makes\ngreedy choices.\nIn the pseudocode that follows, we assume that C is a set of n characters and\nthat each character c 2 C is an object with an attribute c:freq giving its frequency.\nThe algorithm builds the tree T corresponding to the optimal code in a bottom-up\nmanner. It begins with a set of jCj leaves and performs a sequence of jCj \u0005 1\n“merging” operations to create the ﬁnal tree. The algorithm uses a min-priority\nqueue Q, keyed on the freq attribute, to identify the two least-frequent objects to",
    "parent_e6b999f9-8114-4ef2-9035-95e4dbc7cbf5": "manner. It begins with a set of jCj leaves and performs a sequence of jCj \u0005 1\n“merging” operations to create the ﬁnal tree. The algorithm uses a min-priority\nqueue Q, keyed on the freq attribute, to identify the two least-frequent objects to\nmerge together. When we merge two objects, the result is a new object whose\nfrequency is the sum of the frequencies of the two objects that were merged.\nHUFFMAN.C/\n1\nn D jCj\n2\nQ D C\n3\nfor i D 1 to n \u0005 1\n4\nallocate a new node ´\n5\n´:left D x D EXTRACT-MIN.Q/\n6\n´:right D y D EXTRACT-MIN.Q/\n7\n´:freq D x:freq C y:freq\n8\nINSERT.Q; ´/\n9\nreturn EXTRACT-MIN.Q/\n// return the root of the tree\nFor our example, Huffman’s algorithm proceeds as shown in Figure 16.5. Since\nthe alphabet contains 6 letters, the initial queue size is n D 6, and 5 merge steps\nbuild the tree. The ﬁnal tree represents the optimal preﬁx code. The codeword for\na letter is the sequence of edge labels on the simple path from the root to the letter.\nLine 2 initializes the min-priority queue Q with the characters in C. The for\nloop in lines 3–8 repeatedly extracts the two nodes x and y of lowest frequency\n432\nChapter 16\nGreedy Algorithms\ne:9\nf:5\n14\n0\n1\nc:12\nb:13\n25\n0\n1\nd:16\n30\n0\n1\n55\n0\n1\na:45\n100\n0\n1\ne:9\nf:5\n14\n0\n1\nc:12\nb:13\n25\n0\n1\nd:16\n30\n0\n1\n55\n0\n1\na:45\ne:9\nf:5\n14\n0\n1\nc:12\nb:13\n25\n0\n1\nd:16\n30\n0\n1\na:45\ne:9\nf:5\n14\n0\n1\nc:12\nb:13\n25\n0\n1\nd:16\na:45\ne:9\nf:5\n14\n0\n1\nc:12\nb:13\nd:16\na:45\ne:9\nf:5\nc:12\nb:13\nd:16\na:45\n(a)\n(c)\n(e)\n(b)\n(d)\n(f)\nFigure 16.5\nThe steps of Huffman’s algorithm for the frequencies given in Figure 16.3. Each part\nshows the contents of the queue sorted into increasing order by frequency. At each step, the two\ntrees with lowest frequencies are merged. Leaves are shown as rectangles containing a character\nand its frequency. Internal nodes are shown as circles containing the sum of the frequencies of their\nchildren. An edge connecting an internal node with its children is labeled 0 if it is an edge to a left",
    "parent_9fbd202b-0fec-4bed-ad55-112adee41d71": "and its frequency. Internal nodes are shown as circles containing the sum of the frequencies of their\nchildren. An edge connecting an internal node with its children is labeled 0 if it is an edge to a left\nchild and 1 if it is an edge to a right child. The codeword for a letter is the sequence of labels on the\nedges connecting the root to the leaf for that letter. (a) The initial set of n D 6 nodes, one for each\nletter. (b)–(e) Intermediate stages. (f) The ﬁnal tree.\nfrom the queue, replacing them in the queue with a new node ´ representing their\nmerger. The frequency of ´ is computed as the sum of the frequencies of x and y\nin line 7. The node ´ has x as its left child and y as its right child. (This order is\narbitrary; switching the left and right child of any node yields a different code of\nthe same cost.) After n \u0005 1 mergers, line 9 returns the one node left in the queue,\nwhich is the root of the code tree.\nAlthough the algorithm would produce the same result if we were to excise the\nvariables x and y—assigning directly to ´:left and ´:right in lines 5 and 6, and\nchanging line 7 to ´:freq D ´:left:freq C ´:right:freq—we shall use the node\n16.3\nHuffman codes\n433\nnames x and y in the proof of correctness. Therefore, we ﬁnd it convenient to\nleave them in.\nTo analyze the running time of Huffman’s algorithm, we assume that Q is im-\nplemented as a binary min-heap (see Chapter 6). For a set C of n characters, we\ncan initialize Q in line 2 in O.n/ time using the BUILD-MIN-HEAP procedure dis-\ncussed in Section 6.3. The for loop in lines 3–8 executes exactly n \u0005 1 times, and\nsince each heap operation requires time O.lg n/, the loop contributes O.n lg n/ to\nthe running time. Thus, the total running time of HUFFMAN on a set of n charac-\nters is O.n lg n/. We can reduce the running time to O.n lg lg n/ by replacing the\nbinary min-heap with a van Emde Boas tree (see Chapter 20).\nCorrectness of Huffman’s algorithm",
    "parent_413f19d9-b978-4478-ad20-79602fc4b419": "the running time. Thus, the total running time of HUFFMAN on a set of n charac-\nters is O.n lg n/. We can reduce the running time to O.n lg lg n/ by replacing the\nbinary min-heap with a van Emde Boas tree (see Chapter 20).\nCorrectness of Huffman’s algorithm\nTo prove that the greedy algorithm HUFFMAN is correct, we show that the prob-\nlem of determining an optimal preﬁx code exhibits the greedy-choice and optimal-\nsubstructure properties. The next lemma shows that the greedy-choice property\nholds.\nLemma 16.2\nLet C be an alphabet in which each character c 2 C has frequency c:freq. Let\nx and y be two characters in C having the lowest frequencies. Then there exists\nan optimal preﬁx code for C in which the codewords for x and y have the same\nlength and differ only in the last bit.\nProof\nThe idea of the proof is to take the tree T representing an arbitrary optimal\npreﬁx code and modify it to make a tree representing another optimal preﬁx code\nsuch that the characters x and y appear as sibling leaves of maximum depth in the\nnew tree. If we can construct such a tree, then the codewords for x and y will have\nthe same length and differ only in the last bit.\nLet a and b be two characters that are sibling leaves of maximum depth in T .\nWithout loss of generality, we assume that a:freq \u0002 b:freq and x:freq \u0002 y:freq.\nSince x:freq and y:freq are the two lowest leaf frequencies, in order, and a:freq\nand b:freq are two arbitrary frequencies, in order, we have x:freq \u0002 a:freq and\ny:freq \u0002 b:freq.\nIn the remainder of the proof, it is possible that we could have x:freq D a:freq\nor y:freq D b:freq. However, if we had x:freq D b:freq, then we would also have\na:freq D b:freq D x:freq D y:freq (see Exercise 16.3-1), and the lemma would\nbe trivially true. Thus, we will assume that x:freq ¤ b:freq, which means that\nx ¤ b.\nAs Figure 16.6 shows, we exchange the positions in T of a and x to produce a\ntree T 0, and then we exchange the positions in T 0 of b and y to produce a tree T 00\n434",
    "parent_3039497b-3c92-4ec8-ba80-155a224029b8": "be trivially true. Thus, we will assume that x:freq ¤ b:freq, which means that\nx ¤ b.\nAs Figure 16.6 shows, we exchange the positions in T of a and x to produce a\ntree T 0, and then we exchange the positions in T 0 of b and y to produce a tree T 00\n434\nChapter 16\nGreedy Algorithms\nx\ny\na\nb\nx\ny\na\nb\nx\ny\na\nb\nT′′\nT\nT′\nFigure 16.6\nAn illustration of the key step in the proof of Lemma 16.2. In the optimal tree T ,\nleaves a and b are two siblings of maximum depth. Leaves x and y are the two characters with the\nlowest frequencies; they appear in arbitrary positions in T . Assuming that x ¤ b, swapping leaves a\nand x produces tree T 0, and then swapping leaves b and y produces tree T 00. Since each swap does\nnot increase the cost, the resulting tree T 00 is also an optimal tree.\nin which x and y are sibling leaves of maximum depth. (Note that if x D b but\ny ¤ a, then tree T 00 does not have x and y as sibling leaves of maximum depth.\nBecause we assume that x ¤ b, this situation cannot occur.) By equation (16.4),\nthe difference in cost between T and T 0 is\nB.T / \u0005 B.T 0/\nD\nX\nc2C\nc:freq \u0003 dT .c/ \u0005\nX\nc2C\nc:freq \u0003 dT 0.c/\nD\nx:freq \u0003 dT .x/ C a:freq \u0003 dT .a/ \u0005 x:freq \u0003 dT 0.x/ \u0005 a:freq \u0003 dT 0.a/\nD\nx:freq \u0003 dT .x/ C a:freq \u0003 dT .a/ \u0005 x:freq \u0003 dT .a/ \u0005 a:freq \u0003 dT .x/\nD\n.a:freq \u0005 x:freq/.dT .a/ \u0005 dT .x//\n\u0006\n0 ;\nbecause both a:freq \u0005 x:freq and dT .a/ \u0005 dT .x/ are nonnegative. More speciﬁ-\ncally, a:freq \u0005 x:freq is nonnegative because x is a minimum-frequency leaf, and\ndT .a/\u0005dT .x/ is nonnegative because a is a leaf of maximum depth in T . Similarly,\nexchanging y and b does not increase the cost, and so B.T 0/ \u0005 B.T 00/ is nonnega-\ntive. Therefore, B.T 00/ \u0002 B.T /, and since T is optimal, we have B.T / \u0002 B.T 00/,\nwhich implies B.T 00/ D B.T /. Thus, T 00 is an optimal tree in which x and y\nappear as sibling leaves of maximum depth, from which the lemma follows.\nLemma 16.2 implies that the process of building up an optimal tree by mergers",
    "parent_5d7181df-179d-4a15-bde6-a855b71344b9": "which implies B.T 00/ D B.T /. Thus, T 00 is an optimal tree in which x and y\nappear as sibling leaves of maximum depth, from which the lemma follows.\nLemma 16.2 implies that the process of building up an optimal tree by mergers\ncan, without loss of generality, begin with the greedy choice of merging together\nthose two characters of lowest frequency. Why is this a greedy choice? We can\nview the cost of a single merger as being the sum of the frequencies of the two items\nbeing merged. Exercise 16.3-4 shows that the total cost of the tree constructed\nequals the sum of the costs of its mergers. Of all possible mergers at each step,\nHUFFMAN chooses the one that incurs the least cost.\n16.3\nHuffman codes\n435\nThe next lemma shows that the problem of constructing optimal preﬁx codes has\nthe optimal-substructure property.\nLemma 16.3\nLet C be a given alphabet with frequency c:freq deﬁned for each character c 2 C.\nLet x and y be two characters in C with minimum frequency. Let C 0 be the\nalphabet C with the characters x and y removed and a new character ´ added,\nso that C 0\nD C \u0005 fx; yg [ f´g.\nDeﬁne f for C 0 as for C, except that\n´:freq D x:freq C y:freq. Let T 0 be any tree representing an optimal preﬁx code\nfor the alphabet C 0. Then the tree T , obtained from T 0 by replacing the leaf node\nfor ´ with an internal node having x and y as children, represents an optimal preﬁx\ncode for the alphabet C.\nProof\nWe ﬁrst show how to express the cost B.T / of tree T in terms of the\ncost B.T 0/ of tree T 0, by considering the component costs in equation (16.4).\nFor each character c 2 C \u0005 fx; yg, we have that dT .c/ D dT 0.c/, and hence\nc:freq \u0003 dT .c/ D c:freq \u0003 dT 0.c/. Since dT .x/ D dT .y/ D dT 0.´/ C 1, we have\nx:freq \u0003 dT .x/ C y:freq \u0003 dT .y/\nD\n.x:freq C y:freq/.dT 0.´/ C 1/\nD\n´:freq \u0003 dT 0.´/ C .x:freq C y:freq/ ;\nfrom which we conclude that\nB.T / D B.T 0/ C x:freq C y:freq\nor, equivalently,\nB.T 0/ D B.T / \u0005 x:freq \u0005 y:freq :",
    "parent_2f0b2d81-d73a-4fc1-8bdc-2b6f436abfc9": "x:freq \u0003 dT .x/ C y:freq \u0003 dT .y/\nD\n.x:freq C y:freq/.dT 0.´/ C 1/\nD\n´:freq \u0003 dT 0.´/ C .x:freq C y:freq/ ;\nfrom which we conclude that\nB.T / D B.T 0/ C x:freq C y:freq\nor, equivalently,\nB.T 0/ D B.T / \u0005 x:freq \u0005 y:freq :\nWe now prove the lemma by contradiction. Suppose that T does not repre-\nsent an optimal preﬁx code for C. Then there exists an optimal tree T 00 such that\nB.T 00/ < B.T /. Without loss of generality (by Lemma 16.2), T 00 has x and y as\nsiblings. Let T 000 be the tree T 00 with the common parent of x and y replaced by a\nleaf ´ with frequency ´:freq D x:freq C y:freq. Then\nB.T 000/\nD\nB.T 00/ \u0005 x:freq \u0005 y:freq\n<\nB.T / \u0005 x:freq \u0005 y:freq\nD\nB.T 0/ ;\nyielding a contradiction to the assumption that T 0 represents an optimal preﬁx code\nfor C 0. Thus, T must represent an optimal preﬁx code for the alphabet C.\nTheorem 16.4\nProcedure HUFFMAN produces an optimal preﬁx code.\nProof\nImmediate from Lemmas 16.2 and 16.3.\n436\nChapter 16\nGreedy Algorithms\nExercises\n16.3-1\nExplain why, in the proof of Lemma 16.2, if x:freq D b:freq, then we must have\na:freq D b:freq D x:freq D y:freq.\n16.3-2\nProve that a binary tree that is not full cannot correspond to an optimal preﬁx code.\n16.3-3\nWhat is an optimal Huffman code for the following set of frequencies, based on\nthe ﬁrst 8 Fibonacci numbers?\na:1 b:1 c:2 d:3 e:5 f:8 g:13 h:21\nCan you generalize your answer to ﬁnd the optimal code when the frequencies are\nthe ﬁrst n Fibonacci numbers?\n16.3-4\nProve that we can also express the total cost of a tree for a code as the sum, over\nall internal nodes, of the combined frequencies of the two children of the node.\n16.3-5\nProve that if we order the characters in an alphabet so that their frequencies\nare monotonically decreasing, then there exists an optimal code whose codeword\nlengths are monotonically increasing.\n16.3-6\nSuppose we have an optimal preﬁx code on a set C D f0; 1; : : : ; n \u0005 1g of charac-\nters and we wish to transmit this code using as few bits as possible. Show how to",
    "parent_15070397-1cc3-4bfb-9d7b-32cb907ecaee": "are monotonically decreasing, then there exists an optimal code whose codeword\nlengths are monotonically increasing.\n16.3-6\nSuppose we have an optimal preﬁx code on a set C D f0; 1; : : : ; n \u0005 1g of charac-\nters and we wish to transmit this code using as few bits as possible. Show how to\nrepresent any optimal preﬁx code on C using only 2n \u0005 1 C n dlg ne bits. (Hint:\nUse 2n \u0005 1 bits to specify the structure of the tree, as discovered by a walk of the\ntree.)\n16.3-7\nGeneralize Huffman’s algorithm to ternary codewords (i.e., codewords using the\nsymbols 0, 1, and 2), and prove that it yields optimal ternary codes.\n16.3-8\nSuppose that a data ﬁle contains a sequence of 8-bit characters such that all 256\ncharacters are about equally common: the maximum character frequency is less\nthan twice the minimum character frequency. Prove that Huffman coding in this\ncase is no more efﬁcient than using an ordinary 8-bit ﬁxed-length code.\n16.4\nMatroids and greedy methods\n437\n16.3-9\nShow that no compression scheme can expect to compress a ﬁle of randomly cho-\nsen 8-bit characters by even a single bit. (Hint: Compare the number of possible\nﬁles with the number of possible encoded ﬁles.)\n?\n16.4\nMatroids and greedy methods\nIn this section, we sketch a beautiful theory about greedy algorithms. This theory\ndescribes many situations in which the greedy method yields optimal solutions. It\ninvolves combinatorial structures known as “matroids.” Although this theory does\nnot cover all cases for which a greedy method applies (for example, it does not\ncover the activity-selection problem of Section 16.1 or the Huffman-coding prob-\nlem of Section 16.3), it does cover many cases of practical interest. Furthermore,\nthis theory has been extended to cover many applications; see the notes at the end\nof this chapter for references.\nMatroids\nA matroid is an ordered pair M D .S; \u0002/ satisfying the following conditions.\n1. S is a ﬁnite set.",
    "parent_1c269a5a-6ea0-4a6d-af42-ca383aa83caf": "this theory has been extended to cover many applications; see the notes at the end\nof this chapter for references.\nMatroids\nA matroid is an ordered pair M D .S; \u0002/ satisfying the following conditions.\n1. S is a ﬁnite set.\n2. \u0002 is a nonempty family of subsets of S, called the independent subsets of S,\nsuch that if B 2 \u0002 and A \u0007 B, then A 2 \u0002. We say that \u0002 is hereditary if it\nsatisﬁes this property. Note that the empty set ; is necessarily a member of \u0002.\n3. If A 2 \u0002, B 2 \u0002, and jAj < jBj, then there exists some element x 2 B \u0005 A\nsuch that A [ fxg 2 \u0002. We say that M satisﬁes the exchange property.\nThe word “matroid” is due to Hassler Whitney. He was studying matric ma-\ntroids, in which the elements of S are the rows of a given matrix and a set of rows is\nindependent if they are linearly independent in the usual sense. As Exercise 16.4-2\nasks you to show, this structure deﬁnes a matroid.\nAs another example of matroids, consider the graphic matroid MG D .SG; \u0002G/\ndeﬁned in terms of a given undirected graph G D .V; E/ as follows:\n\u0002\nThe set SG is deﬁned to be E, the set of edges of G.\n\u0002\nIf A is a subset of E, then A 2 \u0002G if and only if A is acyclic. That is, a set of\nedges A is independent if and only if the subgraph GA D .V; A/ forms a forest.\nThe graphic matroid MG is closely related to the minimum-spanning-tree problem,\nwhich Chapter 23 covers in detail.\n438\nChapter 16\nGreedy Algorithms\nTheorem 16.5\nIf G D .V; E/ is an undirected graph, then MG D .SG; \u0002G/ is a matroid.\nProof\nClearly, SG D E is a ﬁnite set. Furthermore, \u0002G is hereditary, since a\nsubset of a forest is a forest. Putting it another way, removing edges from an\nacyclic set of edges cannot create cycles.\nThus, it remains to show that MG satisﬁes the exchange property. Suppose that\nGA D .V; A/ and GB D .V; B/ are forests of G and that jBj > jAj. That is, A\nand B are acyclic sets of edges, and B contains more edges than A does.\nWe claim that a forest F D .VF ; EF / contains exactly jVF j \u0005 jEF j trees. To",
    "parent_463c7d8f-58b0-4b92-bd0b-cda357850d1f": "GA D .V; A/ and GB D .V; B/ are forests of G and that jBj > jAj. That is, A\nand B are acyclic sets of edges, and B contains more edges than A does.\nWe claim that a forest F D .VF ; EF / contains exactly jVF j \u0005 jEF j trees. To\nsee why, suppose that F consists of t trees, where the ith tree contains \u0003i vertices\nand ei edges. Then, we have\njEF j\nD\ntX\niD1\nei\nD\ntX\niD1\n.\u0003i \u0005 1/\n(by Theorem B.2)\nD\ntX\niD1\n\u0003i \u0005 t\nD\njVF j \u0005 t ;\nwhich implies that t D jVF j \u0005 jEF j. Thus, forest GA contains jV j \u0005 jAj trees, and\nforest GB contains jV j \u0005 jBj trees.\nSince forest GB has fewer trees than forest GA does, forest GB must contain\nsome tree T whose vertices are in two different trees in forest GA. Moreover,\nsince T is connected, it must contain an edge .u; \u0003/ such that vertices u and \u0003\nare in different trees in forest GA. Since the edge .u; \u0003/ connects vertices in two\ndifferent trees in forest GA, we can add the edge .u; \u0003/ to forest GA without creating\na cycle. Therefore, MG satisﬁes the exchange property, completing the proof that\nMG is a matroid.\nGiven a matroid M D .S; \u0002/, we call an element x … A an extension of A 2 \u0002\nif we can add x to A while preserving independence; that is, x is an extension\nof A if A [ fxg 2 \u0002. As an example, consider a graphic matroid MG. If A is an\nindependent set of edges, then edge e is an extension of A if and only if e is not\nin A and the addition of e to A does not create a cycle.\nIf A is an independent subset in a matroid M, we say that A is maximal if it has\nno extensions. That is, A is maximal if it is not contained in any larger independent\nsubset of M. The following property is often useful.\n16.4\nMatroids and greedy methods\n439\nTheorem 16.6\nAll maximal independent subsets in a matroid have the same size.\nProof\nSuppose to the contrary that A is a maximal independent subset of M\nand there exists another larger maximal independent subset B of M. Then, the\nexchange property implies that for some x 2 B \u0005 A, we can extend A to a larger",
    "parent_7c3a8b07-080e-458a-b386-916ff2e0f4e5": "All maximal independent subsets in a matroid have the same size.\nProof\nSuppose to the contrary that A is a maximal independent subset of M\nand there exists another larger maximal independent subset B of M. Then, the\nexchange property implies that for some x 2 B \u0005 A, we can extend A to a larger\nindependent set A [ fxg, contradicting the assumption that A is maximal.\nAs an illustration of this theorem, consider a graphic matroid MG for a con-\nnected, undirected graph G. Every maximal independent subset of MG must be a\nfree tree with exactly jV j \u0005 1 edges that connects all the vertices of G. Such a tree\nis called a spanning tree of G.\nWe say that a matroid M D .S; \u0002/ is weighted if it is associated with a weight\nfunction w that assigns a strictly positive weight w.x/ to each element x 2 S. The\nweight function w extends to subsets of S by summation:\nw.A/ D\nX\nx2A\nw.x/\nfor any A \u0007 S. For example, if we let w.e/ denote the weight of an edge e in a\ngraphic matroid MG, then w.A/ is the total weight of the edges in edge set A.\nGreedy algorithms on a weighted matroid\nMany problems for which a greedy approach provides optimal solutions can be for-\nmulated in terms of ﬁnding a maximum-weight independent subset in a weighted\nmatroid. That is, we are given a weighted matroid M D .S; \u0002/, and we wish to\nﬁnd an independent set A 2 \u0002 such that w.A/ is maximized. We call such a sub-\nset that is independent and has maximum possible weight an optimal subset of the\nmatroid. Because the weight w.x/ of any element x 2 S is positive, an optimal\nsubset is always a maximal independent subset—it always helps to make A as large\nas possible.\nFor example, in the minimum-spanning-tree problem, we are given a connected\nundirected graph G D .V; E/ and a length function w such that w.e/ is the (posi-\ntive) length of edge e. (We use the term “length” here to refer to the original edge\nweights for the graph, reserving the term “weight” to refer to the weights in the",
    "parent_7f5a7a0b-85ec-4a78-86da-c1e36cd85069": "undirected graph G D .V; E/ and a length function w such that w.e/ is the (posi-\ntive) length of edge e. (We use the term “length” here to refer to the original edge\nweights for the graph, reserving the term “weight” to refer to the weights in the\nassociated matroid.) We wish to ﬁnd a subset of the edges that connects all of\nthe vertices together and has minimum total length. To view this as a problem of\nﬁnding an optimal subset of a matroid, consider the weighted matroid MG with\nweight function w0, where w0.e/ D w0 \u0005 w.e/ and w0 is larger than the maximum\nlength of any edge. In this weighted matroid, all weights are positive and an opti-\nmal subset is a spanning tree of minimum total length in the original graph. More\nspeciﬁcally, each maximal independent subset A corresponds to a spanning tree\n440\nChapter 16\nGreedy Algorithms\nwith jV j \u0005 1 edges, and since\nw0.A/\nD\nX\ne2A\nw0.e/\nD\nX\ne2A\n.w0 \u0005 w.e//\nD\n.jV j \u0005 1/w0 \u0005\nX\ne2A\nw.e/\nD\n.jV j \u0005 1/w0 \u0005 w.A/\nfor any maximal independent subset A, an independent subset that maximizes the\nquantity w0.A/ must minimize w.A/. Thus, any algorithm that can ﬁnd an optimal\nsubset A in an arbitrary matroid can solve the minimum-spanning-tree problem.\nChapter 23 gives algorithms for the minimum-spanning-tree problem, but here\nwe give a greedy algorithm that works for any weighted matroid. The algorithm\ntakes as input a weighted matroid M D .S; \u0002/ with an associated positive weight\nfunction w, and it returns an optimal subset A. In our pseudocode, we denote the\ncomponents of M by M:S and M:\u0002 and the weight function by w. The algorithm\nis greedy because it considers in turn each element x 2 S, in order of monotoni-\ncally decreasing weight, and immediately adds it to the set A being accumulated if\nA [ fxg is independent.\nGREEDY.M; w/\n1\nA D ;\n2\nsort M:S into monotonically decreasing order by weight w\n3\nfor each x 2 M:S, taken in monotonically decreasing order by weight w.x/\n4\nif A [ fxg 2 M:\u0002\n5\nA D A [ fxg\n6\nreturn A",
    "parent_b8da2151-c95a-41ce-acee-d34f4fedd7fe": "A [ fxg is independent.\nGREEDY.M; w/\n1\nA D ;\n2\nsort M:S into monotonically decreasing order by weight w\n3\nfor each x 2 M:S, taken in monotonically decreasing order by weight w.x/\n4\nif A [ fxg 2 M:\u0002\n5\nA D A [ fxg\n6\nreturn A\nLine 4 checks whether adding each element x to A would maintain A as an inde-\npendent set. If A would remain independent, then line 5 adds x to A. Otherwise, x\nis discarded. Since the empty set is independent, and since each iteration of the for\nloop maintains A’s independence, the subset A is always independent, by induc-\ntion. Therefore, GREEDY always returns an independent subset A. We shall see in\na moment that A is a subset of maximum possible weight, so that A is an optimal\nsubset.\nThe running time of GREEDY is easy to analyze. Let n denote jSj. The sorting\nphase of GREEDY takes time O.n lg n/. Line 4 executes exactly n times, once for\neach element of S. Each execution of line 4 requires a check on whether or not\nthe set A [ fxg is independent. If each such check takes time O.f .n//, the entire\nalgorithm runs in time O.n lg n C nf .n//.\n16.4\nMatroids and greedy methods\n441\nWe now prove that GREEDY returns an optimal subset.\nLemma 16.7 (Matroids exhibit the greedy-choice property)\nSuppose that M D .S; \u0002/ is a weighted matroid with weight function w and that S\nis sorted into monotonically decreasing order by weight. Let x be the ﬁrst element\nof S such that fxg is independent, if any such x exists. If x exists, then there exists\nan optimal subset A of S that contains x.\nProof\nIf no such x exists, then the only independent subset is the empty set and\nthe lemma is vacuously true. Otherwise, let B be any nonempty optimal subset.\nAssume that x … B; otherwise, letting A D B gives an optimal subset of S that\ncontains x.\nNo element of B has weight greater than w.x/. To see why, observe that y 2 B\nimplies that fyg is independent, since B 2 \u0002 and \u0002 is hereditary. Our choice of x\ntherefore ensures that w.x/ \u0006 w.y/ for any y 2 B.",
    "parent_00a46f47-1823-441f-b377-ab3fa3338f18": "Assume that x … B; otherwise, letting A D B gives an optimal subset of S that\ncontains x.\nNo element of B has weight greater than w.x/. To see why, observe that y 2 B\nimplies that fyg is independent, since B 2 \u0002 and \u0002 is hereditary. Our choice of x\ntherefore ensures that w.x/ \u0006 w.y/ for any y 2 B.\nConstruct the set A as follows. Begin with A D fxg. By the choice of x, set A is\nindependent. Using the exchange property, repeatedly ﬁnd a new element of B that\nwe can add to A until jAj D jBj, while preserving the independence of A. At that\npoint, A and B are the same except that A has x and B has some other element y.\nThat is, A D B \u0005 fyg [ fxg for some y 2 B, and so\nw.A/\nD\nw.B/ \u0005 w.y/ C w.x/\n\u0006\nw.B/ :\nBecause set B is optimal, set A, which contains x, must also be optimal.\nWe next show that if an element is not an option initially, then it cannot be an\noption later.\nLemma 16.8\nLet M D .S; \u0002/ be any matroid. If x is an element of S that is an extension of\nsome independent subset A of S, then x is also an extension of ;.\nProof\nSince x is an extension of A, we have that A[fxg is independent. Since \u0002\nis hereditary, fxg must be independent. Thus, x is an extension of ;.\nCorollary 16.9\nLet M D .S; \u0002/ be any matroid. If x is an element of S such that x is not an\nextension of ;, then x is not an extension of any independent subset A of S.\nProof\nThis corollary is simply the contrapositive of Lemma 16.8.\n442\nChapter 16\nGreedy Algorithms\nCorollary 16.9 says that any element that cannot be used immediately can never\nbe used. Therefore, GREEDY cannot make an error by passing over any initial\nelements in S that are not an extension of ;, since they can never be used.\nLemma 16.10 (Matroids exhibit the optimal-substructure property)\nLet x be the ﬁrst element of S chosen by GREEDY for the weighted matroid\nM D .S; \u0002/. The remaining problem of ﬁnding a maximum-weight indepen-\ndent subset containing x reduces to ﬁnding a maximum-weight independent subset",
    "parent_8c7d40ca-5333-4004-beb9-0a07235a9e69": "Lemma 16.10 (Matroids exhibit the optimal-substructure property)\nLet x be the ﬁrst element of S chosen by GREEDY for the weighted matroid\nM D .S; \u0002/. The remaining problem of ﬁnding a maximum-weight indepen-\ndent subset containing x reduces to ﬁnding a maximum-weight independent subset\nof the weighted matroid M 0 D .S 0; \u0002 0/, where\nS 0\nD\nfy 2 S W fx; yg 2 \u0002g ;\n\u0002 0\nD\nfB \u0007 S \u0005 fxg W B [ fxg 2 \u0002g ;\nand the weight function for M 0 is the weight function for M, restricted to S 0. (We\ncall M 0 the contraction of M by the element x.)\nProof\nIf A is any maximum-weight independent subset of M containing x, then\nA0 D A \u0005 fxg is an independent subset of M 0. Conversely, any independent sub-\nset A0 of M 0 yields an independent subset A D A0 [ fxg of M. Since we have in\nboth cases that w.A/ D w.A0/Cw.x/, a maximum-weight solution in M contain-\ning x yields a maximum-weight solution in M 0, and vice versa.\nTheorem 16.11 (Correctness of the greedy algorithm on matroids)\nIf M D .S; \u0002/ is a weighted matroid with weight function w, then GREEDY.M; w/\nreturns an optimal subset.\nProof\nBy Corollary 16.9, any elements that GREEDY passes over initially be-\ncause they are not extensions of ; can be forgotten about, since they can never\nbe useful. Once GREEDY selects the ﬁrst element x, Lemma 16.7 implies that\nthe algorithm does not err by adding x to A, since there exists an optimal subset\ncontaining x. Finally, Lemma 16.10 implies that the remaining problem is one of\nﬁnding an optimal subset in the matroid M 0 that is the contraction of M by x.\nAfter the procedure GREEDY sets A to fxg, we can interpret all of its remaining\nsteps as acting in the matroid M 0 D .S 0; \u0002 0/, because B is independent in M 0 if\nand only if B [ fxg is independent in M, for all sets B 2 \u0002 0. Thus, the subsequent\noperation of GREEDY will ﬁnd a maximum-weight independent subset for M 0, and\nthe overall operation of GREEDY will ﬁnd a maximum-weight independent subset\nfor M.\n16.5",
    "parent_c55f15e3-d431-4881-907d-ca9659d1cfb5": "and only if B [ fxg is independent in M, for all sets B 2 \u0002 0. Thus, the subsequent\noperation of GREEDY will ﬁnd a maximum-weight independent subset for M 0, and\nthe overall operation of GREEDY will ﬁnd a maximum-weight independent subset\nfor M.\n16.5\nA task-scheduling problem as a matroid\n443\nExercises\n16.4-1\nShow that .S; \u0002k/ is a matroid, where S is any ﬁnite set and \u0002k is the set of all\nsubsets of S of size at most k, where k \u0002 jSj.\n16.4-2\n?\nGiven an m \t n matrix T over some ﬁeld (such as the reals), show that .S; \u0002/ is a\nmatroid, where S is the set of columns of T and A 2 \u0002 if and only if the columns\nin A are linearly independent.\n16.4-3\n?\nShow that if .S; \u0002/ is a matroid, then .S; \u0002 0/ is a matroid, where\n\u0002 0 D fA0 W S \u0005 A0 contains some maximal A 2 \u0002g :\nThat is, the maximal independent sets of .S; \u0002 0/ are just the complements of the\nmaximal independent sets of .S; \u0002/.\n16.4-4\n?\nLet S be a ﬁnite set and let S1; S2; : : : ; Sk be a partition of S into nonempty disjoint\nsubsets. Deﬁne the structure .S; \u0002/ by the condition that \u0002 D fA W jA \\ Sij \u0002 1\nfor i D 1; 2; : : : ; kg. Show that .S; \u0002/ is a matroid. That is, the set of all sets A\nthat contain at most one member of each subset in the partition determines the\nindependent sets of a matroid.\n16.4-5\nShow how to transform the weight function of a weighted matroid problem, where\nthe desired optimal solution is a minimum-weight maximal independent subset, to\nmake it a standard weighted-matroid problem. Argue carefully that your transfor-\nmation is correct.\n?\n16.5\nA task-scheduling problem as a matroid\nAn interesting problem that we can solve using matroids is the problem of op-\ntimally scheduling unit-time tasks on a single processor, where each task has a\ndeadline, along with a penalty paid if the task misses its deadline. The problem\nlooks complicated, but we can solve it in a surprisingly simple manner by casting\nit as a matroid and using a greedy algorithm.",
    "parent_44ed07d8-e534-41ad-ab1d-28b484c6ef77": "timally scheduling unit-time tasks on a single processor, where each task has a\ndeadline, along with a penalty paid if the task misses its deadline. The problem\nlooks complicated, but we can solve it in a surprisingly simple manner by casting\nit as a matroid and using a greedy algorithm.\nA unit-time task is a job, such as a program to be run on a computer, that requires\nexactly one unit of time to complete. Given a ﬁnite set S of unit-time tasks, a\n444\nChapter 16\nGreedy Algorithms\nschedule for S is a permutation of S specifying the order in which to perform\nthese tasks. The ﬁrst task in the schedule begins at time 0 and ﬁnishes at time 1,\nthe second task begins at time 1 and ﬁnishes at time 2, and so on.\nThe problem of scheduling unit-time tasks with deadlines and penalties for a\nsingle processor has the following inputs:\n\u0002\na set S D fa1; a2; : : : ; ang of n unit-time tasks;\n\u0002\na set of n integer deadlines d1; d2; : : : ; dn, such that each di satisﬁes 1 \u0002 di \u0002 n\nand task ai is supposed to ﬁnish by time di; and\n\u0002\na set of n nonnegative weights or penalties w1; w2; : : : ; wn, such that we incur\na penalty of wi if task ai is not ﬁnished by time di, and we incur no penalty if\na task ﬁnishes by its deadline.\nWe wish to ﬁnd a schedule for S that minimizes the total penalty incurred for\nmissed deadlines.\nConsider a given schedule. We say that a task is late in this schedule if it ﬁnishes\nafter its deadline. Otherwise, the task is early in the schedule. We can always trans-\nform an arbitrary schedule into early-ﬁrst form, in which the early tasks precede\nthe late tasks. To see why, note that if some early task ai follows some late task aj,\nthen we can switch the positions of ai and aj, and ai will still be early and aj will\nstill be late.\nFurthermore, we claim that we can always transform an arbitrary schedule into\ncanonical form, in which the early tasks precede the late tasks and we schedule",
    "parent_8dae03ba-889d-4bd1-98d5-7697563da9f6": "then we can switch the positions of ai and aj, and ai will still be early and aj will\nstill be late.\nFurthermore, we claim that we can always transform an arbitrary schedule into\ncanonical form, in which the early tasks precede the late tasks and we schedule\nthe early tasks in order of monotonically increasing deadlines. To do so, we put\nthe schedule into early-ﬁrst form. Then, as long as there exist two early tasks ai\nand aj ﬁnishing at respective times k and k C 1 in the schedule such that dj < di,\nwe swap the positions of ai and aj. Since aj is early before the swap, k C 1 \u0002 dj.\nTherefore, k C 1 < di, and so ai is still early after the swap. Because task aj is\nmoved earlier in the schedule, it remains early after the swap.\nThe search for an optimal schedule thus reduces to ﬁnding a set A of tasks that\nwe assign to be early in the optimal schedule. Having determined A, we can create\nthe actual schedule by listing the elements of A in order of monotonically increas-\ning deadlines, then listing the late tasks (i.e., S \u0005 A) in any order, producing a\ncanonical ordering of the optimal schedule.\nWe say that a set A of tasks is independent if there exists a schedule for these\ntasks such that no tasks are late. Clearly, the set of early tasks for a schedule forms\nan independent set of tasks. Let \u0002 denote the set of all independent sets of tasks.\nConsider the problem of determining whether a given set A of tasks is indepen-\ndent. For t D 0; 1; 2; : : : ; n, let Nt.A/ denote the number of tasks in A whose\ndeadline is t or earlier. Note that N0.A/ D 0 for any set A.\n16.5\nA task-scheduling problem as a matroid\n445\nLemma 16.12\nFor any set of tasks A, the following statements are equivalent.\n1. The set A is independent.\n2. For t D 0; 1; 2; : : : ; n, we have Nt.A/ \u0002 t.\n3. If the tasks in A are scheduled in order of monotonically increasing deadlines,\nthen no task is late.\nProof\nTo show that (1) implies (2), we prove the contrapositive: if Nt.A/ > t for",
    "parent_3d462f52-c7ae-4ef6-87a7-73fbfd6c8e6d": "1. The set A is independent.\n2. For t D 0; 1; 2; : : : ; n, we have Nt.A/ \u0002 t.\n3. If the tasks in A are scheduled in order of monotonically increasing deadlines,\nthen no task is late.\nProof\nTo show that (1) implies (2), we prove the contrapositive: if Nt.A/ > t for\nsome t, then there is no way to make a schedule with no late tasks for set A, because\nmore than t tasks must ﬁnish before time t. Therefore, (1) implies (2). If (2) holds,\nthen (3) must follow: there is no way to “get stuck” when scheduling the tasks in\norder of monotonically increasing deadlines, since (2) implies that the ith largest\ndeadline is at least i. Finally, (3) trivially implies (1).\nUsing property 2 of Lemma 16.12, we can easily compute whether or not a given\nset of tasks is independent (see Exercise 16.5-2).\nThe problem of minimizing the sum of the penalties of the late tasks is the same\nas the problem of maximizing the sum of the penalties of the early tasks. The\nfollowing theorem thus ensures that we can use the greedy algorithm to ﬁnd an\nindependent set A of tasks with the maximum total penalty.\nTheorem 16.13\nIf S is a set of unit-time tasks with deadlines, and \u0002 is the set of all independent\nsets of tasks, then the corresponding system .S; \u0002/ is a matroid.\nProof\nEvery subset of an independent set of tasks is certainly independent. To\nprove the exchange property, suppose that B and A are independent sets of tasks\nand that jBj > jAj. Let k be the largest t such that Nt.B/ \u0002 Nt.A/. (Such a value\nof t exists, since N0.A/ D N0.B/ D 0.) Since Nn.B/ D jBj and Nn.A/ D jAj,\nbut jBj > jAj, we must have that k < n and that Nj.B/ > Nj.A/ for all j in\nthe range k C 1 \u0002 j \u0002 n. Therefore, B contains more tasks with deadline k C 1\nthan A does. Let ai be a task in B \u0005 A with deadline k C 1. Let A0 D A [ faig.\nWe now show that A0 must be independent by using property 2 of Lemma 16.12.\nFor 0 \u0002 t \u0002 k, we have Nt.A0/ D Nt.A/ \u0002 t, since A is independent. For",
    "parent_a39e94f8-1719-4b2c-aeea-684aec7e14e3": "than A does. Let ai be a task in B \u0005 A with deadline k C 1. Let A0 D A [ faig.\nWe now show that A0 must be independent by using property 2 of Lemma 16.12.\nFor 0 \u0002 t \u0002 k, we have Nt.A0/ D Nt.A/ \u0002 t, since A is independent. For\nk < t \u0002 n, we have Nt.A0/ \u0002 Nt.B/ \u0002 t, since B is independent. Therefore, A0\nis independent, completing our proof that .S; \u0002/ is a matroid.\nBy Theorem 16.11, we can use a greedy algorithm to ﬁnd a maximum-weight\nindependent set of tasks A. We can then create an optimal schedule having the\ntasks in A as its early tasks. This method is an efﬁcient algorithm for scheduling\n446\nChapter 16\nGreedy Algorithms\nTask\nai\n1\n2\n3\n4\n5\n6\n7\ndi\n4\n2\n4\n3\n1\n4\n6\nwi\n70\n60\n50\n40\n30\n20\n10\nFigure 16.7\nAn instance of the problem of scheduling unit-time tasks with deadlines and penalties\nfor a single processor.\nunit-time tasks with deadlines and penalties for a single processor. The running\ntime is O.n2/ using GREEDY, since each of the O.n/ independence checks made\nby that algorithm takes time O.n/ (see Exercise 16.5-2). Problem 16-4 gives a\nfaster implementation.\nFigure 16.7 demonstrates an example of the problem of scheduling unit-time\ntasks with deadlines and penalties for a single processor. In this example, the\ngreedy algorithm selects, in order, tasks a1, a2, a3, and a4, then rejects a5 (because\nN4.fa1; a2; a3; a4; a5g/ D 5) and a6 (because N4.fa1; a2; a3; a4; a6g/ D 5), and\nﬁnally accepts a7. The ﬁnal optimal schedule is\nha2; a4; a1; a3; a7; a5; a6i ;\nwhich has a total penalty incurred of w5 C w6 D 50.\nExercises\n16.5-1\nSolve the instance of the scheduling problem given in Figure 16.7, but with each\npenalty wi replaced by 80 \u0005 wi.\n16.5-2\nShow how to use property 2 of Lemma 16.12 to determine in time O.jAj/ whether\nor not a given set A of tasks is independent.\nProblems\n16-1\nCoin changing\nConsider the problem of making change for n cents using the fewest number of\ncoins. Assume that each coin’s value is an integer.",
    "parent_2edd5709-c2ed-4473-8722-b62e305a1a99": "16.5-2\nShow how to use property 2 of Lemma 16.12 to determine in time O.jAj/ whether\nor not a given set A of tasks is independent.\nProblems\n16-1\nCoin changing\nConsider the problem of making change for n cents using the fewest number of\ncoins. Assume that each coin’s value is an integer.\na. Describe a greedy algorithm to make change consisting of quarters, dimes,\nnickels, and pennies. Prove that your algorithm yields an optimal solution.\nProblems for Chapter 16\n447\nb. Suppose that the available coins are in the denominations that are powers of c,\ni.e., the denominations are c0; c1; : : : ; ck for some integers c > 1 and k \u0006 1.\nShow that the greedy algorithm always yields an optimal solution.\nc. Give a set of coin denominations for which the greedy algorithm does not yield\nan optimal solution. Your set should include a penny so that there is a solution\nfor every value of n.\nd. Give an O.nk/-time algorithm that makes change for any set of k different coin\ndenominations, assuming that one of the coins is a penny.\n16-2\nScheduling to minimize average completion time\nSuppose you are given a set S D fa1; a2; : : : ; ang of tasks, where task ai re-\nquires pi units of processing time to complete, once it has started. You have one\ncomputer on which to run these tasks, and the computer can run only one task at a\ntime. Let ci be the completion time of task ai, that is, the time at which task ai com-\npletes processing. Your goal is to minimize the average completion time, that is,\nto minimize .1=n/ Pn\niD1 ci. For example, suppose there are two tasks, a1 and a2,\nwith p1 D 3 and p2 D 5, and consider the schedule in which a2 runs ﬁrst, followed\nby a1. Then c2 D 5, c1 D 8, and the average completion time is .5 C 8/=2 D 6:5.\nIf task a1 runs ﬁrst, however, then c1 D 3, c2 D 8, and the average completion\ntime is .3 C 8/=2 D 5:5.\na. Give an algorithm that schedules the tasks so as to minimize the average com-",
    "parent_90e40edc-0ea3-4b2d-bfdd-df3b36a6ac9c": "by a1. Then c2 D 5, c1 D 8, and the average completion time is .5 C 8/=2 D 6:5.\nIf task a1 runs ﬁrst, however, then c1 D 3, c2 D 8, and the average completion\ntime is .3 C 8/=2 D 5:5.\na. Give an algorithm that schedules the tasks so as to minimize the average com-\npletion time. Each task must run non-preemptively, that is, once task ai starts, it\nmust run continuously for pi units of time. Prove that your algorithm minimizes\nthe average completion time, and state the running time of your algorithm.\nb. Suppose now that the tasks are not all available at once. That is, each task\ncannot start until its release time ri. Suppose also that we allow preemption, so\nthat a task can be suspended and restarted at a later time. For example, a task ai\nwith processing time pi D 6 and release time ri D 1 might start running at\ntime 1 and be preempted at time 4. It might then resume at time 10 but be\npreempted at time 11, and it might ﬁnally resume at time 13 and complete at\ntime 15. Task ai has run for a total of 6 time units, but its running time has been\ndivided into three pieces. In this scenario, ai’s completion time is 15. Give\nan algorithm that schedules the tasks so as to minimize the average completion\ntime in this new scenario. Prove that your algorithm minimizes the average\ncompletion time, and state the running time of your algorithm.\n448\nChapter 16\nGreedy Algorithms\n16-3\nAcyclic subgraphs\na. The incidence matrix for an undirected graph G D .V; E/ is a jV j \t jEj ma-\ntrix M such that M\u0005e D 1 if edge e is incident on vertex \u0003, and M\u0005e D 0 other-\nwise. Argue that a set of columns of M is linearly independent over the ﬁeld\nof integers modulo 2 if and only if the corresponding set of edges is acyclic.\nThen, use the result of Exercise 16.4-2 to provide an alternate proof that .E; \u0002/\nof part (a) is a matroid.\nb. Suppose that we associate a nonnegative weight w.e/ with each edge in an\nundirected graph G D .V; E/. Give an efﬁcient algorithm to ﬁnd an acyclic",
    "parent_d1378c5d-f8fc-420b-8e75-c61caa467951": "Then, use the result of Exercise 16.4-2 to provide an alternate proof that .E; \u0002/\nof part (a) is a matroid.\nb. Suppose that we associate a nonnegative weight w.e/ with each edge in an\nundirected graph G D .V; E/. Give an efﬁcient algorithm to ﬁnd an acyclic\nsubset of E of maximum total weight.\nc. Let G.V; E/ be an arbitrary directed graph, and let .E; \u0002/ be deﬁned so that\nA 2 \u0002 if and only if A does not contain any directed cycles. Give an example\nof a directed graph G such that the associated system .E; \u0002/ is not a matroid.\nSpecify which deﬁning condition for a matroid fails to hold.\nd. The incidence matrix for a directed graph G D .V; E/ with no self-loops is a\njV j \t jEj matrix M such that M\u0005e D \u00051 if edge e leaves vertex \u0003, M\u0005e D 1 if\nedge e enters vertex \u0003, and M\u0005e D 0 otherwise. Argue that if a set of columns\nof M is linearly independent, then the corresponding set of edges does not\ncontain a directed cycle.\ne. Exercise 16.4-2 tells us that the set of linearly independent sets of columns of\nany matrix M forms a matroid. Explain carefully why the results of parts (d)\nand (e) are not contradictory. How can there fail to be a perfect correspon-\ndence between the notion of a set of edges being acyclic and the notion of the\nassociated set of columns of the incidence matrix being linearly independent?\n16-4\nScheduling variations\nConsider the following algorithm for the problem from Section 16.5 of scheduling\nunit-time tasks with deadlines and penalties. Let all n time slots be initially empty,\nwhere time slot i is the unit-length slot of time that ﬁnishes at time i. We consider\nthe tasks in order of monotonically decreasing penalty. When considering task aj,\nif there exists a time slot at or before aj’s deadline dj that is still empty, assign aj\nto the latest such slot, ﬁlling it. If there is no such slot, assign task aj to the latest\nof the as yet unﬁlled slots.\na. Argue that this algorithm always gives an optimal answer.",
    "parent_d12dff9a-77c2-4c85-87c9-e1eb6bde5ccd": "if there exists a time slot at or before aj’s deadline dj that is still empty, assign aj\nto the latest such slot, ﬁlling it. If there is no such slot, assign task aj to the latest\nof the as yet unﬁlled slots.\na. Argue that this algorithm always gives an optimal answer.\nb. Use the fast disjoint-set forest presented in Section 21.3 to implement the algo-\nrithm efﬁciently. Assume that the set of input tasks has already been sorted into\nProblems for Chapter 16\n449\nmonotonically decreasing order by penalty. Analyze the running time of your\nimplementation.\n16-5\nOff-line caching\nModern computers use a cache to store a small amount of data in a fast memory.\nEven though a program may access large amounts of data, by storing a small subset\nof the main memory in the cache—a small but faster memory—overall access time\ncan greatly decrease. When a computer program executes, it makes a sequence\nhr1; r2; : : : ; rni of n memory requests, where each request is for a particular data\nelement. For example, a program that accesses 4 distinct elements fa; b; c; dg\nmight make the sequence of requests hd; b; d; b; d; a; c; d; b; a; c; bi. Let k be the\nsize of the cache. When the cache contains k elements and the program requests the\n.k C 1/st element, the system must decide, for this and each subsequent request,\nwhich k elements to keep in the cache. More precisely, for each request ri, the\ncache-management algorithm checks whether element ri is already in the cache. If\nit is, then we have a cache hit; otherwise, we have a cache miss. Upon a cache\nmiss, the system retrieves ri from the main memory, and the cache-management\nalgorithm must decide whether to keep ri in the cache. If it decides to keep ri and\nthe cache already holds k elements, then it must evict one element to make room\nfor ri. The cache-management algorithm evicts data with the goal of minimizing\nthe number of cache misses over the entire sequence of requests.",
    "parent_8431b8e8-03f3-4167-8580-1ed06ad96f43": "the cache already holds k elements, then it must evict one element to make room\nfor ri. The cache-management algorithm evicts data with the goal of minimizing\nthe number of cache misses over the entire sequence of requests.\nTypically, caching is an on-line problem. That is, we have to make decisions\nabout which data to keep in the cache without knowing the future requests. Here,\nhowever, we consider the off-line version of this problem, in which we are given\nin advance the entire sequence of n requests and the cache size k, and we wish to\nminimize the total number of cache misses.\nWe can solve this off-line problem by a greedy strategy called furthest-in-future,\nwhich chooses to evict the item in the cache whose next access in the request\nsequence comes furthest in the future.\na. Write pseudocode for a cache manager that uses the furthest-in-future strategy.\nThe input should be a sequence hr1; r2; : : : ; rni of requests and a cache size k,\nand the output should be a sequence of decisions about which data element (if\nany) to evict upon each request. What is the running time of your algorithm?\nb. Show that the off-line caching problem exhibits optimal substructure.\nc. Prove that furthest-in-future produces the minimum possible number of cache\nmisses.\n450\nChapter 16\nGreedy Algorithms\nChapter notes\nMuch more material on greedy algorithms and matroids can be found in Lawler\n[224] and Papadimitriou and Steiglitz [271].\nThe greedy algorithm ﬁrst appeared in the combinatorial optimization literature\nin a 1971 article by Edmonds [101], though the theory of matroids dates back to\na 1935 article by Whitney [355].\nOur proof of the correctness of the greedy algorithm for the activity-selection\nproblem is based on that of Gavril [131]. The task-scheduling problem is studied\nin Lawler [224]; Horowitz, Sahni, and Rajasekaran [181]; and Brassard and Bratley\n[54].\nHuffman codes were invented in 1952 [185]; Lelewer and Hirschberg [231] sur-",
    "parent_3a4d9ab7-0946-4580-ba0f-c1eb278125a1": "problem is based on that of Gavril [131]. The task-scheduling problem is studied\nin Lawler [224]; Horowitz, Sahni, and Rajasekaran [181]; and Brassard and Bratley\n[54].\nHuffman codes were invented in 1952 [185]; Lelewer and Hirschberg [231] sur-\nveys data-compression techniques known as of 1987.\nAn extension of matroid theory to greedoid theory was pioneered by Korte and\nLov´asz [216, 217, 218, 219], who greatly generalize the theory presented here.\n17\nAmortized Analysis\nIn an amortized analysis, we average the time required to perform a sequence of\ndata-structure operations over all the operations performed. With amortized analy-\nsis, we can show that the average cost of an operation is small, if we average over a\nsequence of operations, even though a single operation within the sequence might\nbe expensive. Amortized analysis differs from average-case analysis in that prob-\nability is not involved; an amortized analysis guarantees the average performance\nof each operation in the worst case.\nThe ﬁrst three sections of this chapter cover the three most common techniques\nused in amortized analysis. Section 17.1 starts with aggregate analysis, in which\nwe determine an upper bound T .n/ on the total cost of a sequence of n operations.\nThe average cost per operation is then T .n/=n. We take the average cost as the\namortized cost of each operation, so that all operations have the same amortized\ncost.\nSection 17.2 covers the accounting method, in which we determine an amortized\ncost of each operation. When there is more than one type of operation, each type of\noperation may have a different amortized cost. The accounting method overcharges\nsome operations early in the sequence, storing the overcharge as “prepaid credit”\non speciﬁc objects in the data structure. Later in the sequence, the credit pays for\noperations that are charged less than they actually cost.\nSection 17.3 discusses the potential method, which is like the accounting method",
    "parent_4afa851b-c82c-4cd1-a99f-bd67dc29f17e": "on speciﬁc objects in the data structure. Later in the sequence, the credit pays for\noperations that are charged less than they actually cost.\nSection 17.3 discusses the potential method, which is like the accounting method\nin that we determine the amortized cost of each operation and may overcharge op-\nerations early on to compensate for undercharges later. The potential method main-\ntains the credit as the “potential energy” of the data structure as a whole instead of\nassociating the credit with individual objects within the data structure.\nWe shall use two examples to examine these three methods. One is a stack\nwith the additional operation MULTIPOP, which pops several objects at once. The\nother is a binary counter that counts up from 0 by means of the single operation\nINCREMENT.\n452\nChapter 17\nAmortized Analysis\nWhile reading this chapter, bear in mind that the charges assigned during an\namortized analysis are for analysis purposes only. They need not—and should\nnot—appear in the code. If, for example, we assign a credit to an object x when\nusing the accounting method, we have no need to assign an appropriate amount to\nsome attribute, such as x:credit, in the code.\nWhen we perform an amortized analysis, we often gain insight into a particular\ndata structure, and this insight can help us optimize the design. In Section 17.4,\nfor example, we shall use the potential method to analyze a dynamically expanding\nand contracting table.\n17.1\nAggregate analysis\nIn aggregate analysis, we show that for all n, a sequence of n operations takes\nworst-case time T .n/ in total. In the worst case, the average cost, or amortized\ncost, per operation is therefore T .n/=n. Note that this amortized cost applies to\neach operation, even when there are several types of operations in the sequence.\nThe other two methods we shall study in this chapter, the accounting method and\nthe potential method, may assign different amortized costs to different types of\noperations.\nStack operations",
    "parent_a98857cc-e5d3-48b5-a3b9-f1ce44c7a702": "each operation, even when there are several types of operations in the sequence.\nThe other two methods we shall study in this chapter, the accounting method and\nthe potential method, may assign different amortized costs to different types of\noperations.\nStack operations\nIn our ﬁrst example of aggregate analysis, we analyze stacks that have been aug-\nmented with a new operation. Section 10.1 presented the two fundamental stack\noperations, each of which takes O.1/ time:\nPUSH.S; x/ pushes object x onto stack S.\nPOP.S/ pops the top of stack S and returns the popped object. Calling POP on an\nempty stack generates an error.\nSince each of these operations runs in O.1/ time, let us consider the cost of each\nto be 1. The total cost of a sequence of n PUSH and POP operations is therefore n,\nand the actual running time for n operations is therefore ‚.n/.\nNow we add the stack operation MULTIPOP.S; k/, which removes the k top ob-\njects of stack S, popping the entire stack if the stack contains fewer than k objects.\nOf course, we assume that k is positive; otherwise the MULTIPOP operation leaves\nthe stack unchanged. In the following pseudocode, the operation STACK-EMPTY\nreturns TRUE if there are no objects currently on the stack, and FALSE otherwise.\n17.1\nAggregate analysis\n453\n23\n17\n6\n39\n10\n47\n(a)\ntop\n10\n47\n(b)\ntop\n(c)\nFigure 17.1\nThe action of MULTIPOP on a stack S, shown initially in (a). The top 4 objects are\npopped by MULTIPOP.S; 4/, whose result is shown in (b). The next operation is MULTIPOP.S; 7/,\nwhich empties the stack—shown in (c)—since there were fewer than 7 objects remaining.\nMULTIPOP.S; k/\n1\nwhile not STACK-EMPTY.S/ and k > 0\n2\nPOP.S/\n3\nk D k \u0005 1\nFigure 17.1 shows an example of MULTIPOP.\nWhat is the running time of MULTIPOP.S; k/ on a stack of s objects? The\nactual running time is linear in the number of POP operations actually executed,\nand thus we can analyze MULTIPOP in terms of the abstract costs of 1 each for",
    "parent_a1caba5c-76a1-4045-bb71-5c11db17e774": "2\nPOP.S/\n3\nk D k \u0005 1\nFigure 17.1 shows an example of MULTIPOP.\nWhat is the running time of MULTIPOP.S; k/ on a stack of s objects? The\nactual running time is linear in the number of POP operations actually executed,\nand thus we can analyze MULTIPOP in terms of the abstract costs of 1 each for\nPUSH and POP. The number of iterations of the while loop is the number min.s; k/\nof objects popped off the stack. Each iteration of the loop makes one call to POP in\nline 2. Thus, the total cost of MULTIPOP is min.s; k/, and the actual running time\nis a linear function of this cost.\nLet us analyze a sequence of n PUSH, POP, and MULTIPOP operations on an ini-\ntially empty stack. The worst-case cost of a MULTIPOP operation in the sequence\nis O.n/, since the stack size is at most n. The worst-case time of any stack opera-\ntion is therefore O.n/, and hence a sequence of n operations costs O.n2/, since we\nmay have O.n/ MULTIPOP operations costing O.n/ each. Although this analysis\nis correct, the O.n2/ result, which we obtained by considering the worst-case cost\nof each operation individually, is not tight.\nUsing aggregate analysis, we can obtain a better upper bound that considers the\nentire sequence of n operations. In fact, although a single MULTIPOP operation\ncan be expensive, any sequence of n PUSH, POP, and MULTIPOP operations on an\ninitially empty stack can cost at most O.n/. Why? We can pop each object from the\nstack at most once for each time we have pushed it onto the stack. Therefore, the\nnumber of times that POP can be called on a nonempty stack, including calls within\nMULTIPOP, is at most the number of PUSH operations, which is at most n. For any\nvalue of n, any sequence of n PUSH, POP, and MULTIPOP operations takes a total\nof O.n/ time. The average cost of an operation is O.n/=n D O.1/. In aggregate\n454\nChapter 17\nAmortized Analysis\nanalysis, we assign the amortized cost of each operation to be the average cost. In",
    "parent_acb18694-233a-494e-afb2-080e749ee845": "value of n, any sequence of n PUSH, POP, and MULTIPOP operations takes a total\nof O.n/ time. The average cost of an operation is O.n/=n D O.1/. In aggregate\n454\nChapter 17\nAmortized Analysis\nanalysis, we assign the amortized cost of each operation to be the average cost. In\nthis example, therefore, all three stack operations have an amortized cost of O.1/.\nWe emphasize again that although we have just shown that the average cost, and\nhence the running time, of a stack operation is O.1/, we did not use probabilistic\nreasoning. We actually showed a worst-case bound of O.n/ on a sequence of n\noperations. Dividing this total cost by n yielded the average cost per operation, or\nthe amortized cost.\nIncrementing a binary counter\nAs another example of aggregate analysis, consider the problem of implementing\na k-bit binary counter that counts upward from 0. We use an array AŒ0 : : k \u0005 1\u0002 of\nbits, where A:length D k, as the counter. A binary number x that is stored in the\ncounter has its lowest-order bit in AŒ0\u0002 and its highest-order bit in AŒk \u0005 1\u0002, so that\nx D Pk\u00031\niD0 AŒi\u0002 \u0003 2i. Initially, x D 0, and thus AŒi\u0002 D 0 for i D 0; 1; : : : ; k \u0005 1. To\nadd 1 (modulo 2k) to the value in the counter, we use the following procedure.\nINCREMENT.A/\n1\ni D 0\n2\nwhile i < A:length and AŒi\u0002 == 1\n3\nAŒi\u0002 D 0\n4\ni D i C 1\n5\nif i < A:length\n6\nAŒi\u0002 D 1\nFigure 17.2 shows what happens to a binary counter as we increment it 16 times,\nstarting with the initial value 0 and ending with the value 16.\nAt the start of\neach iteration of the while loop in lines 2–4, we wish to add a 1 into position i.\nIf AŒi\u0002 D 1, then adding 1 ﬂips the bit to 0 in position i and yields a carry of 1,\nto be added into position i C 1 on the next iteration of the loop. Otherwise, the\nloop ends, and then, if i < k, we know that AŒi\u0002 D 0, so that line 6 adds a 1 into\nposition i, ﬂipping the 0 to a 1. The cost of each INCREMENT operation is linear\nin the number of bits ﬂipped.",
    "parent_6e8757dd-f35e-46a6-98db-846967f56832": "to be added into position i C 1 on the next iteration of the loop. Otherwise, the\nloop ends, and then, if i < k, we know that AŒi\u0002 D 0, so that line 6 adds a 1 into\nposition i, ﬂipping the 0 to a 1. The cost of each INCREMENT operation is linear\nin the number of bits ﬂipped.\nAs with the stack example, a cursory analysis yields a bound that is correct but\nnot tight. A single execution of INCREMENT takes time ‚.k/ in the worst case, in\nwhich array A contains all 1s. Thus, a sequence of n INCREMENT operations on\nan initially zero counter takes time O.nk/ in the worst case.\nWe can tighten our analysis to yield a worst-case cost of O.n/ for a sequence of n\nINCREMENT operations by observing that not all bits ﬂip each time INCREMENT\nis called. As Figure 17.2 shows, AŒ0\u0002 does ﬂip each time INCREMENT is called.\nThe next bit up, AŒ1\u0002, ﬂips only every other time: a sequence of n INCREMENT\n17.1\nAggregate analysis\n455\n0 0 0 0 0 0 0 0\n0\n0 0 0 0 0 0 0 1\n1\n0 0 0 0 0 0 1 0\n2\n0 0 0 0 0 0 1 1\n3\n0 0 0 0 0 1 0 0\n4\n0 0 0 0 0 1 0 1\n5\n0 0 0 0 0 1 1 0\n6\n0 0 0 0 0 1 1 1\n7\n0 0 0 0 1 0 0 0\n8\n0 0 0 0 1 0 0 1\n9\n0 0 0 0 1 0 1 0\n10\n0 0 0 0 1 0 1 1\n11\n0 0 0 0 1 1 0 0\n12\n0 0 0 0 1 1 0 1\n13\n0 0 0 0 1 1 1 0\n14\n0 0 0 0 1 1 1 1\n15\n0 0 0 1 0 0 0 0\n16\nA[0]\nA[1]\nA[2]\nA[3]\nA[4]\nA[5]\nA[6]\nA[7]\nCounter\nvalue\nTotal\ncost\n1\n3\n4\n7\n8\n10\n11\n15\n16\n18\n19\n22\n23\n25\n26\n31\n0\nFigure 17.2\nAn 8-bit binary counter as its value goes from 0 to 16 by a sequence of 16 INCREMENT\noperations. Bits that ﬂip to achieve the next value are shaded. The running cost for ﬂipping bits is\nshown at the right. Notice that the total cost is always less than twice the total number of INCREMENT\noperations.\noperations on an initially zero counter causes AŒ1\u0002 to ﬂip bn=2c times. Similarly,\nbit AŒ2\u0002 ﬂips only every fourth time, or bn=4c times in a sequence of n INCREMENT\noperations. In general, for i D 0; 1; : : : ; k \u0005 1, bit AŒi\u0002 ﬂips bn=2ic times in a\nsequence of n INCREMENT operations on an initially zero counter. For i \u0006 k,",
    "parent_e4129397-c4fc-49e3-a3ff-51154ff57a8f": "bit AŒ2\u0002 ﬂips only every fourth time, or bn=4c times in a sequence of n INCREMENT\noperations. In general, for i D 0; 1; : : : ; k \u0005 1, bit AŒi\u0002 ﬂips bn=2ic times in a\nsequence of n INCREMENT operations on an initially zero counter. For i \u0006 k,\nbit AŒi\u0002 does not exist, and so it cannot ﬂip. The total number of ﬂips in the\nsequence is thus\nk\u00031\nX\niD0\nj n\n2i\nk\n<\nn\n1\nX\niD0\n1\n2i\nD\n2n ;\nby equation (A.6). The worst-case time for a sequence of n INCREMENT operations\non an initially zero counter is therefore O.n/. The average cost of each operation,\nand therefore the amortized cost per operation, is O.n/=n D O.1/.\n456\nChapter 17\nAmortized Analysis\nExercises\n17.1-1\nIf the set of stack operations included a MULTIPUSH operation, which pushes k\nitems onto the stack, would the O.1/ bound on the amortized cost of stack opera-\ntions continue to hold?\n17.1-2\nShow that if a DECREMENT operation were included in the k-bit counter example,\nn operations could cost as much as ‚.nk/ time.\n17.1-3\nSuppose we perform a sequence of n operations on a data structure in which the ith\noperation costs i if i is an exact power of 2, and 1 otherwise. Use aggregate analysis\nto determine the amortized cost per operation.\n17.2\nThe accounting method\nIn the accounting method of amortized analysis, we assign differing charges to\ndifferent operations, with some operations charged more or less than they actu-\nally cost. We call the amount we charge an operation its amortized cost. When\nan operation’s amortized cost exceeds its actual cost, we assign the difference to\nspeciﬁc objects in the data structure as credit. Credit can help pay for later oper-\nations whose amortized cost is less than their actual cost. Thus, we can view the\namortized cost of an operation as being split between its actual cost and credit that\nis either deposited or used up. Different operations may have different amortized\ncosts. This method differs from aggregate analysis, in which all operations have\nthe same amortized cost.",
    "parent_05636f9e-1bc2-4b92-af39-593c2354b9bd": "amortized cost of an operation as being split between its actual cost and credit that\nis either deposited or used up. Different operations may have different amortized\ncosts. This method differs from aggregate analysis, in which all operations have\nthe same amortized cost.\nWe must choose the amortized costs of operations carefully. If we want to show\nthat in the worst case the average cost per operation is small by analyzing with\namortized costs, we must ensure that the total amortized cost of a sequence of oper-\nations provides an upper bound on the total actual cost of the sequence. Moreover,\nas in aggregate analysis, this relationship must hold for all sequences of opera-\ntions. If we denote the actual cost of the ith operation by ci and the amortized cost\nof the ith operation by yci, we require\nn\nX\niD1\nyci \u0006\nn\nX\niD1\nci\n(17.1)\nfor all sequences of n operations.\nThe total credit stored in the data structure\nis the difference between the total amortized cost and the total actual cost, or\n17.2\nThe accounting method\n457\nPn\niD1 yci \u0005 Pn\niD1 ci. By inequality (17.1), the total credit associated with the data\nstructure must be nonnegative at all times. If we ever were to allow the total credit\nto become negative (the result of undercharging early operations with the promise\nof repaying the account later on), then the total amortized costs incurred at that\ntime would be below the total actual costs incurred; for the sequence of operations\nup to that time, the total amortized cost would not be an upper bound on the total\nactual cost. Thus, we must take care that the total credit in the data structure never\nbecomes negative.\nStack operations\nTo illustrate the accounting method of amortized analysis, let us return to the stack\nexample. Recall that the actual costs of the operations were\nPUSH\n1 ,\nPOP\n1 ,\nMULTIPOP\nmin.k; s/ ,\nwhere k is the argument supplied to MULTIPOP and s is the stack size when it is\ncalled. Let us assign the following amortized costs:\nPUSH\n2 ,\nPOP\n0 ,",
    "parent_6649ff48-6957-4eda-91bb-03b091c3765b": "example. Recall that the actual costs of the operations were\nPUSH\n1 ,\nPOP\n1 ,\nMULTIPOP\nmin.k; s/ ,\nwhere k is the argument supplied to MULTIPOP and s is the stack size when it is\ncalled. Let us assign the following amortized costs:\nPUSH\n2 ,\nPOP\n0 ,\nMULTIPOP\n0 .\nNote that the amortized cost of MULTIPOP is a constant (0), whereas the actual cost\nis variable. Here, all three amortized costs are constant. In general, the amortized\ncosts of the operations under consideration may differ from each other, and they\nmay even differ asymptotically.\nWe shall now show that we can pay for any sequence of stack operations by\ncharging the amortized costs. Suppose we use a dollar bill to represent each unit\nof cost. We start with an empty stack. Recall the analogy of Section 10.1 between\nthe stack data structure and a stack of plates in a cafeteria. When we push a plate\non the stack, we use 1 dollar to pay the actual cost of the push and are left with a\ncredit of 1 dollar (out of the 2 dollars charged), which we leave on top of the plate.\nAt any point in time, every plate on the stack has a dollar of credit on it.\nThe dollar stored on the plate serves as prepayment for the cost of popping it\nfrom the stack. When we execute a POP operation, we charge the operation nothing\nand pay its actual cost using the credit stored in the stack. To pop a plate, we take\nthe dollar of credit off the plate and use it to pay the actual cost of the operation.\nThus, by charging the PUSH operation a little bit more, we can charge the POP\noperation nothing.\n458\nChapter 17\nAmortized Analysis\nMoreover, we can also charge MULTIPOP operations nothing. To pop the ﬁrst\nplate, we take the dollar of credit off the plate and use it to pay the actual cost of a\nPOP operation. To pop a second plate, we again have a dollar of credit on the plate\nto pay for the POP operation, and so on. Thus, we have always charged enough\nup front to pay for MULTIPOP operations. In other words, since each plate on the",
    "parent_4b856b21-0e89-4e73-b7b7-d80c9b3d7501": "POP operation. To pop a second plate, we again have a dollar of credit on the plate\nto pay for the POP operation, and so on. Thus, we have always charged enough\nup front to pay for MULTIPOP operations. In other words, since each plate on the\nstack has 1 dollar of credit on it, and the stack always has a nonnegative number of\nplates, we have ensured that the amount of credit is always nonnegative. Thus, for\nany sequence of n PUSH, POP, and MULTIPOP operations, the total amortized cost\nis an upper bound on the total actual cost. Since the total amortized cost is O.n/,\nso is the total actual cost.\nIncrementing a binary counter\nAs another illustration of the accounting method, we analyze the INCREMENT op-\neration on a binary counter that starts at zero. As we observed earlier, the running\ntime of this operation is proportional to the number of bits ﬂipped, which we shall\nuse as our cost for this example. Let us once again use a dollar bill to represent\neach unit of cost (the ﬂipping of a bit in this example).\nFor the amortized analysis, let us charge an amortized cost of 2 dollars to set a\nbit to 1. When a bit is set, we use 1 dollar (out of the 2 dollars charged) to pay\nfor the actual setting of the bit, and we place the other dollar on the bit as credit to\nbe used later when we ﬂip the bit back to 0. At any point in time, every 1 in the\ncounter has a dollar of credit on it, and thus we can charge nothing to reset a bit\nto 0; we just pay for the reset with the dollar bill on the bit.\nNow we can determine the amortized cost of INCREMENT. The cost of resetting\nthe bits within the while loop is paid for by the dollars on the bits that are reset. The\nINCREMENT procedure sets at most one bit, in line 6, and therefore the amortized\ncost of an INCREMENT operation is at most 2 dollars. The number of 1s in the\ncounter never becomes negative, and thus the amount of credit stays nonnegative\nat all times. Thus, for n INCREMENT operations, the total amortized cost is O.n/,",
    "parent_bb55d764-c3cc-4de1-8976-61af41fe3258": "cost of an INCREMENT operation is at most 2 dollars. The number of 1s in the\ncounter never becomes negative, and thus the amount of credit stays nonnegative\nat all times. Thus, for n INCREMENT operations, the total amortized cost is O.n/,\nwhich bounds the total actual cost.\nExercises\n17.2-1\nSuppose we perform a sequence of stack operations on a stack whose size never\nexceeds k. After every k operations, we make a copy of the entire stack for backup\npurposes. Show that the cost of n stack operations, including copying the stack,\nis O.n/ by assigning suitable amortized costs to the various stack operations.\n17.3\nThe potential method\n459\n17.2-2\nRedo Exercise 17.1-3 using an accounting method of analysis.\n17.2-3\nSuppose we wish not only to increment a counter but also to reset it to zero (i.e.,\nmake all bits in it 0). Counting the time to examine or modify a bit as ‚.1/,\nshow how to implement a counter as an array of bits so that any sequence of n\nINCREMENT and RESET operations takes time O.n/ on an initially zero counter.\n(Hint: Keep a pointer to the high-order 1.)\n17.3\nThe potential method\nInstead of representing prepaid work as credit stored with speciﬁc objects in the\ndata structure, the potential method of amortized analysis represents the prepaid\nwork as “potential energy,” or just “potential,” which can be released to pay for\nfuture operations. We associate the potential with the data structure as a whole\nrather than with speciﬁc objects within the data structure.\nThe potential method works as follows. We will perform n operations, starting\nwith an initial data structure D0. For each i D 1; 2; : : : ; n, we let ci be the actual\ncost of the ith operation and Di be the data structure that results after applying\nthe ith operation to data structure Di\u00031. A potential function ˆ maps each data\nstructure Di to a real number ˆ.Di/, which is the potential associated with data\nstructure Di. The amortized cost yci of the ith operation with respect to potential",
    "parent_9ef99b89-ed78-4490-9cf2-f0dd60bcc40c": "the ith operation to data structure Di\u00031. A potential function ˆ maps each data\nstructure Di to a real number ˆ.Di/, which is the potential associated with data\nstructure Di. The amortized cost yci of the ith operation with respect to potential\nfunction ˆ is deﬁned by\nyci D ci C ˆ.Di/ \u0005 ˆ.Di\u00031/ :\n(17.2)\nThe amortized cost of each operation is therefore its actual cost plus the change in\npotential due to the operation. By equation (17.2), the total amortized cost of the n\noperations is\nn\nX\niD1\nyci\nD\nn\nX\niD1\n.ci C ˆ.Di/ \u0005 ˆ.Di\u00031//\nD\nn\nX\niD1\nci C ˆ.Dn/ \u0005 ˆ.D0/ :\n(17.3)\nThe second equality follows from equation (A.9) because the ˆ.Di/ terms tele-\nscope.\nIf we can deﬁne a potential function ˆ so that ˆ.Dn/ \u0006 ˆ.D0/, then the total\namortized cost Pn\niD1 yci gives an upper bound on the total actual cost Pn\niD1 ci.\n460\nChapter 17\nAmortized Analysis\nIn practice, we do not always know how many operations might be performed.\nTherefore, if we require that ˆ.Di/ \u0006 ˆ.D0/ for all i, then we guarantee, as in\nthe accounting method, that we pay in advance. We usually just deﬁne ˆ.D0/ to\nbe 0 and then show that ˆ.Di/ \u0006 0 for all i. (See Exercise 17.3-1 for an easy way\nto handle cases in which ˆ.D0/ ¤ 0.)\nIntuitively, if the potential difference ˆ.Di/ \u0005 ˆ.Di\u00031/ of the ith operation is\npositive, then the amortized cost yci represents an overcharge to the ith operation,\nand the potential of the data structure increases. If the potential difference is neg-\native, then the amortized cost represents an undercharge to the ith operation, and\nthe decrease in the potential pays for the actual cost of the operation.\nThe amortized costs deﬁned by equations (17.2) and (17.3) depend on the choice\nof the potential function ˆ. Different potential functions may yield different amor-\ntized costs yet still be upper bounds on the actual costs. We often ﬁnd trade-offs\nthat we can make in choosing a potential function; the best potential function to\nuse depends on the desired time bounds.\nStack operations",
    "parent_a8e9414f-4450-4933-8e1f-3b18913883bf": "tized costs yet still be upper bounds on the actual costs. We often ﬁnd trade-offs\nthat we can make in choosing a potential function; the best potential function to\nuse depends on the desired time bounds.\nStack operations\nTo illustrate the potential method, we return once again to the example of the stack\noperations PUSH, POP, and MULTIPOP. We deﬁne the potential function ˆ on a\nstack to be the number of objects in the stack. For the empty stack D0 with which\nwe start, we have ˆ.D0/ D 0. Since the number of objects in the stack is never\nnegative, the stack Di that results after the ith operation has nonnegative potential,\nand thus\nˆ.Di/\n\u0006\n0\nD\nˆ.D0/ :\nThe total amortized cost of n operations with respect to ˆ therefore represents an\nupper bound on the actual cost.\nLet us now compute the amortized costs of the various stack operations. If the ith\noperation on a stack containing s objects is a PUSH operation, then the potential\ndifference is\nˆ.Di/ \u0005 ˆ.Di\u00031/\nD\n.s C 1/ \u0005 s\nD\n1 :\nBy equation (17.2), the amortized cost of this PUSH operation is\nyci\nD\nci C ˆ.Di/ \u0005 ˆ.Di\u00031/\nD\n1 C 1\nD\n2 :\n17.3\nThe potential method\n461\nSuppose that the ith operation on the stack is MULTIPOP.S; k/, which causes\nk0 D min.k; s/ objects to be popped off the stack. The actual cost of the opera-\ntion is k0, and the potential difference is\nˆ.Di/ \u0005 ˆ.Di\u00031/ D \u0005k0 :\nThus, the amortized cost of the MULTIPOP operation is\nyci\nD\nci C ˆ.Di/ \u0005 ˆ.Di\u00031/\nD\nk0 \u0005 k0\nD\n0 :\nSimilarly, the amortized cost of an ordinary POP operation is 0.\nThe amortized cost of each of the three operations is O.1/, and thus the total\namortized cost of a sequence of n operations is O.n/. Since we have already argued\nthat ˆ.Di/ \u0006 ˆ.D0/, the total amortized cost of n operations is an upper bound\non the total actual cost. The worst-case cost of n operations is therefore O.n/.\nIncrementing a binary counter\nAs another example of the potential method, we again look at incrementing a binary",
    "parent_d9fa73c8-dab4-49ac-ac2b-9c628ff36620": "that ˆ.Di/ \u0006 ˆ.D0/, the total amortized cost of n operations is an upper bound\non the total actual cost. The worst-case cost of n operations is therefore O.n/.\nIncrementing a binary counter\nAs another example of the potential method, we again look at incrementing a binary\ncounter. This time, we deﬁne the potential of the counter after the ith INCREMENT\noperation to be bi, the number of 1s in the counter after the ith operation.\nLet us compute the amortized cost of an INCREMENT operation. Suppose that\nthe ith INCREMENT operation resets ti bits. The actual cost of the operation is\ntherefore at most ti C 1, since in addition to resetting ti bits, it sets at most one\nbit to 1. If bi D 0, then the ith operation resets all k bits, and so bi\u00031 D ti D k.\nIf bi > 0, then bi D bi\u00031 \u0005 ti C 1. In either case, bi \u0002 bi\u00031 \u0005 ti C 1, and the\npotential difference is\nˆ.Di/ \u0005 ˆ.Di\u00031/\n\u0002\n.bi\u00031 \u0005 ti C 1/ \u0005 bi\u00031\nD\n1 \u0005 ti :\nThe amortized cost is therefore\nyci\nD\nci C ˆ.Di/ \u0005 ˆ.Di\u00031/\n\u0002\n.ti C 1/ C .1 \u0005 ti/\nD\n2 :\nIf the counter starts at zero, then ˆ.D0/ D 0. Since ˆ.Di/ \u0006 0 for all i, the total\namortized cost of a sequence of n INCREMENT operations is an upper bound on the\ntotal actual cost, and so the worst-case cost of n INCREMENT operations is O.n/.\nThe potential method gives us an easy way to analyze the counter even when\nit does not start at zero. The counter starts with b0 1s, and after n INCREMENT\n462\nChapter 17\nAmortized Analysis\noperations it has bn 1s, where 0 \u0002 b0; bn \u0002 k. (Recall that k is the number of bits\nin the counter.) We can rewrite equation (17.3) as\nn\nX\niD1\nci D\nn\nX\niD1\nyci \u0005 ˆ.Dn/ C ˆ.D0/ :\n(17.4)\nWe have yci \u0002 2 for all 1 \u0002 i \u0002 n. Since ˆ.D0/ D b0 and ˆ.Dn/ D bn, the total\nactual cost of n INCREMENT operations is\nn\nX\niD1\nci\n\u0002\nn\nX\niD1\n2 \u0005 bn C b0\nD\n2n \u0005 bn C b0 :\nNote in particular that since b0 \u0002 k, as long as k D O.n/, the total actual cost\nis O.n/. In other words, if we execute at least n D \u0004.k/ INCREMENT operations,",
    "parent_ad962d1b-7ef7-440f-8127-9b8e1bf95769": "actual cost of n INCREMENT operations is\nn\nX\niD1\nci\n\u0002\nn\nX\niD1\n2 \u0005 bn C b0\nD\n2n \u0005 bn C b0 :\nNote in particular that since b0 \u0002 k, as long as k D O.n/, the total actual cost\nis O.n/. In other words, if we execute at least n D \u0004.k/ INCREMENT operations,\nthe total actual cost is O.n/, no matter what initial value the counter contains.\nExercises\n17.3-1\nSuppose we have a potential function ˆ such that ˆ.Di/ \u0006 ˆ.D0/ for all i, but\nˆ.D0/ ¤ 0. Show that there exists a potential function ˆ0 such that ˆ0.D0/ D 0,\nˆ0.Di/ \u0006 0 for all i \u0006 1, and the amortized costs using ˆ0 are the same as the\namortized costs using ˆ.\n17.3-2\nRedo Exercise 17.1-3 using a potential method of analysis.\n17.3-3\nConsider an ordinary binary min-heap data structure with n elements supporting\nthe instructions INSERT and EXTRACT-MIN in O.lg n/ worst-case time. Give a\npotential function ˆ such that the amortized cost of INSERT is O.lg n/ and the\namortized cost of EXTRACT-MIN is O.1/, and show that it works.\n17.3-4\nWhat is the total cost of executing n of the stack operations PUSH, POP, and\nMULTIPOP, assuming that the stack begins with s0 objects and ﬁnishes with sn\nobjects?\n17.3-5\nSuppose that a counter begins at a number with b 1s in its binary representa-\ntion, rather than at 0. Show that the cost of performing n INCREMENT operations\nis O.n/ if n D \u0004.b/. (Do not assume that b is constant.)\n17.4\nDynamic tables\n463\n17.3-6\nShow how to implement a queue with two ordinary stacks (Exercise 10.1-6) so that\nthe amortized cost of each ENQUEUE and each DEQUEUE operation is O.1/.\n17.3-7\nDesign a data structure to support the following two operations for a dynamic\nmultiset S of integers, which allows duplicate values:\nINSERT.S; x/ inserts x into S.\nDELETE-LARGER-HALF.S/ deletes the largest djSj =2e elements from S.\nExplain how to implement this data structure so that any sequence of m INSERT\nand DELETE-LARGER-HALF operations runs in O.m/ time. Your implementation",
    "parent_a31d9a0f-bd04-4016-a77a-2d90a9157846": "INSERT.S; x/ inserts x into S.\nDELETE-LARGER-HALF.S/ deletes the largest djSj =2e elements from S.\nExplain how to implement this data structure so that any sequence of m INSERT\nand DELETE-LARGER-HALF operations runs in O.m/ time. Your implementation\nshould also include a way to output the elements of S in O.jSj/ time.\n17.4\nDynamic tables\nWe do not always know in advance how many objects some applications will store\nin a table. We might allocate space for a table, only to ﬁnd out later that it is not\nenough. We must then reallocate the table with a larger size and copy all objects\nstored in the original table over into the new, larger table. Similarly, if many objects\nhave been deleted from the table, it may be worthwhile to reallocate the table with\na smaller size. In this section, we study this problem of dynamically expanding and\ncontracting a table. Using amortized analysis, we shall show that the amortized cost\nof insertion and deletion is only O.1/, even though the actual cost of an operation\nis large when it triggers an expansion or a contraction. Moreover, we shall see how\nto guarantee that the unused space in a dynamic table never exceeds a constant\nfraction of the total space.\nWe assume that the dynamic table supports the operations TABLE-INSERT and\nTABLE-DELETE. TABLE-INSERT inserts into the table an item that occupies a sin-\ngle slot, that is, a space for one item. Likewise, TABLE-DELETE removes an item\nfrom the table, thereby freeing a slot. The details of the data-structuring method\nused to organize the table are unimportant; we might use a stack (Section 10.1),\na heap (Chapter 6), or a hash table (Chapter 11). We might also use an array or\ncollection of arrays to implement object storage, as we did in Section 10.3.\nWe shall ﬁnd it convenient to use a concept introduced in our analysis of hashing\n(Chapter 11). We deﬁne the load factor ˛.T / of a nonempty table T to be the\nnumber of items stored in the table divided by the size (number of slots) of the",
    "parent_959579a8-0e3e-46e4-9ece-a53896a44b6f": "We shall ﬁnd it convenient to use a concept introduced in our analysis of hashing\n(Chapter 11). We deﬁne the load factor ˛.T / of a nonempty table T to be the\nnumber of items stored in the table divided by the size (number of slots) of the\ntable. We assign an empty table (one with no items) size 0, and we deﬁne its load\nfactor to be 1. If the load factor of a dynamic table is bounded below by a constant,\n464\nChapter 17\nAmortized Analysis\nthe unused space in the table is never more than a constant fraction of the total\namount of space.\nWe start by analyzing a dynamic table in which we only insert items. We then\nconsider the more general case in which we both insert and delete items.\n17.4.1\nTable expansion\nLet us assume that storage for a table is allocated as an array of slots. A table ﬁlls\nup when all slots have been used or, equivalently, when its load factor is 1.1 In some\nsoftware environments, upon attempting to insert an item into a full table, the only\nalternative is to abort with an error. We shall assume, however, that our software\nenvironment, like many modern ones, provides a memory-management system that\ncan allocate and free blocks of storage on request. Thus, upon inserting an item\ninto a full table, we can expand the table by allocating a new table with more slots\nthan the old table had. Because we always need the table to reside in contiguous\nmemory, we must allocate a new array for the larger table and then copy items from\nthe old table into the new table.\nA common heuristic allocates a new table with twice as many slots as the old\none. If the only table operations are insertions, then the load factor of the table is\nalways at least 1=2, and thus the amount of wasted space never exceeds half the\ntotal space in the table.\nIn the following pseudocode, we assume that T is an object representing the\ntable. The attribute T:table contains a pointer to the block of storage representing",
    "parent_58266b76-f1e8-4518-a4a7-c5e349870fc9": "always at least 1=2, and thus the amount of wasted space never exceeds half the\ntotal space in the table.\nIn the following pseudocode, we assume that T is an object representing the\ntable. The attribute T:table contains a pointer to the block of storage representing\nthe table, T:num contains the number of items in the table, and T:size gives the total\nnumber of slots in the table. Initially, the table is empty: T:num D T:size D 0.\nTABLE-INSERT.T; x/\n1\nif T:size == 0\n2\nallocate T:table with 1 slot\n3\nT:size D 1\n4\nif T:num == T:size\n5\nallocate new-table with 2 \u0003 T:size slots\n6\ninsert all items in T:table into new-table\n7\nfree T:table\n8\nT:table D new-table\n9\nT:size D 2 \u0003 T:size\n10\ninsert x into T:table\n11\nT:num D T:num C 1\n1In some situations, such as an open-address hash table, we may wish to consider a table to be full if\nits load factor equals some constant strictly less than 1. (See Exercise 17.4-1.)\n17.4\nDynamic tables\n465\nNotice that we have two “insertion” procedures here: the TABLE-INSERT proce-\ndure itself and the elementary insertion into a table in lines 6 and 10. We can\nanalyze the running time of TABLE-INSERT in terms of the number of elementary\ninsertions by assigning a cost of 1 to each elementary insertion. We assume that\nthe actual running time of TABLE-INSERT is linear in the time to insert individual\nitems, so that the overhead for allocating an initial table in line 2 is constant and\nthe overhead for allocating and freeing storage in lines 5 and 7 is dominated by\nthe cost of transferring items in line 6. We call the event in which lines 5–9 are\nexecuted an expansion.\nLet us analyze a sequence of n TABLE-INSERT operations on an initially empty\ntable. What is the cost ci of the ith operation? If the current table has room for the\nnew item (or if this is the ﬁrst operation), then ci D 1, since we need only perform\nthe one elementary insertion in line 10. If the current table is full, however, and an",
    "parent_a20fa0f0-07e7-4287-ad3d-825a4a3661c6": "table. What is the cost ci of the ith operation? If the current table has room for the\nnew item (or if this is the ﬁrst operation), then ci D 1, since we need only perform\nthe one elementary insertion in line 10. If the current table is full, however, and an\nexpansion occurs, then ci D i: the cost is 1 for the elementary insertion in line 10\nplus i \u0005 1 for the items that we must copy from the old table to the new table in\nline 6. If we perform n operations, the worst-case cost of an operation is O.n/,\nwhich leads to an upper bound of O.n2/ on the total running time for n operations.\nThis bound is not tight, because we rarely expand the table in the course of n\nTABLE-INSERT operations. Speciﬁcally, the ith operation causes an expansion\nonly when i \u0005 1 is an exact power of 2. The amortized cost of an operation is in\nfact O.1/, as we can show using aggregate analysis. The cost of the ith operation\nis\nci D\n(\ni\nif i \u0005 1 is an exact power of 2 ;\n1\notherwise :\nThe total cost of n TABLE-INSERT operations is therefore\nn\nX\niD1\nci\n\u0002\nn C\nblg nc\nX\njD0\n2j\n<\nn C 2n\nD\n3n ;\nbecause at most n operations cost 1 and the costs of the remaining operations form\na geometric series. Since the total cost of n TABLE-INSERT operations is bounded\nby 3n, the amortized cost of a single operation is at most 3.\nBy using the accounting method, we can gain some feeling for why the amor-\ntized cost of a TABLE-INSERT operation should be 3. Intuitively, each item pays\nfor 3 elementary insertions: inserting itself into the current table, moving itself\nwhen the table expands, and moving another item that has already been moved\nonce when the table expands. For example, suppose that the size of the table is m\nimmediately after an expansion. Then the table holds m=2 items, and it contains\n466\nChapter 17\nAmortized Analysis\nno credit. We charge 3 dollars for each insertion. The elementary insertion that\noccurs immediately costs 1 dollar. We place another dollar as credit on the item",
    "parent_dad4c2ff-cac2-4a15-8a6c-23f5fd6b531c": "immediately after an expansion. Then the table holds m=2 items, and it contains\n466\nChapter 17\nAmortized Analysis\nno credit. We charge 3 dollars for each insertion. The elementary insertion that\noccurs immediately costs 1 dollar. We place another dollar as credit on the item\ninserted. We place the third dollar as credit on one of the m=2 items already in the\ntable. The table will not ﬁll again until we have inserted another m=2 \u0005 1 items,\nand thus, by the time the table contains m items and is full, we will have placed a\ndollar on each item to pay to reinsert it during the expansion.\nWe can use the potential method to analyze a sequence of n TABLE-INSERT\noperations, and we shall use it in Section 17.4.2 to design a TABLE-DELETE op-\neration that has an O.1/ amortized cost as well. We start by deﬁning a potential\nfunction ˆ that is 0 immediately after an expansion but builds to the table size by\nthe time the table is full, so that we can pay for the next expansion by the potential.\nThe function\nˆ.T / D 2 \u0003 T:num \u0005 T:size\n(17.5)\nis one possibility. Immediately after an expansion, we have T:num D T:size=2,\nand thus ˆ.T / D 0, as desired.\nImmediately before an expansion, we have\nT:num D T:size, and thus ˆ.T / D T:num, as desired. The initial value of the\npotential is 0, and since the table is always at least half full, T:num \u0006 T:size=2,\nwhich implies that ˆ.T / is always nonnegative. Thus, the sum of the amortized\ncosts of n TABLE-INSERT operations gives an upper bound on the sum of the actual\ncosts.\nTo analyze the amortized cost of the ith TABLE-INSERT operation, we let numi\ndenote the number of items stored in the table after the ith operation, sizei denote\nthe total size of the table after the ith operation, and ˆi denote the potential after\nthe ith operation. Initially, we have num0 D 0, size0 D 0, and ˆ0 D 0.\nIf the ith TABLE-INSERT operation does not trigger an expansion, then we have\nsizei D sizei\u00031 and the amortized cost of the operation is\nyci\nD\nci C ˆi \u0005 ˆi\u00031",
    "parent_0ed94738-8be1-4bfb-8de0-8cf56a4fce44": "the ith operation. Initially, we have num0 D 0, size0 D 0, and ˆ0 D 0.\nIf the ith TABLE-INSERT operation does not trigger an expansion, then we have\nsizei D sizei\u00031 and the amortized cost of the operation is\nyci\nD\nci C ˆi \u0005 ˆi\u00031\nD\n1 C .2 \u0003 numi \u0005 sizei/ \u0005 .2 \u0003 numi\u00031 \u0005 sizei\u00031/\nD\n1 C .2 \u0003 numi \u0005 sizei/ \u0005 .2.numi \u0005 1/ \u0005 sizei/\nD\n3 :\nIf the ith operation does trigger an expansion, then we have sizei D 2 \u0003 sizei\u00031 and\nsizei\u00031 D numi\u00031 D numi \u0005 1, which implies that sizei D 2 \u0003 .numi \u0005 1/. Thus,\nthe amortized cost of the operation is\nyci\nD\nci C ˆi \u0005 ˆi\u00031\nD\nnumi C .2 \u0003 numi \u0005 sizei/ \u0005 .2 \u0003 numi\u00031 \u0005 sizei\u00031/\nD\nnumi C .2 \u0003 numi \u0005 2 \u0003 .numi \u0005 1// \u0005 .2.numi \u0005 1/ \u0005 .numi \u0005 1//\nD\nnumi C 2 \u0005 .numi \u0005 1/\nD\n3 :\n17.4\nDynamic tables\n467\nΦi\nnumi\nsizei\n0\n8\n16\n24\n32\n0\n8\n16\n24\n32\ni\nFigure 17.3\nThe effect of a sequence of n TABLE-INSERT operations on the number numi of items\nin the table, the number sizei of slots in the table, and the potential ˆi D 2 \u0003 numi \u0005 sizei, each\nbeing measured after the ith operation. The thin line shows numi, the dashed line shows sizei, and\nthe thick line shows ˆi. Notice that immediately before an expansion, the potential has built up to\nthe number of items in the table, and therefore it can pay for moving all the items to the new table.\nAfterwards, the potential drops to 0, but it is immediately increased by 2 upon inserting the item that\ncaused the expansion.\nFigure 17.3 plots the values of numi, sizei, and ˆi against i. Notice how the\npotential builds to pay for expanding the table.\n17.4.2\nTable expansion and contraction\nTo implement a TABLE-DELETE operation, it is simple enough to remove the spec-\niﬁed item from the table. In order to limit the amount of wasted space, however,\nwe might wish to contract the table when the load factor becomes too small. Table\ncontraction is analogous to table expansion: when the number of items in the table\ndrops too low, we allocate a new, smaller table and then copy the items from the",
    "parent_442febea-1f67-47a4-90cb-7c4abfe8e880": "we might wish to contract the table when the load factor becomes too small. Table\ncontraction is analogous to table expansion: when the number of items in the table\ndrops too low, we allocate a new, smaller table and then copy the items from the\nold table into the new one. We can then free the storage for the old table by return-\ning it to the memory-management system. Ideally, we would like to preserve two\nproperties:\n\u0002\nthe load factor of the dynamic table is bounded below by a positive constant,\nand\n\u0002\nthe amortized cost of a table operation is bounded above by a constant.\n468\nChapter 17\nAmortized Analysis\nWe assume that we measure the cost in terms of elementary insertions and dele-\ntions.\nYou might think that we should double the table size upon inserting an item into\na full table and halve the size when a deleting an item would cause the table to\nbecome less than half full. This strategy would guarantee that the load factor of\nthe table never drops below 1=2, but unfortunately, it can cause the amortized cost\nof an operation to be quite large. Consider the following scenario. We perform n\noperations on a table T , where n is an exact power of 2. The ﬁrst n=2 operations are\ninsertions, which by our previous analysis cost a total of ‚.n/. At the end of this\nsequence of insertions, T:num D T:size D n=2. For the second n=2 operations,\nwe perform the following sequence:\ninsert, delete, delete, insert, insert, delete, delete, insert, insert, . . . .\nThe ﬁrst insertion causes the table to expand to size n. The two following deletions\ncause the table to contract back to size n=2. Two further insertions cause another\nexpansion, and so forth. The cost of each expansion and contraction is ‚.n/, and\nthere are ‚.n/ of them. Thus, the total cost of the n operations is ‚.n2/, making\nthe amortized cost of an operation ‚.n/.\nThe downside of this strategy is obvious: after expanding the table, we do not",
    "parent_96c3ab79-1694-4c03-8d13-befdf2745217": "expansion, and so forth. The cost of each expansion and contraction is ‚.n/, and\nthere are ‚.n/ of them. Thus, the total cost of the n operations is ‚.n2/, making\nthe amortized cost of an operation ‚.n/.\nThe downside of this strategy is obvious: after expanding the table, we do not\ndelete enough items to pay for a contraction. Likewise, after contracting the table,\nwe do not insert enough items to pay for an expansion.\nWe can improve upon this strategy by allowing the load factor of the table to\ndrop below 1=2. Speciﬁcally, we continue to double the table size upon inserting\nan item into a full table, but we halve the table size when deleting an item causes\nthe table to become less than 1=4 full, rather than 1=2 full as before. The load\nfactor of the table is therefore bounded below by the constant 1=4.\nIntuitively, we would consider a load factor of 1=2 to be ideal, and the table’s\npotential would then be 0. As the load factor deviates from 1=2, the potential\nincreases so that by the time we expand or contract the table, the table has garnered\nsufﬁcient potential to pay for copying all the items into the newly allocated table.\nThus, we will need a potential function that has grown to T:num by the time that\nthe load factor has either increased to 1 or decreased to 1=4. After either expanding\nor contracting the table, the load factor goes back to 1=2 and the table’s potential\nreduces back to 0.\nWe omit the code for TABLE-DELETE, since it is analogous to TABLE-INSERT.\nFor our analysis, we shall assume that whenever the number of items in the table\ndrops to 0, we free the storage for the table. That is, if T:num D 0, then T:size D 0.\nWe can now use the potential method to analyze the cost of a sequence of n\nTABLE-INSERT and TABLE-DELETE operations. We start by deﬁning a poten-\ntial function ˆ that is 0 immediately after an expansion or contraction and builds\nas the load factor increases to 1 or decreases to 1=4. Let us denote the load fac-\n17.4\nDynamic tables\n469\nnumi",
    "parent_5ae15283-350e-449f-b322-e21e42710f49": "TABLE-INSERT and TABLE-DELETE operations. We start by deﬁning a poten-\ntial function ˆ that is 0 immediately after an expansion or contraction and builds\nas the load factor increases to 1 or decreases to 1=4. Let us denote the load fac-\n17.4\nDynamic tables\n469\nnumi\nΦi\nsizei\n0\n8\n16\n24\n32\n40\n48\n0\n8\n16\n24\n32\ni\nFigure 17.4\nThe effect of a sequence of n TABLE-INSERT and TABLE-DELETE operations on the\nnumber numi of items in the table, the number sizei of slots in the table, and the potential\nˆi D\n\u0011\n2 \u0003 numi \u0005 sizei\nif ˛i \u0006 1=2 ;\nsizei=2 \u0005 numi\nif ˛i < 1=2 ;\neach measured after the ith operation. The thin line shows numi, the dashed line shows sizei, and\nthe thick line shows ˆi. Notice that immediately before an expansion, the potential has built up to\nthe number of items in the table, and therefore it can pay for moving all the items to the new table.\nLikewise, immediately before a contraction, the potential has built up to the number of items in the\ntable.\ntor of a nonempty table T by ˛.T / D T:num=T:size. Since for an empty table,\nT:num D T:size D 0 and ˛.T / D 1, we always have T:num D ˛.T / \u0003 T:size,\nwhether the table is empty or not. We shall use as our potential function\nˆ.T / D\n(\n2 \u0003 T:num \u0005 T:size\nif ˛.T / \u0006 1=2 ;\nT:size=2 \u0005 T:num\nif ˛.T / < 1=2 :\n(17.6)\nObserve that the potential of an empty table is 0 and that the potential is never\nnegative. Thus, the total amortized cost of a sequence of operations with respect\nto ˆ provides an upper bound on the actual cost of the sequence.\nBefore proceeding with a precise analysis, we pause to observe some properties\nof the potential function, as illustrated in Figure 17.4. Notice that when the load\nfactor is 1=2, the potential is 0. When the load factor is 1, we have T:size D T:num,\nwhich implies ˆ.T / D T:num, and thus the potential can pay for an expansion if\nan item is inserted. When the load factor is 1=4, we have T:size D 4\u0003T:num, which\n470\nChapter 17\nAmortized Analysis",
    "parent_6a769039-e474-482e-a4ff-3a9bdb6693c7": "factor is 1=2, the potential is 0. When the load factor is 1, we have T:size D T:num,\nwhich implies ˆ.T / D T:num, and thus the potential can pay for an expansion if\nan item is inserted. When the load factor is 1=4, we have T:size D 4\u0003T:num, which\n470\nChapter 17\nAmortized Analysis\nimplies ˆ.T / D T:num, and thus the potential can pay for a contraction if an item\nis deleted.\nTo analyze a sequence of n TABLE-INSERT and TABLE-DELETE operations,\nwe let ci denote the actual cost of the ith operation, yci denote its amortized cost\nwith respect to ˆ, numi denote the number of items stored in the table after the ith\noperation, sizei denote the total size of the table after the ith operation, ˛i denote\nthe load factor of the table after the ith operation, and ˆi denote the potential after\nthe ith operation. Initially, num0 D 0, size0 D 0, ˛0 D 1, and ˆ0 D 0.\nWe start with the case in which the ith operation is TABLE-INSERT. The analy-\nsis is identical to that for table expansion in Section 17.4.1 if ˛i\u00031 \u0006 1=2. Whether\nthe table expands or not, the amortized cost yci of the operation is at most 3.\nIf ˛i\u00031 < 1=2, the table cannot expand as a result of the operation, since the ta-\nble expands only when ˛i\u00031 D 1. If ˛i < 1=2 as well, then the amortized cost of\nthe ith operation is\nyci\nD\nci C ˆi \u0005 ˆi\u00031\nD\n1 C .sizei=2 \u0005 numi/ \u0005 .sizei\u00031=2 \u0005 numi\u00031/\nD\n1 C .sizei=2 \u0005 numi/ \u0005 .sizei=2 \u0005 .numi \u0005 1//\nD\n0 :\nIf ˛i\u00031 < 1=2 but ˛i \u0006 1=2, then\nyci\nD\nci C ˆi \u0005 ˆi\u00031\nD\n1 C .2 \u0003 numi \u0005 sizei/ \u0005 .sizei\u00031=2 \u0005 numi\u00031/\nD\n1 C .2.numi\u00031 C 1/ \u0005 sizei\u00031/ \u0005 .sizei\u00031=2 \u0005 numi\u00031/\nD\n3 \u0003 numi\u00031 \u0005 3\n2sizei\u00031 C 3\nD\n3˛i\u00031sizei\u00031 \u0005 3\n2sizei\u00031 C 3\n<\n3\n2sizei\u00031 \u0005 3\n2sizei\u00031 C 3\nD\n3 :\nThus, the amortized cost of a TABLE-INSERT operation is at most 3.\nWe now turn to the case in which the ith operation is TABLE-DELETE. In this\ncase, numi D numi\u00031 \u0005 1. If ˛i\u00031 < 1=2, then we must consider whether the\noperation causes the table to contract. If it does not, then sizei D sizei\u00031 and the",
    "parent_8a3a9764-2247-4554-806d-a68fea929f24": "We now turn to the case in which the ith operation is TABLE-DELETE. In this\ncase, numi D numi\u00031 \u0005 1. If ˛i\u00031 < 1=2, then we must consider whether the\noperation causes the table to contract. If it does not, then sizei D sizei\u00031 and the\namortized cost of the operation is\nyci\nD\nci C ˆi \u0005 ˆi\u00031\nD\n1 C .sizei=2 \u0005 numi/ \u0005 .sizei\u00031=2 \u0005 numi\u00031/\nD\n1 C .sizei=2 \u0005 numi/ \u0005 .sizei=2 \u0005 .numi C 1//\nD\n2 :\n17.4\nDynamic tables\n471\nIf ˛i\u00031 < 1=2 and the ith operation does trigger a contraction, then the actual cost\nof the operation is ci D numi C 1, since we delete one item and move numi items.\nWe have sizei=2 D sizei\u00031=4 D numi\u00031 D numi C 1, and the amortized cost of\nthe operation is\nyci\nD\nci C ˆi \u0005 ˆi\u00031\nD\n.numi C 1/ C .sizei=2 \u0005 numi/ \u0005 .sizei\u00031=2 \u0005 numi\u00031/\nD\n.numi C 1/ C ..numi C 1/ \u0005 numi/ \u0005 ..2 \u0003 numi C 2/ \u0005 .numi C 1//\nD\n1 :\nWhen the ith operation is a TABLE-DELETE and ˛i\u00031 \u0006 1=2, the amortized cost\nis also bounded above by a constant. We leave the analysis as Exercise 17.4-2.\nIn summary, since the amortized cost of each operation is bounded above by\na constant, the actual time for any sequence of n operations on a dynamic table\nis O.n/.\nExercises\n17.4-1\nSuppose that we wish to implement a dynamic, open-address hash table. Why\nmight we consider the table to be full when its load factor reaches some value ˛\nthat is strictly less than 1? Describe brieﬂy how to make insertion into a dynamic,\nopen-address hash table run in such a way that the expected value of the amortized\ncost per insertion is O.1/. Why is the expected value of the actual cost per insertion\nnot necessarily O.1/ for all insertions?\n17.4-2\nShow that if ˛i\u00031 \u0006 1=2 and the ith operation on a dynamic table is TABLE-\nDELETE, then the amortized cost of the operation with respect to the potential\nfunction (17.6) is bounded above by a constant.\n17.4-3\nSuppose that instead of contracting a table by halving its size when its load factor\ndrops below 1=4, we contract it by multiplying its size by 2=3 when its load factor",
    "parent_fa85d23f-fff1-4803-813f-08b44a679335": "function (17.6) is bounded above by a constant.\n17.4-3\nSuppose that instead of contracting a table by halving its size when its load factor\ndrops below 1=4, we contract it by multiplying its size by 2=3 when its load factor\ndrops below 1=3. Using the potential function\nˆ.T / D j2 \u0003 T:num \u0005 T:sizej ;\nshow that the amortized cost of a TABLE-DELETE that uses this strategy is bounded\nabove by a constant.\n472\nChapter 17\nAmortized Analysis\nProblems\n17-1\nBit-reversed binary counter\nChapter 30 examines an important algorithm called the fast Fourier transform,\nor FFT. The ﬁrst step of the FFT algorithm performs a bit-reversal permutation on\nan input array AŒ0 : : n\u00051\u0002 whose length is n D 2k for some nonnegative integer k.\nThis permutation swaps elements whose indices have binary representations that\nare the reverse of each other.\nWe can express each index a as a k-bit sequence hak\u00031; ak\u00032; : : : ; a0i, where\na D Pk\u00031\niD0 ai 2i. We deﬁne\nrevk.hak\u00031; ak\u00032; : : : ; a0i/ D ha0; a1; : : : ; ak\u00031i I\nthus,\nrevk.a/ D\nk\u00031\nX\niD0\nak\u0003i\u000312i :\nFor example, if n D 16 (or, equivalently, k D 4), then revk.3/ D 12, since\nthe 4-bit representation of 3 is 0011, which when reversed gives 1100, the 4-bit\nrepresentation of 12.\na. Given a function revk that runs in ‚.k/ time, write an algorithm to perform the\nbit-reversal permutation on an array of length n D 2k in O.nk/ time.\nWe can use an algorithm based on an amortized analysis to improve the running\ntime of the bit-reversal permutation. We maintain a “bit-reversed counter” and a\nprocedure BIT-REVERSED-INCREMENT that, when given a bit-reversed-counter\nvalue a, produces revk.revk.a/ C 1/. If k D 4, for example, and the bit-reversed\ncounter starts at 0, then successive calls to BIT-REVERSED-INCREMENT produce\nthe sequence\n0000; 1000; 0100; 1100; 0010; 1010; : : : D 0; 8; 4; 12; 2; 10; : : : :\nb. Assume that the words in your computer store k-bit values and that in unit time,",
    "parent_49602d01-607e-43df-9b21-844a71eea668": "counter starts at 0, then successive calls to BIT-REVERSED-INCREMENT produce\nthe sequence\n0000; 1000; 0100; 1100; 0010; 1010; : : : D 0; 8; 4; 12; 2; 10; : : : :\nb. Assume that the words in your computer store k-bit values and that in unit time,\nyour computer can manipulate the binary values with operations such as shifting\nleft or right by arbitrary amounts, bitwise-AND, bitwise-OR, etc. Describe\nan implementation of the BIT-REVERSED-INCREMENT procedure that allows\nthe bit-reversal permutation on an n-element array to be performed in a total\nof O.n/ time.\nc. Suppose that you can shift a word left or right by only one bit in unit time. Is it\nstill possible to implement an O.n/-time bit-reversal permutation?\nProblems for Chapter 17\n473\n17-2\nMaking binary search dynamic\nBinary search of a sorted array takes logarithmic search time, but the time to insert\na new element is linear in the size of the array. We can improve the time for\ninsertion by keeping several sorted arrays.\nSpeciﬁcally, suppose that we wish to support SEARCH and INSERT on a set\nof n elements.\nLet k D dlg.n C 1/e, and let the binary representation of n\nbe hnk\u00031; nk\u00032; : : : ; n0i. We have k sorted arrays A0; A1; : : : ; Ak\u00031, where for\ni D 0; 1; : : : ; k \u0005 1, the length of array Ai is 2i. Each array is either full or empty,\ndepending on whether ni D 1 or ni D 0, respectively. The total number of ele-\nments held in all k arrays is therefore Pk\u00031\niD0 ni 2i D n. Although each individual\narray is sorted, elements in different arrays bear no particular relationship to each\nother.\na. Describe how to perform the SEARCH operation for this data structure. Analyze\nits worst-case running time.\nb. Describe how to perform the INSERT operation. Analyze its worst-case and\namortized running times.\nc. Discuss how to implement DELETE.\n17-3\nAmortized weight-balanced trees\nConsider an ordinary binary search tree augmented by adding to each node x the",
    "parent_02c72ba4-57c8-4233-ba53-ef9b1fbf61f1": "its worst-case running time.\nb. Describe how to perform the INSERT operation. Analyze its worst-case and\namortized running times.\nc. Discuss how to implement DELETE.\n17-3\nAmortized weight-balanced trees\nConsider an ordinary binary search tree augmented by adding to each node x the\nattribute x:size giving the number of keys stored in the subtree rooted at x. Let ˛\nbe a constant in the range 1=2 \u0002 ˛ < 1. We say that a given node x is ˛-balanced\nif x:left:size \u0002 ˛ \u0003 x:size and x:right:size \u0002 ˛ \u0003 x:size. The tree as a whole\nis ˛-balanced if every node in the tree is ˛-balanced. The following amortized\napproach to maintaining weight-balanced trees was suggested by G. Varghese.\na. A 1=2-balanced tree is, in a sense, as balanced as it can be. Given a node x\nin an arbitrary binary search tree, show how to rebuild the subtree rooted at x\nso that it becomes 1=2-balanced. Your algorithm should run in time ‚.x:size/,\nand it can use O.x:size/ auxiliary storage.\nb. Show that performing a search in an n-node ˛-balanced binary search tree\ntakes O.lg n/ worst-case time.\nFor the remainder of this problem, assume that the constant ˛ is strictly greater\nthan 1=2. Suppose that we implement INSERT and DELETE as usual for an n-node\nbinary search tree, except that after every such operation, if any node in the tree\nis no longer ˛-balanced, then we “rebuild” the subtree rooted at the highest such\nnode in the tree so that it becomes 1=2-balanced.\n474\nChapter 17\nAmortized Analysis\nWe shall analyze this rebuilding scheme using the potential method. For a node x\nin a binary search tree T , we deﬁne\n\f.x/ D jx:left:size \u0005 x:right:sizej ;\nand we deﬁne the potential of T as\nˆ.T / D c\nX\nx2T W\u0006.x/\u00062\n\f.x/ ;\nwhere c is a sufﬁciently large constant that depends on ˛.\nc. Argue that any binary search tree has nonnegative potential and that a 1=2-\nbalanced tree has potential 0.\nd. Suppose that m units of potential can pay for rebuilding an m-node subtree.",
    "parent_cd3ec2fd-7b79-4712-bcb4-2b13982cdfa6": "ˆ.T / D c\nX\nx2T W\u0006.x/\u00062\n\f.x/ ;\nwhere c is a sufﬁciently large constant that depends on ˛.\nc. Argue that any binary search tree has nonnegative potential and that a 1=2-\nbalanced tree has potential 0.\nd. Suppose that m units of potential can pay for rebuilding an m-node subtree.\nHow large must c be in terms of ˛ in order for it to take O.1/ amortized time\nto rebuild a subtree that is not ˛-balanced?\ne. Show that inserting a node into or deleting a node from an n-node ˛-balanced\ntree costs O.lg n/ amortized time.\n17-4\nThe cost of restructuring red-black trees\nThere are four basic operations on red-black trees that perform structural modi-\nﬁcations: node insertions, node deletions, rotations, and color changes. We have\nseen that RB-INSERT and RB-DELETE use only O.1/ rotations, node insertions,\nand node deletions to maintain the red-black properties, but they may make many\nmore color changes.\na. Describe a legal red-black tree with n nodes such that calling RB-INSERT to\nadd the .n C 1/st node causes \u0004.lg n/ color changes. Then describe a legal\nred-black tree with n nodes for which calling RB-DELETE on a particular node\ncauses \u0004.lg n/ color changes.\nAlthough the worst-case number of color changes per operation can be logarithmic,\nwe shall prove that any sequence of m RB-INSERT and RB-DELETE operations on\nan initially empty red-black tree causes O.m/ structural modiﬁcations in the worst\ncase. Note that we count each color change as a structural modiﬁcation.\nb. Some of the cases handled by the main loop of the code of both RB-INSERT-\nFIXUP and RB-DELETE-FIXUP are terminating: once encountered, they cause\nthe loop to terminate after a constant number of additional operations. For each\nof the cases of RB-INSERT-FIXUP and RB-DELETE-FIXUP, specify which are\nterminating and which are not. (Hint: Look at Figures 13.5, 13.6, and 13.7.)\nProblems for Chapter 17\n475\nWe shall ﬁrst analyze the structural modiﬁcations when only insertions are per-",
    "parent_0984733c-1804-4e8f-8051-09e9f0c545c0": "of the cases of RB-INSERT-FIXUP and RB-DELETE-FIXUP, specify which are\nterminating and which are not. (Hint: Look at Figures 13.5, 13.6, and 13.7.)\nProblems for Chapter 17\n475\nWe shall ﬁrst analyze the structural modiﬁcations when only insertions are per-\nformed. Let T be a red-black tree, and deﬁne ˆ.T / to be the number of red nodes\nin T . Assume that 1 unit of potential can pay for the structural modiﬁcations per-\nformed by any of the three cases of RB-INSERT-FIXUP.\nc. Let T 0 be the result of applying Case 1 of RB-INSERT-FIXUP to T . Argue that\nˆ.T 0/ D ˆ.T / \u0005 1.\nd. When we insert a node into a red-black tree using RB-INSERT, we can break\nthe operation into three parts. List the structural modiﬁcations and potential\nchanges resulting from lines 1–16 of RB-INSERT, from nonterminating cases\nof RB-INSERT-FIXUP, and from terminating cases of RB-INSERT-FIXUP.\ne. Using part (d), argue that the amortized number of structural modiﬁcations per-\nformed by any call of RB-INSERT is O.1/.\nWe now wish to prove that there are O.m/ structural modiﬁcations when there are\nboth insertions and deletions. Let us deﬁne, for each node x,\nw.x/ D\n„\n0\nif x is red ;\n1\nif x is black and has no red children ;\n0\nif x is black and has one red child ;\n2\nif x is black and has two red children :\nNow we redeﬁne the potential of a red-black tree T as\nˆ.T / D\nX\nx2T\nw.x/ ;\nand let T 0 be the tree that results from applying any nonterminating case of RB-\nINSERT-FIXUP or RB-DELETE-FIXUP to T .\nf. Show that ˆ.T 0/ \u0002 ˆ.T / \u0005 1 for all nonterminating cases of RB-INSERT-\nFIXUP. Argue that the amortized number of structural modiﬁcations performed\nby any call of RB-INSERT-FIXUP is O.1/.\ng. Show that ˆ.T 0/ \u0002 ˆ.T / \u0005 1 for all nonterminating cases of RB-DELETE-\nFIXUP. Argue that the amortized number of structural modiﬁcations performed\nby any call of RB-DELETE-FIXUP is O.1/.\nh. Complete the proof that in the worst case, any sequence of m RB-INSERT and",
    "parent_00fd1867-8701-4164-8f27-906e9aa03802": "g. Show that ˆ.T 0/ \u0002 ˆ.T / \u0005 1 for all nonterminating cases of RB-DELETE-\nFIXUP. Argue that the amortized number of structural modiﬁcations performed\nby any call of RB-DELETE-FIXUP is O.1/.\nh. Complete the proof that in the worst case, any sequence of m RB-INSERT and\nRB-DELETE operations performs O.m/ structural modiﬁcations.\n476\nChapter 17\nAmortized Analysis\n17-5\nCompetitive analysis of self-organizing lists with move-to-front\nA self-organizing list is a linked list of n elements, in which each element has a\nunique key. When we search for an element in the list, we are given a key, and we\nwant to ﬁnd an element with that key.\nA self-organizing list has two important properties:\n1. To ﬁnd an element in the list, given its key, we must traverse the list from the\nbeginning until we encounter the element with the given key. If that element is\nthe kth element from the start of the list, then the cost to ﬁnd the element is k.\n2. We may reorder the list elements after any operation, according to a given rule\nwith a given cost. We may choose any heuristic we like to decide how to reorder\nthe list.\nAssume that we start with a given list of n elements, and we are given an access\nsequence \t D h\t1; \t2; : : : ; \tmi of keys to ﬁnd, in order. The cost of the sequence\nis the sum of the costs of the individual accesses in the sequence.\nOut of the various possible ways to reorder the list after an operation, this prob-\nlem focuses on transposing adjacent list elements—switching their positions in the\nlist—with a unit cost for each transpose operation. You will show, by means of a\npotential function, that a particular heuristic for reordering the list, move-to-front,\nentails a total cost no worse than 4 times that of any other heuristic for maintaining\nthe list order—even if the other heuristic knows the access sequence in advance!\nWe call this type of analysis a competitive analysis.\nFor a heuristic H and a given initial ordering of the list, denote the access cost of",
    "parent_932871e9-7a1c-40ac-bcce-de53cb6d9d0e": "the list order—even if the other heuristic knows the access sequence in advance!\nWe call this type of analysis a competitive analysis.\nFor a heuristic H and a given initial ordering of the list, denote the access cost of\nsequence \t by CH.\t/. Let m be the number of accesses in \t.\na. Argue that if heuristic H does not know the access sequence in advance, then\nthe worst-case cost for H on an access sequence \t is CH.\t/ D \u0004.mn/.\nWith the move-to-front heuristic, immediately after searching for an element x,\nwe move x to the ﬁrst position on the list (i.e., the front of the list).\nLet rankL.x/ denote the rank of element x in list L, that is, the position of x in\nlist L. For example, if x is the fourth element in L, then rankL.x/ D 4. Let ci\ndenote the cost of access \ti using the move-to-front heuristic, which includes the\ncost of ﬁnding the element in the list and the cost of moving it to the front of the\nlist by a series of transpositions of adjacent list elements.\nb. Show that if \ti accesses element x in list L using the move-to-front heuristic,\nthen ci D 2 \u0003 rankL.x/ \u0005 1.\nNow we compare move-to-front with any other heuristic H that processes an\naccess sequence according to the two properties above. Heuristic H may transpose\nProblems for Chapter 17\n477\nelements in the list in any way it wants, and it might even know the entire access\nsequence in advance.\nLet Li be the list after access \ti using move-to-front, and let L\u0004\ni be the list after\naccess \ti using heuristic H. We denote the cost of access \ti by ci for move-to-\nfront and by c\u0004\ni for heuristic H. Suppose that heuristic H performs t\u0004\ni transpositions\nduring access \ti.\nc. In part (b), you showed that ci D 2 \u0003 rankLi\u00041.x/ \u0005 1. Now show that c\u0004\ni D\nrankL\u0003\ni\u00041.x/ C t\u0004\ni .\nWe deﬁne an inversion in list Li as a pair of elements y and ´ such that y\nprecedes ´ in Li and ´ precedes y in list L\u0004\ni . Suppose that list Li has qi inversions\nafter processing the access sequence h\t1; \t2; : : : ; \tii. Then, we deﬁne a potential",
    "parent_43cff2d8-244a-490a-8b96-e4444cb0618e": "i D\nrankL\u0003\ni\u00041.x/ C t\u0004\ni .\nWe deﬁne an inversion in list Li as a pair of elements y and ´ such that y\nprecedes ´ in Li and ´ precedes y in list L\u0004\ni . Suppose that list Li has qi inversions\nafter processing the access sequence h\t1; \t2; : : : ; \tii. Then, we deﬁne a potential\nfunction ˆ that maps Li to a real number by ˆ.Li/ D 2qi. For example, if Li has\nthe elements he; c; a; d; bi and L\u0004\ni has the elements hc; a; b; d; ei, then Li has 5\ninversions (.e; c/; .e; a/; .e; d/; .e; b/; .d; b/), and so ˆ.Li/ D 10. Observe that\nˆ.Li/ \u0006 0 for all i and that, if move-to-front and heuristic H start with the same\nlist L0, then ˆ.L0/ D 0.\nd. Argue that a transposition either increases the potential by 2 or decreases the\npotential by 2.\nSuppose that access \ti ﬁnds the element x. To understand how the potential\nchanges due to \ti, let us partition the elements other than x into four sets, depend-\ning on where they are in the lists just before the ith access:\n\u0002\nSet A consists of elements that precede x in both Li\u00031 and L\u0004\ni\u00031.\n\u0002\nSet B consists of elements that precede x in Li\u00031 and follow x in L\u0004\ni\u00031.\n\u0002\nSet C consists of elements that follow x in Li\u00031 and precede x in L\u0004\ni\u00031.\n\u0002\nSet D consists of elements that follow x in both Li\u00031 and L\u0004\ni\u00031.\ne. Argue that rankLi\u00041.x/ D jAj C jBj C 1 and rankL\u0003\ni\u00041.x/ D jAj C jCj C 1.\nf. Show that access \ti causes a change in potential of\nˆ.Li/ \u0005 ˆ.Li\u00031/ \u0002 2.jAj \u0005 jBj C t\u0004\ni / ;\nwhere, as before, heuristic H performs t\u0004\ni transpositions during access \ti.\nDeﬁne the amortized cost yci of access \ti by yci D ci C ˆ.Li/ \u0005 ˆ.Li\u00031/.\ng. Show that the amortized cost yci of access \ti is bounded from above by 4c\u0004\ni .\nh. Conclude that the cost CMTF.\t/ of access sequence \t with move-to-front is at\nmost 4 times the cost CH.\t/ of \t with any other heuristic H, assuming that\nboth heuristics start with the same list.\n478\nChapter 17\nAmortized Analysis\nChapter notes\nAho, Hopcroft, and Ullman [5] used aggregate analysis to determine the running",
    "parent_0f1b5547-520a-4a0b-8d99-101267a5b6c9": "most 4 times the cost CH.\t/ of \t with any other heuristic H, assuming that\nboth heuristics start with the same list.\n478\nChapter 17\nAmortized Analysis\nChapter notes\nAho, Hopcroft, and Ullman [5] used aggregate analysis to determine the running\ntime of operations on a disjoint-set forest; we shall analyze this data structure us-\ning the potential method in Chapter 21. Tarjan [331] surveys the accounting and\npotential methods of amortized analysis and presents several applications. He at-\ntributes the accounting method to several authors, including M. R. Brown, R. E.\nTarjan, S. Huddleston, and K. Mehlhorn. He attributes the potential method to\nD. D. Sleator. The term “amortized” is due to D. D. Sleator and R. E. Tarjan.\nPotential functions are also useful for proving lower bounds for certain types of\nproblems. For each conﬁguration of the problem, we deﬁne a potential function\nthat maps the conﬁguration to a real number. Then we determine the potential ˆinit\nof the initial conﬁguration, the potential ˆﬁnal of the ﬁnal conﬁguration, and the\nmaximum change in potential \fˆmax due to any step. The number of steps must\ntherefore be at least jˆﬁnal \u0005 ˆinitj = j\fˆmaxj. Examples of potential functions to\nprove lower bounds in I/O complexity appear in works by Cormen, Sundquist, and\nWisniewski [79]; Floyd [107]; and Aggarwal and Vitter [3]. Krumme, Cybenko,\nand Venkataraman [221] applied potential functions to prove lower bounds on gos-\nsiping: communicating a unique item from each vertex in a graph to every other\nvertex.\nThe move-to-front heuristic from Problem 17-5 works quite well in practice.\nMoreover, if we recognize that when we ﬁnd an element, we can splice it out of its\nposition in the list and relocate it to the front of the list in constant time, we can\nshow that the cost of move-to-front is at most twice the cost of any other heuristic\nincluding, again, one that knows the entire access sequence in advance.\nV\nAdvanced Data Structures\nIntroduction",
    "parent_4ae80eef-60be-4bfc-bf6f-756030aa2f29": "position in the list and relocate it to the front of the list in constant time, we can\nshow that the cost of move-to-front is at most twice the cost of any other heuristic\nincluding, again, one that knows the entire access sequence in advance.\nV\nAdvanced Data Structures\nIntroduction\nThis part returns to studying data structures that support operations on dynamic\nsets, but at a more advanced level than Part III. Two of the chapters, for example,\nmake extensive use of the amortized analysis techniques we saw in Chapter 17.\nChapter 18 presents B-trees, which are balanced search trees speciﬁcally de-\nsigned to be stored on disks.\nBecause disks operate much more slowly than\nrandom-access memory, we measure the performance of B-trees not only by how\nmuch computing time the dynamic-set operations consume but also by how many\ndisk accesses they perform. For each B-tree operation, the number of disk accesses\nincreases with the height of the B-tree, but B-tree operations keep the height low.\nChapter 19 gives an implementation of a mergeable heap, which supports the\noperations INSERT, MINIMUM, EXTRACT-MIN, and UNION.1 The UNION oper-\nation unites, or merges, two heaps. Fibonacci heaps—the data structure in Chap-\nter 19—also support the operations DELETE and DECREASE-KEY. We use amor-\ntized time bounds to measure the performance of Fibonacci heaps. The opera-\ntions INSERT, MINIMUM, and UNION take only O.1/ actual and amortized time\non Fibonacci heaps, and the operations EXTRACT-MIN and DELETE take O.lg n/\namortized time. The most signiﬁcant advantage of Fibonacci heaps, however, is\nthat DECREASE-KEY takes only O.1/ amortized time. Because the DECREASE-\n1As in Problem 10-2, we have deﬁned a mergeable heap to support MINIMUM and EXTRACT-MIN,\nand so we can also refer to it as a mergeable min-heap. Alternatively, if it supported MAXIMUM\nand EXTRACT-MAX, it would be a mergeable max-heap. Unless we specify otherwise, mergeable\nheaps will be by default mergeable min-heaps.\n482\nPart V",
    "parent_a9818b66-efcb-47b3-be8b-506aa85e03ab": "and so we can also refer to it as a mergeable min-heap. Alternatively, if it supported MAXIMUM\nand EXTRACT-MAX, it would be a mergeable max-heap. Unless we specify otherwise, mergeable\nheaps will be by default mergeable min-heaps.\n482\nPart V\nAdvanced Data Structures\nKEY operation takes constant amortized time, Fibonacci heaps are key components\nof some of the asymptotically fastest algorithms to date for graph problems.\nNoting that we can beat the \u0004.n lg n/ lower bound for sorting when the keys\nare integers in a restricted range, Chapter 20 asks whether we can design a data\nstructure that supports the dynamic-set operations SEARCH, INSERT, DELETE,\nMINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR in o.lg n/ time when\nthe keys are integers in a restricted range. The answer turns out to be that we can,\nby using a recursive data structure known as a van Emde Boas tree. If the keys are\nunique integers drawn from the set f0; 1; 2; : : : ; u \u0005 1g, where u is an exact power\nof 2, then van Emde Boas trees support each of the above operations in O.lg lg u/\ntime.\nFinally, Chapter 21 presents data structures for disjoint sets. We have a universe\nof n elements that are partitioned into dynamic sets. Initially, each element belongs\nto its own singleton set. The operation UNION unites two sets, and the query FIND-\nSET identiﬁes the unique set that contains a given element at the moment. By\nrepresenting each set as a simple rooted tree, we obtain surprisingly fast operations:\na sequence of m operations runs in O.m ˛.n// time, where ˛.n/ is an incredibly\nslowly growing function—˛.n/ is at most 4 in any conceivable application. The\namortized analysis that proves this time bound is as complex as the data structure\nis simple.\nThe topics covered in this part are by no means the only examples of “advanced”\ndata structures. Other advanced data structures include the following:\n\u0002\nDynamic trees, introduced by Sleator and Tarjan [319] and discussed by Tarjan",
    "parent_9e0ee0d7-d7cd-4a8e-8ef6-b9833d65dd52": "is simple.\nThe topics covered in this part are by no means the only examples of “advanced”\ndata structures. Other advanced data structures include the following:\n\u0002\nDynamic trees, introduced by Sleator and Tarjan [319] and discussed by Tarjan\n[330], maintain a forest of disjoint rooted trees. Each edge in each tree has\na real-valued cost. Dynamic trees support queries to ﬁnd parents, roots, edge\ncosts, and the minimum edge cost on a simple path from a node up to a root.\nTrees may be manipulated by cutting edges, updating all edge costs on a simple\npath from a node up to a root, linking a root into another tree, and making a\nnode the root of the tree it appears in. One implementation of dynamic trees\ngives an O.lg n/ amortized time bound for each operation; a more complicated\nimplementation yields O.lg n/ worst-case time bounds. Dynamic trees are used\nin some of the asymptotically fastest network-ﬂow algorithms.\n\u0002\nSplay trees, developed by Sleator and Tarjan [320] and, again, discussed by\nTarjan [330], are a form of binary search tree on which the standard search-\ntree operations run in O.lg n/ amortized time. One application of splay trees\nsimpliﬁes dynamic trees.\n\u0002\nPersistent data structures allow queries, and sometimes updates as well, on past\nversions of a data structure. Driscoll, Sarnak, Sleator, and Tarjan [97] present\ntechniques for making linked data structures persistent with only a small time\nPart V\nAdvanced Data Structures\n483\nand space cost. Problem 13-1 gives a simple example of a persistent dynamic\nset.\n\u0002\nAs in Chapter 20, several data structures allow a faster implementation of dic-\ntionary operations (INSERT, DELETE, and SEARCH) for a restricted universe\nof keys. By taking advantage of these restrictions, they are able to achieve bet-\nter worst-case asymptotic running times than comparison-based data structures.\nFredman and Willard introduced fusion trees [115], which were the ﬁrst data",
    "parent_e9d9dab3-d2a6-4d4c-88b3-a0f7f6e2f07d": "of keys. By taking advantage of these restrictions, they are able to achieve bet-\nter worst-case asymptotic running times than comparison-based data structures.\nFredman and Willard introduced fusion trees [115], which were the ﬁrst data\nstructure to allow faster dictionary operations when the universe is restricted to\nintegers. They showed how to implement these operations in O.lg n= lg lg n/\ntime. Several subsequent data structures, including exponential search trees\n[16], have also given improved bounds on some or all of the dictionary opera-\ntions and are mentioned in the chapter notes throughout this book.\n\u0002\nDynamic graph data structures support various queries while allowing the\nstructure of a graph to change through operations that insert or delete vertices\nor edges. Examples of the queries that they support include vertex connectivity\n[166], edge connectivity, minimum spanning trees [165], biconnectivity, and\ntransitive closure [164].\nChapter notes throughout this book mention additional data structures.\n18\nB-Trees\nB-trees are balanced search trees designed to work well on disks or other direct-\naccess secondary storage devices. B-trees are similar to red-black trees (Chap-\nter 13), but they are better at minimizing disk I/O operations. Many database sys-\ntems use B-trees, or variants of B-trees, to store information.\nB-trees differ from red-black trees in that B-tree nodes may have many children,\nfrom a few to thousands. That is, the “branching factor” of a B-tree can be quite\nlarge, although it usually depends on characteristics of the disk unit used. B-trees\nare similar to red-black trees in that every n-node B-tree has height O.lg n/. The\nexact height of a B-tree can be considerably less than that of a red-black tree,\nhowever, because its branching factor, and hence the base of the logarithm that\nexpresses its height, can be much larger. Therefore, we can also use B-trees to\nimplement many dynamic-set operations in time O.lg n/.",
    "parent_7d884b5f-da8a-4599-833b-d34846f9aa05": "exact height of a B-tree can be considerably less than that of a red-black tree,\nhowever, because its branching factor, and hence the base of the logarithm that\nexpresses its height, can be much larger. Therefore, we can also use B-trees to\nimplement many dynamic-set operations in time O.lg n/.\nB-trees generalize binary search trees in a natural manner. Figure 18.1 shows a\nsimple B-tree. If an internal B-tree node x contains x:n keys, then x has x:n C 1\nchildren. The keys in node x serve as dividing points separating the range of keys\nhandled by x into x:n C 1 subranges, each handled by one child of x. When\nsearching for a key in a B-tree, we make an .x:n C 1/-way decision based on\ncomparisons with the x:n keys stored at node x. The structure of leaf nodes differs\nfrom that of internal nodes; we will examine these differences in Section 18.1.\nSection 18.1 gives a precise deﬁnition of B-trees and proves that the height of\na B-tree grows only logarithmically with the number of nodes it contains. Sec-\ntion 18.2 describes how to search for a key and insert a key into a B-tree, and\nSection 18.3 discusses deletion. Before proceeding, however, we need to ask why\nwe evaluate data structures designed to work on a disk differently from data struc-\ntures designed to work in main random-access memory.\nData structures on secondary storage\nComputer systems take advantage of various technologies that provide memory\ncapacity. The primary memory (or main memory) of a computer system normally\nChapter 18\nB-Trees\n485\nB\nC\nF\nG\nJ\nK\nL\nD H\nN\nP\nR\nS\nV W\nY\nZ\nQ\nT\nX\nM\nT:root\nFigure 18.1\nA B-tree whose keys are the consonants of English. An internal node x containing\nx:n keys has x:n C 1 children. All leaves are at the same depth in the tree. The lightly shaded nodes\nare examined in a search for the letter R.\nplatter\ntrack\narms\nread/write\nhead\nspindle\nFigure 18.2\nA typical disk drive. It comprises one or more platters (two platters are shown here)",
    "parent_cacb9ff7-8ee7-48c8-9eeb-76e9e2470614": "x:n keys has x:n C 1 children. All leaves are at the same depth in the tree. The lightly shaded nodes\nare examined in a search for the letter R.\nplatter\ntrack\narms\nread/write\nhead\nspindle\nFigure 18.2\nA typical disk drive. It comprises one or more platters (two platters are shown here)\nthat rotate around a spindle. Each platter is read and written with a head at the end of an arm. Arms\nrotate around a common pivot axis. A track is the surface that passes beneath the read/write head\nwhen the head is stationary.\nconsists of silicon memory chips. This technology is typically more than an order\nof magnitude more expensive per bit stored than magnetic storage technology, such\nas tapes or disks. Most computer systems also have secondary storage based on\nmagnetic disks; the amount of such secondary storage often exceeds the amount of\nprimary memory by at least two orders of magnitude.\nFigure 18.2 shows a typical disk drive. The drive consists of one or more plat-\nters, which rotate at a constant speed around a common spindle. A magnetizable\nmaterial covers the surface of each platter. The drive reads and writes each platter\nby a head at the end of an arm. The arms can move their heads toward or away\n486\nChapter 18\nB-Trees\nfrom the spindle. When a given head is stationary, the surface that passes under-\nneath it is called a track. Multiple platters increase only the disk drive’s capacity\nand not its performance.\nAlthough disks are cheaper and have higher capacity than main memory, they are\nmuch, much slower because they have moving mechanical parts.1 The mechanical\nmotion has two components: platter rotation and arm movement. As of this writing,\ncommodity disks rotate at speeds of 5400–15,000 revolutions per minute (RPM).\nWe typically see 15,000 RPM speeds in server-grade drives, 7200 RPM speeds\nin drives for desktops, and 5400 RPM speeds in drives for laptops.\nAlthough\n7200 RPM may seem fast, one rotation takes 8.33 milliseconds, which is over 5",
    "parent_0d357997-5428-46b7-8e86-726cf06ba042": "We typically see 15,000 RPM speeds in server-grade drives, 7200 RPM speeds\nin drives for desktops, and 5400 RPM speeds in drives for laptops.\nAlthough\n7200 RPM may seem fast, one rotation takes 8.33 milliseconds, which is over 5\norders of magnitude longer than the 50 nanosecond access times (more or less)\ncommonly found for silicon memory. In other words, if we have to wait a full rota-\ntion for a particular item to come under the read/write head, we could access main\nmemory more than 100,000 times during that span. On average we have to wait\nfor only half a rotation, but still, the difference in access times for silicon memory\ncompared with disks is enormous. Moving the arms also takes some time. As of\nthis writing, average access times for commodity disks are in the range of 8 to 11\nmilliseconds.\nIn order to amortize the time spent waiting for mechanical movements, disks\naccess not just one item but several at a time. Information is divided into a number\nof equal-sized pages of bits that appear consecutively within tracks, and each disk\nread or write is of one or more entire pages. For a typical disk, a page might be 211\nto 214 bytes in length. Once the read/write head is positioned correctly and the disk\nhas rotated to the beginning of the desired page, reading or writing a magnetic disk\nis entirely electronic (aside from the rotation of the disk), and the disk can quickly\nread or write large amounts of data.\nOften, accessing a page of information and reading it from a disk takes longer\nthan examining all the information read. For this reason, in this chapter we shall\nlook separately at the two principal components of the running time:\n\u0002\nthe number of disk accesses, and\n\u0002\nthe CPU (computing) time.\nWe measure the number of disk accesses in terms of the number of pages of infor-\nmation that need to be read from or written to the disk. We note that disk-access\ntime is not constant—it depends on the distance between the current track and",
    "parent_2274ebdc-86d7-4f09-9b17-cf1ec181e3bf": "\u0002\nthe CPU (computing) time.\nWe measure the number of disk accesses in terms of the number of pages of infor-\nmation that need to be read from or written to the disk. We note that disk-access\ntime is not constant—it depends on the distance between the current track and\nthe desired track and also on the initial rotational position of the disk. We shall\n1As of this writing, solid-state drives have recently come onto the consumer market. Although they\nare faster than mechanical disk drives, they cost more per gigabyte and have lower capacities than\nmechanical disk drives.\nChapter 18\nB-Trees\n487\nnonetheless use the number of pages read or written as a ﬁrst-order approximation\nof the total time spent accessing the disk.\nIn a typical B-tree application, the amount of data handled is so large that all\nthe data do not ﬁt into main memory at once. The B-tree algorithms copy selected\npages from disk into main memory as needed and write back onto disk the pages\nthat have changed. B-tree algorithms keep only a constant number of pages in\nmain memory at any time; thus, the size of main memory does not limit the size of\nB-trees that can be handled.\nWe model disk operations in our pseudocode as follows. Let x be a pointer to an\nobject. If the object is currently in the computer’s main memory, then we can refer\nto the attributes of the object as usual: x:key, for example. If the object referred to\nby x resides on disk, however, then we must perform the operation DISK-READ.x/\nto read object x into main memory before we can refer to its attributes. (We as-\nsume that if x is already in main memory, then DISK-READ.x/ requires no disk\naccesses; it is a “no-op.”) Similarly, the operation DISK-WRITE.x/ is used to save\nany changes that have been made to the attributes of object x. That is, the typical\npattern for working with an object is as follows:\nx D a pointer to some object\nDISK-READ.x/\noperations that access and/or modify the attributes of x\nDISK-WRITE.x/",
    "parent_8e1187ad-e24b-4931-89d6-cde1d416dea6": "any changes that have been made to the attributes of object x. That is, the typical\npattern for working with an object is as follows:\nx D a pointer to some object\nDISK-READ.x/\noperations that access and/or modify the attributes of x\nDISK-WRITE.x/\n// omitted if no attributes of x were changed\nother operations that access but do not modify attributes of x\nThe system can keep only a limited number of pages in main memory at any one\ntime. We shall assume that the system ﬂushes from main memory pages no longer\nin use; our B-tree algorithms will ignore this issue.\nSince in most systems the running time of a B-tree algorithm depends primar-\nily on the number of DISK-READ and DISK-WRITE operations it performs, we\ntypically want each of these operations to read or write as much information as\npossible. Thus, a B-tree node is usually as large as a whole disk page, and this size\nlimits the number of children a B-tree node can have.\nFor a large B-tree stored on a disk, we often see branching factors between 50\nand 2000, depending on the size of a key relative to the size of a page. A large\nbranching factor dramatically reduces both the height of the tree and the number of\ndisk accesses required to ﬁnd any key. Figure 18.3 shows a B-tree with a branching\nfactor of 1001 and height 2 that can store over one billion keys; nevertheless, since\nwe can keep the root node permanently in main memory, we can ﬁnd any key in\nthis tree by making at most only two disk accesses.\n488\nChapter 18\nB-Trees\n1000\n1001\n1000\n1001\n1000\n1001\n1000\n1001\n1000\n1000\n1000\n…\n1 node,\n   1000 keys\n1001 nodes,\n   1,001,000 keys\n1,002,001 nodes,\n   1,002,001,000 keys\n…\nT:root\nFigure 18.3\nA B-tree of height 2 containing over one billion keys. Shown inside each node x\nis x:n, the number of keys in x. Each internal node and leaf contains 1000 keys. This B-tree has\n1001 nodes at depth 1 and over one million leaves at depth 2.\n18.1\nDeﬁnition of B-trees",
    "parent_35309673-e150-42c5-bb82-d116da235111": "…\nT:root\nFigure 18.3\nA B-tree of height 2 containing over one billion keys. Shown inside each node x\nis x:n, the number of keys in x. Each internal node and leaf contains 1000 keys. This B-tree has\n1001 nodes at depth 1 and over one million leaves at depth 2.\n18.1\nDeﬁnition of B-trees\nTo keep things simple, we assume, as we have for binary search trees and red-black\ntrees, that any “satellite information” associated with a key resides in the same\nnode as the key. In practice, one might actually store with each key just a pointer to\nanother disk page containing the satellite information for that key. The pseudocode\nin this chapter implicitly assumes that the satellite information associated with a\nkey, or the pointer to such satellite information, travels with the key whenever the\nkey is moved from node to node. A common variant on a B-tree, known as a\nBC-tree, stores all the satellite information in the leaves and stores only keys and\nchild pointers in the internal nodes, thus maximizing the branching factor of the\ninternal nodes.\nA B-tree T is a rooted tree (whose root is T:root) having the following proper-\nties:\n1. Every node x has the following attributes:\na. x:n, the number of keys currently stored in node x,\nb. the x:n keys themselves, x:key1; x:key2; : : : ; x:keyx:n, stored in nondecreas-\ning order, so that x:key1 \u0002 x:key2 \u0002 \u0003 \u0003 \u0003 \u0002 x:keyx:n,\nc. x:leaf , a boolean value that is TRUE if x is a leaf and FALSE if x is an internal\nnode.\n2. Each internal node x also contains x:n C 1 pointers x:c1; x:c2; : : : ; x:cx:nC1 to\nits children. Leaf nodes have no children, and so their ci attributes are unde-\nﬁned.\n18.1\nDeﬁnition of B-trees\n489\n3. The keys x:keyi separate the ranges of keys stored in each subtree: if ki is any\nkey stored in the subtree with root x:ci, then\nk1 \u0002 x:key1 \u0002 k2 \u0002 x:key2 \u0002 \u0003 \u0003 \u0003 \u0002 x:keyx:n \u0002 kx:nC1 :\n4. All leaves have the same depth, which is the tree’s height h.\n5. Nodes have lower and upper bounds on the number of keys they can contain.",
    "parent_3881aea5-1bc2-4eb7-8472-5c55a58c3a20": "key stored in the subtree with root x:ci, then\nk1 \u0002 x:key1 \u0002 k2 \u0002 x:key2 \u0002 \u0003 \u0003 \u0003 \u0002 x:keyx:n \u0002 kx:nC1 :\n4. All leaves have the same depth, which is the tree’s height h.\n5. Nodes have lower and upper bounds on the number of keys they can contain.\nWe express these bounds in terms of a ﬁxed integer t \u0006 2 called the minimum\ndegree of the B-tree:\na. Every node other than the root must have at least t \u0005 1 keys. Every internal\nnode other than the root thus has at least t children. If the tree is nonempty,\nthe root must have at least one key.\nb. Every node may contain at most 2t \u0005 1 keys. Therefore, an internal node\nmay have at most 2t children. We say that a node is full if it contains exactly\n2t \u0005 1 keys.2\nThe simplest B-tree occurs when t D 2. Every internal node then has either 2,\n3, or 4 children, and we have a 2-3-4 tree. In practice, however, much larger values\nof t yield B-trees with smaller height.\nThe height of a B-tree\nThe number of disk accesses required for most operations on a B-tree is propor-\ntional to the height of the B-tree. We now analyze the worst-case height of a B-tree.\nTheorem 18.1\nIf n \u0006 1, then for any n-key B-tree T of height h and minimum degree t \u0006 2,\nh \u0002 logt\nn C 1\n2\n:\nProof\nThe root of a B-tree T contains at least one key, and all other nodes contain\nat least t \u0005 1 keys. Thus, T , whose height is h, has at least 2 nodes at depth 1, at\nleast 2t nodes at depth 2, at least 2t2 nodes at depth 3, and so on, until at depth h\nit has at least 2th\u00031 nodes. Figure 18.4 illustrates such a tree for h D 3. Thus, the\n2Another common variant on a B-tree, known as a B\u0002-tree, requires each internal node to be at\nleast 2=3 full, rather than at least half full, as a B-tree requires.\n490\nChapter 18\nB-Trees\nt – 1\nt – 1\nt – 1\n…\nt\nt – 1\nt\n…\n1\nt – 1\nt – 1\nt – 1\n…\nt\nt – 1\nt – 1\nt – 1\n…\nt\nt – 1\nt\n…\nt – 1\nt – 1\nt – 1\n…\nt\ndepth\nnumber\nof nodes\n3\n2t2\n1\n2\n0\n1\n2\n2t\nT:root\nFigure 18.4\nA B-tree of height 3 containing a minimum possible number of keys. Shown inside",
    "parent_e4f4a81f-7b7b-405d-aaf4-4ed629bcfd09": "490\nChapter 18\nB-Trees\nt – 1\nt – 1\nt – 1\n…\nt\nt – 1\nt\n…\n1\nt – 1\nt – 1\nt – 1\n…\nt\nt – 1\nt – 1\nt – 1\n…\nt\nt – 1\nt\n…\nt – 1\nt – 1\nt – 1\n…\nt\ndepth\nnumber\nof nodes\n3\n2t2\n1\n2\n0\n1\n2\n2t\nT:root\nFigure 18.4\nA B-tree of height 3 containing a minimum possible number of keys. Shown inside\neach node x is x:n.\nnumber n of keys satisﬁes the inequality\nn\n\u0006\n1 C .t \u0005 1/\nh\nX\niD1\n2ti\u00031\nD\n1 C 2.t \u0005 1/\n\u0002th \u0005 1\nt \u0005 1\n\u0003\nD\n2th \u0005 1 :\nBy simple algebra, we get th \u0002 .n C 1/=2. Taking base-t logarithms of both sides\nproves the theorem.\nHere we see the power of B-trees, as compared with red-black trees. Although\nthe height of the tree grows as O.lg n/ in both cases (recall that t is a constant), for\nB-trees the base of the logarithm can be many times larger. Thus, B-trees save a\nfactor of about lg t over red-black trees in the number of nodes examined for most\ntree operations. Because we usually have to access the disk to examine an arbitrary\nnode in a tree, B-trees avoid a substantial number of disk accesses.\nExercises\n18.1-1\nWhy don’t we allow a minimum degree of t D 1?\n18.1-2\nFor what values of t is the tree of Figure 18.1 a legal B-tree?\n18.2\nBasic operations on B-trees\n491\n18.1-3\nShow all legal B-trees of minimum degree 2 that represent f1; 2; 3; 4; 5g.\n18.1-4\nAs a function of the minimum degree t, what is the maximum number of keys that\ncan be stored in a B-tree of height h?\n18.1-5\nDescribe the data structure that would result if each black node in a red-black tree\nwere to absorb its red children, incorporating their children with its own.\n18.2\nBasic operations on B-trees\nIn this section, we present the details of the operations B-TREE-SEARCH, B-\nTREE-CREATE, and B-TREE-INSERT. In these procedures, we adopt two con-\nventions:\n\u0002\nThe root of the B-tree is always in main memory, so that we never need to\nperform a DISK-READ on the root; we do have to perform a DISK-WRITE of\nthe root, however, whenever the root node is changed.\n\u0002",
    "parent_d596a7ff-7753-48c7-bf5d-6ed9ac983d34": "TREE-CREATE, and B-TREE-INSERT. In these procedures, we adopt two con-\nventions:\n\u0002\nThe root of the B-tree is always in main memory, so that we never need to\nperform a DISK-READ on the root; we do have to perform a DISK-WRITE of\nthe root, however, whenever the root node is changed.\n\u0002\nAny nodes that are passed as parameters must already have had a DISK-READ\noperation performed on them.\nThe procedures we present are all “one-pass” algorithms that proceed downward\nfrom the root of the tree, without having to back up.\nSearching a B-tree\nSearching a B-tree is much like searching a binary search tree, except that instead\nof making a binary, or “two-way,” branching decision at each node, we make a\nmultiway branching decision according to the number of the node’s children. More\nprecisely, at each internal node x, we make an .x:n C 1/-way branching decision.\nB-TREE-SEARCH is a straightforward generalization of the TREE-SEARCH pro-\ncedure deﬁned for binary search trees. B-TREE-SEARCH takes as input a pointer\nto the root node x of a subtree and a key k to be searched for in that subtree. The\ntop-level call is thus of the form B-TREE-SEARCH.T:root; k/. If k is in the B-tree,\nB-TREE-SEARCH returns the ordered pair .y; i/ consisting of a node y and an\nindex i such that y:keyi D k. Otherwise, the procedure returns NIL.\n492\nChapter 18\nB-Trees\nB-TREE-SEARCH.x; k/\n1\ni D 1\n2\nwhile i \u0002 x:n and k > x:keyi\n3\ni D i C 1\n4\nif i \u0002 x:n and k == x:keyi\n5\nreturn .x; i/\n6\nelseif x:leaf\n7\nreturn NIL\n8\nelse DISK-READ.x:ci/\n9\nreturn B-TREE-SEARCH.x:ci; k/\nUsing a linear-search procedure, lines 1–3 ﬁnd the smallest index i such that\nk \u0002 x:keyi, or else they set i to x:n C 1. Lines 4–5 check to see whether we\nhave now discovered the key, returning if we have. Otherwise, lines 6–9 either ter-\nminate the search unsuccessfully (if x is a leaf) or recurse to search the appropriate\nsubtree of x, after performing the necessary DISK-READ on that child.",
    "parent_1786b4e5-64b8-4fc2-a99a-26d16fd734ff": "have now discovered the key, returning if we have. Otherwise, lines 6–9 either ter-\nminate the search unsuccessfully (if x is a leaf) or recurse to search the appropriate\nsubtree of x, after performing the necessary DISK-READ on that child.\nFigure 18.1 illustrates the operation of B-TREE-SEARCH. The procedure exam-\nines the lightly shaded nodes during a search for the key R.\nAs in the TREE-SEARCH procedure for binary search trees, the nodes encoun-\ntered during the recursion form a simple path downward from the root of the\ntree. The B-TREE-SEARCH procedure therefore accesses O.h/ D O.logt n/ disk\npages, where h is the height of the B-tree and n is the number of keys in the B-tree.\nSince x:n < 2t, the while loop of lines 2–3 takes O.t/ time within each node, and\nthe total CPU time is O.th/ D O.t logt n/.\nCreating an empty B-tree\nTo build a B-tree T , we ﬁrst use B-TREE-CREATE to create an empty root node\nand then call B-TREE-INSERT to add new keys. Both of these procedures use an\nauxiliary procedure ALLOCATE-NODE, which allocates one disk page to be used\nas a new node in O.1/ time. We can assume that a node created by ALLOCATE-\nNODE requires no DISK-READ, since there is as yet no useful information stored\non the disk for that node.\nB-TREE-CREATE.T /\n1\nx D ALLOCATE-NODE./\n2\nx:leaf D TRUE\n3\nx:n D 0\n4\nDISK-WRITE.x/\n5\nT:root D x\nB-TREE-CREATE requires O.1/ disk operations and O.1/ CPU time.\n18.2\nBasic operations on B-trees\n493\nInserting a key into a B-tree\nInserting a key into a B-tree is signiﬁcantly more complicated than inserting a key\ninto a binary search tree. As with binary search trees, we search for the leaf position\nat which to insert the new key. With a B-tree, however, we cannot simply create\na new leaf node and insert it, as the resulting tree would fail to be a valid B-tree.\nInstead, we insert the new key into an existing leaf node. Since we cannot insert a\nkey into a leaf node that is full, we introduce an operation that splits a full node y",
    "parent_bebb5cda-0173-40ec-b65a-f24b63c2f707": "a new leaf node and insert it, as the resulting tree would fail to be a valid B-tree.\nInstead, we insert the new key into an existing leaf node. Since we cannot insert a\nkey into a leaf node that is full, we introduce an operation that splits a full node y\n(having 2t \u00051 keys) around its median key y:keyt into two nodes having only t \u00051\nkeys each. The median key moves up into y’s parent to identify the dividing point\nbetween the two new trees. But if y’s parent is also full, we must split it before we\ncan insert the new key, and thus we could end up splitting full nodes all the way up\nthe tree.\nAs with a binary search tree, we can insert a key into a B-tree in a single pass\ndown the tree from the root to a leaf. To do so, we do not wait to ﬁnd out whether\nwe will actually need to split a full node in order to do the insertion. Instead, as we\ntravel down the tree searching for the position where the new key belongs, we split\neach full node we come to along the way (including the leaf itself). Thus whenever\nwe want to split a full node y, we are assured that its parent is not full.\nSplitting a node in a B-tree\nThe procedure B-TREE-SPLIT-CHILD takes as input a nonfull internal node x (as-\nsumed to be in main memory) and an index i such that x:ci (also assumed to be in\nmain memory) is a full child of x. The procedure then splits this child in two and\nadjusts x so that it has an additional child. To split a full root, we will ﬁrst make the\nroot a child of a new empty root node, so that we can use B-TREE-SPLIT-CHILD.\nThe tree thus grows in height by one; splitting is the only means by which the tree\ngrows.\nFigure 18.5 illustrates this process. We split the full node y D x:ci about its\nmedian key S, which moves up into y’s parent node x. Those keys in y that are\ngreater than the median key move into a new node ´, which becomes a new child\nof x.\n494\nChapter 18\nB-Trees\nR\nS\nT\nQ\nP\nU\nV\nN W\n…\n…\nR\nQ\nP\nT\nU\nV\nN\nW\nS\n…\n…\nx\nx\nT1\nT1\nT2\nT2\nT3\nT3\nT4\nT4\nT5\nT5\nT6\nT6\nT7\nT7\nT8\nT8\ny D x:ci",
    "parent_ec9ed60f-89d4-43d7-a186-a9605bb65a8d": "median key S, which moves up into y’s parent node x. Those keys in y that are\ngreater than the median key move into a new node ´, which becomes a new child\nof x.\n494\nChapter 18\nB-Trees\nR\nS\nT\nQ\nP\nU\nV\nN W\n…\n…\nR\nQ\nP\nT\nU\nV\nN\nW\nS\n…\n…\nx\nx\nT1\nT1\nT2\nT2\nT3\nT3\nT4\nT4\nT5\nT5\nT6\nT6\nT7\nT7\nT8\nT8\ny D x:ci\ny D x:ci\n´ D x:ciC1\nx:keyi\u00021\nx:keyi\u00021\nx:keyi\nx:keyi\nx:keyiC1\nFigure 18.5\nSplitting a node with t D 4. Node y D x:ci splits into two nodes, y and ´, and the\nmedian key S of y moves up into y’s parent.\nB-TREE-SPLIT-CHILD.x; i/\n1\n´ D ALLOCATE-NODE./\n2\ny D x:ci\n3\n´:leaf D y:leaf\n4\n´:n D t \u0002 1\n5\nfor j D 1 to t \u0002 1\n6\n´:keyj D y:keyjCt\n7\nif not y:leaf\n8\nfor j D 1 to t\n9\n´:cj D y:cjCt\n10\ny:n D t \u0002 1\n11\nfor j D x:n C 1 downto i C 1\n12\nx:cjC1 D x:cj\n13\nx:ciC1 D ´\n14\nfor j D x:n downto i\n15\nx:keyjC1 D x:keyj\n16\nx:keyi D y:keyt\n17\nx:n D x:n C 1\n18\nDISK-WRITE.y/\n19\nDISK-WRITE.´/\n20\nDISK-WRITE.x/\nB-TREE-SPLIT-CHILD works by straightforward “cutting and pasting.” Here, x\nis the node being split, and y is x’s ith child (set in line 2). Node y originally has 2t\nchildren (2t \u0002 1 keys) but is reduced to t children (t \u0002 1 keys) by this operation.\nNode ´ takes the t largest children (t \u0002 1 keys) from y, and ´ becomes a new child\n18.2\nBasic operations on B-trees\n495\nof x, positioned just after y in x’s table of children. The median key of y moves\nup to become the key in x that separates y and ´.\nLines 1–9 create node ´ and give it the largest t \u0005 1 keys and corresponding t\nchildren of y. Line 10 adjusts the key count for y. Finally, lines 11–17 insert ´ as\na child of x, move the median key from y up to x in order to separate y from ´,\nand adjust x’s key count. Lines 18–20 write out all modiﬁed disk pages. The\nCPU time used by B-TREE-SPLIT-CHILD is ‚.t/, due to the loops on lines 5–6\nand 8–9. (The other loops run for O.t/ iterations.) The procedure performs O.1/\ndisk operations.\nInserting a key into a B-tree in a single pass down the tree",
    "parent_08986ab5-b944-4add-a185-dcfceb978d09": "CPU time used by B-TREE-SPLIT-CHILD is ‚.t/, due to the loops on lines 5–6\nand 8–9. (The other loops run for O.t/ iterations.) The procedure performs O.1/\ndisk operations.\nInserting a key into a B-tree in a single pass down the tree\nWe insert a key k into a B-tree T of height h in a single pass down the tree, re-\nquiring O.h/ disk accesses. The CPU time required is O.th/ D O.t logt n/. The\nB-TREE-INSERT procedure uses B-TREE-SPLIT-CHILD to guarantee that the re-\ncursion never descends to a full node.\nB-TREE-INSERT.T; k/\n1\nr D T:root\n2\nif r:n == 2t \u0005 1\n3\ns D ALLOCATE-NODE./\n4\nT:root D s\n5\ns:leaf D FALSE\n6\ns:n D 0\n7\ns:c1 D r\n8\nB-TREE-SPLIT-CHILD.s; 1/\n9\nB-TREE-INSERT-NONFULL.s; k/\n10\nelse B-TREE-INSERT-NONFULL.r; k/\nLines 3–9 handle the case in which the root node r is full: the root splits and a\nnew node s (having two children) becomes the root. Splitting the root is the only\nway to increase the height of a B-tree. Figure 18.6 illustrates this case. Unlike a\nbinary search tree, a B-tree increases in height at the top instead of at the bottom.\nThe procedure ﬁnishes by calling B-TREE-INSERT-NONFULL to insert key k into\nthe tree rooted at the nonfull root node. B-TREE-INSERT-NONFULL recurses as\nnecessary down the tree, at all times guaranteeing that the node to which it recurses\nis not full by calling B-TREE-SPLIT-CHILD as necessary.\nThe auxiliary recursive procedure B-TREE-INSERT-NONFULL inserts key k into\nnode x, which is assumed to be nonfull when the procedure is called. The operation\nof B-TREE-INSERT and the recursive operation of B-TREE-INSERT-NONFULL\nguarantee that this assumption is true.\n496\nChapter 18\nB-Trees\nT8\nT7\nT6\nT5\nT4\nT3\nT2\nT1\nT8\nT7\nT6\nT5\nT4\nT3\nT2\nT1\nF\nH\nL\nD\nA\nN\nP\nF\nD\nA\nL\nN\nP\ns\nH\nr\nr\nT:root\nT:root\nFigure 18.6\nSplitting the root with t D 4. Root node r splits in two, and a new root node s is\ncreated. The new root contains the median key of r and has the two halves of r as children. The\nB-tree grows in height by one when the root is split.",
    "parent_20bea214-9926-46b6-acc1-006421ddf401": "T2\nT1\nF\nH\nL\nD\nA\nN\nP\nF\nD\nA\nL\nN\nP\ns\nH\nr\nr\nT:root\nT:root\nFigure 18.6\nSplitting the root with t D 4. Root node r splits in two, and a new root node s is\ncreated. The new root contains the median key of r and has the two halves of r as children. The\nB-tree grows in height by one when the root is split.\nB-TREE-INSERT-NONFULL.x; k/\n1\ni D x:n\n2\nif x:leaf\n3\nwhile i \u0006 1 and k < x:keyi\n4\nx:keyiC1 D x:keyi\n5\ni D i \u0005 1\n6\nx:keyiC1 D k\n7\nx:n D x:n C 1\n8\nDISK-WRITE.x/\n9\nelse while i \u0006 1 and k < x:keyi\n10\ni D i \u0005 1\n11\ni D i C 1\n12\nDISK-READ.x:ci/\n13\nif x:ci:n == 2t \u0005 1\n14\nB-TREE-SPLIT-CHILD.x; i/\n15\nif k > x:keyi\n16\ni D i C 1\n17\nB-TREE-INSERT-NONFULL.x:ci; k/\nThe B-TREE-INSERT-NONFULL procedure works as follows. Lines 3–8 handle\nthe case in which x is a leaf node by inserting key k into x. If x is not a leaf\nnode, then we must insert k into the appropriate leaf node in the subtree rooted\nat internal node x. In this case, lines 9–11 determine the child of x to which the\nrecursion descends. Line 13 detects whether the recursion would descend to a full\nchild, in which case line 14 uses B-TREE-SPLIT-CHILD to split that child into two\nnonfull children, and lines 15–16 determine which of the two children is now the\n18.2\nBasic operations on B-trees\n497\ncorrect one to descend to. (Note that there is no need for a DISK-READ.x:ci/ after\nline 16 increments i, since the recursion will descend in this case to a child that\nwas just created by B-TREE-SPLIT-CHILD.) The net effect of lines 13–16 is thus\nto guarantee that the procedure never recurses to a full node. Line 17 then recurses\nto insert k into the appropriate subtree. Figure 18.7 illustrates the various cases of\ninserting into a B-tree.\nFor a B-tree of height h, B-TREE-INSERT performs O.h/ disk accesses, since\nonly O.1/ DISK-READ and DISK-WRITE operations occur between calls to\nB-TREE-INSERT-NONFULL. The total CPU time used is O.th/ D O.t logt n/.\nSince B-TREE-INSERT-NONFULL is tail-recursive, we can alternatively imple-",
    "parent_1278a6fb-df56-4a92-9877-66763faac79f": "For a B-tree of height h, B-TREE-INSERT performs O.h/ disk accesses, since\nonly O.1/ DISK-READ and DISK-WRITE operations occur between calls to\nB-TREE-INSERT-NONFULL. The total CPU time used is O.th/ D O.t logt n/.\nSince B-TREE-INSERT-NONFULL is tail-recursive, we can alternatively imple-\nment it as a while loop, thereby demonstrating that the number of pages that need\nto be in main memory at any time is O.1/.\nExercises\n18.2-1\nShow the results of inserting the keys\nF; S; Q; K; C; L; H; T; V; W; M; R; N; P; A; B; X; Y; D; Z; E\nin order into an empty B-tree with minimum degree 2. Draw only the conﬁgura-\ntions of the tree just before some node must split, and also draw the ﬁnal conﬁgu-\nration.\n18.2-2\nExplain under what circumstances, if any, redundant DISK-READ or DISK-WRITE\noperations occur during the course of executing a call to B-TREE-INSERT. (A\nredundant DISK-READ is a DISK-READ for a page that is already in memory.\nA redundant DISK-WRITE writes to disk a page of information that is identical to\nwhat is already stored there.)\n18.2-3\nExplain how to ﬁnd the minimum key stored in a B-tree and how to ﬁnd the prede-\ncessor of a given key stored in a B-tree.\n18.2-4\n?\nSuppose that we insert the keys f1; 2; : : : ; ng into an empty B-tree with minimum\ndegree 2. How many nodes does the ﬁnal B-tree have?\n18.2-5\nSince leaf nodes require no pointers to children, they could conceivably use a dif-\nferent (larger) t value than internal nodes for the same disk page size. Show how\nto modify the procedures for creating and inserting into a B-tree to handle this\nvariation.\n498\nChapter 18\nB-Trees\nJ\nK\nN O\nR\nS\nT\nD\nE\nC\nA\nU\nV\nY\nZ\nP\nX\nM\nG\n(a)\nJ\nK\nN O\nR\nS\nT\nD\nE\nB\nA\nU\nV\nY\nZ\nP\nX\nM\nG\n(b)\nC\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nP\nX\nM\nG\n(c)\nC\nR\nS\nQ\nT\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nM\nG\n(d)\nC\nR\nS\nQ\nL\nP\nX\nT\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nM\nG\n(e)\nC\nR\nS\nQ\nL\nP\nX\nT\nF\nQ inserted\nL inserted\nF inserted\ninitial tree\nB inserted\nFigure 18.7\nInserting keys into a B-tree. The minimum degree t for this B-tree is 3, so a node can",
    "parent_64bc1cc7-2d9e-4c9f-8bfa-0cc736008816": "J\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nP\nX\nM\nG\n(c)\nC\nR\nS\nQ\nT\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nM\nG\n(d)\nC\nR\nS\nQ\nL\nP\nX\nT\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nM\nG\n(e)\nC\nR\nS\nQ\nL\nP\nX\nT\nF\nQ inserted\nL inserted\nF inserted\ninitial tree\nB inserted\nFigure 18.7\nInserting keys into a B-tree. The minimum degree t for this B-tree is 3, so a node can\nhold at most 5 keys. Nodes that are modiﬁed by the insertion process are lightly shaded. (a) The\ninitial tree for this example. (b) The result of inserting B into the initial tree; this is a simple insertion\ninto a leaf node. (c) The result of inserting Q into the previous tree. The node RST U V splits into\ntwo nodes containing RS and U V , the key T moves up to the root, and Q is inserted in the leftmost\nof the two halves (the RS node). (d) The result of inserting L into the previous tree. The root\nsplits right away, since it is full, and the B-tree grows in height by one. Then L is inserted into the\nleaf containing JK. (e) The result of inserting F into the previous tree. The node ABCDE splits\nbefore F is inserted into the rightmost of the two halves (the DE node).\n18.3\nDeleting a key from a B-tree\n499\n18.2-6\nSuppose that we were to implement B-TREE-SEARCH to use binary search rather\nthan linear search within each node. Show that this change makes the CPU time\nrequired O.lg n/, independently of how t might be chosen as a function of n.\n18.2-7\nSuppose that disk hardware allows us to choose the size of a disk page arbitrarily,\nbut that the time it takes to read the disk page is aCbt, where a and b are speciﬁed\nconstants and t is the minimum degree for a B-tree using pages of the selected size.\nDescribe how to choose t so as to minimize (approximately) the B-tree search time.\nSuggest an optimal value of t for the case in which a D 5 milliseconds and b D 10\nmicroseconds.\n18.3\nDeleting a key from a B-tree\nDeletion from a B-tree is analogous to insertion but a little more complicated, be-\ncause we can delete a key from any node—not just a leaf—and when we delete a",
    "parent_5057178e-b396-4523-ab00-fd58d83cf78f": "Suggest an optimal value of t for the case in which a D 5 milliseconds and b D 10\nmicroseconds.\n18.3\nDeleting a key from a B-tree\nDeletion from a B-tree is analogous to insertion but a little more complicated, be-\ncause we can delete a key from any node—not just a leaf—and when we delete a\nkey from an internal node, we will have to rearrange the node’s children. As in\ninsertion, we must guard against deletion producing a tree whose structure violates\nthe B-tree properties. Just as we had to ensure that a node didn’t get too big due to\ninsertion, we must ensure that a node doesn’t get too small during deletion (except\nthat the root is allowed to have fewer than the minimum number t \u0005 1 of keys).\nJust as a simple insertion algorithm might have to back up if a node on the path\nto where the key was to be inserted was full, a simple approach to deletion might\nhave to back up if a node (other than the root) along the path to where the key is to\nbe deleted has the minimum number of keys.\nThe procedure B-TREE-DELETE deletes the key k from the subtree rooted at x.\nWe design this procedure to guarantee that whenever it calls itself recursively on a\nnode x, the number of keys in x is at least the minimum degree t. Note that this\ncondition requires one more key than the minimum required by the usual B-tree\nconditions, so that sometimes a key may have to be moved into a child node before\nrecursion descends to that child. This strengthened condition allows us to delete a\nkey from the tree in one downward pass without having to “back up” (with one ex-\nception, which we’ll explain). You should interpret the following speciﬁcation for\ndeletion from a B-tree with the understanding that if the root node x ever becomes\nan internal node having no keys (this situation can occur in cases 2c and 3b on\npages 501–502), then we delete x, and x’s only child x:c1 becomes the new root\nof the tree, decreasing the height of the tree by one and preserving the property that",
    "parent_869b3068-94e5-41b2-b8d6-dabb85894778": "an internal node having no keys (this situation can occur in cases 2c and 3b on\npages 501–502), then we delete x, and x’s only child x:c1 becomes the new root\nof the tree, decreasing the height of the tree by one and preserving the property that\nthe root of the tree contains at least one key (unless the tree is empty).\n500\nChapter 18\nB-Trees\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nM\nG\n(a)\nC\nR\nS\nQ\nL\nP\nX\nT\nF\ninitial tree\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nM\nG\n(b)\nC\nR\nS\nQ\nL\nP\nX\nT\nF deleted: case 1\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\nG\n(c)\nC\nR\nS\nQ\nL\nP\nX\nT\nM deleted: case 2a\nJ\nK\nN O\nD\nE\nB\nA\nU\nV\nY\nZ\n(d)\nC\nR\nS\nQ\nL\nP\nX\nT\nG deleted: case 2c\nFigure 18.8\nDeleting keys from a B-tree. The minimum degree for this B-tree is t D 3, so a node\n(other than the root) cannot have fewer than 2 keys. Nodes that are modiﬁed are lightly shaded.\n(a) The B-tree of Figure 18.7(e). (b) Deletion of F . This is case 1: simple deletion from a leaf.\n(c) Deletion of M. This is case 2a: the predecessor L of M moves up to take M’s position. (d) Dele-\ntion of G. This is case 2c: we push G down to make node DEGJK and then delete G from this leaf\n(case 1).\nWe sketch how deletion works instead of presenting the pseudocode. Figure 18.8\nillustrates the various cases of deleting keys from a B-tree.\n1. If the key k is in node x and x is a leaf, delete the key k from x.\n2. If the key k is in node x and x is an internal node, do the following:\n18.3\nDeleting a key from a B-tree\n501\nJ\nK\nN O\nE\nB\nA\nU\nV\nY\nZ\n(e)\nC\nR\nS\nQ\nL\nP\nX\nT\nD deleted: case 3b\nJ\nK\nN O\nE\nB\nA\nU\nV\nY\nZ\nC\nR\nS\nQ\nL\nP\nX\nT\nJ\nK\nN O\nA\nU\nV\nY\nZ\nC\nR\nS\nQ\nL\nP\nX\nT\n(f)\nB deleted: case 3a\nE\n(e′) tree shrinks\nin height\nFigure 18.8, continued\n(e) Deletion of D.\nThis is case 3b: the recursion cannot descend to\nnode CL because it has only 2 keys, so we push P down and merge it with CL and TX to form\nCLP TX; then we delete D from a leaf (case 1). (e0) After (e), we delete the root and the tree shrinks\nin height by one. (f) Deletion of B. This is case 3a: C moves to ﬁll B’s position and E moves to",
    "parent_ddc26fca-88b2-4dc0-a13c-24cc0712ee63": "node CL because it has only 2 keys, so we push P down and merge it with CL and TX to form\nCLP TX; then we delete D from a leaf (case 1). (e0) After (e), we delete the root and the tree shrinks\nin height by one. (f) Deletion of B. This is case 3a: C moves to ﬁll B’s position and E moves to\nﬁll C’s position.\na. If the child y that precedes k in node x has at least t keys, then ﬁnd the\npredecessor k0 of k in the subtree rooted at y. Recursively delete k0, and\nreplace k by k0 in x. (We can ﬁnd k0 and delete it in a single downward\npass.)\nb. If y has fewer than t keys, then, symmetrically, examine the child ´ that\nfollows k in node x. If ´ has at least t keys, then ﬁnd the successor k0 of k in\nthe subtree rooted at ´. Recursively delete k0, and replace k by k0 in x. (We\ncan ﬁnd k0 and delete it in a single downward pass.)\nc. Otherwise, if both y and ´ have only t \u0005 1 keys, merge k and all of ´ into y,\nso that x loses both k and the pointer to ´, and y now contains 2t \u0005 1 keys.\nThen free ´ and recursively delete k from y.\n3. If the key k is not present in internal node x, determine the root x:ci of the\nappropriate subtree that must contain k, if k is in the tree at all. If x:ci has\nonly t \u00051 keys, execute step 3a or 3b as necessary to guarantee that we descend\nto a node containing at least t keys. Then ﬁnish by recursing on the appropriate\nchild of x.\n502\nChapter 18\nB-Trees\na. If x:ci has only t \u0005 1 keys but has an immediate sibling with at least t keys,\ngive x:ci an extra key by moving a key from x down into x:ci, moving a\nkey from x:ci’s immediate left or right sibling up into x, and moving the\nappropriate child pointer from the sibling into x:ci.\nb. If x:ci and both of x:ci’s immediate siblings have t \u0005 1 keys, merge x:ci\nwith one sibling, which involves moving a key from x down into the new\nmerged node to become the median key for that node.\nSince most of the keys in a B-tree are in the leaves, we may expect that in",
    "parent_568116a8-3798-461f-b548-31cd66f3d629": "b. If x:ci and both of x:ci’s immediate siblings have t \u0005 1 keys, merge x:ci\nwith one sibling, which involves moving a key from x down into the new\nmerged node to become the median key for that node.\nSince most of the keys in a B-tree are in the leaves, we may expect that in\npractice, deletion operations are most often used to delete keys from leaves. The\nB-TREE-DELETE procedure then acts in one downward pass through the tree,\nwithout having to back up. When deleting a key in an internal node, however,\nthe procedure makes a downward pass through the tree but may have to return to\nthe node from which the key was deleted to replace the key with its predecessor or\nsuccessor (cases 2a and 2b).\nAlthough this procedure seems complicated, it involves only O.h/ disk oper-\nations for a B-tree of height h, since only O.1/ calls to DISK-READ and DISK-\nWRITE are made between recursive invocations of the procedure. The CPU time\nrequired is O.th/ D O.t logt n/.\nExercises\n18.3-1\nShow the results of deleting C, P , and V , in order, from the tree of Figure 18.8(f).\n18.3-2\nWrite pseudocode for B-TREE-DELETE.\nProblems\n18-1\nStacks on secondary storage\nConsider implementing a stack in a computer that has a relatively small amount\nof fast primary memory and a relatively large amount of slower disk storage. The\noperations PUSH and POP work on single-word values. The stack we wish to\nsupport can grow to be much larger than can ﬁt in memory, and thus most of it\nmust be stored on disk.\nA simple, but inefﬁcient, stack implementation keeps the entire stack on disk.\nWe maintain in memory a stack pointer, which is the disk address of the top element\non the stack. If the pointer has value p, the top element is the .p mod m/th word\non page bp=mc of the disk, where m is the number of words per page.\nProblems for Chapter 18\n503\nTo implement the PUSH operation, we increment the stack pointer, read the ap-\npropriate page into memory from disk, copy the element to be pushed to the ap-",
    "parent_0c6c149b-6439-481e-9e01-43de61407252": "on page bp=mc of the disk, where m is the number of words per page.\nProblems for Chapter 18\n503\nTo implement the PUSH operation, we increment the stack pointer, read the ap-\npropriate page into memory from disk, copy the element to be pushed to the ap-\npropriate word on the page, and write the page back to disk. A POP operation is\nsimilar. We decrement the stack pointer, read in the appropriate page from disk,\nand return the top of the stack. We need not write back the page, since it was not\nmodiﬁed.\nBecause disk operations are relatively expensive, we count two costs for any\nimplementation: the total number of disk accesses and the total CPU time. Any\ndisk access to a page of m words incurs charges of one disk access and ‚.m/ CPU\ntime.\na. Asymptotically, what is the worst-case number of disk accesses for n stack\noperations using this simple implementation? What is the CPU time for n stack\noperations? (Express your answer in terms of m and n for this and subsequent\nparts.)\nNow consider a stack implementation in which we keep one page of the stack in\nmemory. (We also maintain a small amount of memory to keep track of which page\nis currently in memory.) We can perform a stack operation only if the relevant disk\npage resides in memory. If necessary, we can write the page currently in memory\nto the disk and read in the new page from the disk to memory. If the relevant disk\npage is already in memory, then no disk accesses are required.\nb. What is the worst-case number of disk accesses required for n PUSH opera-\ntions? What is the CPU time?\nc. What is the worst-case number of disk accesses required for n stack operations?\nWhat is the CPU time?\nSuppose that we now implement the stack by keeping two pages in memory (in\naddition to a small number of words for bookkeeping).\nd. Describe how to manage the stack pages so that the amortized number of disk\naccesses for any stack operation is O.1=m/ and the amortized CPU time for\nany stack operation is O.1/.\n18-2",
    "parent_fb5dba7d-0aad-4dd6-9966-7f71d1a40e0f": "addition to a small number of words for bookkeeping).\nd. Describe how to manage the stack pages so that the amortized number of disk\naccesses for any stack operation is O.1=m/ and the amortized CPU time for\nany stack operation is O.1/.\n18-2\nJoining and splitting 2-3-4 trees\nThe join operation takes two dynamic sets S 0 and S 00 and an element x such that\nfor any x0 2 S 0 and x00 2 S 00, we have x0:key < x:key < x00:key. It returns a set\nS D S 0 [ fxg [ S 00. The split operation is like an “inverse” join: given a dynamic\nset S and an element x 2 S, it creates a set S0 that consists of all elements in\nS \u0005 fxg whose keys are less than x:key and a set S 00 that consists of all elements\nin S \u0005 fxg whose keys are greater than x:key. In this problem, we investigate\n504\nChapter 18\nB-Trees\nhow to implement these operations on 2-3-4 trees. We assume for convenience that\nelements consist only of keys and that all key values are distinct.\na. Show how to maintain, for every node x of a 2-3-4 tree, the height of the subtree\nrooted at x as an attribute x:height. Make sure that your implementation does\nnot affect the asymptotic running times of searching, insertion, and deletion.\nb. Show how to implement the join operation. Given two 2-3-4 trees T 0 and T 00\nand a key k, the join operation should run in O.1 C jh0 \u0005 h00j/ time, where h0\nand h00 are the heights of T 0 and T 00, respectively.\nc. Consider the simple path p from the root of a 2-3-4 tree T to a given key k,\nthe set S 0 of keys in T that are less than k, and the set S 00 of keys in T that are\ngreater than k. Show that p breaks S 0 into a set of trees fT 0\n0; T 0\n1; : : : ; T 0\nmg and a\nset of keys fk0\n1; k0\n2; : : : ; k0\nmg, where, for i D 1; 2; : : : ; m, we have y < k0\ni < ´\nfor any keys y 2 T 0\ni\u00031 and ´ 2 T 0\ni . What is the relationship between the heights\nof T 0\ni\u00031 and T 0\ni ? Describe how p breaks S 00 into sets of trees and keys.\nd. Show how to implement the split operation on T . Use the join operation to",
    "parent_476d3638-2fc9-4d59-bd9a-d7afe7b8262b": "mg, where, for i D 1; 2; : : : ; m, we have y < k0\ni < ´\nfor any keys y 2 T 0\ni\u00031 and ´ 2 T 0\ni . What is the relationship between the heights\nof T 0\ni\u00031 and T 0\ni ? Describe how p breaks S 00 into sets of trees and keys.\nd. Show how to implement the split operation on T . Use the join operation to\nassemble the keys in S 0 into a single 2-3-4 tree T 0 and the keys in S 00 into a\nsingle 2-3-4 tree T 00. The running time of the split operation should be O.lg n/,\nwhere n is the number of keys in T . (Hint: The costs for joining should tele-\nscope.)\nChapter notes\nKnuth [211], Aho, Hopcroft, and Ullman [5], and Sedgewick [306] give further\ndiscussions of balanced-tree schemes and B-trees. Comer [74] provides a compre-\nhensive survey of B-trees. Guibas and Sedgewick [155] discuss the relationships\namong various kinds of balanced-tree schemes, including red-black trees and 2-3-4\ntrees.\nIn 1970, J. E. Hopcroft invented 2-3 trees, a precursor to B-trees and 2-3-4\ntrees, in which every internal node has either two or three children. Bayer and\nMcCreight [35] introduced B-trees in 1972; they did not explain their choice of\nname.\nBender, Demaine, and Farach-Colton [40] studied how to make B-trees perform\nwell in the presence of memory-hierarchy effects. Their cache-oblivious algo-\nrithms work efﬁciently without explicitly knowing the data transfer sizes within\nthe memory hierarchy.\n19\nFibonacci Heaps\nThe Fibonacci heap data structure serves a dual purpose. First, it supports a set of\noperations that constitutes what is known as a “mergeable heap.” Second, several\nFibonacci-heap operations run in constant amortized time, which makes this data\nstructure well suited for applications that invoke these operations frequently.\nMergeable heaps\nA mergeable heap is any data structure that supports the following ﬁve operations,\nin which each element has a key:\nMAKE-HEAP./ creates and returns a new heap containing no elements.",
    "parent_1d142a8f-00ad-428f-99be-2c31d646790d": "structure well suited for applications that invoke these operations frequently.\nMergeable heaps\nA mergeable heap is any data structure that supports the following ﬁve operations,\nin which each element has a key:\nMAKE-HEAP./ creates and returns a new heap containing no elements.\nINSERT.H; x/ inserts element x, whose key has already been ﬁlled in, into heap H.\nMINIMUM.H/ returns a pointer to the element in heap H whose key is minimum.\nEXTRACT-MIN.H/ deletes the element from heap H whose key is minimum, re-\nturning a pointer to the element.\nUNION.H1; H2/ creates and returns a new heap that contains all the elements of\nheaps H1 and H2. Heaps H1 and H2 are “destroyed” by this operation.\nIn addition to the mergeable-heap operations above, Fibonacci heaps also support\nthe following two operations:\nDECREASE-KEY.H; x; k/ assigns to element x within heap H the new key\nvalue k, which we assume to be no greater than its current key value.1\nDELETE.H; x/ deletes element x from heap H.\n1As mentioned in the introduction to Part V, our default mergeable heaps are mergeable min-\nheaps, and so the operations MINIMUM, EXTRACT-MIN, and DECREASE-KEY apply. Alterna-\ntively, we could deﬁne a mergeable max-heap with the operations MAXIMUM, EXTRACT-MAX,\nand INCREASE-KEY.\n506\nChapter 19\nFibonacci Heaps\nBinary heap\nFibonacci heap\nProcedure\n(worst-case)\n(amortized)\nMAKE-HEAP\n‚.1/\n‚.1/\nINSERT\n‚.lg n/\n‚.1/\nMINIMUM\n‚.1/\n‚.1/\nEXTRACT-MIN\n‚.lg n/\nO.lg n/\nUNION\n‚.n/\n‚.1/\nDECREASE-KEY\n‚.lg n/\n‚.1/\nDELETE\n‚.lg n/\nO.lg n/\nFigure 19.1\nRunning times for operations on two implementations of mergeable heaps. The num-\nber of items in the heap(s) at the time of an operation is denoted by n.\nAs the table in Figure 19.1 shows, if we don’t need the UNION operation, ordi-\nnary binary heaps, as used in heapsort (Chapter 6), work fairly well. Operations\nother than UNION run in worst-case time O.lg n/ on a binary heap. If we need\nto support the UNION operation, however, binary heaps perform poorly. By con-",
    "parent_062219b8-46e4-4ec0-9eb3-035299b4d11f": "nary binary heaps, as used in heapsort (Chapter 6), work fairly well. Operations\nother than UNION run in worst-case time O.lg n/ on a binary heap. If we need\nto support the UNION operation, however, binary heaps perform poorly. By con-\ncatenating the two arrays that hold the binary heaps to be merged and then running\nBUILD-MIN-HEAP (see Section 6.3), the UNION operation takes ‚.n/ time in the\nworst case.\nFibonacci heaps, on the other hand, have better asymptotic time bounds than\nbinary heaps for the INSERT, UNION, and DECREASE-KEY operations, and they\nhave the same asymptotic running times for the remaining operations. Note, how-\never, that the running times for Fibonacci heaps in Figure 19.1 are amortized time\nbounds, not worst-case per-operation time bounds. The UNION operation takes\nonly constant amortized time in a Fibonacci heap, which is signiﬁcantly better\nthan the linear worst-case time required in a binary heap (assuming, of course, that\nan amortized time bound sufﬁces).\nFibonacci heaps in theory and practice\nFrom a theoretical standpoint, Fibonacci heaps are especially desirable when the\nnumber of EXTRACT-MIN and DELETE operations is small relative to the number\nof other operations performed. This situation arises in many applications. For\nexample, some algorithms for graph problems may call DECREASE-KEY once per\nedge. For dense graphs, which have many edges, the ‚.1/ amortized time of each\ncall of DECREASE-KEY adds up to a big improvement over the ‚.lg n/ worst-case\ntime of binary heaps. Fast algorithms for problems such as computing minimum\nspanning trees (Chapter 23) and ﬁnding single-source shortest paths (Chapter 24)\nmake essential use of Fibonacci heaps.\n19.1\nStructure of Fibonacci heaps\n507\nFrom a practical point of view, however, the constant factors and program-\nming complexity of Fibonacci heaps make them less desirable than ordinary binary\n(or k-ary) heaps for most applications, except for certain applications that manage",
    "parent_6b447b0e-5917-4770-9e02-e74fd73414ec": "19.1\nStructure of Fibonacci heaps\n507\nFrom a practical point of view, however, the constant factors and program-\nming complexity of Fibonacci heaps make them less desirable than ordinary binary\n(or k-ary) heaps for most applications, except for certain applications that manage\nlarge amounts of data. Thus, Fibonacci heaps are predominantly of theoretical in-\nterest. If a much simpler data structure with the same amortized time bounds as\nFibonacci heaps were developed, it would be of practical use as well.\nBoth binary heaps and Fibonacci heaps are inefﬁcient in how they support the\noperation SEARCH; it can take a while to ﬁnd an element with a given key. For this\nreason, operations such as DECREASE-KEY and DELETE that refer to a given ele-\nment require a pointer to that element as part of their input. As in our discussion of\npriority queues in Section 6.5, when we use a mergeable heap in an application, we\noften store a handle to the corresponding application object in each mergeable-heap\nelement, as well as a handle to the corresponding mergeable-heap element in each\napplication object. The exact nature of these handles depends on the application\nand its implementation.\nLike several other data structures that we have seen, Fibonacci heaps are based\non rooted trees. We represent each element by a node within a tree, and each\nnode has a key attribute. For the remainder of this chapter, we shall use the term\n“node” instead of “element.” We shall also ignore issues of allocating nodes prior\nto insertion and freeing nodes following deletion, assuming instead that the code\ncalling the heap procedures deals with these details.\nSection 19.1 deﬁnes Fibonacci heaps, discusses how we represent them, and\npresents the potential function used for their amortized analysis.\nSection 19.2\nshows how to implement the mergeable-heap operations and achieve the amortized\ntime bounds shown in Figure 19.1. The remaining two operations, DECREASE-",
    "parent_4655fd13-96af-4196-97d7-036c433e28f3": "presents the potential function used for their amortized analysis.\nSection 19.2\nshows how to implement the mergeable-heap operations and achieve the amortized\ntime bounds shown in Figure 19.1. The remaining two operations, DECREASE-\nKEY and DELETE, form the focus of Section 19.3. Finally, Section 19.4 ﬁnishes a\nkey part of the analysis and also explains the curious name of the data structure.\n19.1\nStructure of Fibonacci heaps\nA Fibonacci heap is a collection of rooted trees that are min-heap ordered. That\nis, each tree obeys the min-heap property: the key of a node is greater than or equal\nto the key of its parent. Figure 19.2(a) shows an example of a Fibonacci heap.\nAs Figure 19.2(b) shows, each node x contains a pointer x:p to its parent and\na pointer x:child to any one of its children. The children of x are linked together\nin a circular, doubly linked list, which we call the child list of x. Each child y in\na child list has pointers y:left and y:right that point to y’s left and right siblings,\nrespectively. If node y is an only child, then y:left D y:right D y. Siblings may\nappear in a child list in any order.\n508\nChapter 19\nFibonacci Heaps\n17\n30\n26\n46\n35\n24\n18\n52\n38\n3\n39\n41\n23\n7\n17\n30\n26\n46\n35\n24\n18\n52\n38\n3\n39\n41\n23\n7\n(a)\n(b)\nH:min\nH:min\nFigure 19.2\n(a) A Fibonacci heap consisting of ﬁve min-heap-ordered trees and 14 nodes. The\ndashed line indicates the root list. The minimum node of the heap is the node containing the key 3.\nBlack nodes are marked. The potential of this particular Fibonacci heap is 5C2\u00033 D 11. (b) A more\ncomplete representation showing pointers p (up arrows), child (down arrows), and left and right\n(sideways arrows). The remaining ﬁgures in this chapter omit these details, since all the information\nshown here can be determined from what appears in part (a).\nCircular, doubly linked lists (see Section 10.2) have two advantages for use in\nFibonacci heaps. First, we can insert a node into any location or remove a node",
    "parent_edd19c2f-c4bd-40fd-9024-fa3c1488f2ad": "shown here can be determined from what appears in part (a).\nCircular, doubly linked lists (see Section 10.2) have two advantages for use in\nFibonacci heaps. First, we can insert a node into any location or remove a node\nfrom anywhere in a circular, doubly linked list in O.1/ time. Second, given two\nsuch lists, we can concatenate them (or “splice” them together) into one circular,\ndoubly linked list in O.1/ time. In the descriptions of Fibonacci heap operations,\nwe shall refer to these operations informally, letting you ﬁll in the details of their\nimplementations if you wish.\nEach node has two other attributes. We store the number of children in the child\nlist of node x in x:degree. The boolean-valued attribute x:mark indicates whether\nnode x has lost a child since the last time x was made the child of another node.\nNewly created nodes are unmarked, and a node x becomes unmarked whenever it\nis made the child of another node. Until we look at the DECREASE-KEY operation\nin Section 19.3, we will just set all mark attributes to FALSE.\nWe access a given Fibonacci heap H by a pointer H:min to the root of a tree\ncontaining the minimum key; we call this node the minimum node of the Fibonacci\n19.1\nStructure of Fibonacci heaps\n509\nheap. If more than one root has a key with the minimum value, then any such root\nmay serve as the minimum node. When a Fibonacci heap H is empty, H:min\nis NIL.\nThe roots of all the trees in a Fibonacci heap are linked together using their\nleft and right pointers into a circular, doubly linked list called the root list of the\nFibonacci heap. The pointer H:min thus points to the node in the root list whose\nkey is minimum. Trees may appear in any order within a root list.\nWe rely on one other attribute for a Fibonacci heap H: H:n, the number of\nnodes currently in H.\nPotential function\nAs mentioned, we shall use the potential method of Section 17.3 to analyze the\nperformance of Fibonacci heap operations. For a given Fibonacci heap H, we",
    "parent_da0f58a7-7a0b-42d1-ac28-718ab6be2955": "We rely on one other attribute for a Fibonacci heap H: H:n, the number of\nnodes currently in H.\nPotential function\nAs mentioned, we shall use the potential method of Section 17.3 to analyze the\nperformance of Fibonacci heap operations. For a given Fibonacci heap H, we\nindicate by t.H/ the number of trees in the root list of H and by m.H/ the number\nof marked nodes in H. We then deﬁne the potential ˆ.H/ of Fibonacci heap H\nby\nˆ.H/ D t.H/ C 2 m.H/ :\n(19.1)\n(We will gain some intuition for this potential function in Section 19.3.) For exam-\nple, the potential of the Fibonacci heap shown in Figure 19.2 is 5C2\u00033 D 11. The\npotential of a set of Fibonacci heaps is the sum of the potentials of its constituent\nFibonacci heaps. We shall assume that a unit of potential can pay for a constant\namount of work, where the constant is sufﬁciently large to cover the cost of any of\nthe speciﬁc constant-time pieces of work that we might encounter.\nWe assume that a Fibonacci heap application begins with no heaps. The initial\npotential, therefore, is 0, and by equation (19.1), the potential is nonnegative at\nall subsequent times. From equation (17.3), an upper bound on the total amortized\ncost provides an upper bound on the total actual cost for the sequence of operations.\nMaximum degree\nThe amortized analyses we shall perform in the remaining sections of this chapter\nassume that we know an upper bound D.n/ on the maximum degree of any node\nin an n-node Fibonacci heap. We won’t prove it, but when only the mergeable-\nheap operations are supported, D.n/ \u0002 blg nc. (Problem 19-2(d) asks you to prove\nthis property.) In Sections 19.3 and 19.4, we shall show that when we support\nDECREASE-KEY and DELETE as well, D.n/ D O.lg n/.\n510\nChapter 19\nFibonacci Heaps\n19.2\nMergeable-heap operations\nThe mergeable-heap operations on Fibonacci heaps delay work as long as possible.\nThe various operations have performance trade-offs. For example, we insert a node",
    "parent_20089963-374f-44f0-94ee-67f2eba8daa8": "DECREASE-KEY and DELETE as well, D.n/ D O.lg n/.\n510\nChapter 19\nFibonacci Heaps\n19.2\nMergeable-heap operations\nThe mergeable-heap operations on Fibonacci heaps delay work as long as possible.\nThe various operations have performance trade-offs. For example, we insert a node\nby adding it to the root list, which takes just constant time. If we were to start\nwith an empty Fibonacci heap and then insert k nodes, the Fibonacci heap would\nconsist of just a root list of k nodes. The trade-off is that if we then perform\nan EXTRACT-MIN operation on Fibonacci heap H, after removing the node that\nH:min points to, we would have to look through each of the remaining k \u00051 nodes\nin the root list to ﬁnd the new minimum node. As long as we have to go through\nthe entire root list during the EXTRACT-MIN operation, we also consolidate nodes\ninto min-heap-ordered trees to reduce the size of the root list. We shall see that, no\nmatter what the root list looks like before a EXTRACT-MIN operation, afterward\neach node in the root list has a degree that is unique within the root list, which leads\nto a root list of size at most D.n/ C 1.\nCreating a new Fibonacci heap\nTo make an empty Fibonacci heap, the MAKE-FIB-HEAP procedure allocates and\nreturns the Fibonacci heap object H, where H:n D 0 and H:min D NIL; there\nare no trees in H. Because t.H/ D 0 and m.H/ D 0, the potential of the empty\nFibonacci heap is ˆ.H/ D 0. The amortized cost of MAKE-FIB-HEAP is thus\nequal to its O.1/ actual cost.\nInserting a node\nThe following procedure inserts node x into Fibonacci heap H, assuming that the\nnode has already been allocated and that x:key has already been ﬁlled in.\nFIB-HEAP-INSERT.H; x/\n1\nx:degree D 0\n2\nx:p D NIL\n3\nx:child D NIL\n4\nx:mark D FALSE\n5\nif H:min == NIL\n6\ncreate a root list for H containing just x\n7\nH:min D x\n8\nelse insert x into H’s root list\n9\nif x:key < H:min:key\n10\nH:min D x\n11\nn D\nn C 1\nH:\nH:\n19.2\nMergeable-heap operations\n511\n(a)\n(b)\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n3\n17\n30\n24",
    "parent_88c903d7-66ec-4272-b5cf-4d1cd3a3d3b8": "3\nx:child D NIL\n4\nx:mark D FALSE\n5\nif H:min == NIL\n6\ncreate a root list for H containing just x\n7\nH:min D x\n8\nelse insert x into H’s root list\n9\nif x:key < H:min:key\n10\nH:min D x\n11\nn D\nn C 1\nH:\nH:\n19.2\nMergeable-heap operations\n511\n(a)\n(b)\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n3\n17\n30\n24\n23\n26\n35\n46\n7\n18\n52\n38\n39\n41\n3\nH:min\nH:min\nFigure 19.3\nInserting a node into a Fibonacci heap. (a) A Fibonacci heap H. (b) Fibonacci heap H\nafter inserting the node with key 21. The node becomes its own min-heap-ordered tree and is then\nadded to the root list, becoming the left sibling of the root.\nLines 1–4 initialize some of the structural attributes of node x. Line 5 tests to see\nwhether Fibonacci heap H is empty. If it is, then lines 6–7 make x be the only\nnode in H’s root list and set H:min to point to x. Otherwise, lines 8–10 insert x\ninto H’s root list and update H:min if necessary. Finally, line 11 increments H:n\nto reﬂect the addition of the new node. Figure 19.3 shows a node with key 21\ninserted into the Fibonacci heap of Figure 19.2.\nTo determine the amortized cost of FIB-HEAP-INSERT, let H be the input Fi-\nbonacci heap and H 0 be the resulting Fibonacci heap. Then, t.H 0/ D t.H/ C 1\nand m.H 0/ D m.H/, and the increase in potential is\n..t.H/ C 1/ C 2 m.H// \u0005 .t.H/ C 2 m.H// D 1 :\nSince the actual cost is O.1/, the amortized cost is O.1/ C 1 D O.1/.\nFinding the minimum node\nThe minimum node of a Fibonacci heap H is given by the pointer H:min, so we\ncan ﬁnd the minimum node in O.1/ actual time. Because the potential of H does\nnot change, the amortized cost of this operation is equal to its O.1/ actual cost.\nUniting two Fibonacci heaps\nThe following procedure unites Fibonacci heaps H1 and H2, destroying H1 and H2\nin the process. It simply concatenates the root lists of H1 and H2 and then deter-\nmines the new minimum node. Afterward, the objects representing H1 and H2 will\nnever be used again.\n512\nChapter 19\nFibonacci Heaps\nFIB-HEAP-UNION.H1; H2/\n1\nH D MAKE-FIB-HEAP./\n2",
    "parent_fd937b6c-be1d-4af4-80d8-a104e3b25baf": "in the process. It simply concatenates the root lists of H1 and H2 and then deter-\nmines the new minimum node. Afterward, the objects representing H1 and H2 will\nnever be used again.\n512\nChapter 19\nFibonacci Heaps\nFIB-HEAP-UNION.H1; H2/\n1\nH D MAKE-FIB-HEAP./\n2\nH:min D H1:min\n3\nconcatenate the root list of H2 with the root list of H\n4\nif .H1:min == NIL/ or .H2:min ¤ NIL and H2:min:key < H1:min:key/\n5\nH:min D H2:min\n6\nH:n D H1:n C H2:n\n7\nreturn H\nLines 1–3 concatenate the root lists of H1 and H2 into a new root list H. Lines\n2, 4, and 5 set the minimum node of H, and line 6 sets H:n to the total number\nof nodes. Line 7 returns the resulting Fibonacci heap H. As in the FIB-HEAP-\nINSERT procedure, all roots remain roots.\nThe change in potential is\nˆ.H/ \u0005 .ˆ.H1/ C ˆ.H2//\nD\n.t.H/ C 2 m.H// \u0005 ..t.H1/ C 2 m.H1// C .t.H2/ C 2 m.H2///\nD\n0 ;\nbecause t.H/ D t.H1/ C t.H2/ and m.H/ D m.H1/ C m.H2/. The amortized\ncost of FIB-HEAP-UNION is therefore equal to its O.1/ actual cost.\nExtracting the minimum node\nThe process of extracting the minimum node is the most complicated of the oper-\nations presented in this section. It is also where the delayed work of consolidating\ntrees in the root list ﬁnally occurs. The following pseudocode extracts the mini-\nmum node. The code assumes for convenience that when a node is removed from\na linked list, pointers remaining in the list are updated, but pointers in the extracted\nnode are left unchanged.\nIt also calls the auxiliary procedure CONSOLIDATE,\nwhich we shall see shortly.\n19.2\nMergeable-heap operations\n513\nFIB-HEAP-EXTRACT-MIN.H/\n1\n´ D H:min\n2\nif ´ ¤ NIL\n3\nfor each child x of ´\n4\nadd x to the root list of H\n5\nx:p D NIL\n6\nremove ´ from the root list of H\n7\nif ´ == ´:right\n8\nH:min D NIL\n9\nelse H:min D ´:right\n10\nCONSOLIDATE.H/\n11\nH:n D H:n \u0005 1\n12\nreturn ´\nAs Figure 19.4 illustrates, FIB-HEAP-EXTRACT-MIN works by ﬁrst making a root\nout of each of the minimum node’s children and removing the minimum node from",
    "parent_57f26561-4a80-4b46-9610-e3b40f0a7d0e": "6\nremove ´ from the root list of H\n7\nif ´ == ´:right\n8\nH:min D NIL\n9\nelse H:min D ´:right\n10\nCONSOLIDATE.H/\n11\nH:n D H:n \u0005 1\n12\nreturn ´\nAs Figure 19.4 illustrates, FIB-HEAP-EXTRACT-MIN works by ﬁrst making a root\nout of each of the minimum node’s children and removing the minimum node from\nthe root list. It then consolidates the root list by linking roots of equal degree until\nat most one root remains of each degree.\nWe start in line 1 by saving a pointer ´ to the minimum node; the procedure\nreturns this pointer at the end. If ´ is NIL, then Fibonacci heap H is already empty\nand we are done. Otherwise, we delete node ´ from H by making all of ´’s chil-\ndren roots of H in lines 3–5 (putting them into the root list) and removing ´ from\nthe root list in line 6. If ´ is its own right sibling after line 6, then ´ was the\nonly node on the root list and it had no children, so all that remains is to make\nthe Fibonacci heap empty in line 8 before returning ´. Otherwise, we set the\npointer H:min into the root list to point to a root other than ´ (in this case, ´’s\nright sibling), which is not necessarily going to be the new minimum node when\nFIB-HEAP-EXTRACT-MIN is done. Figure 19.4(b) shows the Fibonacci heap of\nFigure 19.4(a) after executing line 9.\nThe next step, in which we reduce the number of trees in the Fibonacci heap, is\nconsolidating the root list of H, which the call CONSOLIDATE.H/ accomplishes.\nConsolidating the root list consists of repeatedly executing the following steps until\nevery root in the root list has a distinct degree value:\n1. Find two roots x and y in the root list with the same degree. Without loss of\ngenerality, let x:key \u0002 y:key.\n2. Link y to x: remove y from the root list, and make y a child of x by calling the\nFIB-HEAP-LINK procedure. This procedure increments the attribute x:degree\nand clears the mark on y.\n514\nChapter 19\nFibonacci Heaps\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\n(c)\n(d)\n(e)\n17\n30\n24\n23\n26\n35\n46\n7\n17\n30\n24\n23",
    "parent_062ad7dc-aa53-45d8-8069-73e56cf77be4": "FIB-HEAP-LINK procedure. This procedure increments the attribute x:degree\nand clears the mark on y.\n514\nChapter 19\nFibonacci Heaps\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\n(c)\n(d)\n(e)\n17\n30\n24\n23\n26\n35\n46\n7\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n(a)\n3\n(b)\n(f)\n(g)\n21\n18\n52\n38\n39\n41\n(h)\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\nw,x\nw,x\nw,x\nw,x\nw,x\nw,x\nH:min\nH:min\nFigure 19.4\nThe action of FIB-HEAP-EXTRACT-MIN. (a) A Fibonacci heap H. (b) The situa-\ntion after removing the minimum node ´ from the root list and adding its children to the root list.\n(c)–(e) The array A and the trees after each of the ﬁrst three iterations of the for loop of lines 4–14 of\nthe procedure CONSOLIDATE. The procedure processes the root list by starting at the node pointed\nto by H:min and following right pointers. Each part shows the values of w and x at the end of an\niteration. (f)–(h) The next iteration of the for loop, with the values of w and x shown at the end of\neach iteration of the while loop of lines 7–13. Part (f) shows the situation after the ﬁrst time through\nthe while loop. The node with key 23 has been linked to the node with key 7, which x now points to.\nIn part (g), the node with key 17 has been linked to the node with key 7, which x still points to. In\npart (h), the node with key 24 has been linked to the node with key 7. Since no node was previously\npointed to by AŒ3\u0002, at the end of the for loop iteration, AŒ3\u0002 is set to point to the root of the resulting\ntree.\n19.2\nMergeable-heap operations\n515\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n(i)\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n(j)\n17\n30\n24\n23\n26\n35\n46\n7\n38\n41\n(k)\n21\n18\n52\n39\n17\n30\n24\n23\n26\n35\n46\n7\n38\n41\n(l)\n21\n18\n52\n39\n17\n30\n24\n23\n26\n35\n46\n7\n38\n41\n(m)\n21\n18\n52\n39",
    "parent_d49f5756-4ba8-4aea-a39e-9323a43ea26b": "19.2\nMergeable-heap operations\n515\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\nA\n0 1 2 3\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n(i)\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n(j)\n17\n30\n24\n23\n26\n35\n46\n7\n38\n41\n(k)\n21\n18\n52\n39\n17\n30\n24\n23\n26\n35\n46\n7\n38\n41\n(l)\n21\n18\n52\n39\n17\n30\n24\n23\n26\n35\n46\n7\n38\n41\n(m)\n21\n18\n52\n39\nw,x\nw,x\nx\nw,x\nw\nH:min\nFigure 19.4, continued\n(i)–(l) The situation after each of the next four iterations of the for loop.\n(m) Fibonacci heap H after reconstructing the root list from the array A and determining the new\nH:min pointer.\nThe procedure CONSOLIDATE uses an auxiliary array AŒ0 : : D.H:n/\u0002 to keep\ntrack of roots according to their degrees. If AŒi\u0002 D y, then y is currently a root\nwith y:degree D i. Of course, in order to allocate the array we have to know how\nto calculate the upper bound D.H:n/ on the maximum degree, but we will see how\nto do so in Section 19.4.\n516\nChapter 19\nFibonacci Heaps\nCONSOLIDATE.H/\n1\nlet AŒ0 : : D.H:n/\u0002 be a new array\n2\nfor i D 0 to D.H:n/\n3\nAŒi\u0002 D NIL\n4\nfor each node w in the root list of H\n5\nx D w\n6\nd D x:degree\n7\nwhile AŒd\u0002 ¤ NIL\n8\ny D AŒd\u0002\n// another node with the same degree as x\n9\nif x:key > y:key\n10\nexchange x with y\n11\nFIB-HEAP-LINK.H; y; x/\n12\nAŒd\u0002 D NIL\n13\nd D d C 1\n14\nAŒd\u0002 D x\n15\nH:min D NIL\n16\nfor i D 0 to D.H:n/\n17\nif AŒi\u0002 ¤ NIL\n18\nif H:min == NIL\n19\ncreate a root list for H containing just AŒi\u0002\n20\nH:min D AŒi\u0002\n21\nelse insert AŒi\u0002 into H’s root list\n22\nif AŒi\u0002:key < H:min:key\n23\nH:min D AŒi\u0002\nFIB-HEAP-LINK.H; y; x/\n1\nremove y from the root list of H\n2\nmake y a child of x, incrementing x:degree\n3\ny:mark D FALSE\nIn detail, the CONSOLIDATE procedure works as follows. Lines 1–3 allocate\nand initialize the array A by making each entry NIL. The for loop of lines 4–14\nprocesses each root w in the root list. As we link roots together, w may be linked\nto some other node and no longer be a root. Nevertheless, w is always in a tree\nrooted at some node x, which may or may not be w itself. Because we want at",
    "parent_7791e202-b3db-4f4c-be59-e0f093f65f10": "processes each root w in the root list. As we link roots together, w may be linked\nto some other node and no longer be a root. Nevertheless, w is always in a tree\nrooted at some node x, which may or may not be w itself. Because we want at\nmost one root with each degree, we look in the array A to see whether it contains\na root y with the same degree as x. If it does, then we link the roots x and y but\nguaranteeing that x remains a root after linking. That is, we link y to x after ﬁrst\nexchanging the pointers to the two roots if y’s key is smaller than x’s key. After\nwe link y to x, the degree of x has increased by 1, and so we continue this process,\nlinking x and another root whose degree equals x’s new degree, until no other root\n19.2\nMergeable-heap operations\n517\nthat we have processed has the same degree as x. We then set the appropriate entry\nof A to point to x, so that as we process roots later on, we have recorded that x is\nthe unique root of its degree that we have already processed. When this for loop\nterminates, at most one root of each degree will remain, and the array A will point\nto each remaining root.\nThe while loop of lines 7–13 repeatedly links the root x of the tree containing\nnode w to another tree whose root has the same degree as x, until no other root has\nthe same degree. This while loop maintains the following invariant:\nAt the start of each iteration of the while loop, d D x:degree.\nWe use this loop invariant as follows:\nInitialization: Line 6 ensures that the loop invariant holds the ﬁrst time we enter\nthe loop.\nMaintenance: In each iteration of the while loop, AŒd\u0002 points to some root y.\nBecause d D x:degree D y:degree, we want to link x and y. Whichever of\nx and y has the smaller key becomes the parent of the other as a result of the\nlink operation, and so lines 9–10 exchange the pointers to x and y if necessary.\nNext, we link y to x by the call FIB-HEAP-LINK.H; y; x/ in line 11. This",
    "parent_8321882f-6195-42d9-96fa-54f941f8f5af": "x and y has the smaller key becomes the parent of the other as a result of the\nlink operation, and so lines 9–10 exchange the pointers to x and y if necessary.\nNext, we link y to x by the call FIB-HEAP-LINK.H; y; x/ in line 11. This\ncall increments x:degree but leaves y:degree as d. Node y is no longer a root,\nand so line 12 removes the pointer to it in array A. Because the call of FIB-\nHEAP-LINK increments the value of x:degree, line 13 restores the invariant\nthat d D x:degree.\nTermination: We repeat the while loop until AŒd\u0002 D NIL, in which case there is\nno other root with the same degree as x.\nAfter the while loop terminates, we set AŒd\u0002 to x in line 14 and perform the next\niteration of the for loop.\nFigures 19.4(c)–(e) show the array A and the resulting trees after the ﬁrst three\niterations of the for loop of lines 4–14. In the next iteration of the for loop, three\nlinks occur; their results are shown in Figures 19.4(f)–(h). Figures 19.4(i)–(l) show\nthe result of the next four iterations of the for loop.\nAll that remains is to clean up. Once the for loop of lines 4–14 completes,\nline 15 empties the root list, and lines 16–23 reconstruct it from the array A. The\nresulting Fibonacci heap appears in Figure 19.4(m). After consolidating the root\nlist, FIB-HEAP-EXTRACT-MIN ﬁnishes up by decrementing H:n in line 11 and\nreturning a pointer to the deleted node ´ in line 12.\nWe are now ready to show that the amortized cost of extracting the minimum\nnode of an n-node Fibonacci heap is O.D.n//. Let H denote the Fibonacci heap\njust prior to the FIB-HEAP-EXTRACT-MIN operation.\nWe start by accounting for the actual cost of extracting the minimum node.\nAn O.D.n// contribution comes from FIB-HEAP-EXTRACT-MIN processing at\n518\nChapter 19\nFibonacci Heaps\nmost D.n/ children of the minimum node and from the work in lines 2–3 and\n16–23 of CONSOLIDATE. It remains to analyze the contribution from the for loop",
    "parent_4cfbb04f-e50e-45b1-8173-99c3664c339c": "An O.D.n// contribution comes from FIB-HEAP-EXTRACT-MIN processing at\n518\nChapter 19\nFibonacci Heaps\nmost D.n/ children of the minimum node and from the work in lines 2–3 and\n16–23 of CONSOLIDATE. It remains to analyze the contribution from the for loop\nof lines 4–14 in CONSOLIDATE, for which we use an aggregate analysis. The size\nof the root list upon calling CONSOLIDATE is at most D.n/ C t.H/ \u0005 1, since it\nconsists of the original t.H/ root-list nodes, minus the extracted root node, plus\nthe children of the extracted node, which number at most D.n/. Within a given\niteration of the for loop of lines 4–14, the number of iterations of the while loop of\nlines 7–13 depends on the root list. But we know that every time through the while\nloop, one of the roots is linked to another, and thus the total number of iterations\nof the while loop over all iterations of the for loop is at most the number of roots\nin the root list. Hence, the total amount of work performed in the for loop is at\nmost proportional to D.n/ C t.H/. Thus, the total actual work in extracting the\nminimum node is O.D.n/ C t.H//.\nThe potential before extracting the minimum node is t.H/ C 2 m.H/, and the\npotential afterward is at most .D.n/ C 1/ C 2 m.H/, since at most D.n/ C 1 roots\nremain and no nodes become marked during the operation. The amortized cost is\nthus at most\nO.D.n/ C t.H// C ..D.n/ C 1/ C 2 m.H// \u0005 .t.H/ C 2 m.H//\nD\nO.D.n// C O.t.H// \u0005 t.H/\nD\nO.D.n// ;\nsince we can scale up the units of potential to dominate the constant hidden\nin O.t.H//. Intuitively, the cost of performing each link is paid for by the re-\nduction in potential due to the link’s reducing the number of roots by one. We shall\nsee in Section 19.4 that D.n/ D O.lg n/, so that the amortized cost of extracting\nthe minimum node is O.lg n/.\nExercises\n19.2-1\nShow the Fibonacci heap that results from calling FIB-HEAP-EXTRACT-MIN on\nthe Fibonacci heap shown in Figure 19.4(m).\n19.3\nDecreasing a key and deleting a node",
    "parent_f43af429-873c-4b8c-a49e-80e1c36a1687": "see in Section 19.4 that D.n/ D O.lg n/, so that the amortized cost of extracting\nthe minimum node is O.lg n/.\nExercises\n19.2-1\nShow the Fibonacci heap that results from calling FIB-HEAP-EXTRACT-MIN on\nthe Fibonacci heap shown in Figure 19.4(m).\n19.3\nDecreasing a key and deleting a node\nIn this section, we show how to decrease the key of a node in a Fibonacci heap\nin O.1/ amortized time and how to delete any node from an n-node Fibonacci\nheap in O.D.n// amortized time. In Section 19.4, we will show that the maxi-\n19.3\nDecreasing a key and deleting a node\n519\nmum degree D.n/ is O.lg n/, which will imply that FIB-HEAP-EXTRACT-MIN\nand FIB-HEAP-DELETE run in O.lg n/ amortized time.\nDecreasing a key\nIn the following pseudocode for the operation FIB-HEAP-DECREASE-KEY, we\nassume as before that removing a node from a linked list does not change any of\nthe structural attributes in the removed node.\nFIB-HEAP-DECREASE-KEY.H; x; k/\n1\nif k > x:key\n2\nerror “new key is greater than current key”\n3\nx:key D k\n4\ny D x:p\n5\nif y ¤ NIL and x:key < y:key\n6\nCUT.H; x; y/\n7\nCASCADING-CUT.H; y/\n8\nif x:key < H:min:key\n9\nH:min D x\nCUT.H; x; y/\n1\nremove x from the child list of y, decrementing y:degree\n2\nadd x to the root list of H\n3\nx:p D NIL\n4\nx:mark D FALSE\nCASCADING-CUT.H; y/\n1\n´ D y:p\n2\nif ´ ¤ NIL\n3\nif y:mark == FALSE\n4\ny:mark D TRUE\n5\nelse CUT.H; y; ´/\n6\nCASCADING-CUT.H; ´/\nThe FIB-HEAP-DECREASE-KEY procedure works as follows. Lines 1–3 ensure\nthat the new key is no greater than the current key of x and then assign the new key\nto x. If x is a root or if x:key \u0006 y:key, where y is x’s parent, then no structural\nchanges need occur, since min-heap order has not been violated. Lines 4–5 test for\nthis condition.\nIf min-heap order has been violated, many changes may occur. We start by\ncutting x in line 6. The CUT procedure “cuts” the link between x and its parent y,\nmaking x a root.\n520\nChapter 19\nFibonacci Heaps\nWe use the mark attributes to obtain the desired time bounds. They record a little",
    "parent_7d0938d3-76a9-4e7b-ac45-d1acf1825133": "If min-heap order has been violated, many changes may occur. We start by\ncutting x in line 6. The CUT procedure “cuts” the link between x and its parent y,\nmaking x a root.\n520\nChapter 19\nFibonacci Heaps\nWe use the mark attributes to obtain the desired time bounds. They record a little\npiece of the history of each node. Suppose that the following events have happened\nto node x:\n1. at some time, x was a root,\n2. then x was linked to (made the child of) another node,\n3. then two children of x were removed by cuts.\nAs soon as the second child has been lost, we cut x from its parent, making it a new\nroot. The attribute x:mark is TRUE if steps 1 and 2 have occurred and one child\nof x has been cut. The CUT procedure, therefore, clears x:mark in line 4, since it\nperforms step 1. (We can now see why line 3 of FIB-HEAP-LINK clears y:mark:\nnode y is being linked to another node, and so step 2 is being performed. The next\ntime a child of y is cut, y:mark will be set to TRUE.)\nWe are not yet done, because x might be the second child cut from its parent y\nsince the time that y was linked to another node. Therefore, line 7 of FIB-HEAP-\nDECREASE-KEY attempts to perform a cascading-cut operation on y. If y is a\nroot, then the test in line 2 of CASCADING-CUT causes the procedure to just return.\nIf y is unmarked, the procedure marks it in line 4, since its ﬁrst child has just been\ncut, and returns. If y is marked, however, it has just lost its second child; y is cut\nin line 5, and CASCADING-CUT calls itself recursively in line 6 on y’s parent ´.\nThe CASCADING-CUT procedure recurses its way up the tree until it ﬁnds either a\nroot or an unmarked node.\nOnce all the cascading cuts have occurred, lines 8–9 of FIB-HEAP-DECREASE-\nKEY ﬁnish up by updating H:min if necessary. The only node whose key changed\nwas the node x whose key decreased. Thus, the new minimum node is either the\noriginal minimum node or node x.\nFigure 19.5 shows the execution of two calls of FIB-HEAP-DECREASE-KEY,",
    "parent_baa671d5-68e7-4c07-af03-c4d6d15a0b53": "KEY ﬁnish up by updating H:min if necessary. The only node whose key changed\nwas the node x whose key decreased. Thus, the new minimum node is either the\noriginal minimum node or node x.\nFigure 19.5 shows the execution of two calls of FIB-HEAP-DECREASE-KEY,\nstarting with the Fibonacci heap shown in Figure 19.5(a). The ﬁrst call, shown\nin Figure 19.5(b), involves no cascading cuts. The second call, shown in Fig-\nures 19.5(c)–(e), invokes two cascading cuts.\nWe shall now show that the amortized cost of FIB-HEAP-DECREASE-KEY is\nonly O.1/. We start by determining its actual cost. The FIB-HEAP-DECREASE-\nKEY procedure takes O.1/ time, plus the time to perform the cascading cuts. Sup-\npose that a given invocation of FIB-HEAP-DECREASE-KEY results in c calls of\nCASCADING-CUT (the call made from line 7 of FIB-HEAP-DECREASE-KEY fol-\nlowed by c \u0005 1 recursive calls of CASCADING-CUT). Each call of CASCADING-\nCUT takes O.1/ time exclusive of recursive calls. Thus, the actual cost of FIB-\nHEAP-DECREASE-KEY, including all recursive calls, is O.c/.\nWe next compute the change in potential. Let H denote the Fibonacci heap just\nprior to the FIB-HEAP-DECREASE-KEY operation. The call to CUT in line 6 of\n19.3\nDecreasing a key and deleting a node\n521\n17\n30\n24\n23\n26\n35\n15\n7\n21\n18\n52\n38\n39\n41\n(b)\n17\n30\n24\n23\n26\n5\n15\n7\n21\n18\n52\n38\n39\n41\n(c)\n17\n30\n24\n23\n26\n5\n15\n7\n21\n18\n52\n38\n39\n41\n(d)\n17\n30\n24\n23\n26\n5\n15\n7\n21\n18\n52\n38\n39\n41\n(e)\n17\n30\n24\n23\n26\n35\n46\n7\n21\n18\n52\n38\n39\n41\n(a)\nH:min\nH:min\nH:min\nH:min\nH:min\nFigure 19.5\nTwo calls of FIB-HEAP-DECREASE-KEY. (a) The initial Fibonacci heap. (b) The\nnode with key 46 has its key decreased to 15. The node becomes a root, and its parent (with key 24),\nwhich had previously been unmarked, becomes marked. (c)–(e) The node with key 35 has its key\ndecreased to 5. In part (c), the node, now with key 5, becomes a root. Its parent, with key 26,\nis marked, so a cascading cut occurs. The node with key 26 is cut from its parent and made an",
    "parent_bc7cf4b5-4405-42d0-acdc-30bb01fa9d8b": "which had previously been unmarked, becomes marked. (c)–(e) The node with key 35 has its key\ndecreased to 5. In part (c), the node, now with key 5, becomes a root. Its parent, with key 26,\nis marked, so a cascading cut occurs. The node with key 26 is cut from its parent and made an\nunmarked root in (d). Another cascading cut occurs, since the node with key 24 is marked as well.\nThis node is cut from its parent and made an unmarked root in part (e). The cascading cuts stop\nat this point, since the node with key 7 is a root. (Even if this node were not a root, the cascading\ncuts would stop, since it is unmarked.) Part (e) shows the result of the FIB-HEAP-DECREASE-KEY\noperation, with H:min pointing to the new minimum node.\nFIB-HEAP-DECREASE-KEY creates a new tree rooted at node x and clears x’s\nmark bit (which may have already been FALSE). Each call of CASCADING-CUT,\nexcept for the last one, cuts a marked node and clears the mark bit. Afterward, the\nFibonacci heap contains t.H/Cc trees (the original t.H/ trees, c\u00051 trees produced\nby cascading cuts, and the tree rooted at x) and at most m.H/\u0005cC2 marked nodes\n(c\u00051 were unmarked by cascading cuts and the last call of CASCADING-CUT may\nhave marked a node). The change in potential is therefore at most\n..t.H/ C c/ C 2.m.H/ \u0005 c C 2// \u0005 .t.H/ C 2 m.H// D 4 \u0005 c :\n522\nChapter 19\nFibonacci Heaps\nThus, the amortized cost of FIB-HEAP-DECREASE-KEY is at most\nO.c/ C 4 \u0005 c D O.1/ ;\nsince we can scale up the units of potential to dominate the constant hidden in O.c/.\nYou can now see why we deﬁned the potential function to include a term that is\ntwice the number of marked nodes. When a marked node y is cut by a cascading\ncut, its mark bit is cleared, which reduces the potential by 2. One unit of potential\npays for the cut and the clearing of the mark bit, and the other unit compensates\nfor the unit increase in potential due to node y becoming a root.\nDeleting a node",
    "parent_4f3e8783-baa5-421f-a7e5-4f476fd8de98": "cut, its mark bit is cleared, which reduces the potential by 2. One unit of potential\npays for the cut and the clearing of the mark bit, and the other unit compensates\nfor the unit increase in potential due to node y becoming a root.\nDeleting a node\nThe following pseudocode deletes a node from an n-node Fibonacci heap in\nO.D.n// amortized time. We assume that there is no key value of \u00051 currently\nin the Fibonacci heap.\nFIB-HEAP-DELETE.H; x/\n1\nFIB-HEAP-DECREASE-KEY.H; x; \u00051/\n2\nFIB-HEAP-EXTRACT-MIN.H/\nFIB-HEAP-DELETE makes x become the minimum node in the Fibonacci heap by\ngiving it a uniquely small key of \u00051. The FIB-HEAP-EXTRACT-MIN procedure\nthen removes node x from the Fibonacci heap. The amortized time of FIB-HEAP-\nDELETE is the sum of the O.1/ amortized time of FIB-HEAP-DECREASE-KEY\nand the O.D.n// amortized time of FIB-HEAP-EXTRACT-MIN. Since we shall see\nin Section 19.4 that D.n/ D O.lg n/, the amortized time of FIB-HEAP-DELETE\nis O.lg n/.\nExercises\n19.3-1\nSuppose that a root x in a Fibonacci heap is marked. Explain how x came to be\na marked root. Argue that it doesn’t matter to the analysis that x is marked, even\nthough it is not a root that was ﬁrst linked to another node and then lost one child.\n19.3-2\nJustify the O.1/ amortized time of FIB-HEAP-DECREASE-KEY as an average cost\nper operation by using aggregate analysis.\n19.4\nBounding the maximum degree\n523\n19.4\nBounding the maximum degree\nTo prove that the amortized time of FIB-HEAP-EXTRACT-MIN and FIB-HEAP-\nDELETE is O.lg n/, we must show that the upper bound D.n/ on the degree of\nany node of an n-node Fibonacci heap is O.lg n/. In particular, we shall show that\nD.n/ \u0002\n\r\nlog\u0007 n\n˘\n, where \u0007 is the golden ratio, deﬁned in equation (3.24) as\n\u0007 D .1 C\np\n5/=2 D 1:61803 : : : :\nThe key to the analysis is as follows. For each node x within a Fibonacci heap,\ndeﬁne size.x/ to be the number of nodes, including x itself, in the subtree rooted",
    "parent_6165fea1-7255-46e7-925c-6639e420eda7": "D.n/ \u0002\n\r\nlog\u0007 n\n˘\n, where \u0007 is the golden ratio, deﬁned in equation (3.24) as\n\u0007 D .1 C\np\n5/=2 D 1:61803 : : : :\nThe key to the analysis is as follows. For each node x within a Fibonacci heap,\ndeﬁne size.x/ to be the number of nodes, including x itself, in the subtree rooted\nat x. (Note that x need not be in the root list—it can be any node at all.) We shall\nshow that size.x/ is exponential in x:degree. Bear in mind that x:degree is always\nmaintained as an accurate count of the degree of x.\nLemma 19.1\nLet x be any node in a Fibonacci heap, and suppose that x:degree D k. Let\ny1; y2; : : : ; yk denote the children of x in the order in which they were linked to x,\nfrom the earliest to the latest. Then, y1:degree \u0006 0 and yi:degree \u0006 i \u0005 2 for\ni D 2; 3; : : : ; k.\nProof\nObviously, y1:degree \u0006 0.\nFor i \u0006 2, we note that when yi was linked to x, all of y1; y2; : : : ; yi\u00031 were\nchildren of x, and so we must have had x:degree \u0006 i \u0005 1. Because node yi is\nlinked to x (by CONSOLIDATE) only if x:degree D yi:degree, we must have also\nhad yi:degree \u0006 i \u0005 1 at that time. Since then, node yi has lost at most one\nchild, since it would have been cut from x (by CASCADING-CUT) if it had lost\ntwo children. We conclude that yi:degree \u0006 i \u0005 2.\nWe ﬁnally come to the part of the analysis that explains the name “Fibonacci\nheaps.” Recall from Section 3.2 that for k D 0; 1; 2; : : :, the kth Fibonacci number\nis deﬁned by the recurrence\nFk D\n\u0002\n0\nif k D 0 ;\n1\nif k D 1 ;\nFk\u00031 C Fk\u00032\nif k \u0006 2 :\nThe following lemma gives another way to express Fk.\n524\nChapter 19\nFibonacci Heaps\nLemma 19.2\nFor all integers k \u0006 0,\nFkC2 D 1 C\nk\nX\niD0\nFi :\nProof\nThe proof is by induction on k. When k D 0,\n1 C\n0\nX\niD0\nFi\nD\n1 C F0\nD\n1 C 0\nD\nF2 :\nWe now assume the inductive hypothesis that FkC1 D 1 C Pk\u00031\niD0 Fi, and we\nhave\nFkC2\nD\nFk C FkC1\nD\nFk C\n \n1 C\nk\u00031\nX\niD0\nFi\n!\nD\n1 C\nk\nX\niD0\nFi :\nLemma 19.3\nFor all integers k \u0006 0, the .k C 2/nd Fibonacci number satisﬁes FkC2 \u0006 \u0007k.\nProof",
    "parent_1dfdbdaa-8ac1-4ab4-943f-9b708d30f401": "1 C\n0\nX\niD0\nFi\nD\n1 C F0\nD\n1 C 0\nD\nF2 :\nWe now assume the inductive hypothesis that FkC1 D 1 C Pk\u00031\niD0 Fi, and we\nhave\nFkC2\nD\nFk C FkC1\nD\nFk C\n \n1 C\nk\u00031\nX\niD0\nFi\n!\nD\n1 C\nk\nX\niD0\nFi :\nLemma 19.3\nFor all integers k \u0006 0, the .k C 2/nd Fibonacci number satisﬁes FkC2 \u0006 \u0007k.\nProof\nThe proof is by induction on k. The base cases are for k D 0 and k D 1.\nWhen k D 0 we have F2 D 1 D \u00070, and when k D 1 we have F3 D 2 >\n1:619 > \u00071. The inductive step is for k \u0006 2, and we assume that FiC2 > \u0007i for\ni D 0; 1; : : : ; k\u00051. Recall that \u0007 is the positive root of equation (3.23), x2 D xC1.\nThus, we have\nFkC2\nD\nFkC1 C Fk\n\u0006\n\u0007k\u00031 C \u0007k\u00032\n(by the inductive hypothesis)\nD\n\u0007k\u00032.\u0007 C 1/\nD\n\u0007k\u00032 \u0003 \u00072\n(by equation (3.23))\nD\n\u0007k :\nThe following lemma and its corollary complete the analysis.\n19.4\nBounding the maximum degree\n525\nLemma 19.4\nLet x be any node in a Fibonacci heap, and let k D x:degree. Then size.x/ \u0006\nFkC2 \u0006 \u0007k, where \u0007 D .1 C\np\n5/=2.\nProof\nLet sk denote the minimum possible size of any node of degree k in any\nFibonacci heap. Trivially, s0 D 1 and s1 D 2. The number sk is at most size.x/\nand, because adding children to a node cannot decrease the node’s size, the value\nof sk increases monotonically with k. Consider some node ´, in any Fibonacci\nheap, such that ´:degree D k and size.´/ D sk. Because sk \u0002 size.x/, we\ncompute a lower bound on size.x/ by computing a lower bound on sk. As in\nLemma 19.1, let y1; y2; : : : ; yk denote the children of ´ in the order in which they\nwere linked to ´. To bound sk, we count one for ´ itself and one for the ﬁrst child y1\n(for which size.y1/ \u0006 1), giving\nsize.x/\n\u0006\nsk\n\u0006\n2 C\nk\nX\niD2\nsyi :degree\n\u0006\n2 C\nk\nX\niD2\nsi\u00032 ;\nwhere the last line follows from Lemma 19.1 (so that yi:degree \u0006 i \u0005 2) and the\nmonotonicity of sk (so that syi :degree \u0006 si\u00032).\nWe now show by induction on k that sk \u0006 FkC2 for all nonnegative integers k.\nThe bases, for k D 0 and k D 1, are trivial. For the inductive step, we assume that",
    "parent_290c67b7-359e-4f33-88c8-257713492183": "si\u00032 ;\nwhere the last line follows from Lemma 19.1 (so that yi:degree \u0006 i \u0005 2) and the\nmonotonicity of sk (so that syi :degree \u0006 si\u00032).\nWe now show by induction on k that sk \u0006 FkC2 for all nonnegative integers k.\nThe bases, for k D 0 and k D 1, are trivial. For the inductive step, we assume that\nk \u0006 2 and that si \u0006 FiC2 for i D 0; 1; : : : ; k \u0005 1. We have\nsk\n\u0006\n2 C\nk\nX\niD2\nsi\u00032\n\u0006\n2 C\nk\nX\niD2\nFi\nD\n1 C\nk\nX\niD0\nFi\nD\nFkC2\n(by Lemma 19.2)\n\u0006\n\u0007k\n(by Lemma 19.3) .\nThus, we have shown that size.x/ \u0006 sk \u0006 FkC2 \u0006 \u0007k.\n526\nChapter 19\nFibonacci Heaps\nCorollary 19.5\nThe maximum degree D.n/ of any node in an n-node Fibonacci heap is O.lg n/.\nProof\nLet x be any node in an n-node Fibonacci heap, and let k D x:degree.\nBy Lemma 19.4, we have n \u0006 size.x/ \u0006 \u0007k. Taking base-\u0007 logarithms gives\nus k \u0002 log\u0007 n. (In fact, because k is an integer, k \u0002\n\r\nlog\u0007 n\n˘\n.) The maximum\ndegree D.n/ of any node is thus O.lg n/.\nExercises\n19.4-1\nProfessor Pinocchio claims that the height of an n-node Fibonacci heap is O.lg n/.\nShow that the professor is mistaken by exhibiting, for any positive integer n, a\nsequence of Fibonacci-heap operations that creates a Fibonacci heap consisting of\njust one tree that is a linear chain of n nodes.\n19.4-2\nSuppose we generalize the cascading-cut rule to cut a node x from its parent as\nsoon as it loses its kth child, for some integer constant k. (The rule in Section 19.3\nuses k D 2.) For what values of k is D.n/ D O.lg n/?\nProblems\n19-1\nAlternative implementation of deletion\nProfessor Pisano has proposed the following variant of the FIB-HEAP-DELETE\nprocedure, claiming that it runs faster when the node being deleted is not the node\npointed to by H:min.\nPISANO-DELETE.H; x/\n1\nif x == H:min\n2\nFIB-HEAP-EXTRACT-MIN.H/\n3\nelse y D x:p\n4\nif y ¤ NIL\n5\nCUT.H; x; y/\n6\nCASCADING-CUT.H; y/\n7\nadd x’s child list to the root list of H\n8\nremove x from the root list of H\nProblems for Chapter 19\n527\na. The professor’s claim that this procedure runs faster is based partly on the as-",
    "parent_4e4a7000-3aa7-4363-a95c-55a82470d4a3": "1\nif x == H:min\n2\nFIB-HEAP-EXTRACT-MIN.H/\n3\nelse y D x:p\n4\nif y ¤ NIL\n5\nCUT.H; x; y/\n6\nCASCADING-CUT.H; y/\n7\nadd x’s child list to the root list of H\n8\nremove x from the root list of H\nProblems for Chapter 19\n527\na. The professor’s claim that this procedure runs faster is based partly on the as-\nsumption that line 7 can be performed in O.1/ actual time. What is wrong with\nthis assumption?\nb. Give a good upper bound on the actual time of PISANO-DELETE when x is\nnot H:min. Your bound should be in terms of x:degree and the number c of\ncalls to the CASCADING-CUT procedure.\nc. Suppose that we call PISANO-DELETE.H; x/, and let H 0 be the Fibonacci heap\nthat results. Assuming that node x is not a root, bound the potential of H 0 in\nterms of x:degree, c, t.H/, and m.H/.\nd. Conclude that the amortized time for PISANO-DELETE is asymptotically no\nbetter than for FIB-HEAP-DELETE, even when x ¤ H:min.\n19-2\nBinomial trees and binomial heaps\nThe binomial tree Bk is an ordered tree (see Section B.5.2) deﬁned recursively.\nAs shown in Figure 19.6(a), the binomial tree B0 consists of a single node. The\nbinomial tree Bk consists of two binomial trees Bk\u00031 that are linked together so\nthat the root of one is the leftmost child of the root of the other. Figure 19.6(b)\nshows the binomial trees B0 through B4.\na. Show that for the binomial tree Bk,\n1. there are 2k nodes,\n2. the height of the tree is k,\n3. there are exactly\n\u000bk\ni\n\f\nnodes at depth i for i D 0; 1; : : : ; k, and\n4. the root has degree k, which is greater than that of any other node; moreover,\nas Figure 19.6(c) shows, if we number the children of the root from left to\nright by k \u0005 1; k \u0005 2; : : : ; 0, then child i is the root of a subtree Bi.\nA binomial heap H is a set of binomial trees that satisﬁes the following proper-\nties:\n1. Each node has a key (like a Fibonacci heap).\n2. Each binomial tree in H obeys the min-heap property.\n3. For any nonnegative integer k, there is at most one binomial tree in H whose\nroot has degree k.",
    "parent_aadb2f48-5d2d-48de-bcb0-bff44c95b603": "A binomial heap H is a set of binomial trees that satisﬁes the following proper-\nties:\n1. Each node has a key (like a Fibonacci heap).\n2. Each binomial tree in H obeys the min-heap property.\n3. For any nonnegative integer k, there is at most one binomial tree in H whose\nroot has degree k.\nb. Suppose that a binomial heap H has a total of n nodes. Discuss the relationship\nbetween the binomial trees that H contains and the binary representation of n.\nConclude that H consists of at most blg nc C 1 binomial trees.\n528\nChapter 19\nFibonacci Heaps\nB4\nBk–1\nBk–2\nBk\nB2\nB1\nB0\nB3\nB2\nB1\nB0\nBk\nBk–1\nBk–1\nB0\n(a)\ndepth\n0\n1\n2\n3\n4\n(b)\n(c)\nFigure 19.6\n(a) The recursive deﬁnition of the binomial tree Bk. Triangles represent rooted sub-\ntrees. (b) The binomial trees B0 through B4. Node depths in B4 are shown. (c) Another way of\nlooking at the binomial tree Bk.\nSuppose that we represent a binomial heap as follows. The left-child, right-\nsibling scheme of Section 10.4 represents each binomial tree within a binomial\nheap. Each node contains its key; pointers to its parent, to its leftmost child, and\nto the sibling immediately to its right (these pointers are NIL when appropriate);\nand its degree (as in Fibonacci heaps, how many children it has). The roots form a\nsingly linked root list, ordered by the degrees of the roots (from low to high), and\nwe access the binomial heap by a pointer to the ﬁrst node on the root list.\nc. Complete the description of how to represent a binomial heap (i.e., name the\nattributes, describe when attributes have the value NIL, and deﬁne how the root\nlist is organized), and show how to implement the same seven operations on\nbinomial heaps as this chapter implemented on Fibonacci heaps. Each opera-\ntion should run in O.lg n/ worst-case time, where n is the number of nodes in\nProblems for Chapter 19\n529\nthe binomial heap (or in the case of the UNION operation, in the two binomial\nheaps that are being united). The MAKE-HEAP operation should take constant\ntime.",
    "parent_58f57069-c955-4865-b231-1daf7d741ff3": "tion should run in O.lg n/ worst-case time, where n is the number of nodes in\nProblems for Chapter 19\n529\nthe binomial heap (or in the case of the UNION operation, in the two binomial\nheaps that are being united). The MAKE-HEAP operation should take constant\ntime.\nd. Suppose that we were to implement only the mergeable-heap operations on a\nFibonacci heap (i.e., we do not implement the DECREASE-KEY or DELETE op-\nerations). How would the trees in a Fibonacci heap resemble those in a binomial\nheap? How would they differ? Show that the maximum degree in an n-node\nFibonacci heap would be at most blg nc.\ne. Professor McGee has devised a new data structure based on Fibonacci heaps.\nA McGee heap has the same structure as a Fibonacci heap and supports just\nthe mergeable-heap operations. The implementations of the operations are the\nsame as for Fibonacci heaps, except that insertion and union consolidate the\nroot list as their last step. What are the worst-case running times of operations\non McGee heaps?\n19-3\nMore Fibonacci-heap operations\nWe wish to augment a Fibonacci heap H to support two new operations without\nchanging the amortized running time of any other Fibonacci-heap operations.\na. The operation FIB-HEAP-CHANGE-KEY.H; x; k/ changes the key of node x\nto the value k. Give an efﬁcient implementation of FIB-HEAP-CHANGE-KEY,\nand analyze the amortized running time of your implementation for the cases\nin which k is greater than, less than, or equal to x:key.\nb. Give an efﬁcient implementation of FIB-HEAP-PRUNE.H; r/, which deletes\nq D min.r; H:n/ nodes from H. You may choose any q nodes to delete. Ana-\nlyze the amortized running time of your implementation. (Hint: You may need\nto modify the data structure and potential function.)\n19-4\n2-3-4 heaps\nChapter 18 introduced the 2-3-4 tree, in which every internal node (other than pos-\nsibly the root) has two, three, or four children and all leaves have the same depth. In",
    "parent_9720eb60-5577-499e-9fdc-63f1c1e1dd8d": "to modify the data structure and potential function.)\n19-4\n2-3-4 heaps\nChapter 18 introduced the 2-3-4 tree, in which every internal node (other than pos-\nsibly the root) has two, three, or four children and all leaves have the same depth. In\nthis problem, we shall implement 2-3-4 heaps, which support the mergeable-heap\noperations.\nThe 2-3-4 heaps differ from 2-3-4 trees in the following ways. In 2-3-4 heaps,\nonly leaves store keys, and each leaf x stores exactly one key in the attribute x:key.\nThe keys in the leaves may appear in any order. Each internal node x contains\na value x:small that is equal to the smallest key stored in any leaf in the subtree\nrooted at x. The root r contains an attribute r:height that gives the height of the\n530\nChapter 19\nFibonacci Heaps\ntree. Finally, 2-3-4 heaps are designed to be kept in main memory, so that disk\nreads and writes are not needed.\nImplement the following 2-3-4 heap operations. In parts (a)–(e), each operation\nshould run in O.lg n/ time on a 2-3-4 heap with n elements. The UNION operation\nin part (f) should run in O.lg n/ time, where n is the number of elements in the two\ninput heaps.\na. MINIMUM, which returns a pointer to the leaf with the smallest key.\nb. DECREASE-KEY, which decreases the key of a given leaf x to a given value\nk \u0002 x:key.\nc. INSERT, which inserts leaf x with key k.\nd. DELETE, which deletes a given leaf x.\ne. EXTRACT-MIN, which extracts the leaf with the smallest key.\nf.\nUNION, which unites two 2-3-4 heaps, returning a single 2-3-4 heap and de-\nstroying the input heaps.\nChapter notes\nFredman and Tarjan [114] introduced Fibonacci heaps. Their paper also describes\nthe application of Fibonacci heaps to the problems of single-source shortest paths,\nall-pairs shortest paths, weighted bipartite matching, and the minimum-spanning-\ntree problem.\nSubsequently, Driscoll, Gabow, Shrairman, and Tarjan [96] developed “relaxed\nheaps” as an alternative to Fibonacci heaps. They devised two varieties of re-",
    "parent_9379793e-d641-4b99-b06c-1817a3070c4f": "all-pairs shortest paths, weighted bipartite matching, and the minimum-spanning-\ntree problem.\nSubsequently, Driscoll, Gabow, Shrairman, and Tarjan [96] developed “relaxed\nheaps” as an alternative to Fibonacci heaps. They devised two varieties of re-\nlaxed heaps. One gives the same amortized time bounds as Fibonacci heaps. The\nother allows DECREASE-KEY to run in O.1/ worst-case (not amortized) time and\nEXTRACT-MIN and DELETE to run in O.lg n/ worst-case time. Relaxed heaps\nalso have some advantages over Fibonacci heaps in parallel algorithms.\nSee also the chapter notes for Chapter 6 for other data structures that support fast\nDECREASE-KEY operations when the sequence of values returned by EXTRACT-\nMIN calls are monotonically increasing over time and the data are integers in a\nspeciﬁc range.\n20\nvan Emde Boas Trees\nIn previous chapters, we saw data structures that support the operations of a priority\nqueue—binary heaps in Chapter 6, red-black trees in Chapter 13,1 and Fibonacci\nheaps in Chapter 19. In each of these data structures, at least one important op-\neration took O.lg n/ time, either worst case or amortized. In fact, because each\nof these data structures bases its decisions on comparing keys, the \u0004.n lg n/ lower\nbound for sorting in Section 8.1 tells us that at least one operation will have to\ntake \u0004.lg n/ time. Why? If we could perform both the INSERT and EXTRACT-MIN\noperations in o.lg n/ time, then we could sort n keys in o.n lg n/ time by ﬁrst per-\nforming n INSERT operations, followed by n EXTRACT-MIN operations.\nWe saw in Chapter 8, however, that sometimes we can exploit additional infor-\nmation about the keys to sort in o.n lg n/ time. In particular, with counting sort\nwe can sort n keys, each an integer in the range 0 to k, in time ‚.n C k/, which\nis ‚.n/ when k D O.n/.\nSince we can circumvent the \u0004.n lg n/ lower bound for sorting when the keys are\nintegers in a bounded range, you might wonder whether we can perform each of the",
    "parent_93a2368c-8054-42d5-a6a8-1edbc523087c": "we can sort n keys, each an integer in the range 0 to k, in time ‚.n C k/, which\nis ‚.n/ when k D O.n/.\nSince we can circumvent the \u0004.n lg n/ lower bound for sorting when the keys are\nintegers in a bounded range, you might wonder whether we can perform each of the\npriority-queue operations in o.lg n/ time in a similar scenario. In this chapter, we\nshall see that we can: van Emde Boas trees support the priority-queue operations,\nand a few others, each in O.lg lg n/ worst-case time. The hitch is that the keys\nmust be integers in the range 0 to n \u0005 1, with no duplicates allowed.\nSpeciﬁcally, van Emde Boas trees support each of the dynamic set operations\nlisted on page 230—SEARCH, INSERT, DELETE, MINIMUM, MAXIMUM, SUC-\nCESSOR, and PREDECESSOR—in O.lg lg n/ time. In this chapter, we will omit\ndiscussion of satellite data and focus only on storing keys. Because we concentrate\non keys and disallow duplicate keys to be stored, instead of describing the SEARCH\n1Chapter 13 does not explicitly discuss how to implement EXTRACT-MIN and DECREASE-KEY, but\nwe can easily build these operations for any data structure that supports MINIMUM, DELETE, and\nINSERT.\n532\nChapter 20\nvan Emde Boas Trees\noperation, we will implement the simpler operation MEMBER.S; x/, which returns\na boolean indicating whether the value x is currently in dynamic set S.\nSo far, we have used the parameter n for two distinct purposes: the number of\nelements in the dynamic set, and the range of the possible values. To avoid any\nfurther confusion, from here on we will use n to denote the number of elements\ncurrently in the set and u as the range of possible values, so that each van Emde\nBoas tree operation runs in O.lg lg u/ time. We call the set f0; 1; 2; : : : ; u \u0005 1g\nthe universe of values that can be stored and u the universe size. We assume\nthroughout this chapter that u is an exact power of 2, i.e., u D 2k for some integer\nk \u0006 1.\nSection 20.1 starts us out by examining some simple approaches that will get",
    "parent_6537550d-d561-4c47-b96a-baebd5a20a40": "the universe of values that can be stored and u the universe size. We assume\nthroughout this chapter that u is an exact power of 2, i.e., u D 2k for some integer\nk \u0006 1.\nSection 20.1 starts us out by examining some simple approaches that will get\nus going in the right direction. We enhance these approaches in Section 20.2,\nintroducing proto van Emde Boas structures, which are recursive but do not achieve\nour goal of O.lg lg u/-time operations. Section 20.3 modiﬁes proto van Emde Boas\nstructures to develop van Emde Boas trees, and it shows how to implement each\noperation in O.lg lg u/ time.\n20.1\nPreliminary approaches\nIn this section, we shall examine various approaches for storing a dynamic set.\nAlthough none will achieve the O.lg lg u/ time bounds that we desire, we will gain\ninsights that will help us understand van Emde Boas trees when we see them later\nin this chapter.\nDirect addressing\nDirect addressing, as we saw in Section 11.1, provides the simplest approach to\nstoring a dynamic set. Since in this chapter we are concerned only with storing\nkeys, we can simplify the direct-addressing approach to store the dynamic set as a\nbit vector, as discussed in Exercise 11.1-2. To store a dynamic set of values from\nthe universe f0; 1; 2; : : : ; u \u0005 1g, we maintain an array AŒ0 : : u \u0005 1\u0002 of u bits. The\nentry AŒx\u0002 holds a 1 if the value x is in the dynamic set, and it holds a 0 otherwise.\nAlthough we can perform each of the INSERT, DELETE, and MEMBER operations\nin O.1/ time with a bit vector, the remaining operations—MINIMUM, MAXIMUM,\nSUCCESSOR, and PREDECESSOR—each take ‚.u/ time in the worst case because\n20.1\nPreliminary approaches\n533\n0\n0\n0\n1\n1\n2\n1\n3\n1\n4\n1\n5\n0\n6\n1\n7\n0\n8\n0\n9\n0\n10\n0\n11\n0\n12\n0\n13\n1\n14\n1\n15\n0\n1\n1\n1\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\nA\nFigure 20.1\nA binary tree of bits superimposed on top of a bit vector representing the set\nf2; 3; 4; 5; 7; 14; 15g when u D 16. Each internal node contains a 1 if and only if some leaf in",
    "parent_9ada32ad-3f5e-44ff-8ca9-afb6d62ca72e": "533\n0\n0\n0\n1\n1\n2\n1\n3\n1\n4\n1\n5\n0\n6\n1\n7\n0\n8\n0\n9\n0\n10\n0\n11\n0\n12\n0\n13\n1\n14\n1\n15\n0\n1\n1\n1\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\nA\nFigure 20.1\nA binary tree of bits superimposed on top of a bit vector representing the set\nf2; 3; 4; 5; 7; 14; 15g when u D 16. Each internal node contains a 1 if and only if some leaf in\nits subtree contains a 1. The arrows show the path followed to determine the predecessor of 14 in the\nset.\nwe might have to scan through ‚.u/ elements.2 For example, if a set contains only\nthe values 0 and u \u0005 1, then to ﬁnd the successor of 0, we would have to scan\nentries 1 through u \u0005 2 before ﬁnding a 1 in AŒu \u0005 1\u0002.\nSuperimposing a binary tree structure\nWe can short-cut long scans in the bit vector by superimposing a binary tree of bits\non top of it. Figure 20.1 shows an example. The entries of the bit vector form the\nleaves of the binary tree, and each internal node contains a 1 if and only if any leaf\nin its subtree contains a 1. In other words, the bit stored in an internal node is the\nlogical-or of its two children.\nThe operations that took ‚.u/ worst-case time with an unadorned bit vector now\nuse the tree structure:\n\u0002\nTo ﬁnd the minimum value in the set, start at the root and head down toward\nthe leaves, always taking the leftmost node containing a 1.\n\u0002\nTo ﬁnd the maximum value in the set, start at the root and head down toward\nthe leaves, always taking the rightmost node containing a 1.\n2We assume throughout this chapter that MINIMUM and MAXIMUM return NIL if the dynamic set\nis empty and that SUCCESSOR and PREDECESSOR return NIL if the element they are given has no\nsuccessor or predecessor, respectively.\n534\nChapter 20\nvan Emde Boas Trees\n\u0002\nTo ﬁnd the successor of x, start at the leaf indexed by x, and head up toward the\nroot until we enter a node from the left and this node has a 1 in its right child ´.\nThen head down through node ´, always taking the leftmost node containing\na 1 (i.e., ﬁnd the minimum value in the subtree rooted at the right child ´).\n\u0002",
    "parent_6a331514-74bc-4fad-99fc-28c89f64bd89": "root until we enter a node from the left and this node has a 1 in its right child ´.\nThen head down through node ´, always taking the leftmost node containing\na 1 (i.e., ﬁnd the minimum value in the subtree rooted at the right child ´).\n\u0002\nTo ﬁnd the predecessor of x, start at the leaf indexed by x, and head up toward\nthe root until we enter a node from the right and this node has a 1 in its left\nchild ´. Then head down through node ´, always taking the rightmost node\ncontaining a 1 (i.e., ﬁnd the maximum value in the subtree rooted at the left\nchild ´).\nFigure 20.1 shows the path taken to ﬁnd the predecessor, 7, of the value 14.\nWe also augment the INSERT and DELETE operations appropriately. When in-\nserting a value, we store a 1 in each node on the simple path from the appropriate\nleaf up to the root. When deleting a value, we go from the appropriate leaf up to\nthe root, recomputing the bit in each internal node on the path as the logical-or of\nits two children.\nSince the height of the tree is lg u and each of the above operations makes at\nmost one pass up the tree and at most one pass down, each operation takes O.lg u/\ntime in the worst case.\nThis approach is only marginally better than just using a red-black tree. We can\nstill perform the MEMBER operation in O.1/ time, whereas searching a red-black\ntree takes O.lg n/ time. Then again, if the number n of elements stored is much\nsmaller than the size u of the universe, a red-black tree would be faster for all the\nother operations.\nSuperimposing a tree of constant height\nWhat happens if we superimpose a tree with greater degree? Let us assume that\nthe size of the universe is u D 22k for some integer k, so that pu is an integer.\nInstead of superimposing a binary tree on top of the bit vector, we superimpose a\ntree of degree pu. Figure 20.2(a) shows such a tree for the same bit vector as in\nFigure 20.1. The height of the resulting tree is always 2.",
    "parent_ac3c9da8-2f29-4c73-bba6-6a658c5672a7": "Instead of superimposing a binary tree on top of the bit vector, we superimpose a\ntree of degree pu. Figure 20.2(a) shows such a tree for the same bit vector as in\nFigure 20.1. The height of the resulting tree is always 2.\nAs before, each internal node stores the logical-or of the bits within its sub-\ntree, so that the pu internal nodes at depth 1 summarize each group of pu val-\nues. As Figure 20.2(b) demonstrates, we can think of these nodes as an array\nsummaryŒ0 : : pu \u0005 1\u0002, where summaryŒi\u0002 contains a 1 if and only if the subar-\nray AŒipu : : .i C 1/pu \u0005 1\u0002 contains a 1. We call this pu-bit subarray of A\nthe ith cluster.\nFor a given value of x, the bit AŒx\u0002 appears in cluster num-\nber bx=puc. Now INSERT becomes an O.1/-time operation: to insert x, set\nboth AŒx\u0002 and summaryŒbx=puc\u0002 to 1. We can use the summary array to perform\n20.1\nPreliminary approaches\n535\n0\n0\n0\n1\n1\n2\n1\n3\n1\n4\n1\n5\n0\n6\n1\n7\n0\n8\n0\n9\n0\n10\n0\n11\n0\n12\n0\n13\n1\n14\n1\n15\n1\n1\n1\n0\n1\n(a)\n0\n0\n0\n1\n1\n2\n1\n3\n1\n4\n1\n5\n0\n6\n1\n7\n0\n8\n0\n9\n0\n10\n0\n11\n0\n12\n0\n13\n1\n14\n1\n15\n(b)\n1\n0\n1\n1\n0\n2\n1\n3\nA\nA\nsummary\npu bits\npu bits\nFigure 20.2\n(a) A tree of degree pu superimposed on top of the same bit vector as in Figure 20.1.\nEach internal node stores the logical-or of the bits in its subtree. (b) A view of the same structure,\nbut with the internal nodes at depth 1 treated as an array summaryŒ0 : : pu \u0005 1\u0002, where summaryŒi\u0002 is\nthe logical-or of the subarray AŒipu : : .i C 1/pu \u0005 1\u0002.\neach of the operations MINIMUM, MAXIMUM, SUCCESSOR, PREDECESSOR, and\nDELETE in O.pu/ time:\n\u0002\nTo ﬁnd the minimum (maximum) value, ﬁnd the leftmost (rightmost) entry in\nsummary that contains a 1, say summaryŒi\u0002, and then do a linear search within\nthe ith cluster for the leftmost (rightmost) 1.\n\u0002\nTo ﬁnd the successor (predecessor) of x, ﬁrst search to the right (left) within its\ncluster. If we ﬁnd a 1, that position gives the result. Otherwise, let i D bx=puc\nand search to the right (left) within the summary array from index i. The ﬁrst",
    "parent_21cfb1b5-0053-4fc0-9452-aae062fc7dc8": "the ith cluster for the leftmost (rightmost) 1.\n\u0002\nTo ﬁnd the successor (predecessor) of x, ﬁrst search to the right (left) within its\ncluster. If we ﬁnd a 1, that position gives the result. Otherwise, let i D bx=puc\nand search to the right (left) within the summary array from index i. The ﬁrst\nposition that holds a 1 gives the index of a cluster. Search within that cluster\nfor the leftmost (rightmost) 1. That position holds the successor (predecessor).\n\u0002\nTo delete the value x, let i D bx=puc\u0002. Set AŒx\u0002 to 0 and then set summaryŒi\u0002\nto the logical-or of the bits in the ith cluster.\nIn each of the above operations, we search through at most two clusters of pu bits\nplus the summary array, and so each operation takes O.pu/ time.\nAt ﬁrst glance, it seems as though we have made negative progress. Superimpos-\ning a binary tree gave us O.lg u/-time operations, which are asymptotically faster\nthan O.pu/ time. Using a tree of degree pu will turn out to be a key idea of van\nEmde Boas trees, however. We continue down this path in the next section.\nExercises\n20.1-1\nModify the data structures in this section to support duplicate keys.\n536\nChapter 20\nvan Emde Boas Trees\n20.1-2\nModify the data structures in this section to support keys that have associated satel-\nlite data.\n20.1-3\nObserve that, using the structures in this section, the way we ﬁnd the successor and\npredecessor of a value x does not depend on whether x is in the set at the time.\nShow how to ﬁnd the successor of x in a binary search tree when x is not stored in\nthe tree.\n20.1-4\nSuppose that instead of superimposing a tree of degree pu, we were to superim-\npose a tree of degree u1=k, where k > 1 is a constant. What would be the height of\nsuch a tree, and how long would each of the operations take?\n20.2\nA recursive structure\nIn this section, we modify the idea of superimposing a tree of degree pu on top of\na bit vector. In the previous section, we used a summary structure of size pu, with",
    "parent_64678c00-6eff-4c37-a1cf-c49492113d72": "such a tree, and how long would each of the operations take?\n20.2\nA recursive structure\nIn this section, we modify the idea of superimposing a tree of degree pu on top of\na bit vector. In the previous section, we used a summary structure of size pu, with\neach entry pointing to another stucture of size pu. Now, we make the structure\nrecursive, shrinking the universe size by the square root at each level of recursion.\nStarting with a universe of size u, we make structures holding pu D u1=2 items,\nwhich themselves hold structures of u1=4 items, which hold structures of u1=8 items,\nand so on, down to a base size of 2.\nFor simplicity, in this section, we assume that u D 22k for some integer k, so\nthat u; u1=2; u1=4; : : : are integers. This restriction would be quite severe in practice,\nallowing only values of u in the sequence 2; 4; 16; 256; 65536; : : :. We shall see in\nthe next section how to relax this assumption and assume only that u D 2k for\nsome integer k. Since the structure we examine in this section is only a precursor\nto the true van Emde Boas tree structure, we tolerate this restriction in favor of\naiding our understanding.\nRecalling that our goal is to achieve running times of O.lg lg u/ for the oper-\nations, let’s think about how we might obtain such running times. At the end of\nSection 4.3, we saw that by changing variables, we could show that the recurrence\nT .n/ D 2T\n\u000b\rpn\n˘\f\nC lg n\n(20.1)\nhas the solution T .n/ D O.lg n lg lg n/. Let’s consider a similar, but simpler,\nrecurrence:\nT .u/ D T .pu/ C O.1/ :\n(20.2)\n20.2\nA recursive structure\n537\nIf we use the same technique, changing variables, we can show that recur-\nrence (20.2) has the solution T .u/ D O.lg lg u/. Let m D lg u, so that u D 2m\nand we have\nT .2m/ D T .2m=2/ C O.1/ :\nNow we rename S.m/ D T .2m/, giving the new recurrence\nS.m/ D S.m=2/ C O.1/ :\nBy case 2 of the master method, this recurrence has the solution S.m/ D O.lg m/.",
    "parent_6924f5c4-42cc-48c8-a9fe-f9f24cc129dc": "rence (20.2) has the solution T .u/ D O.lg lg u/. Let m D lg u, so that u D 2m\nand we have\nT .2m/ D T .2m=2/ C O.1/ :\nNow we rename S.m/ D T .2m/, giving the new recurrence\nS.m/ D S.m=2/ C O.1/ :\nBy case 2 of the master method, this recurrence has the solution S.m/ D O.lg m/.\nWe change back from S.m/ to T .u/, giving T .u/ D T .2m/ D S.m/ D O.lg m/ D\nO.lg lg u/.\nRecurrence (20.2) will guide our search for a data structure. We will design a\nrecursive data structure that shrinks by a factor of pu in each level of its recursion.\nWhen an operation traverses this data structure, it will spend a constant amount of\ntime at each level before recursing to the level below. Recurrence (20.2) will then\ncharacterize the running time of the operation.\nHere is another way to think of how the term lg lg u ends up in the solution to\nrecurrence (20.2). As we look at the universe size in each level of the recursive data\nstructure, we see the sequence u; u1=2; u1=4; u1=8; : : :. If we consider how many bits\nwe need to store the universe size at each level, we need lg u at the top level, and\neach level needs half the bits of the previous level. In general, if we start with b\nbits and halve the number of bits at each level, then after lg b levels, we get down\nto just one bit. Since b D lg u, we see that after lg lg u levels, we have a universe\nsize of 2.\nLooking back at the data structure in Figure 20.2, a given value x resides in\ncluster number bx=puc. If we view x as a lg u-bit binary integer, that cluster\nnumber, bx=puc, is given by the most signiﬁcant .lg u/=2 bits of x. Within its\ncluster, x appears in position x mod pu, which is given by the least signiﬁcant\n.lg u/=2 bits of x. We will need to index in this way, and so let us deﬁne some\nfunctions that will help us do so:\nhigh.x/\nD\n\r\nx=pu\n˘\n;\nlow.x/\nD\nx mod pu ;\nindex.x; y/\nD\nxpu C y :\nThe function high.x/ gives the most signiﬁcant .lg u/=2 bits of x, producing the",
    "parent_a5662cda-6713-4211-9e5d-4ba12d168379": ".lg u/=2 bits of x. We will need to index in this way, and so let us deﬁne some\nfunctions that will help us do so:\nhigh.x/\nD\n\r\nx=pu\n˘\n;\nlow.x/\nD\nx mod pu ;\nindex.x; y/\nD\nxpu C y :\nThe function high.x/ gives the most signiﬁcant .lg u/=2 bits of x, producing the\nnumber of x’s cluster. The function low.x/ gives the least signiﬁcant .lg u/=2 bits\nof x and provides x’s position within its cluster. The function index.x; y/ builds an\nelement number from x and y, treating x as the most signiﬁcant .lg u/=2 bits of the\nelement number and y as the least signiﬁcant .lg u/=2 bits. We have the identity\nx D index.high.x/; low.x//. The value of u used by each of these functions will\n538\nChapter 20\nvan Emde Boas Trees\n…\n0\n1\n2\n3\npu \u0005 1\nproto-\u0003EB.u/\nu\nsummary\ncluster\nproto-\u0003EB.pu/ structure\npu proto-\u0003EB.pu/ structures\nFigure 20.3\nThe information in a proto-\u0003EB.u/ structure when u \u0006 4. The structure contains the\nuniverse size u, a pointer summary to a proto-\u0003EB.pu/ structure, and an array clusterŒ0 : : pu \u0005 1\u0002\nof pu pointers to proto-\u0003EB.pu/ structures.\nalways be the universe size of the data structure in which we call the function,\nwhich changes as we descend into the recursive structure.\n20.2.1\nProto van Emde Boas structures\nTaking our cue from recurrence (20.2), let us design a recursive data structure to\nsupport the operations. Although this data structure will fail to achieve our goal of\nO.lg lg u/ time for some operations, it serves as a basis for the van Emde Boas tree\nstructure that we will see in Section 20.3.\nFor the universe f0; 1; 2; : : : ; u \u0005 1g, we deﬁne a proto van Emde Boas struc-\nture, or proto-vEB structure, which we denote as proto-\u0003EB.u/, recursively as\nfollows. Each proto-\u0003EB.u/ structure contains an attribute u giving its universe\nsize. In addition, it contains the following:\n\u0002\nIf u D 2, then it is the base size, and it contains an array AŒ0 : : 1\u0002 of two bits.\n\u0002\nOtherwise, u D 22k for some integer k \u0006 1, so that u \u0006 4. In addition",
    "parent_4d38d2b8-15c3-46d9-829b-f638d7253d76": "follows. Each proto-\u0003EB.u/ structure contains an attribute u giving its universe\nsize. In addition, it contains the following:\n\u0002\nIf u D 2, then it is the base size, and it contains an array AŒ0 : : 1\u0002 of two bits.\n\u0002\nOtherwise, u D 22k for some integer k \u0006 1, so that u \u0006 4. In addition\nto the universe size u, the data structure proto-\u0003EB.u/ contains the following\nattributes, illustrated in Figure 20.3:\n\u0002 a pointer named summary to a proto-\u0003EB.pu/ structure and\n\u0002 an array clusterŒ0 : : pu\u00051\u0002 of pu pointers, each to a proto-\u0003EB.pu/ struc-\nture.\nThe element x, where 0 \u0002 x < u, is recursively stored in the cluster numbered\nhigh.x/ as element low.x/ within that cluster.\nIn the two-level structure of the previous section, each node stores a summary\narray of size pu, in which each entry contains a bit. From the index of each\nentry, we can compute the starting index of the subarray of size pu that the bit\nsummarizes. In the proto-vEB structure, we use explicit pointers rather than index\n20.2\nA recursive structure\n539\n0\n1\n2\n3\ncluster\nu 16\nsummary\nproto-vEB(16)\n0\n1\ncluster\nu\n4\nsummary\nproto-vEB(4)\n0\n1\nA\nproto-vEB(2)\n1\n1\n0\n1\ncluster\nu\n4\nsummary\nproto-vEB(4)\n0\n1\ncluster\nu\n4\nsummary\nproto-vEB(4)\n0\n1\ncluster\nu\n4\nsummary\nproto-vEB(4)\n0\n1\ncluster\nu\n4\nsummary\nproto-vEB(4)\nelements 0,1\nelements 2,3\nclusters 0,1\nclusters 2,3\nelements 4,5\nelements 6,7\nelements 8,9\nelements 10,11\nelements 12,13 elements 14,15\nu\n2\n0\n1\nA\nproto-vEB(2)\n1\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n0\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n0\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n0\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n0\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n1\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n1\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n1\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n0\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n1\n1\nu\n2\nFigure 20.4\nA proto-\u0003EB.16/ structure representing the set f2; 3; 4; 5; 7; 14; 15g. It points to four\nproto-\u0003EB.4/ structures in clusterŒ0 : : 3\u0002, and to a summary structure, which is also a proto-\u0003EB.4/.",
    "parent_c1a60182-070b-422e-9b92-b2b13dc37567": "0\n0\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n0\n1\nu\n2\n0\n1\nA\nproto-vEB(2)\n1\n1\nu\n2\nFigure 20.4\nA proto-\u0003EB.16/ structure representing the set f2; 3; 4; 5; 7; 14; 15g. It points to four\nproto-\u0003EB.4/ structures in clusterŒ0 : : 3\u0002, and to a summary structure, which is also a proto-\u0003EB.4/.\nEach proto-\u0003EB.4/ structure points to two proto-\u0003EB.2/ structures in clusterŒ0 : : 1\u0002, and to a\nproto-\u0003EB.2/ summary. Each proto-\u0003EB.2/ structure contains just an array AŒ0 : : 1\u0002 of two bits.\nThe proto-\u0003EB.2/ structures above “elements i,j” store bits i and j of the actual dynamic set, and\nthe proto-\u0003EB.2/ structures above “clusters i,j” store the summary bits for clusters i and j in the\ntop-level proto-\u0003EB.16/ structure. For clarity, heavy shading indicates the top level of a proto-vEB\nstructure that stores summary information for its parent structure; such a proto-vEB structure is\notherwise identical to any other proto-vEB structure with the same universe size.\n540\nChapter 20\nvan Emde Boas Trees\ncalculations. The array summary contains the summary bits stored recursively in a\nproto-vEB structure, and the array cluster contains pu pointers.\nFigure 20.4 shows a fully expanded proto-\u0003EB.16/ structure representing the\nset f2; 3; 4; 5; 7; 14; 15g. If the value i is in the proto-vEB structure pointed to by\nsummary, then the ith cluster contains some value in the set being represented.\nAs in the tree of constant height, clusterŒi\u0002 represents the values ipu through\n.i C 1/pu \u0005 1, which form the ith cluster.\nAt the base level, the elements of the actual dynamic sets are stored in some\nof the proto-\u0003EB.2/ structures, and the remaining proto-\u0003EB.2/ structures store\nsummary bits. Beneath each of the non-summary base structures, the ﬁgure in-\ndicates which bits it stores.\nFor example, the proto-\u0003EB.2/ structure labeled\n“elements 6,7” stores bit 6 (0, since element 6 is not in the set) in its AŒ0\u0002 and\nbit 7 (1, since element 7 is in the set) in its AŒ1\u0002.",
    "parent_92219b3f-5c03-44cc-a0ff-f6819ea7013b": "summary bits. Beneath each of the non-summary base structures, the ﬁgure in-\ndicates which bits it stores.\nFor example, the proto-\u0003EB.2/ structure labeled\n“elements 6,7” stores bit 6 (0, since element 6 is not in the set) in its AŒ0\u0002 and\nbit 7 (1, since element 7 is in the set) in its AŒ1\u0002.\nLike the clusters, each summary is just a dynamic set with universe size pu ,\nand so we represent each summary as a proto-\u0003EB.pu/ structure. The four sum-\nmary bits for the main proto-\u0003EB.16/ structure are in the leftmost proto-\u0003EB.4/\nstructure, and they ultimately appear in two proto-\u0003EB.2/ structures. For exam-\nple, the proto-\u0003EB.2/ structure labeled “clusters 2,3” has AŒ0\u0002 D 0, indicating that\ncluster 2 of the proto-\u0003EB.16/ structure (containing elements 8; 9; 10; 11) is all 0,\nand AŒ1\u0002 D 1, telling us that cluster 3 (containing elements 12; 13; 14; 15) has at\nleast one 1. Each proto-\u0003EB.4/ structure points to its own summary, which is itself\nstored as a proto-\u0003EB.2/ structure. For example, look at the proto-\u0003EB.2/ struc-\nture just to the left of the one labeled “elements 0,1.” Because its AŒ0\u0002 is 0, it tells\nus that the “elements 0,1” structure is all 0, and because its AŒ1\u0002 is 1, we know that\nthe “elements 2,3” structure contains at least one 1.\n20.2.2\nOperations on a proto van Emde Boas structure\nWe shall now describe how to perform operations on a proto-vEB structure.\nWe ﬁrst examine the query operations—MEMBER, MINIMUM, MAXIMUM, and\nSUCCESSOR—which do not change the proto-vEB structure.\nWe then discuss\nINSERT and DELETE. We leave MAXIMUM and PREDECESSOR, which are sym-\nmetric to MINIMUM and SUCCESSOR, respectively, as Exercise 20.2-1.\nEach of the MEMBER, SUCCESSOR, PREDECESSOR, INSERT, and DELETE op-\nerations takes a parameter x, along with a proto-vEB structure V . Each of these\noperations assumes that 0 \u0002 x < V:u.\nDetermining whether a value is in the set\nTo perform MEMBER.x/, we need to ﬁnd the bit corresponding to x within the",
    "parent_172a0e09-3e49-4975-9037-b6750ae24d23": "erations takes a parameter x, along with a proto-vEB structure V . Each of these\noperations assumes that 0 \u0002 x < V:u.\nDetermining whether a value is in the set\nTo perform MEMBER.x/, we need to ﬁnd the bit corresponding to x within the\nappropriate proto-\u0003EB.2/ structure. We can do so in O.lg lg u/ time, bypassing\n20.2\nA recursive structure\n541\nthe summary structures altogether. The following procedure takes a proto-\u0003EB\nstructure V and a value x, and it returns a bit indicating whether x is in the dynamic\nset held by V .\nPROTO-VEB-MEMBER.V; x/\n1\nif V:u == 2\n2\nreturn V:AŒx\u0002\n3\nelse return PROTO-VEB-MEMBER.V:clusterŒhigh.x/\u0002; low.x//\nThe PROTO-VEB-MEMBER procedure works as follows. Line 1 tests whether\nwe are in a base case, where V is a proto-\u0003EB.2/ structure. Line 2 handles the\nbase case, simply returning the appropriate bit of array A. Line 3 deals with the\nrecursive case, “drilling down” into the appropriate smaller proto-vEB structure.\nThe value high.x/ says which proto-\u0003EB.pu/ structure we visit, and low.x/ de-\ntermines which element within that proto-\u0003EB.pu/ structure we are querying.\nLet’s see what happens when we call PROTO-VEB-MEMBER.V; 6/ on the\nproto-\u0003EB.16/ structure in Figure 20.4. Since high.6/ D 1 when u D 16, we\nrecurse into the proto-\u0003EB.4/ structure in the upper right, and we ask about ele-\nment low.6/ D 2 of that structure. In this recursive call, u D 4, and so we recurse\nagain. With u D 4, we have high.2/ D 1 and low.2/ D 0, and so we ask about\nelement 0 of the proto-\u0003EB.2/ structure in the upper right. This recursive call turns\nout to be a base case, and so it returns AŒ0\u0002 D 0 back up through the chain of re-\ncursive calls. Thus, we get the result that PROTO-VEB-MEMBER.V; 6/ returns 0,\nindicating that 6 is not in the set.\nTo determine the running time of PROTO-VEB-MEMBER, let T .u/ denote\nits running time on a proto-\u0003EB.u/ structure.\nEach recursive call takes con-\nstant time, not including the time taken by the recursive calls that it makes.",
    "parent_6862a4d3-f488-49ea-8bfd-96fbb67320d7": "indicating that 6 is not in the set.\nTo determine the running time of PROTO-VEB-MEMBER, let T .u/ denote\nits running time on a proto-\u0003EB.u/ structure.\nEach recursive call takes con-\nstant time, not including the time taken by the recursive calls that it makes.\nWhen PROTO-VEB-MEMBER makes a recursive call, it makes a call on a\nproto-\u0003EB.pu/ structure. Thus, we can characterize the running time by the recur-\nrence T .u/ D T .pu/ C O.1/, which we have already seen as recurrence (20.2).\nIts solution is T .u/ D O.lg lg u/, and so we conclude that PROTO-VEB-MEMBER\nruns in time O.lg lg u/.\nFinding the minimum element\nNow we examine how to perform the MINIMUM operation.\nThe procedure\nPROTO-VEB-MINIMUM.V / returns the minimum element in the proto-vEB struc-\nture V , or NIL if V represents an empty set.\n542\nChapter 20\nvan Emde Boas Trees\nPROTO-VEB-MINIMUM.V /\n1\nif V:u == 2\n2\nif V:AŒ0\u0002 == 1\n3\nreturn 0\n4\nelseif V:AŒ1\u0002 == 1\n5\nreturn 1\n6\nelse return NIL\n7\nelse min-cluster D PROTO-VEB-MINIMUM.V:summary/\n8\nif min-cluster == NIL\n9\nreturn NIL\n10\nelse offset D PROTO-VEB-MINIMUM.V:clusterŒmin-cluster\u0002/\n11\nreturn index.min-cluster; offset/\nThis procedure works as follows. Line 1 tests for the base case, which lines 2–6\nhandle by brute force. Lines 7–11 handle the recursive case. First, line 7 ﬁnds the\nnumber of the ﬁrst cluster that contains an element of the set. It does so by recur-\nsively calling PROTO-VEB-MINIMUM on V:summary, which is a proto-\u0003EB.pu/\nstructure. Line 7 assigns this cluster number to the variable min-cluster. If the set\nis empty, then the recursive call returned NIL, and line 9 returns NIL. Otherwise,\nthe minimum element of the set is somewhere in cluster number min-cluster. The\nrecursive call in line 10 ﬁnds the offset within the cluster of the minimum element\nin this cluster. Finally, line 11 constructs the value of the minimum element from\nthe cluster number and offset, and it returns this value.",
    "parent_c43f921b-3d02-4924-8a27-42815e2519e7": "recursive call in line 10 ﬁnds the offset within the cluster of the minimum element\nin this cluster. Finally, line 11 constructs the value of the minimum element from\nthe cluster number and offset, and it returns this value.\nAlthough querying the summary information allows us to quickly ﬁnd the clus-\nter containing the minimum element, because this procedure makes two recursive\ncalls on proto-\u0003EB.pu/ structures, it does not run in O.lg lg u/ time in the worst\ncase. Letting T .u/ denote the worst-case time for PROTO-VEB-MINIMUM on a\nproto-\u0003EB.u/ structure, we have the recurrence\nT .u/ D 2T .pu/ C O.1/ :\n(20.3)\nAgain, we use a change of variables to solve this recurrence, letting m D lg u,\nwhich gives\nT .2m/ D 2T .2m=2/ C O.1/ :\nRenaming S.m/ D T .2m/ gives\nS.m/ D 2S.m=2/ C O.1/ ;\nwhich, by case 1 of the master method, has the solution S.m/ D ‚.m/. By chang-\ning back from S.m/ to T .u/, we have that T .u/ D T .2m/ D S.m/ D ‚.m/ D\n‚.lg u/. Thus, we see that because of the second recursive call, PROTO-VEB-\nMINIMUM runs in ‚.lg u/ time rather than the desired O.lg lg u/ time.\n20.2\nA recursive structure\n543\nFinding the successor\nThe SUCCESSOR operation is even worse. In the worst case, it makes two recursive\ncalls, along with a call to PROTO-VEB-MINIMUM. The procedure PROTO-VEB-\nSUCCESSOR.V; x/ returns the smallest element in the proto-vEB structure V that\nis greater than x, or NIL if no element in V is greater than x. It does not require x\nto be a member of the set, but it does assume that 0 \u0002 x < V:u.\nPROTO-VEB-SUCCESSOR.V; x/\n1\nif V:u == 2\n2\nif x == 0 and V:AŒ1\u0002 == 1\n3\nreturn 1\n4\nelse return NIL\n5\nelse offset D PROTO-VEB-SUCCESSOR.V:clusterŒhigh.x/\u0002; low.x//\n6\nif offset ¤ NIL\n7\nreturn index.high.x/; offset/\n8\nelse succ-cluster D PROTO-VEB-SUCCESSOR.V:summary; high.x//\n9\nif succ-cluster == NIL\n10\nreturn NIL\n11\nelse offset D PROTO-VEB-MINIMUM.V:clusterŒsucc-cluster\u0002/\n12\nreturn index.succ-cluster; offset/",
    "parent_7ebb0e32-7c28-40d2-874a-771cc7f8083d": "6\nif offset ¤ NIL\n7\nreturn index.high.x/; offset/\n8\nelse succ-cluster D PROTO-VEB-SUCCESSOR.V:summary; high.x//\n9\nif succ-cluster == NIL\n10\nreturn NIL\n11\nelse offset D PROTO-VEB-MINIMUM.V:clusterŒsucc-cluster\u0002/\n12\nreturn index.succ-cluster; offset/\nThe PROTO-VEB-SUCCESSOR procedure works as follows. As usual, line 1\ntests for the base case, which lines 2–4 handle by brute force: the only way that x\ncan have a successor within a proto-\u0003EB.2/ structure is when x D 0 and AŒ1\u0002\nis 1. Lines 5–12 handle the recursive case. Line 5 searches for a successor to x\nwithin x’s cluster, assigning the result to offset. Line 6 determines whether x has\na successor within its cluster; if it does, then line 7 computes and returns the value\nof this successor. Otherwise, we have to search in other clusters. Line 8 assigns to\nsucc-cluster the number of the next nonempty cluster, using the summary informa-\ntion to ﬁnd it. Line 9 tests whether succ-cluster is NIL, with line 10 returning NIL\nif all succeeding clusters are empty. If succ-cluster is non-NIL, line 11 assigns\nthe ﬁrst element within that cluster to offset, and line 12 computes and returns the\nminimum element in that cluster.\nIn the worst case, PROTO-VEB-SUCCESSOR calls itself recursively twice on\nproto-\u0003EB.pu/ structures, and it makes one call to PROTO-VEB-MINIMUM on\na proto-\u0003EB.pu/ structure.\nThus, the recurrence for the worst-case running\ntime T .u/ of PROTO-VEB-SUCCESSOR is\nT .u/\nD\n2T .pu/ C ‚.lg pu/\nD\n2T .pu/ C ‚.lg u/ :\n544\nChapter 20\nvan Emde Boas Trees\nWe can employ the same technique that we used for recurrence (20.1) to show\nthat this recurrence has the solution T .u/ D ‚.lg u lg lg u/. Thus, PROTO-VEB-\nSUCCESSOR is asymptotically slower than PROTO-VEB-MINIMUM.\nInserting an element\nTo insert an element, we need to insert it into the appropriate cluster and also set\nthe summary bit for that cluster to 1. The procedure PROTO-VEB-INSERT.V; x/\ninserts the value x into the proto-vEB structure V .\nPROTO-VEB-INSERT.V; x/\n1",
    "parent_da51c3a9-da25-40a6-ab2b-7ad07d9efbb6": "Inserting an element\nTo insert an element, we need to insert it into the appropriate cluster and also set\nthe summary bit for that cluster to 1. The procedure PROTO-VEB-INSERT.V; x/\ninserts the value x into the proto-vEB structure V .\nPROTO-VEB-INSERT.V; x/\n1\nif V:u == 2\n2\nV:AŒx\u0002 D 1\n3\nelse PROTO-VEB-INSERT.V:clusterŒhigh.x/\u0002; low.x//\n4\nPROTO-VEB-INSERT.V:summary; high.x//\nIn the base case, line 2 sets the appropriate bit in the array A to 1. In the recursive\ncase, the recursive call in line 3 inserts x into the appropriate cluster, and line 4\nsets the summary bit for that cluster to 1.\nBecause PROTO-VEB-INSERT makes two recursive calls in the worst case, re-\ncurrence (20.3) characterizes its running time. Hence, PROTO-VEB-INSERT runs\nin ‚.lg u/ time.\nDeleting an element\nThe DELETE operation is more complicated than insertion. Whereas we can always\nset a summary bit to 1 when inserting, we cannot always reset the same summary\nbit to 0 when deleting. We need to determine whether any bit in the appropriate\ncluster is 1. As we have deﬁned proto-vEB structures, we would have to examine\nall pu bits within a cluster to determine whether any of them are 1. Alternatively,\nwe could add an attribute n to the proto-vEB structure, counting how many el-\nements it has. We leave implementation of PROTO-VEB-DELETE as Exercises\n20.2-2 and 20.2-3.\nClearly, we need to modify the proto-vEB structure to get each operation down\nto making at most one recursive call. We will see in the next section how to do so.\nExercises\n20.2-1\nWrite pseudocode for the procedures PROTO-VEB-MAXIMUM and PROTO-VEB-\nPREDECESSOR.\n20.3\nThe van Emde Boas tree\n545\n20.2-2\nWrite pseudocode for PROTO-VEB-DELETE.\nIt should update the appropriate\nsummary bit by scanning the related bits within the cluster. What is the worst-\ncase running time of your procedure?\n20.2-3\nAdd the attribute n to each proto-vEB structure, giving the number of elements",
    "parent_c97b6343-1e39-45d5-8de1-1a5a4127fa2f": "545\n20.2-2\nWrite pseudocode for PROTO-VEB-DELETE.\nIt should update the appropriate\nsummary bit by scanning the related bits within the cluster. What is the worst-\ncase running time of your procedure?\n20.2-3\nAdd the attribute n to each proto-vEB structure, giving the number of elements\ncurrently in the set it represents, and write pseudocode for PROTO-VEB-DELETE\nthat uses the attribute n to decide when to reset summary bits to 0. What is the\nworst-case running time of your procedure? What other procedures need to change\nbecause of the new attribute? Do these changes affect their running times?\n20.2-4\nModify the proto-vEB structure to support duplicate keys.\n20.2-5\nModify the proto-vEB structure to support keys that have associated satellite data.\n20.2-6\nWrite pseudocode for a procedure that creates a proto-\u0003EB.u/ structure.\n20.2-7\nArgue that if line 9 of PROTO-VEB-MINIMUM is executed, then the proto-vEB\nstructure is empty.\n20.2-8\nSuppose that we designed a proto-vEB structure in which each cluster array had\nonly u1=4 elements. What would the running times of each operation be?\n20.3\nThe van Emde Boas tree\nThe proto-vEB structure of the previous section is close to what we need to achieve\nO.lg lg u/ running times. It falls short because we have to recurse too many times\nin most of the operations. In this section, we shall design a data structure that\nis similar to the proto-vEB structure but stores a little more information, thereby\nremoving the need for some of the recursion.\nIn Section 20.2, we observed that the assumption that we made about the uni-\nverse size—that u D 22k for some integer k—is unduly restrictive, conﬁning the\npossible values of u an overly sparse set. From this point on, therefore, we will\nallow the universe size u to be any exact power of 2, and when pu is not an inte-\n546\nChapter 20\nvan Emde Boas Trees\n…\n0\n1\n2\n3\n\"pu \u0005 1\n\u0003EB.u/\nu\nmin\nmax\nsummary\ncluster\n\u0003EB. \"pu/\n\"pu \u0003EB. #pu/ trees\nFigure 20.5",
    "parent_e2e9328d-789e-4135-9608-7c33096259e4": "possible values of u an overly sparse set. From this point on, therefore, we will\nallow the universe size u to be any exact power of 2, and when pu is not an inte-\n546\nChapter 20\nvan Emde Boas Trees\n…\n0\n1\n2\n3\n\"pu \u0005 1\n\u0003EB.u/\nu\nmin\nmax\nsummary\ncluster\n\u0003EB. \"pu/\n\"pu \u0003EB. #pu/ trees\nFigure 20.5\nThe information in a \u0003EB.u/ tree when u > 2. The structure contains the uni-\nverse size u, elements min and max, a pointer summary to a \u0003EB. \"pu/ tree, and an array\nclusterŒ0 : : \"pu \u0005 1\u0002 of\n\"pu pointers to \u0003EB. #pu/ trees.\nger—that is, if u is an odd power of 2 (u D 22kC1 for some integer k \u0006 0)—then\nwe will divide the lg u bits of a number into the most signiﬁcant d.lg u/=2e bits and\nthe least signiﬁcant b.lg u/=2c bits. For convenience, we denote 2d.lg u/=2e (the “up-\nper square root” of u) by\n\"pu and 2b.lg u/=2c (the “lower square root” of u) by\n#pu,\nso that u D\n\"pu \u0003\n#pu and, when u is an even power of 2 (u D 22k for some\ninteger k),\n\"pu D\n#pu D pu. Because we now allow u to be an odd power of 2,\nwe must redeﬁne our helpful functions from Section 20.2:\nhigh.x/\nD\n\r\nx=\n#pu\n˘\n;\nlow.x/\nD\nx mod\n#pu ;\nindex.x; y/\nD\nx\n#pu C y :\n20.3.1\nvan Emde Boas trees\nThe van Emde Boas tree, or vEB tree, modiﬁes the proto-vEB structure. We\ndenote a vEB tree with a universe size of u as \u0003EB.u/ and, unless u equals the\nbase size of 2, the attribute summary points to a \u0003EB. \"pu/ tree and the array\nclusterŒ0 : :\n\"pu \u0005 1\u0002 points to\n\"pu \u0003EB. #pu/ trees. As Figure 20.5 illustrates, a\nvEB tree contains two attributes not found in a proto-vEB structure:\n\u0002\nmin stores the minimum element in the vEB tree, and\n\u0002\nmax stores the maximum element in the vEB tree.\nFurthermore, the element stored in min does not appear in any of the recur-\nsive \u0003EB. #pu/ trees that the cluster array points to. The elements stored in a\n\u0003EB.u/ tree V , therefore, are V:min plus all the elements recursively stored in\nthe \u0003EB. #pu/ trees pointed to by V:clusterŒ0 : :\n\"pu \u0005 1\u0002. Note that when a vEB",
    "parent_170f64e8-a67d-4e53-a0dd-97328f120d40": "sive \u0003EB. #pu/ trees that the cluster array points to. The elements stored in a\n\u0003EB.u/ tree V , therefore, are V:min plus all the elements recursively stored in\nthe \u0003EB. #pu/ trees pointed to by V:clusterŒ0 : :\n\"pu \u0005 1\u0002. Note that when a vEB\ntree contains two or more elements, we treat min and max differently: the element\n20.3\nThe van Emde Boas tree\n547\nstored in min does not appear in any of the clusters, but the element stored in max\ndoes.\nSince the base size is 2, a \u0003EB.2/ tree does not need the array A that the cor-\nresponding proto-\u0003EB.2/ structure has. Instead, we can determine its elements\nfrom its min and max attributes. In a vEB tree with no elements, regardless of its\nuniverse size u, both min and max are NIL.\nFigure 20.6 shows a \u0003EB.16/ tree V holding the set f2; 3; 4; 5; 7; 14; 15g. Be-\ncause the smallest element is 2, V:min equals 2, and even though high.2/ D 0, the\nelement 2 does not appear in the \u0003EB.4/ tree pointed to by V:clusterŒ0\u0002: notice\nthat V:clusterŒ0\u0002:min equals 3, and so 2 is not in this vEB tree. Similarly, since\nV:clusterŒ0\u0002:min equals 3, and 2 and 3 are the only elements in V:clusterŒ0\u0002, the\n\u0003EB.2/ clusters within V:clusterŒ0\u0002 are empty.\nThe min and max attributes will turn out to be key to reducing the number of\nrecursive calls within the operations on vEB trees. These attributes will help us in\nfour ways:\n1. The MINIMUM and MAXIMUM operations do not even need to recurse, for they\ncan just return the values of min or max.\n2. The SUCCESSOR operation can avoid making a recursive call to determine\nwhether the successor of a value x lies within high.x/. That is because x’s\nsuccessor lies within its cluster if and only if x is strictly less than the max\nattribute of its cluster. A symmetric argument holds for PREDECESSOR and\nmin.\n3. We can tell whether a vEB tree has no elements, exactly one element, or at least\ntwo elements in constant time from its min and max values. This ability will",
    "parent_07fb1789-f4cc-49fc-a7fb-4cbeb838f997": "attribute of its cluster. A symmetric argument holds for PREDECESSOR and\nmin.\n3. We can tell whether a vEB tree has no elements, exactly one element, or at least\ntwo elements in constant time from its min and max values. This ability will\nhelp in the INSERT and DELETE operations. If min and max are both NIL, then\nthe vEB tree has no elements. If min and max are non-NIL but are equal to each\nother, then the vEB tree has exactly one element. Otherwise, both min and max\nare non-NIL but are unequal, and the vEB tree has two or more elements.\n4. If we know that a vEB tree is empty, we can insert an element into it by updating\nonly its min and max attributes. Hence, we can insert into an empty vEB tree in\nconstant time. Similarly, if we know that a vEB tree has only one element, we\ncan delete that element in constant time by updating only min and max. These\nproperties will allow us to cut short the chain of recursive calls.\nEven if the universe size u is an odd power of 2, the difference in the sizes\nof the summary vEB tree and the clusters will not turn out to affect the asymptotic\nrunning times of the vEB-tree operations. The recursive procedures that implement\nthe vEB-tree operations will all have running times characterized by the recurrence\nT .u/ \u0002 T .\n\"pu/ C O.1/ :\n(20.4)\n548\nChapter 20\nvan Emde Boas Trees\n0\n1\n2\n3\ncluster\nu 16\nsummary\nvEB(16)\nmin 2\nmax 15\n0\n1\ncluster\nu 4\nsummary\nvEB(4)\nmin 0\nmax 3\nu 2\nmin 0\nmax 1\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\n0\n1\ncluster\nsummary\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\n0\n1\ncluster\nsummary\nu 2\nmin 0\nmax 1\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\n0\n1\ncluster\nsummary\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\n0\n1\ncluster\nsummary\nu 2\nmin 1\nmax 1\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\nu 4\nvEB(4)\nmin 3\nmax 3\nu 4\nvEB(4)\nmin 0\nmax 3\nu 4\nvEB(4)\nmin\nmax\nu 4\nvEB(4)\nmin 2\nmax 3\nFigure 20.6",
    "parent_ea7e1fd6-d01f-416a-a1e8-6db907d07ed8": "max 1\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\n0\n1\ncluster\nsummary\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\n0\n1\ncluster\nsummary\nu 2\nmin 1\nmax 1\nvEB(2)\nu 2\nmin\nmax\nvEB(2)\nu 2\nmin 1\nmax 1\nvEB(2)\nu 4\nvEB(4)\nmin 3\nmax 3\nu 4\nvEB(4)\nmin 0\nmax 3\nu 4\nvEB(4)\nmin\nmax\nu 4\nvEB(4)\nmin 2\nmax 3\nFigure 20.6\nA \u0003EB.16/ tree corresponding to the proto-vEB tree in Figure 20.4. It stores the set\nf2; 3; 4; 5; 7; 14; 15g. Slashes indicate NIL values. The value stored in the min attribute of a vEB tree\ndoes not appear in any of its clusters. Heavy shading serves the same purpose here as in Figure 20.4.\n20.3\nThe van Emde Boas tree\n549\nThis recurrence looks similar to recurrence (20.2), and we will solve it in a similar\nfashion. Letting m D lg u, we rewrite it as\nT .2m/ \u0002 T .2dm=2e/ C O.1/ :\nNoting that dm=2e \u0002 2m=3 for all m \u0006 2, we have\nT .2m/ \u0002 T .22m=3/ C O.1/ :\nLetting S.m/ D T .2m/, we rewrite this last recurrence as\nS.m/ \u0002 S.2m=3/ C O.1/ ;\nwhich, by case 2 of the master method, has the solution S.m/ D O.lg m/. (In\nterms of the asymptotic solution, the fraction 2=3 does not make any difference\ncompared with the fraction 1=2, because when we apply the master method, we\nﬁnd that log3=2 1 D log2 1 D 0:) Thus, we have T .u/ D T .2m/ D S.m/ D\nO.lg m/ D O.lg lg u/.\nBefore using a van Emde Boas tree, we must know the universe size u, so that\nwe can create a van Emde Boas tree of the appropriate size that initially represents\nan empty set. As Problem 20-1 asks you to show, the total space requirement of\na van Emde Boas tree is O.u/, and it is straightforward to create an empty tree\nin O.u/ time. In contrast, we can create an empty red-black tree in constant time.\nTherefore, we might not want to use a van Emde Boas tree when we perform only\na small number of operations, since the time to create the data structure would\nexceed the time saved in the individual operations. This drawback is usually not\nsigniﬁcant, since we typically use a simple data structure, such as an array or linked",
    "parent_979405b2-f848-4e68-a8a7-93d1c46ef3cb": "a small number of operations, since the time to create the data structure would\nexceed the time saved in the individual operations. This drawback is usually not\nsigniﬁcant, since we typically use a simple data structure, such as an array or linked\nlist, to represent a set with only a few elements.\n20.3.2\nOperations on a van Emde Boas tree\nWe are now ready to see how to perform operations on a van Emde Boas tree. As\nwe did for the proto van Emde Boas structure, we will consider the querying oper-\nations ﬁrst, and then INSERT and DELETE. Due to the slight asymmetry between\nthe minimum and maximum elements in a vEB tree—when a vEB tree contains\nat least two elements, the minumum element does not appear within a cluster but\nthe maximum element does—we will provide pseudocode for all ﬁve querying op-\nerations. As in the operations on proto van Emde Boas structures, the operations\nhere that take parameters V and x, where V is a van Emde Boas tree and x is an\nelement, assume that 0 \u0002 x < V:u.\nFinding the minimum and maximum elements\nBecause we store the minimum and maximum in the attributes min and max, two\nof the operations are one-liners, taking constant time:\n550\nChapter 20\nvan Emde Boas Trees\nVEB-TREE-MINIMUM.V /\n1\nreturn V:min\nVEB-TREE-MAXIMUM.V /\n1\nreturn V:max\nDetermining whether a value is in the set\nThe procedure VEB-TREE-MEMBER.V; x/ has a recursive case like that of\nPROTO-VEB-MEMBER, but the base case is a little different. We also check di-\nrectly whether x equals the minimum or maximum element. Since a vEB tree\ndoesn’t store bits as a proto-vEB structure does, we design VEB-TREE-MEMBER\nto return TRUE or FALSE rather than 1 or 0.\nVEB-TREE-MEMBER.V; x/\n1\nif x == V:min or x == V:max\n2\nreturn TRUE\n3\nelseif V:u == 2\n4\nreturn FALSE\n5\nelse return VEB-TREE-MEMBER.V:clusterŒhigh.x/\u0002; low.x//\nLine 1 checks to see whether x equals either the minimum or maximum element.\nIf it does, line 2 returns TRUE. Otherwise, line 3 tests for the base case. Since",
    "parent_92ec14c1-73be-4c3e-b3db-2f561c3c1a13": "1\nif x == V:min or x == V:max\n2\nreturn TRUE\n3\nelseif V:u == 2\n4\nreturn FALSE\n5\nelse return VEB-TREE-MEMBER.V:clusterŒhigh.x/\u0002; low.x//\nLine 1 checks to see whether x equals either the minimum or maximum element.\nIf it does, line 2 returns TRUE. Otherwise, line 3 tests for the base case. Since\na \u0003EB.2/ tree has no elements other than those in min and max, if it is the base\ncase, line 4 returns FALSE. The other possibility—it is not a base case and x equals\nneither min nor max—is handled by the recursive call in line 5.\nRecurrence (20.4) characterizes the running time of the VEB-TREE-MEMBER\nprocedure, and so this procedure takes O.lg lg u/ time.\nFinding the successor and predecessor\nNext we see how to implement the SUCCESSOR operation. Recall that the pro-\ncedure PROTO-VEB-SUCCESSOR.V; x/ could make two recursive calls: one to\ndetermine whether x’s successor resides in the same cluster as x and, if it does\nnot, one to ﬁnd the cluster containing x’s successor. Because we can access the\nmaximum value in a vEB tree quickly, we can avoid making two recursive calls,\nand instead make one recursive call on either a cluster or on the summary, but not\non both.\n20.3\nThe van Emde Boas tree\n551\nVEB-TREE-SUCCESSOR.V; x/\n1\nif V:u == 2\n2\nif x == 0 and V:max == 1\n3\nreturn 1\n4\nelse return NIL\n5\nelseif V:min ¤ NIL and x < V:min\n6\nreturn V:min\n7\nelse max-low D VEB-TREE-MAXIMUM.V:clusterŒhigh.x/\u0002/\n8\nif max-low ¤ NIL and low.x/ < max-low\n9\noffset D VEB-TREE-SUCCESSOR.V:clusterŒhigh.x/\u0002; low.x//\n10\nreturn index.high.x/; offset/\n11\nelse succ-cluster D VEB-TREE-SUCCESSOR.V:summary; high.x//\n12\nif succ-cluster == NIL\n13\nreturn NIL\n14\nelse offset D VEB-TREE-MINIMUM.V:clusterŒsucc-cluster\u0002/\n15\nreturn index.succ-cluster; offset/\nThis procedure has six return statements and several cases. We start with the\nbase case in lines 2–4, which returns 1 in line 3 if we are trying to ﬁnd the successor\nof 0 and 1 is in the 2-element set; otherwise, the base case returns NIL in line 4.",
    "parent_fd247744-9d33-425f-b359-cffb57a497a7": "15\nreturn index.succ-cluster; offset/\nThis procedure has six return statements and several cases. We start with the\nbase case in lines 2–4, which returns 1 in line 3 if we are trying to ﬁnd the successor\nof 0 and 1 is in the 2-element set; otherwise, the base case returns NIL in line 4.\nIf we are not in the base case, we next check in line 5 whether x is strictly less\nthan the minimum element. If so, then we simply return the minimum element in\nline 6.\nIf we get to line 7, then we know that we are not in a base case and that x is\ngreater than or equal to the minimum value in the vEB tree V . Line 7 assigns to\nmax-low the maximum element in x’s cluster. If x’s cluster contains some element\nthat is greater than x, then we know that x’s successor lies somewhere within x’s\ncluster. Line 8 tests for this condition. If x’s successor is within x’s cluster, then\nline 9 determines where in the cluster it is, and line 10 returns the successor in the\nsame way as line 7 of PROTO-VEB-SUCCESSOR.\nWe get to line 11 if x is greater than or equal to the greatest element in its\ncluster. In this case, lines 11–15 ﬁnd x’s successor in the same way as lines 8–12\nof PROTO-VEB-SUCCESSOR.\nIt is easy to see how recurrence (20.4) characterizes the running time of VEB-\nTREE-SUCCESSOR. Depending on the result of the test in line 7, the procedure\ncalls itself recursively in either line 9 (on a vEB tree with universe size\n#pu) or\nline 11 (on a vEB tree with universe size\n\"pu). In either case, the one recursive\ncall is on a vEB tree with universe size at most\n\"pu. The remainder of the proce-\ndure, including the calls to VEB-TREE-MINIMUM and VEB-TREE-MAXIMUM,\ntakes O.1/ time. Hence, VEB-TREE-SUCCESSOR runs in O.lg lg u/ worst-case\ntime.\n552\nChapter 20\nvan Emde Boas Trees\nThe VEB-TREE-PREDECESSOR procedure is symmetric to the VEB-TREE-\nSUCCESSOR procedure, but with one additional case:\nVEB-TREE-PREDECESSOR.V; x/\n1\nif V:u == 2\n2\nif x == 1 and V:min == 0\n3\nreturn 0\n4\nelse return NIL\n5",
    "parent_d3627024-4820-4fde-b5d8-8b2474b6f9fa": "time.\n552\nChapter 20\nvan Emde Boas Trees\nThe VEB-TREE-PREDECESSOR procedure is symmetric to the VEB-TREE-\nSUCCESSOR procedure, but with one additional case:\nVEB-TREE-PREDECESSOR.V; x/\n1\nif V:u == 2\n2\nif x == 1 and V:min == 0\n3\nreturn 0\n4\nelse return NIL\n5\nelseif V:max ¤ NIL and x > V:max\n6\nreturn V:max\n7\nelse min-low D VEB-TREE-MINIMUM.V:clusterŒhigh.x/\u0002/\n8\nif min-low ¤ NIL and low.x/ > min-low\n9\noffset D VEB-TREE-PREDECESSOR.V:clusterŒhigh.x/\u0002; low.x//\n10\nreturn index.high.x/; offset/\n11\nelse pred-cluster D VEB-TREE-PREDECESSOR.V:summary; high.x//\n12\nif pred-cluster == NIL\n13\nif V:min ¤ NIL and x > V:min\n14\nreturn V:min\n15\nelse return NIL\n16\nelse offset D VEB-TREE-MAXIMUM.V:clusterŒpred-cluster\u0002/\n17\nreturn index.pred-cluster; offset/\nLines 13–14 form the additional case. This case occurs when x’s predecessor,\nif it exists, does not reside in x’s cluster. In VEB-TREE-SUCCESSOR, we were\nassured that if x’s successor resides outside of x’s cluster, then it must reside in\na higher-numbered cluster. But if x’s predecessor is the minimum value in vEB\ntree V , then the successor resides in no cluster at all. Line 13 checks for this\ncondition, and line 14 returns the minimum value as appropriate.\nThis extra case does not affect the asymptotic running time of VEB-TREE-\nPREDECESSOR when compared with VEB-TREE-SUCCESSOR, and so VEB-\nTREE-PREDECESSOR runs in O.lg lg u/ worst-case time.\nInserting an element\nNow we examine how to insert an element into a vEB tree. Recall that PROTO-\nVEB-INSERT made two recursive calls: one to insert the element and one to insert\nthe element’s cluster number into the summary. The VEB-TREE-INSERT proce-\ndure will make only one recursive call. How can we get away with just one? When\nwe insert an element, either the cluster that it goes into already has another element\nor it does not. If the cluster already has another element, then the cluster number\nis already in the summary, and so we do not need to make that recursive call. If\n20.3",
    "parent_87367bc5-947e-4ed2-a7ca-dd71f67f7cb1": "we insert an element, either the cluster that it goes into already has another element\nor it does not. If the cluster already has another element, then the cluster number\nis already in the summary, and so we do not need to make that recursive call. If\n20.3\nThe van Emde Boas tree\n553\nthe cluster does not already have another element, then the element being inserted\nbecomes the only element in the cluster, and we do not need to recurse to insert an\nelement into an empty vEB tree:\nVEB-EMPTY-TREE-INSERT.V; x/\n1\nV:min D x\n2\nV:max D x\nWith this procedure in hand, here is the pseudocode for VEB-TREE-INSERT.V; x/,\nwhich assumes that x is not already an element in the set represented by vEB\ntree V :\nVEB-TREE-INSERT.V; x/\n1\nif V:min == NIL\n2\nVEB-EMPTY-TREE-INSERT.V; x/\n3\nelse if x < V:min\n4\nexchange x with V:min\n5\nif V:u > 2\n6\nif VEB-TREE-MINIMUM.V:clusterŒhigh.x/\u0002/ == NIL\n7\nVEB-TREE-INSERT.V:summary; high.x//\n8\nVEB-EMPTY-TREE-INSERT.V:clusterŒhigh.x/\u0002; low.x//\n9\nelse VEB-TREE-INSERT.V:clusterŒhigh.x/\u0002; low.x//\n10\nif x > V:max\n11\nV:max D x\nThis procedure works as follows. Line 1 tests whether V is an empty vEB tree\nand, if it is, then line 2 handles this easy case. Lines 3–11 assume that V is not\nempty, and therefore some element will be inserted into one of V ’s clusters. But\nthat element might not necessarily be the element x passed to VEB-TREE-INSERT.\nIf x < min, as tested in line 3, then x needs to become the new min. We don’t\nwant to lose the original min, however, and so we need to insert it into one of V ’s\nclusters. In this case, line 4 exchanges x with min, so that we insert the original\nmin into one of V ’s clusters.\nWe execute lines 6–9 only if V is not a base-case vEB tree. Line 6 determines\nwhether the cluster that x will go into is currently empty. If so, then line 7 in-\nserts x’s cluster number into the summary and line 8 handles the easy case of\ninserting x into an empty cluster. If x’s cluster is not currently empty, then line 9",
    "parent_71d06ed2-f004-4886-b6ed-a331ceca5a65": "whether the cluster that x will go into is currently empty. If so, then line 7 in-\nserts x’s cluster number into the summary and line 8 handles the easy case of\ninserting x into an empty cluster. If x’s cluster is not currently empty, then line 9\ninserts x into its cluster. In this case, we do not need to update the summary,\nsince x’s cluster number is already a member of the summary.\nFinally, lines 10–11 take care of updating max if x > max. Note that if V is a\nbase-case vEB tree that is not empty, then lines 3–4 and 10–11 update min and max\nproperly.\n554\nChapter 20\nvan Emde Boas Trees\nOnce again, we can easily see how recurrence (20.4) characterizes the running\ntime. Depending on the result of the test in line 6, either the recursive call in line 7\n(run on a vEB tree with universe size\n\"pu) or the recursive call in line 9 (run on\na vEB with universe size\n#pu) executes. In either case, the one recursive call is\non a vEB tree with universe size at most\n\"pu. Because the remainder of VEB-\nTREE-INSERT takes O.1/ time, recurrence (20.4) applies, and so the running time\nis O.lg lg u/.\nDeleting an element\nFinally, we look at how to delete an element from a vEB tree. The procedure\nVEB-TREE-DELETE.V; x/ assumes that x is currently an element in the set repre-\nsented by the vEB tree V .\nVEB-TREE-DELETE.V; x/\n1\nif V:min == V:max\n2\nV:min D NIL\n3\nV:max D NIL\n4\nelseif V:u == 2\n5\nif x == 0\n6\nV:min D 1\n7\nelse V:min D 0\n8\nV:max D V:min\n9\nelse if x == V:min\n10\nﬁrst-cluster D VEB-TREE-MINIMUM.V:summary/\n11\nx D index.ﬁrst-cluster;\nVEB-TREE-MINIMUM.V:clusterŒﬁrst-cluster\u0002//\n12\nV:min D x\n13\nVEB-TREE-DELETE.V:clusterŒhigh.x/\u0002; low.x//\n14\nif VEB-TREE-MINIMUM.V:clusterŒhigh.x/\u0002/ == NIL\n15\nVEB-TREE-DELETE.V:summary; high.x//\n16\nif x == V:max\n17\nsummary-max D VEB-TREE-MAXIMUM.V:summary/\n18\nif summary-max == NIL\n19\nV:max D V:min\n20\nelse V:max D index.summary-max;\nVEB-TREE-MAXIMUM.V:clusterŒsummary-max\u0002//\n21\nelseif x == V:max\n22\nV:max D index.high.x/;\nVEB-TREE-MAXIMUM.V:clusterŒhigh.x/\u0002//",
    "parent_2af54e2a-1fda-4540-83e4-c523d20d5c52": "16\nif x == V:max\n17\nsummary-max D VEB-TREE-MAXIMUM.V:summary/\n18\nif summary-max == NIL\n19\nV:max D V:min\n20\nelse V:max D index.summary-max;\nVEB-TREE-MAXIMUM.V:clusterŒsummary-max\u0002//\n21\nelseif x == V:max\n22\nV:max D index.high.x/;\nVEB-TREE-MAXIMUM.V:clusterŒhigh.x/\u0002//\n20.3\nThe van Emde Boas tree\n555\nThe VEB-TREE-DELETE procedure works as follows. If the vEB tree V con-\ntains only one element, then it’s just as easy to delete it as it was to insert an element\ninto an empty vEB tree: just set min and max to NIL. Lines 1–3 handle this case.\nOtherwise, V has at least two elements. Line 4 tests whether V is a base-case vEB\ntree and, if so, lines 5–8 set min and max to the one remaining element.\nLines 9–22 assume that V has two or more elements and that u \u0006 4. In this\ncase, we will have to delete an element from a cluster. The element we delete from\na cluster might not be x, however, because if x equals min, then once we have\ndeleted x, some other element within one of V ’s clusters becomes the new min,\nand we have to delete that other element from its cluster. If the test in line 9 reveals\nthat we are in this case, then line 10 sets ﬁrst-cluster to the number of the cluster\nthat contains the lowest element other than min, and line 11 sets x to the value of\nthe lowest element in that cluster. This element becomes the new min in line 12\nand, because we set x to its value, it is the element that will be deleted from its\ncluster.\nWhen we reach line 13, we know that we need to delete element x from its\ncluster, whether x was the value originally passed to VEB-TREE-DELETE or x\nis the element becoming the new minimum. Line 13 deletes x from its cluster.\nThat cluster might now become empty, which line 14 tests, and if it does, then\nwe need to remove x’s cluster number from the summary, which line 15 handles.\nAfter updating the summary, we might need to update max. Line 16 checks to see\nwhether we are deleting the maximum element in V and, if we are, then line 17 sets",
    "parent_ea63a27f-3a48-401e-ab9b-8fec9a098083": "we need to remove x’s cluster number from the summary, which line 15 handles.\nAfter updating the summary, we might need to update max. Line 16 checks to see\nwhether we are deleting the maximum element in V and, if we are, then line 17 sets\nsummary-max to the number of the highest-numbered nonempty cluster. (The call\nVEB-TREE-MAXIMUM.V:summary/ works because we have already recursively\ncalled VEB-TREE-DELETE on V:summary, and therefore V:summary:max has al-\nready been updated as necessary.) If all of V ’s clusters are empty, then the only\nremaining element in V is min; line 18 checks for this case, and line 19 updates\nmax appropriately. Otherwise, line 20 sets max to the maximum element in the\nhighest-numbered cluster. (If this cluster is where the element has been deleted,\nwe again rely on the recursive call in line 13 having already corrected that cluster’s\nmax attribute.)\nFinally, we have to handle the case in which x’s cluster did not become empty\ndue to x being deleted. Although we do not have to update the summary in this\ncase, we might have to update max. Line 21 tests for this case, and if we have to\nupdate max, line 22 does so (again relying on the recursive call to have corrected\nmax in the cluster).\nNow we show that VEB-TREE-DELETE runs in O.lg lg u/ time in the worst\ncase. At ﬁrst glance, you might think that recurrence (20.4) does not always apply,\nbecause a single call of VEB-TREE-DELETE can make two recursive calls: one\non line 13 and one on line 15. Although the procedure can make both recursive\ncalls, let’s think about what happens when it does. In order for the recursive call on\n556\nChapter 20\nvan Emde Boas Trees\nline 15 to occur, the test on line 14 must show that x’s cluster is empty. The only\nway that x’s cluster can be empty is if x was the only element in its cluster when\nwe made the recursive call on line 13. But if x was the only element in its cluster,\nthen that recursive call took O.1/ time, because it executed only lines 1–3. Thus,",
    "parent_cef4f989-3976-4dcc-99ec-c3c817ee9549": "way that x’s cluster can be empty is if x was the only element in its cluster when\nwe made the recursive call on line 13. But if x was the only element in its cluster,\nthen that recursive call took O.1/ time, because it executed only lines 1–3. Thus,\nwe have two mutually exclusive possibilities:\n\u0002\nThe recursive call on line 13 took constant time.\n\u0002\nThe recursive call on line 15 did not occur.\nIn either case, recurrence (20.4) characterizes the running time of VEB-TREE-\nDELETE, and hence its worst-case running time is O.lg lg u/.\nExercises\n20.3-1\nModify vEB trees to support duplicate keys.\n20.3-2\nModify vEB trees to support keys that have associated satellite data.\n20.3-3\nWrite pseudocode for a procedure that creates an empty van Emde Boas tree.\n20.3-4\nWhat happens if you call VEB-TREE-INSERT with an element that is already in\nthe vEB tree? What happens if you call VEB-TREE-DELETE with an element that\nis not in the vEB tree? Explain why the procedures exhibit the behavior that they\ndo. Show how to modify vEB trees and their operations so that we can check in\nconstant time whether an element is present.\n20.3-5\nSuppose that instead of\n\"pu clusters, each with universe size\n#pu, we constructed\nvEB trees to have u1=k clusters, each with universe size u1\u00031=k, where k > 1 is a\nconstant. If we were to modify the operations appropriately, what would be their\nrunning times? For the purpose of analysis, assume that u1=k and u1\u00031=k are always\nintegers.\n20.3-6\nCreating a vEB tree with universe size u requires O.u/ time. Suppose we wish to\nexplicitly account for that time. What is the smallest number of operations n for\nwhich the amortized time of each operation in a vEB tree is O.lg lg u/?\nProblems for Chapter 20\n557\nProblems\n20-1\nSpace requirements for van Emde Boas trees\nThis problem explores the space requirements for van Emde Boas trees and sug-\ngests a way to modify the data structure to make its space requirement depend on",
    "parent_f547d4e4-d2db-4b55-8edd-1c8944203f41": "Problems for Chapter 20\n557\nProblems\n20-1\nSpace requirements for van Emde Boas trees\nThis problem explores the space requirements for van Emde Boas trees and sug-\ngests a way to modify the data structure to make its space requirement depend on\nthe number n of elements actually stored in the tree, rather than on the universe\nsize u. For simplicity, assume that pu is always an integer.\na. Explain why the following recurrence characterizes the space requirement P.u/\nof a van Emde Boas tree with universe size u:\nP.u/ D .pu C 1/P.pu/ C ‚.pu/ :\n(20.5)\nb. Prove that recurrence (20.5) has the solution P.u/ D O.u/.\nIn order to reduce the space requirements, let us deﬁne a reduced-space van Emde\nBoas tree, or RS-vEB tree, as a vEB tree V but with the following changes:\n\u0002\nThe attribute V:cluster, rather than being stored as a simple array of pointers to\nvEB trees with universe size pu, is a hash table (see Chapter 11) stored as a dy-\nnamic table (see Section 17.4). Corresponding to the array version of V:cluster,\nthe hash table stores pointers to RS-vEB trees with universe size pu. To ﬁnd\nthe ith cluster, we look up the key i in the hash table, so that we can ﬁnd the\nith cluster by a single search in the hash table.\n\u0002\nThe hash table stores only pointers to nonempty clusters. A search in the hash\ntable for an empty cluster returns NIL, indicating that the cluster is empty.\n\u0002\nThe attribute V:summary is NIL if all clusters are empty. Otherwise, V:summary\npoints to an RS-vEB tree with universe size pu.\nBecause the hash table is implemented with a dynamic table, the space it requires\nis proportional to the number of nonempty clusters.\nWhen we need to insert an element into an empty RS-vEB tree, we create the RS-\nvEB tree by calling the following procedure, where the parameter u is the universe\nsize of the RS-vEB tree:\nCREATE-NEW-RS-VEB-TREE.u/\n1\nallocate a new vEB tree V\n2\nV:u D u\n3\nV:min D NIL\n4\nV:max D NIL\n5\nV:summary D NIL\n6\ncreate V:cluster as an empty dynamic hash table\n7",
    "parent_6afe0afa-41b1-4024-b27a-08b4f1e22342": "vEB tree by calling the following procedure, where the parameter u is the universe\nsize of the RS-vEB tree:\nCREATE-NEW-RS-VEB-TREE.u/\n1\nallocate a new vEB tree V\n2\nV:u D u\n3\nV:min D NIL\n4\nV:max D NIL\n5\nV:summary D NIL\n6\ncreate V:cluster as an empty dynamic hash table\n7\nreturn V\n558\nChapter 20\nvan Emde Boas Trees\nc. Modify the VEB-TREE-INSERT procedure to produce pseudocode for the pro-\ncedure RS-VEB-TREE-INSERT.V; x/, which inserts x into the RS-vEB tree V ,\ncalling CREATE-NEW-RS-VEB-TREE as appropriate.\nd. Modify the VEB-TREE-SUCCESSOR procedure to produce pseudocode for\nthe procedure RS-VEB-TREE-SUCCESSOR.V; x/, which returns the successor\nof x in RS-vEB tree V , or NIL if x has no successor in V .\ne. Prove that, under the assumption of simple uniform hashing, your RS-VEB-\nTREE-INSERT and RS-VEB-TREE-SUCCESSOR procedures run in O.lg lg u/\nexpected time.\nf.\nAssuming that elements are never deleted from a vEB tree, prove that the space\nrequirement for the RS-vEB tree structure is O.n/, where n is the number of\nelements actually stored in the RS-vEB tree.\ng. RS-vEB trees have another advantage over vEB trees: they require less time to\ncreate. How long does it take to create an empty RS-vEB tree?\n20-2\ny-fast tries\nThis problem investigates D. Willard’s “y-fast tries” which, like van Emde Boas\ntrees, perform each of the operations MEMBER, MINIMUM, MAXIMUM, PRE-\nDECESSOR, and SUCCESSOR on elements drawn from a universe with size u in\nO.lg lg u/ worst-case time. The INSERT and DELETE operations take O.lg lg u/\namortized time. Like reduced-space van Emde Boas trees (see Problem 20-1), y-\nfast tries use only O.n/ space to store n elements. The design of y-fast tries relies\non perfect hashing (see Section 11.5).\nAs a preliminary structure, suppose that we create a perfect hash table containing\nnot only every element in the dynamic set, but every preﬁx of the binary represen-\ntation of every element in the set. For example, if u D 16, so that lg u D 4, and",
    "parent_803f17e5-ecd3-4a7d-aa6d-9fcbeb539386": "on perfect hashing (see Section 11.5).\nAs a preliminary structure, suppose that we create a perfect hash table containing\nnot only every element in the dynamic set, but every preﬁx of the binary represen-\ntation of every element in the set. For example, if u D 16, so that lg u D 4, and\nx D 13 is in the set, then because the binary representation of 13 is 1101, the\nperfect hash table would contain the strings 1, 11, 110, and 1101. In addition to\nthe hash table, we create a doubly linked list of the elements currently in the set, in\nincreasing order.\na. How much space does this structure require?\nb. Show how to perform the MINIMUM and MAXIMUM operations in O.1/ time;\nthe MEMBER, PREDECESSOR, and SUCCESSOR operations in O.lg lg u/ time;\nand the INSERT and DELETE operations in O.lg u/ time.\nTo reduce the space requirement to O.n/, we make the following changes to the\ndata structure:\nNotes for Chapter 20\n559\n\u0002\nWe cluster the n elements into n= lg u groups of size lg u. (Assume for now\nthat lg u divides n.) The ﬁrst group consists of the lg u smallest elements in the\nset, the second group consists of the next lg u smallest elements, and so on.\n\u0002\nWe designate a “representative” value for each group. The representative of\nthe ith group is at least as large as the largest element in the ith group, and it is\nsmaller than every element of the .i C1/st group. (The representative of the last\ngroup can be the maximum possible element u \u0005 1.) Note that a representative\nmight be a value not currently in the set.\n\u0002\nWe store the lg u elements of each group in a balanced binary search tree, such\nas a red-black tree. Each representative points to the balanced binary search\ntree for its group, and each balanced binary search tree points to its group’s\nrepresentative.\n\u0002\nThe perfect hash table stores only the representatives, which are also stored in\na doubly linked list in increasing order.\nWe call this structure a y-fast trie.",
    "parent_1fe90840-57ac-4d00-90d4-d847ea0728b5": "tree for its group, and each balanced binary search tree points to its group’s\nrepresentative.\n\u0002\nThe perfect hash table stores only the representatives, which are also stored in\na doubly linked list in increasing order.\nWe call this structure a y-fast trie.\nc. Show that a y-fast trie requires only O.n/ space to store n elements.\nd. Show how to perform the MINIMUM and MAXIMUM operations in O.lg lg u/\ntime with a y-fast trie.\ne. Show how to perform the MEMBER operation in O.lg lg u/ time.\nf. Show how to perform the PREDECESSOR and SUCCESSOR operations in\nO.lg lg u/ time.\ng. Explain why the INSERT and DELETE operations take \u0004.lg lg u/ time.\nh. Show how to relax the requirement that each group in a y-fast trie has exactly\nlg u elements to allow INSERT and DELETE to run in O.lg lg u/ amortized time\nwithout affecting the asymptotic running times of the other operations.\nChapter notes\nThe data structure in this chapter is named after P. van Emde Boas, who described\nan early form of the idea in 1975 [339]. Later papers by van Emde Boas [340]\nand van Emde Boas, Kaas, and Zijlstra [341] reﬁned the idea and the exposition.\nMehlhorn and N¨aher [252] subsequently extended the ideas to apply to universe\n560\nChapter 20\nvan Emde Boas Trees\nsizes that are prime. Mehlhorn’s book [249] contains a slightly different treatment\nof van Emde Boas trees than the one in this chapter.\nUsing the ideas behind van Emde Boas trees, Dementiev et al. [83] developed\na nonrecursive, three-level search tree that ran faster than van Emde Boas trees in\ntheir own experiments.\nWang and Lin [347] designed a hardware-pipelined version of van Emde Boas\ntrees, which achieves constant amortized time per operation and uses O.lg lg u/\nstages in the pipeline.\nA lower bound by Pˇatras¸cu and Thorup [273, 274] for ﬁnding the predecessor\nshows that van Emde Boas trees are optimal for this operation, even if randomiza-\ntion is allowed.\n21\nData Structures for Disjoint Sets",
    "parent_a90ec619-499e-4e52-a723-16bbff228be9": "stages in the pipeline.\nA lower bound by Pˇatras¸cu and Thorup [273, 274] for ﬁnding the predecessor\nshows that van Emde Boas trees are optimal for this operation, even if randomiza-\ntion is allowed.\n21\nData Structures for Disjoint Sets\nSome applications involve grouping n distinct elements into a collection of disjoint\nsets. These applications often need to perform two operations in particular: ﬁnding\nthe unique set that contains a given element and uniting two sets. This chapter\nexplores methods for maintaining a data structure that supports these operations.\nSection 21.1 describes the operations supported by a disjoint-set data structure\nand presents a simple application. In Section 21.2, we look at a simple linked-list\nimplementation for disjoint sets. Section 21.3 presents a more efﬁcient represen-\ntation using rooted trees. The running time using the tree representation is theo-\nretically superlinear, but for all practical purposes it is linear. Section 21.4 deﬁnes\nand discusses a very quickly growing function and its very slowly growing inverse,\nwhich appears in the running time of operations on the tree-based implementation,\nand then, by a complex amortized analysis, proves an upper bound on the running\ntime that is just barely superlinear.\n21.1\nDisjoint-set operations\nA disjoint-set data structure maintains a collection S D fS1; S2; : : : ; Skg of dis-\njoint dynamic sets. We identify each set by a representative, which is some mem-\nber of the set. In some applications, it doesn’t matter which member is used as the\nrepresentative; we care only that if we ask for the representative of a dynamic set\ntwice without modifying the set between the requests, we get the same answer both\ntimes. Other applications may require a prespeciﬁed rule for choosing the repre-\nsentative, such as choosing the smallest member in the set (assuming, of course,\nthat the elements can be ordered).\nAs in the other dynamic-set implementations we have studied, we represent each",
    "parent_2406180f-cf13-453e-86b1-8de6e984d852": "times. Other applications may require a prespeciﬁed rule for choosing the repre-\nsentative, such as choosing the smallest member in the set (assuming, of course,\nthat the elements can be ordered).\nAs in the other dynamic-set implementations we have studied, we represent each\nelement of a set by an object. Letting x denote an object, we wish to support the\nfollowing operations:\n562\nChapter 21\nData Structures for Disjoint Sets\nMAKE-SET.x/ creates a new set whose only member (and thus representative)\nis x. Since the sets are disjoint, we require that x not already be in some other\nset.\nUNION.x; y/ unites the dynamic sets that contain x and y, say Sx and Sy, into a\nnew set that is the union of these two sets. We assume that the two sets are dis-\njoint prior to the operation. The representative of the resulting set is any member\nof Sx [ Sy, although many implementations of UNION speciﬁcally choose the\nrepresentative of either Sx or Sy as the new representative. Since we require\nthe sets in the collection to be disjoint, conceptually we destroy sets Sx and Sy,\nremoving them from the collection S. In practice, we often absorb the elements\nof one of the sets into the other set.\nFIND-SET.x/ returns a pointer to the representative of the (unique) set contain-\ning x.\nThroughout this chapter, we shall analyze the running times of disjoint-set data\nstructures in terms of two parameters: n, the number of MAKE-SET operations,\nand m, the total number of MAKE-SET, UNION, and FIND-SET operations. Since\nthe sets are disjoint, each UNION operation reduces the number of sets by one.\nAfter n \u0005 1 UNION operations, therefore, only one set remains. The number of\nUNION operations is thus at most n \u0005 1. Note also that since the MAKE-SET\noperations are included in the total number of operations m, we have m \u0006 n. We\nassume that the n MAKE-SET operations are the ﬁrst n operations performed.\nAn application of disjoint-set data structures",
    "parent_1481d2da-b966-48a2-b106-f9f829780c4c": "UNION operations is thus at most n \u0005 1. Note also that since the MAKE-SET\noperations are included in the total number of operations m, we have m \u0006 n. We\nassume that the n MAKE-SET operations are the ﬁrst n operations performed.\nAn application of disjoint-set data structures\nOne of the many applications of disjoint-set data structures arises in determin-\ning the connected components of an undirected graph (see Section B.4).\nFig-\nure 21.1(a), for example, shows a graph with four connected components.\nThe procedure CONNECTED-COMPONENTS that follows uses the disjoint-set\noperations to compute the connected components of a graph. Once CONNECTED-\nCOMPONENTS has preprocessed the graph, the procedure SAME-COMPONENT\nanswers queries about whether two vertices are in the same connected component.1\n(In pseudocode, we denote the set of vertices of a graph G by G:V and the set of\nedges by G:E.)\n1When the edges of the graph are static—not changing over time—we can compute the connected\ncomponents faster by using depth-ﬁrst search (Exercise 22.3-12). Sometimes, however, the edges\nare added dynamically and we need to maintain the connected components as each edge is added. In\nthis case, the implementation given here can be more efﬁcient than running a new depth-ﬁrst search\nfor each new edge.\n21.1\nDisjoint-set operations\n563\na\nb\nc\nd\ne\nf\ng\nh\ni\nj\nEdge processed\ninitial sets\n(b,d)\n(e,g)\n(a,c)\n(h,i)\n(a,b)\n(e, f )\n(b,c)\n{a,b,c,d}\n{a,b,c,d}\n{a,c}\n{a,c}\n{a}\n{a}\n{a}\n{a,b,c,d}\n{b,d}\n{b,d}\n{b,d}\n{b,d}\n{b}\n{c}\n{c}\n{c}\n{d}\n{e, f,g}\n{e, f,g}\n{e,g}\n{e,g}\n{e,g}\n{e,g}\n{e}\n{e}\n{f}\n{f}\n{f}\n{f}\n{f}\n{f}\n{g}\n{g}\n{h,i}\n{h,i}\n{h,i}\n{h,i}\n{h}\n{h}\n{h}\n{h}\n{i}\n{i}\n{i}\n{i}\n{j}\n{j}\n{j}\n{j}\n{j}\n{j}\n{j}\n{j}\nCollection of disjoint sets\n(a)\n(b)\nFigure 21.1\n(a) A graph with four connected components: fa; b; c; dg, fe; f; gg, fh; ig, and fjg.\n(b) The collection of disjoint sets after processing each edge.\nCONNECTED-COMPONENTS.G/\n1\nfor each vertex \u0003 2 G:V\n2\nMAKE-SET.\u0003/\n3\nfor each edge .u; \u0003/ 2 G:E\n4",
    "parent_1f47d3ab-70fb-48d0-a311-2c572e8a6b8f": "{j}\nCollection of disjoint sets\n(a)\n(b)\nFigure 21.1\n(a) A graph with four connected components: fa; b; c; dg, fe; f; gg, fh; ig, and fjg.\n(b) The collection of disjoint sets after processing each edge.\nCONNECTED-COMPONENTS.G/\n1\nfor each vertex \u0003 2 G:V\n2\nMAKE-SET.\u0003/\n3\nfor each edge .u; \u0003/ 2 G:E\n4\nif FIND-SET.u/ ¤ FIND-SET.\u0003/\n5\nUNION.u; \u0003/\nSAME-COMPONENT.u; \u0003/\n1\nif FIND-SET.u/ == FIND-SET.\u0003/\n2\nreturn TRUE\n3\nelse return FALSE\nThe procedure CONNECTED-COMPONENTS initially places each vertex \u0003 in its\nown set. Then, for each edge .u; \u0003/, it unites the sets containing u and \u0003. By\nExercise 21.1-2, after processing all the edges, two vertices are in the same con-\nnected component if and only if the corresponding objects are in the same set.\nThus, CONNECTED-COMPONENTS computes sets in such a way that the proce-\ndure SAME-COMPONENT can determine whether two vertices are in the same con-\n564\nChapter 21\nData Structures for Disjoint Sets\nnected component. Figure 21.1(b) illustrates how CONNECTED-COMPONENTS\ncomputes the disjoint sets.\nIn an actual implementation of this connected-components algorithm, the repre-\nsentations of the graph and the disjoint-set data structure would need to reference\neach other. That is, an object representing a vertex would contain a pointer to\nthe corresponding disjoint-set object, and vice versa. These programming details\ndepend on the implementation language, and we do not address them further here.\nExercises\n21.1-1\nSuppose that CONNECTED-COMPONENTS is run on the undirected graph G D\n.V; E/, where V\nD fa; b; c; d; e; f; g; h; i; j; kg and the edges of E are pro-\ncessed in the order .d; i/; .f; k/; .g; i/; .b; g/; .a; h/; .i; j /; .d; k/; .b; j /; .d; f /;\n.g; j /; .a; e/. List the vertices in each connected component after each iteration of\nlines 3–5.\n21.1-2\nShow that after all edges are processed by CONNECTED-COMPONENTS, two ver-\ntices are in the same connected component if and only if they are in the same set.\n21.1-3",
    "parent_83d4aeac-9115-4955-9a19-59492a8db4ba": ".g; j /; .a; e/. List the vertices in each connected component after each iteration of\nlines 3–5.\n21.1-2\nShow that after all edges are processed by CONNECTED-COMPONENTS, two ver-\ntices are in the same connected component if and only if they are in the same set.\n21.1-3\nDuring the execution of CONNECTED-COMPONENTS on an undirected graph G D\n.V; E/ with k connected components, how many times is FIND-SET called? How\nmany times is UNION called? Express your answers in terms of jV j, jEj, and k.\n21.2\nLinked-list representation of disjoint sets\nFigure 21.2(a) shows a simple way to implement a disjoint-set data structure: each\nset is represented by its own linked list. The object for each set has attributes head,\npointing to the ﬁrst object in the list, and tail, pointing to the last object. Each\nobject in the list contains a set member, a pointer to the next object in the list, and\na pointer back to the set object. Within each linked list, the objects may appear in\nany order. The representative is the set member in the ﬁrst object in the list.\nWith this linked-list representation, both MAKE-SET and FIND-SET are easy,\nrequiring O.1/ time. To carry out MAKE-SET.x/, we create a new linked list\nwhose only object is x. For FIND-SET.x/, we just follow the pointer from x back\nto its set object and then return the member in the object that head points to. For\nexample, in Figure 21.2(a), the call FIND-SET.g/ would return f .\n21.2\nLinked-list representation of disjoint sets\n565\nf\ng\nd\nc\nh\ne\nb\n(a)\n(b)\nhead\ntail\nS1\nc\nh\ne\nhead\ntail\nS2\nb\nf\ng\nd\nhead\ntail\nS1\nFigure 21.2\n(a) Linked-list representations of two sets. Set S1 contains members d, f , and g, with\nrepresentative f , and set S2 contains members b, c, e, and h, with representative c. Each object in\nthe list contains a set member, a pointer to the next object in the list, and a pointer back to the set\nobject. Each set object has pointers head and tail to the ﬁrst and last objects, respectively. (b) The",
    "parent_ee4f20fe-e16d-4cf7-aad7-c23984f69a4d": "the list contains a set member, a pointer to the next object in the list, and a pointer back to the set\nobject. Each set object has pointers head and tail to the ﬁrst and last objects, respectively. (b) The\nresult of UNION.g; e/, which appends the linked list containing e to the linked list containing g. The\nrepresentative of the resulting set is f . The set object for e’s list, S2, is destroyed.\nA simple implementation of union\nThe simplest implementation of the UNION operation using the linked-list set rep-\nresentation takes signiﬁcantly more time than MAKE-SET or FIND-SET. As Fig-\nure 21.2(b) shows, we perform UNION.x; y/ by appending y’s list onto the end\nof x’s list. The representative of x’s list becomes the representative of the resulting\nset. We use the tail pointer for x’s list to quickly ﬁnd where to append y’s list. Be-\ncause all members of y’s list join x’s list, we can destroy the set object for y’s list.\nUnfortunately, we must update the pointer to the set object for each object origi-\nnally on y’s list, which takes time linear in the length of y’s list. In Figure 21.2, for\nexample, the operation UNION.g; e/ causes pointers to be updated in the objects\nfor b, c, e, and h.\nIn fact, we can easily construct a sequence of m operations on n objects that\nrequires ‚.n2/ time. Suppose that we have objects x1; x2; : : : ; xn. We execute\nthe sequence of n MAKE-SET operations followed by n \u0005 1 UNION operations\nshown in Figure 21.3, so that m D 2n \u0005 1. We spend ‚.n/ time performing the n\nMAKE-SET operations. Because the ith UNION operation updates i objects, the\ntotal number of objects updated by all n \u0005 1 UNION operations is\n566\nChapter 21\nData Structures for Disjoint Sets\nOperation\nNumber of objects updated\nMAKE-SET.x1/\n1\nMAKE-SET.x2/\n1\n:::\n:::\nMAKE-SET.xn/\n1\nUNION.x2; x1/\n1\nUNION.x3; x2/\n2\nUNION.x4; x3/\n3\n:::\n:::\nUNION.xn; xn\u00031/\nn \u0005 1\nFigure 21.3\nA sequence of 2n \u0005 1 operations on n objects that takes ‚.n2/ time, or ‚.n/ time",
    "parent_594d01c8-7d54-41cc-978a-764348a90a9a": "Data Structures for Disjoint Sets\nOperation\nNumber of objects updated\nMAKE-SET.x1/\n1\nMAKE-SET.x2/\n1\n:::\n:::\nMAKE-SET.xn/\n1\nUNION.x2; x1/\n1\nUNION.x3; x2/\n2\nUNION.x4; x3/\n3\n:::\n:::\nUNION.xn; xn\u00031/\nn \u0005 1\nFigure 21.3\nA sequence of 2n \u0005 1 operations on n objects that takes ‚.n2/ time, or ‚.n/ time\nper operation on average, using the linked-list set representation and the simple implementation of\nUNION.\nn\u00031\nX\niD1\ni D ‚.n2/ :\nThe total number of operations is 2n\u00051, and so each operation on average requires\n‚.n/ time. That is, the amortized time of an operation is ‚.n/.\nA weighted-union heuristic\nIn the worst case, the above implementation of the UNION procedure requires an\naverage of ‚.n/ time per call because we may be appending a longer list onto\na shorter list; we must update the pointer to the set object for each member of\nthe longer list. Suppose instead that each list also includes the length of the list\n(which we can easily maintain) and that we always append the shorter list onto the\nlonger, breaking ties arbitrarily. With this simple weighted-union heuristic, a sin-\ngle UNION operation can still take \u0004.n/ time if both sets have \u0004.n/ members. As\nthe following theorem shows, however, a sequence of m MAKE-SET, UNION, and\nFIND-SET operations, n of which are MAKE-SET operations, takes O.m C n lg n/\ntime.\nTheorem 21.1\nUsing the linked-list representation of disjoint sets and the weighted-union heuris-\ntic, a sequence of m MAKE-SET, UNION, and FIND-SET operations, n of which\nare MAKE-SET operations, takes O.m C n lg n/ time.\n21.2\nLinked-list representation of disjoint sets\n567\nProof\nBecause each UNION operation unites two disjoint sets, we perform at\nmost n\u00051 UNION operations over all. We now bound the total time taken by these\nUNION operations. We start by determining, for each object, an upper bound on the\nnumber of times the object’s pointer back to its set object is updated. Consider a\nparticular object x. We know that each time x’s pointer was updated, x must have",
    "parent_be583ec9-ac1e-44bb-8687-20ce464c2b0a": "UNION operations. We start by determining, for each object, an upper bound on the\nnumber of times the object’s pointer back to its set object is updated. Consider a\nparticular object x. We know that each time x’s pointer was updated, x must have\nstarted in the smaller set. The ﬁrst time x’s pointer was updated, therefore, the\nresulting set must have had at least 2 members. Similarly, the next time x’s pointer\nwas updated, the resulting set must have had at least 4 members. Continuing on,\nwe observe that for any k \u0002 n, after x’s pointer has been updated dlg ke times,\nthe resulting set must have at least k members. Since the largest set has at most n\nmembers, each object’s pointer is updated at most dlg ne times over all the UNION\noperations. Thus the total time spent updating object pointers over all UNION\noperations is O.n lg n/. We must also account for updating the tail pointers and\nthe list lengths, which take only ‚.1/ time per UNION operation. The total time\nspent in all UNION operations is thus O.n lg n/.\nThe time for the entire sequence of m operations follows easily. Each MAKE-\nSET and FIND-SET operation takes O.1/ time, and there are O.m/ of them. The\ntotal time for the entire sequence is thus O.m C n lg n/.\nExercises\n21.2-1\nWrite pseudocode for MAKE-SET, FIND-SET, and UNION using the linked-list\nrepresentation and the weighted-union heuristic. Make sure to specify the attributes\nthat you assume for set objects and list objects.\n21.2-2\nShow the data structure that results and the answers returned by the FIND-SET\noperations in the following program. Use the linked-list representation with the\nweighted-union heuristic.\n1\nfor i D 1 to 16\n2\nMAKE-SET.xi/\n3\nfor i D 1 to 15 by 2\n4\nUNION.xi; xiC1/\n5\nfor i D 1 to 13 by 4\n6\nUNION.xi; xiC2/\n7\nUNION.x1; x5/\n8\nUNION.x11; x13/\n9\nUNION.x1; x10/\n10\nFIND-SET.x2/\n11\nFIND-SET.x9/\n568\nChapter 21\nData Structures for Disjoint Sets\nAssume that if the sets containing xi and xj have the same size, then the operation",
    "parent_ce7db6a8-45d3-4e49-bf27-45bb3d824aad": "3\nfor i D 1 to 15 by 2\n4\nUNION.xi; xiC1/\n5\nfor i D 1 to 13 by 4\n6\nUNION.xi; xiC2/\n7\nUNION.x1; x5/\n8\nUNION.x11; x13/\n9\nUNION.x1; x10/\n10\nFIND-SET.x2/\n11\nFIND-SET.x9/\n568\nChapter 21\nData Structures for Disjoint Sets\nAssume that if the sets containing xi and xj have the same size, then the operation\nUNION.xi; xj/ appends xj’s list onto xi’s list.\n21.2-3\nAdapt the aggregate proof of Theorem 21.1 to obtain amortized time bounds\nof O.1/ for MAKE-SET and FIND-SET and O.lg n/ for UNION using the linked-\nlist representation and the weighted-union heuristic.\n21.2-4\nGive a tight asymptotic bound on the running time of the sequence of operations in\nFigure 21.3 assuming the linked-list representation and the weighted-union heuris-\ntic.\n21.2-5\nProfessor Gompers suspects that it might be possible to keep just one pointer in\neach set object, rather than two (head and tail), while keeping the number of point-\ners in each list element at two. Show that the professor’s suspicion is well founded\nby describing how to represent each set by a linked list such that each operation\nhas the same running time as the operations described in this section. Describe\nalso how the operations work. Your scheme should allow for the weighted-union\nheuristic, with the same effect as described in this section. (Hint: Use the tail of a\nlinked list as its set’s representative.)\n21.2-6\nSuggest a simple change to the UNION procedure for the linked-list representation\nthat removes the need to keep the tail pointer to the last object in each list. Whether\nor not the weighted-union heuristic is used, your change should not change the\nasymptotic running time of the UNION procedure. (Hint: Rather than appending\none list to another, splice them together.)\n21.3\nDisjoint-set forests\nIn a faster implementation of disjoint sets, we represent sets by rooted trees, with\neach node containing one member and each tree representing one set. In a disjoint-",
    "parent_92d1ba53-5d32-45a9-8668-af3554026a02": "one list to another, splice them together.)\n21.3\nDisjoint-set forests\nIn a faster implementation of disjoint sets, we represent sets by rooted trees, with\neach node containing one member and each tree representing one set. In a disjoint-\nset forest, illustrated in Figure 21.4(a), each member points only to its parent. The\nroot of each tree contains the representative and is its own parent. As we shall\nsee, although the straightforward algorithms that use this representation are no\nfaster than ones that use the linked-list representation, by introducing two heuris-\ntics—“union by rank” and “path compression”—we can achieve an asymptotically\noptimal disjoint-set data structure.\n21.3\nDisjoint-set forests\n569\nc\nh\ne\nb\nf\nd\ng\n(a)\nf\nc\nh\ne\nb\nd\ng\n(b)\nFigure 21.4\nA disjoint-set forest. (a) Two trees representing the two sets of Figure 21.2. The\ntree on the left represents the set fb; c; e; hg, with c as the representative, and the tree on the right\nrepresents the set fd; f; gg, with f as the representative. (b) The result of UNION.e; g/.\nWe perform the three disjoint-set operations as follows. A MAKE-SET operation\nsimply creates a tree with just one node. We perform a FIND-SET operation by\nfollowing parent pointers until we ﬁnd the root of the tree. The nodes visited on\nthis simple path toward the root constitute the ﬁnd path. A UNION operation,\nshown in Figure 21.4(b), causes the root of one tree to point to the root of the other.\nHeuristics to improve the running time\nSo far, we have not improved on the linked-list implementation. A sequence of\nn \u0005 1 UNION operations may create a tree that is just a linear chain of n nodes. By\nusing two heuristics, however, we can achieve a running time that is almost linear\nin the total number of operations m.\nThe ﬁrst heuristic, union by rank, is similar to the weighted-union heuristic we\nused with the linked-list representation. The obvious approach would be to make",
    "parent_1ccf41c9-74cc-4efc-a8e8-fbb2eda08157": "using two heuristics, however, we can achieve a running time that is almost linear\nin the total number of operations m.\nThe ﬁrst heuristic, union by rank, is similar to the weighted-union heuristic we\nused with the linked-list representation. The obvious approach would be to make\nthe root of the tree with fewer nodes point to the root of the tree with more nodes.\nRather than explicitly keeping track of the size of the subtree rooted at each node,\nwe shall use an approach that eases the analysis. For each node, we maintain a\nrank, which is an upper bound on the height of the node. In union by rank, we\nmake the root with smaller rank point to the root with larger rank during a UNION\noperation.\nThe second heuristic, path compression, is also quite simple and highly effec-\ntive. As shown in Figure 21.5, we use it during FIND-SET operations to make each\nnode on the ﬁnd path point directly to the root. Path compression does not change\nany ranks.\n570\nChapter 21\nData Structures for Disjoint Sets\na\nb\nc\nd\ne\nf\na\nb\nc\nd\ne\nf\n(a)\n(b)\nFigure 21.5\nPath compression during the operation FIND-SET. Arrows and self-loops at roots are\nomitted. (a) A tree representing a set prior to executing FIND-SET.a/. Triangles represent subtrees\nwhose roots are the nodes shown. Each node has a pointer to its parent. (b) The same set after\nexecuting FIND-SET.a/. Each node on the ﬁnd path now points directly to the root.\nPseudocode for disjoint-set forests\nTo implement a disjoint-set forest with the union-by-rank heuristic, we must keep\ntrack of ranks. With each node x, we maintain the integer value x:rank, which is\nan upper bound on the height of x (the number of edges in the longest simple path\nbetween x and a descendant leaf). When MAKE-SET creates a singleton set, the\nsingle node in the corresponding tree has an initial rank of 0. Each FIND-SET oper-\nation leaves all ranks unchanged. The UNION operation has two cases, depending",
    "parent_3907248e-9d86-4418-bd91-ee7e90b40c22": "between x and a descendant leaf). When MAKE-SET creates a singleton set, the\nsingle node in the corresponding tree has an initial rank of 0. Each FIND-SET oper-\nation leaves all ranks unchanged. The UNION operation has two cases, depending\non whether the roots of the trees have equal rank. If the roots have unequal rank,\nwe make the root with higher rank the parent of the root with lower rank, but the\nranks themselves remain unchanged. If, instead, the roots have equal ranks, we\narbitrarily choose one of the roots as the parent and increment its rank.\nLet us put this method into pseudocode. We designate the parent of node x\nby x:p. The LINK procedure, a subroutine called by UNION, takes pointers to two\nroots as inputs.\n21.3\nDisjoint-set forests\n571\nMAKE-SET.x/\n1\nx:p D x\n2\nx:rank D 0\nUNION.x; y/\n1\nLINK.FIND-SET.x/; FIND-SET.y//\nLINK.x; y/\n1\nif x:rank > y:rank\n2\ny:p D x\n3\nelse x:p D y\n4\nif x:rank == y:rank\n5\ny:rank D y:rank C 1\nThe FIND-SET procedure with path compression is quite simple:\nFIND-SET.x/\n1\nif x ¤ x:p\n2\nx:p D FIND-SET.x:p/\n3\nreturn x:p\nThe FIND-SET procedure is a two-pass method: as it recurses, it makes one pass\nup the ﬁnd path to ﬁnd the root, and as the recursion unwinds, it makes a second\npass back down the ﬁnd path to update each node to point directly to the root. Each\ncall of FIND-SET.x/ returns x:p in line 3. If x is the root, then FIND-SET skips\nline 2 and instead returns x:p, which is x; this is the case in which the recursion\nbottoms out. Otherwise, line 2 executes, and the recursive call with parameter x:p\nreturns a pointer to the root. Line 2 updates node x to point directly to the root,\nand line 3 returns this pointer.\nEffect of the heuristics on the running time\nSeparately, either union by rank or path compression improves the running time of\nthe operations on disjoint-set forests, and the improvement is even greater when\nwe use the two heuristics together. Alone, union by rank yields a running time",
    "parent_f27de504-349c-481f-b3be-0f8ea361a1d9": "Effect of the heuristics on the running time\nSeparately, either union by rank or path compression improves the running time of\nthe operations on disjoint-set forests, and the improvement is even greater when\nwe use the two heuristics together. Alone, union by rank yields a running time\nof O.m lg n/ (see Exercise 21.4-4), and this bound is tight (see Exercise 21.3-3).\nAlthough we shall not prove it here, for a sequence of n MAKE-SET opera-\ntions (and hence at most n \u0005 1 UNION operations) and f FIND-SET opera-\ntions, the path-compression heuristic alone gives a worst-case running time of\n‚.n C f \u0003 .1 C log2Cf=n n//.\n572\nChapter 21\nData Structures for Disjoint Sets\nWhen we use both union by rank and path compression, the worst-case running\ntime is O.m ˛.n//, where ˛.n/ is a very slowly growing function, which we de-\nﬁne in Section 21.4. In any conceivable application of a disjoint-set data structure,\n˛.n/ \u0002 4; thus, we can view the running time as linear in m in all practical situa-\ntions. Strictly speaking, however, it is superlinear. In Section 21.4, we prove this\nupper bound.\nExercises\n21.3-1\nRedo Exercise 21.2-2 using a disjoint-set forest with union by rank and path com-\npression.\n21.3-2\nWrite a nonrecursive version of FIND-SET with path compression.\n21.3-3\nGive a sequence of m MAKE-SET, UNION, and FIND-SET operations, n of which\nare MAKE-SET operations, that takes \u0004.m lg n/ time when we use union by rank\nonly.\n21.3-4\nSuppose that we wish to add the operation PRINT-SET.x/, which is given a node x\nand prints all the members of x’s set, in any order. Show how we can add just\na single attribute to each node in a disjoint-set forest so that PRINT-SET.x/ takes\ntime linear in the number of members of x’s set and the asymptotic running times\nof the other operations are unchanged. Assume that we can print each member of\nthe set in O.1/ time.\n21.3-5\n?\nShow that any sequence of m MAKE-SET, FIND-SET, and LINK operations, where",
    "parent_a6ad90b2-1cfd-4eb5-8cf3-af4e9bd3038d": "time linear in the number of members of x’s set and the asymptotic running times\nof the other operations are unchanged. Assume that we can print each member of\nthe set in O.1/ time.\n21.3-5\n?\nShow that any sequence of m MAKE-SET, FIND-SET, and LINK operations, where\nall the LINK operations appear before any of the FIND-SET operations, takes only\nO.m/ time if we use both path compression and union by rank. What happens in\nthe same situation if we use only the path-compression heuristic?\n21.4\nAnalysis of union by rank with path compression\n573\n?\n21.4\nAnalysis of union by rank with path compression\nAs noted in Section 21.3, the combined union-by-rank and path-compression heu-\nristic runs in time O.m ˛.n// for m disjoint-set operations on n elements. In this\nsection, we shall examine the function ˛ to see just how slowly it grows. Then we\nprove this running time using the potential method of amortized analysis.\nA very quickly growing function and its very slowly growing inverse\nFor integers k \u0006 0 and j \u0006 1, we deﬁne the function Ak.j / as\nAk.j / D\n(\nj C 1\nif k D 0 ;\nA.jC1/\nk\u00031 .j /\nif k \u0006 1 ;\nwhere the expression A.jC1/\nk\u00031 .j / uses the functional-iteration notation given in Sec-\ntion 3.2. Speciﬁcally, A.0/\nk\u00031.j / D j and A.i/\nk\u00031.j / D Ak\u00031.A.i\u00031/\nk\u00031 .j // for i \u0006 1.\nWe will refer to the parameter k as the level of the function A.\nThe function Ak.j / strictly increases with both j and k. To see just how quickly\nthis function grows, we ﬁrst obtain closed-form expressions for A1.j / and A2.j /.\nLemma 21.2\nFor any integer j \u0006 1, we have A1.j / D 2j C 1.\nProof\nWe ﬁrst use induction on i to show that A.i/\n0 .j / D j Ci. For the base case,\nwe have A.0/\n0 .j / D j D j C 0. For the inductive step, assume that A.i\u00031/\n0\n.j / D\nj C .i \u0005 1/. Then A.i/\n0 .j / D A0.A.i\u00031/\n0\n.j // D .j C .i \u0005 1// C 1 D j C i. Finally,\nwe note that A1.j / D A.jC1/\n0\n.j / D j C .j C 1/ D 2j C 1.\nLemma 21.3\nFor any integer j \u0006 1, we have A2.j / D 2jC1.j C 1/ \u0005 1.\nProof",
    "parent_2c56f2ff-985f-4fee-9bfa-c245d5a995b1": "0 .j / D j D j C 0. For the inductive step, assume that A.i\u00031/\n0\n.j / D\nj C .i \u0005 1/. Then A.i/\n0 .j / D A0.A.i\u00031/\n0\n.j // D .j C .i \u0005 1// C 1 D j C i. Finally,\nwe note that A1.j / D A.jC1/\n0\n.j / D j C .j C 1/ D 2j C 1.\nLemma 21.3\nFor any integer j \u0006 1, we have A2.j / D 2jC1.j C 1/ \u0005 1.\nProof\nWe ﬁrst use induction on i to show that A.i/\n1 .j / D 2i.j C 1/ \u0005 1. For\nthe base case, we have A.0/\n1 .j / D j D 20.j C 1/ \u0005 1. For the inductive step,\nassume that A.i\u00031/\n1\n.j / D 2i\u00031.j C 1/ \u0005 1. Then A.i/\n1 .j / D A1.A.i\u00031/\n1\n.j // D\nA1.2i\u00031.j C 1/ \u0005 1/ D 2\u0003.2i\u00031.j C1/\u00051/C1 D 2i.j C1/\u00052C1 D 2i.j C1/\u00051.\nFinally, we note that A2.j / D A.jC1/\n1\n.j / D 2jC1.j C 1/ \u0005 1.\nNow we can see how quickly Ak.j / grows by simply examining Ak.1/ for levels\nk D 0; 1; 2; 3; 4. From the deﬁnition of A0.k/ and the above lemmas, we have\nA0.1/ D 1 C 1 D 2, A1.1/ D 2 \u0003 1 C 1 D 3, and A2.1/ D 21C1 \u0003 .1 C 1/ \u0005 1 D 7.\n574\nChapter 21\nData Structures for Disjoint Sets\nWe also have\nA3.1/\nD\nA.2/\n2 .1/\nD\nA2.A2.1//\nD\nA2.7/\nD\n28 \u0003 8 \u0005 1\nD\n211 \u0005 1\nD\n2047\nand\nA4.1/\nD\nA.2/\n3 .1/\nD\nA3.A3.1//\nD\nA3.2047/\nD\nA.2048/\n2\n.2047/\n\u000b\nA2.2047/\nD\n22048 \u0003 2048 \u0005 1\n>\n22048\nD\n.24/512\nD\n16512\n\u000b\n1080 ;\nwhich is the estimated number of atoms in the observable universe. (The symbol\n“\u000b” denotes the “much-greater-than” relation.)\nWe deﬁne the inverse of the function Ak.n/, for integer n \u0006 0, by\n˛.n/ D min fk W Ak.1/ \u0006 ng :\nIn words, ˛.n/ is the lowest level k for which Ak.1/ is at least n. From the above\nvalues of Ak.1/, we see that\n˛.n/ D\n˚\n0\nfor 0 \u0002 n \u0002 2 ;\n1\nfor n D 3 ;\n2\nfor 4 \u0002 n \u0002 7 ;\n3\nfor 8 \u0002 n \u0002 2047 ;\n4\nfor 2048 \u0002 n \u0002 A4.1/ :\nIt is only for values of n so large that the term “astronomical” understates them\n(greater than A4.1/, a huge number) that ˛.n/ > 4, and so ˛.n/ \u0002 4 for all\npractical purposes.\n21.4\nAnalysis of union by rank with path compression\n575\nProperties of ranks\nIn the remainder of this section, we prove an O.m˛.n// bound on the running time",
    "parent_dbfcb29b-05e3-4557-ae98-2cacaeea2697": "(greater than A4.1/, a huge number) that ˛.n/ > 4, and so ˛.n/ \u0002 4 for all\npractical purposes.\n21.4\nAnalysis of union by rank with path compression\n575\nProperties of ranks\nIn the remainder of this section, we prove an O.m˛.n// bound on the running time\nof the disjoint-set operations with union by rank and path compression. In order to\nprove this bound, we ﬁrst prove some simple properties of ranks.\nLemma 21.4\nFor all nodes x, we have x:rank \u0002 x:p:rank, with strict inequality if x ¤ x:p.\nThe value of x:rank is initially 0 and increases through time until x ¤ x:p; from\nthen on, x:rank does not change. The value of x:p:rank monotonically increases\nover time.\nProof\nThe proof is a straightforward induction on the number of operations, us-\ning the implementations of MAKE-SET, UNION, and FIND-SET that appear in\nSection 21.3. We leave it as Exercise 21.4-1.\nCorollary 21.5\nAs we follow the simple path from any node toward a root, the node ranks strictly\nincrease.\nLemma 21.6\nEvery node has rank at most n \u0005 1.\nProof\nEach node’s rank starts at 0, and it increases only upon LINK operations.\nBecause there are at most n \u0005 1 UNION operations, there are also at most n \u0005 1\nLINK operations. Because each LINK operation either leaves all ranks alone or\nincreases some node’s rank by 1, all ranks are at most n \u0005 1.\nLemma 21.6 provides a weak bound on ranks. In fact, every node has rank at\nmost blg nc (see Exercise 21.4-2). The looser bound of Lemma 21.6 will sufﬁce\nfor our purposes, however.\nProving the time bound\nWe shall use the potential method of amortized analysis (see Section 17.3) to prove\nthe O.m ˛.n// time bound. In performing the amortized analysis, we will ﬁnd it\nconvenient to assume that we invoke the LINK operation rather than the UNION\noperation. That is, since the parameters of the LINK procedure are pointers to two\nroots, we act as though we perform the appropriate FIND-SET operations sepa-\nrately. The following lemma shows that even if we count the extra FIND-SET op-",
    "parent_02ce2517-eac1-4958-84be-adb2572871b9": "operation. That is, since the parameters of the LINK procedure are pointers to two\nroots, we act as though we perform the appropriate FIND-SET operations sepa-\nrately. The following lemma shows that even if we count the extra FIND-SET op-\nerations induced by UNION calls, the asymptotic running time remains unchanged.\n576\nChapter 21\nData Structures for Disjoint Sets\nLemma 21.7\nSuppose we convert a sequence S 0 of m0 MAKE-SET, UNION, and FIND-SET op-\nerations into a sequence S of m MAKE-SET, LINK, and FIND-SET operations by\nturning each UNION into two FIND-SET operations followed by a LINK. Then, if\nsequence S runs in O.m ˛.n// time, sequence S 0 runs in O.m0 ˛.n// time.\nProof\nSince each UNION operation in sequence S 0 is converted into three opera-\ntions in S, we have m0 \u0002 m \u0002 3m0. Since m D O.m0/, an O.m ˛.n// time bound\nfor the converted sequence S implies an O.m0 ˛.n// time bound for the original\nsequence S 0.\nIn the remainder of this section, we shall assume that the initial sequence of m0\nMAKE-SET, UNION, and FIND-SET operations has been converted to a sequence\nof m MAKE-SET, LINK, and FIND-SET operations. We now prove an O.m ˛.n//\ntime bound for the converted sequence and appeal to Lemma 21.7 to prove the\nO.m0 ˛.n// running time of the original sequence of m0 operations.\nPotential function\nThe potential function we use assigns a potential \u0007q.x/ to each node x in the\ndisjoint-set forest after q operations. We sum the node potentials for the poten-\ntial of the entire forest: ˆq D P\nx \u0007q.x/, where ˆq denotes the potential of the\nforest after q operations. The forest is empty prior to the ﬁrst operation, and we\narbitrarily set ˆ0 D 0. No potential ˆq will ever be negative.\nThe value of \u0007q.x/ depends on whether x is a tree root after the qth operation.\nIf it is, or if x:rank D 0, then \u0007q.x/ D ˛.n/ \u0003 x:rank.\nNow suppose that after the qth operation, x is not a root and that x:rank \u0006 1.\nWe need to deﬁne two auxiliary functions on x before we can deﬁne \u0007q.x/. First",
    "parent_4596a278-a465-43a1-a808-b37aff1a0cd8": "The value of \u0007q.x/ depends on whether x is a tree root after the qth operation.\nIf it is, or if x:rank D 0, then \u0007q.x/ D ˛.n/ \u0003 x:rank.\nNow suppose that after the qth operation, x is not a root and that x:rank \u0006 1.\nWe need to deﬁne two auxiliary functions on x before we can deﬁne \u0007q.x/. First\nwe deﬁne\nlevel.x/ D max fk W x:p:rank \u0006 Ak.x:rank/g :\nThat is, level.x/ is the greatest level k for which Ak, applied to x’s rank, is no\ngreater than x’s parent’s rank.\nWe claim that\n0 \u0002 level.x/ < ˛.n/ ;\n(21.1)\nwhich we see as follows. We have\nx:p:rank\n\u0006\nx:rank C 1\n(by Lemma 21.4)\nD\nA0.x:rank/\n(by deﬁnition of A0.j /) ,\nwhich implies that level.x/ \u0006 0, and we have\n21.4\nAnalysis of union by rank with path compression\n577\nA˛.n/.x:rank/\n\u0006\nA˛.n/.1/\n(because Ak.j / is strictly increasing)\n\u0006\nn\n(by the deﬁnition of ˛.n/)\n>\nx:p:rank\n(by Lemma 21.6) ,\nwhich implies that level.x/ < ˛.n/. Note that because x:p:rank monotonically\nincreases over time, so does level.x/.\nThe second auxiliary function applies when x:rank \u0006 1:\niter.x/ D max\n˚\ni W x:p:rank \u0006 A.i/\nlevel.x/.x:rank/",
    "parent_08234e58-2dac-494a-98fa-762549bb3831": ":\nThat is, iter.x/ is the largest number of times we can iteratively apply Alevel.x/,\napplied initially to x’s rank, before we get a value greater than x’s parent’s rank.\nWe claim that when x:rank \u0006 1, we have\n1 \u0002 iter.x/ \u0002 x:rank ;\n(21.2)\nwhich we see as follows. We have\nx:p:rank\n\u0006\nAlevel.x/.x:rank/\n(by deﬁnition of level.x/)\nD\nA.1/\nlevel.x/.x:rank/\n(by deﬁnition of functional iteration) ,\nwhich implies that iter.x/ \u0006 1, and we have\nA.x:rankC1/\nlevel.x/\n.x:rank/\nD\nAlevel.x/C1.x:rank/\n(by deﬁnition of Ak.j /)\n>\nx:p:rank\n(by deﬁnition of level.x/) ,\nwhich implies that iter.x/ \u0002 x:rank. Note that because x:p:rank monotonically\nincreases over time, in order for iter.x/ to decrease, level.x/ must increase. As long\nas level.x/ remains unchanged, iter.x/ must either increase or remain unchanged.\nWith these auxiliary functions in place, we are ready to deﬁne the potential of\nnode x after q operations:\n\u0007q.x/ D\n(\n˛.n/ \u0003 x:rank\nif x is a root or x:rank D 0 ;\n.˛.n/ \u0005 level.x//\u0003x:rank \u0005 iter.x/ if x is not a root and x:rank \u0006 1 :\nWe next investigate some useful properties of node potentials.\nLemma 21.8\nFor every node x, and for all operation counts q, we have\n0 \u0002 \u0007q.x/ \u0002 ˛.n/ \u0003 x:rank :\n578\nChapter 21\nData Structures for Disjoint Sets\nProof\nIf x is a root or x:rank D 0, then \u0007q.x/ D ˛.n/\u0003x:rank by deﬁnition. Now\nsuppose that x is not a root and that x:rank \u0006 1. We obtain a lower bound on \u0007q.x/\nby maximizing level.x/ and iter.x/. By the bound (21.1), level.x/ \u0002 ˛.n/\u00051, and\nby the bound (21.2), iter.x/ \u0002 x:rank. Thus,\n\u0007q.x/\nD\n.˛.n/ \u0005 level.x// \u0003 x:rank \u0005 iter.x/\n\u0006\n.˛.n/ \u0005 .˛.n/ \u0005 1// \u0003 x:rank \u0005 x:rank\nD\nx:rank \u0005 x:rank\nD\n0 :\nSimilarly, we obtain an upper bound on \u0007q.x/ by minimizing level.x/ and iter.x/.\nBy the bound (21.1), level.x/ \u0006 0, and by the bound (21.2), iter.x/ \u0006 1. Thus,\n\u0007q.x/\n\u0002\n.˛.n/ \u0005 0/ \u0003 x:rank \u0005 1\nD\n˛.n/ \u0003 x:rank \u0005 1\n<\n˛.n/ \u0003 x:rank :\nCorollary 21.9\nIf node x is not a root and x:rank > 0, then \u0007q.x/ < ˛.n/ \u0003 x:rank.",
    "parent_c1be4ec2-f10c-4690-bff7-20946440aff0": "By the bound (21.1), level.x/ \u0006 0, and by the bound (21.2), iter.x/ \u0006 1. Thus,\n\u0007q.x/\n\u0002\n.˛.n/ \u0005 0/ \u0003 x:rank \u0005 1\nD\n˛.n/ \u0003 x:rank \u0005 1\n<\n˛.n/ \u0003 x:rank :\nCorollary 21.9\nIf node x is not a root and x:rank > 0, then \u0007q.x/ < ˛.n/ \u0003 x:rank.\nPotential changes and amortized costs of operations\nWe are now ready to examine how the disjoint-set operations affect node potentials.\nWith an understanding of the change in potential due to each operation, we can\ndetermine each operation’s amortized cost.\nLemma 21.10\nLet x be a node that is not a root, and suppose that the qth operation is either a\nLINK or FIND-SET. Then after the qth operation, \u0007q.x/ \u0002 \u0007q\u00031.x/. Moreover, if\nx:rank \u0006 1 and either level.x/ or iter.x/ changes due to the qth operation, then\n\u0007q.x/ \u0002 \u0007q\u00031.x/ \u0005 1. That is, x’s potential cannot increase, and if it has positive\nrank and either level.x/ or iter.x/ changes, then x’s potential drops by at least 1.\nProof\nBecause x is not a root, the qth operation does not change x:rank, and\nbecause n does not change after the initial n MAKE-SET operations, ˛.n/ remains\nunchanged as well. Hence, these components of the formula for x’s potential re-\nmain the same after the qth operation. If x:rank D 0, then \u0007q.x/ D \u0007q\u00031.x/ D 0.\nNow assume that x:rank \u0006 1.\nRecall that level.x/ monotonically increases over time. If the qth operation\nleaves level.x/ unchanged, then iter.x/ either increases or remains unchanged.\nIf both level.x/ and iter.x/ are unchanged, then \u0007q.x/ D \u0007q\u00031.x/. If level.x/\n21.4\nAnalysis of union by rank with path compression\n579\nis unchanged and iter.x/ increases, then it increases by at least 1, and so\n\u0007q.x/ \u0002 \u0007q\u00031.x/ \u0005 1.\nFinally, if the qth operation increases level.x/, it increases by at least 1, so that\nthe value of the term .˛.n/ \u0005 level.x// \u0003 x:rank drops by at least x:rank. Be-\ncause level.x/ increased, the value of iter.x/ might drop, but according to the\nbound (21.2), the drop is by at most x:rank \u0005 1. Thus, the increase in poten-",
    "parent_25ae2bc6-3c92-47fe-abef-76324d83c8e3": "the value of the term .˛.n/ \u0005 level.x// \u0003 x:rank drops by at least x:rank. Be-\ncause level.x/ increased, the value of iter.x/ might drop, but according to the\nbound (21.2), the drop is by at most x:rank \u0005 1. Thus, the increase in poten-\ntial due to the change in iter.x/ is less than the decrease in potential due to the\nchange in level.x/, and we conclude that \u0007q.x/ \u0002 \u0007q\u00031.x/ \u0005 1.\nOur ﬁnal three lemmas show that the amortized cost of each MAKE-SET, LINK,\nand FIND-SET operation is O.˛.n//. Recall from equation (17.2) that the amor-\ntized cost of each operation is its actual cost plus the increase in potential due to\nthe operation.\nLemma 21.11\nThe amortized cost of each MAKE-SET operation is O.1/.\nProof\nSuppose that the qth operation is MAKE-SET.x/. This operation creates\nnode x with rank 0, so that \u0007q.x/ D 0. No other ranks or potentials change, and\nso ˆq D ˆq\u00031. Noting that the actual cost of the MAKE-SET operation is O.1/\ncompletes the proof.\nLemma 21.12\nThe amortized cost of each LINK operation is O.˛.n//.\nProof\nSuppose that the qth operation is LINK.x; y/. The actual cost of the LINK\noperation is O.1/. Without loss of generality, suppose that the LINK makes y the\nparent of x.\nTo determine the change in potential due to the LINK, we note that the only\nnodes whose potentials may change are x, y, and the children of y just prior to the\noperation. We shall show that the only node whose potential can increase due to\nthe LINK is y, and that its increase is at most ˛.n/:\n\u0002\nBy Lemma 21.10, any node that is y’s child just before the LINK cannot have\nits potential increase due to the LINK.\n\u0002\nFrom the deﬁnition of \u0007q.x/, we see that, since x was a root just before the qth\noperation, \u0007q\u00031.x/ D ˛.n/\u0003x:rank. If x:rank D 0, then \u0007q.x/ D \u0007q\u00031.x/ D 0.\nOtherwise,\n\u0007q.x/\n<\n˛.n/ \u0003 x:rank\n(by Corollary 21.9)\nD\n\u0007q\u00031.x/ ;\nand so x’s potential decreases.\n580\nChapter 21\nData Structures for Disjoint Sets\n\u0002\nBecause y is a root prior to the LINK, \u0007q\u00031.y/ D ˛.n/ \u0003 y:rank. The LINK",
    "parent_4bda2e5a-5a31-455e-b875-4a4d1ba100a7": "operation, \u0007q\u00031.x/ D ˛.n/\u0003x:rank. If x:rank D 0, then \u0007q.x/ D \u0007q\u00031.x/ D 0.\nOtherwise,\n\u0007q.x/\n<\n˛.n/ \u0003 x:rank\n(by Corollary 21.9)\nD\n\u0007q\u00031.x/ ;\nand so x’s potential decreases.\n580\nChapter 21\nData Structures for Disjoint Sets\n\u0002\nBecause y is a root prior to the LINK, \u0007q\u00031.y/ D ˛.n/ \u0003 y:rank. The LINK\noperation leaves y as a root, and it either leaves y’s rank alone or it increases y’s\nrank by 1. Therefore, either \u0007q.y/ D \u0007q\u00031.y/ or \u0007q.y/ D \u0007q\u00031.y/ C ˛.n/.\nThe increase in potential due to the LINK operation, therefore, is at most ˛.n/.\nThe amortized cost of the LINK operation is O.1/ C ˛.n/ D O.˛.n//.\nLemma 21.13\nThe amortized cost of each FIND-SET operation is O.˛.n//.\nProof\nSuppose that the qth operation is a FIND-SET and that the ﬁnd path con-\ntains s nodes.\nThe actual cost of the FIND-SET operation is O.s/.\nWe shall\nshow that no node’s potential increases due to the FIND-SET and that at least\nmax.0; s \u0005 .˛.n/ C 2// nodes on the ﬁnd path have their potential decrease by\nat least 1.\nTo see that no node’s potential increases, we ﬁrst appeal to Lemma 21.10 for all\nnodes other than the root. If x is the root, then its potential is ˛.n/ \u0003 x:rank, which\ndoes not change.\nNow we show that at least max.0; s \u0005 .˛.n/ C 2// nodes have their potential\ndecrease by at least 1. Let x be a node on the ﬁnd path such that x:rank > 0\nand x is followed somewhere on the ﬁnd path by another node y that is not a root,\nwhere level.y/ D level.x/ just before the FIND-SET operation. (Node y need not\nimmediately follow x on the ﬁnd path.) All but at most ˛.n/ C 2 nodes on the ﬁnd\npath satisfy these constraints on x. Those that do not satisfy them are the ﬁrst node\non the ﬁnd path (if it has rank 0), the last node on the path (i.e., the root), and the\nlast node w on the path for which level.w/ D k, for each k D 0; 1; 2; : : : ; ˛.n/\u00051.\nLet us ﬁx such a node x, and we shall show that x’s potential decreases by at\nleast 1. Let k D level.x/ D level.y/. Just prior to the path compression caused by",
    "parent_6c3c67b3-d9dc-4764-84fe-c9eb4db9cd78": "last node w on the path for which level.w/ D k, for each k D 0; 1; 2; : : : ; ˛.n/\u00051.\nLet us ﬁx such a node x, and we shall show that x’s potential decreases by at\nleast 1. Let k D level.x/ D level.y/. Just prior to the path compression caused by\nthe FIND-SET, we have\nx:p:rank\n\u0006\nA.iter.x//\nk\n.x:rank/\n(by deﬁnition of iter.x/) ,\ny:p:rank\n\u0006\nAk.y:rank/\n(by deﬁnition of level.y/) ,\ny:rank\n\u0006\nx:p:rank\n(by Corollary 21.5 and because\ny follows x on the ﬁnd path) .\nPutting these inequalities together and letting i be the value of iter.x/ before path\ncompression, we have\ny:p:rank\n\u0006\nAk.y:rank/\n\u0006\nAk.x:p:rank/\n(because Ak.j / is strictly increasing)\n\u0006\nAk.A.iter.x//\nk\n.x:rank//\nD\nA.iC1/\nk\n.x:rank/ :\n21.4\nAnalysis of union by rank with path compression\n581\nBecause path compression will make x and y have the same parent, we know\nthat after path compression, x:p:rank D y:p:rank and that the path compression\ndoes not decrease y:p:rank. Since x:rank does not change, after path compression\nwe have that x:p:rank \u0006 A.iC1/\nk\n.x:rank/. Thus, path compression will cause ei-\nther iter.x/ to increase (to at least i C 1) or level.x/ to increase (which occurs if\niter.x/ increases to at least x:rank C 1). In either case, by Lemma 21.10, we have\n\u0007q.x/ \u0002 \u0007q\u00031.x/ \u0005 1. Hence, x’s potential decreases by at least 1.\nThe amortized cost of the FIND-SET operation is the actual cost plus the change\nin potential. The actual cost is O.s/, and we have shown that the total potential\ndecreases by at least max.0; s \u0005 .˛.n/ C 2//. The amortized cost, therefore, is at\nmost O.s/ \u0005 .s \u0005 .˛.n/ C 2// D O.s/ \u0005 s C O.˛.n// D O.˛.n//, since we can\nscale up the units of potential to dominate the constant hidden in O.s/.\nPutting the preceding lemmas together yields the following theorem.\nTheorem 21.14\nA sequence of m MAKE-SET, UNION, and FIND-SET operations, n of which are\nMAKE-SET operations, can be performed on a disjoint-set forest with union by\nrank and path compression in worst-case time O.m ˛.n//.\nProof",
    "parent_f698967d-c7c9-4899-bbae-a4598fc09c61": "Putting the preceding lemmas together yields the following theorem.\nTheorem 21.14\nA sequence of m MAKE-SET, UNION, and FIND-SET operations, n of which are\nMAKE-SET operations, can be performed on a disjoint-set forest with union by\nrank and path compression in worst-case time O.m ˛.n//.\nProof\nImmediate from Lemmas 21.7, 21.11, 21.12, and 21.13.\nExercises\n21.4-1\nProve Lemma 21.4.\n21.4-2\nProve that every node has rank at most blg nc.\n21.4-3\nIn light of Exercise 21.4-2, how many bits are necessary to store x:rank for each\nnode x?\n21.4-4\nUsing Exercise 21.4-2, give a simple proof that operations on a disjoint-set forest\nwith union by rank but without path compression run in O.m lg n/ time.\n21.4-5\nProfessor Dante reasons that because node ranks increase strictly along a simple\npath to the root, node levels must monotonically increase along the path. In other\n582\nChapter 21\nData Structures for Disjoint Sets\nwords, if x:rank > 0 and x:p is not a root, then level.x/ \u0002 level.x:p/. Is the\nprofessor correct?\n21.4-6\n?\nConsider the function ˛0.n/ D min fk W Ak.1/ \u0006 lg.n C 1/g. Show that ˛0.n/ \u0002 3\nfor all practical values of n and, using Exercise 21.4-2, show how to modify the\npotential-function argument to prove that we can perform a sequence of m MAKE-\nSET, UNION, and FIND-SET operations, n of which are MAKE-SET operations, on\na disjoint-set forest with union by rank and path compression in worst-case time\nO.m ˛0.n//.\nProblems\n21-1\nOff-line minimum\nThe off-line minimum problem asks us to maintain a dynamic set T of elements\nfrom the domain f1; 2; : : : ; ng under the operations INSERT and EXTRACT-MIN.\nWe are given a sequence S of n INSERT and m EXTRACT-MIN calls, where each\nkey in f1; 2; : : : ; ng is inserted exactly once. We wish to determine which key\nis returned by each EXTRACT-MIN call. Speciﬁcally, we wish to ﬁll in an array\nextractedŒ1 : : m\u0002, where for i D 1; 2; : : : ; m, extractedŒi\u0002 is the key returned by",
    "parent_ea08ec7a-ab3c-45ee-a803-f6c19c7c699c": "key in f1; 2; : : : ; ng is inserted exactly once. We wish to determine which key\nis returned by each EXTRACT-MIN call. Speciﬁcally, we wish to ﬁll in an array\nextractedŒ1 : : m\u0002, where for i D 1; 2; : : : ; m, extractedŒi\u0002 is the key returned by\nthe ith EXTRACT-MIN call. The problem is “off-line” in the sense that we are\nallowed to process the entire sequence S before determining any of the returned\nkeys.\na. In the following instance of the off-line minimum problem, each operation\nINSERT.i/ is represented by the value of i and each EXTRACT-MIN is rep-\nresented by the letter E:\n4; 8; E; 3; E; 9; 2; 6; E; E; E; 1; 7; E; 5 :\nFill in the correct values in the extracted array.\nTo develop an algorithm for this problem, we break the sequence S into homoge-\nneous subsequences. That is, we represent S by\nI1; E; I2; E; I3; : : : ; Im; E; ImC1 ;\nwhere each E represents a single EXTRACT-MIN call and each Ij represents a (pos-\nsibly empty) sequence of INSERT calls. For each subsequence Ij, we initially place\nthe keys inserted by these operations into a set Kj, which is empty if Ij is empty.\nWe then do the following:\nProblems for Chapter 21\n583\nOFF-LINE-MINIMUM.m; n/\n1\nfor i D 1 to n\n2\ndetermine j such that i 2 Kj\n3\nif j ¤ m C 1\n4\nextractedŒj \u0002 D i\n5\nlet l be the smallest value greater than j\nfor which set Kl exists\n6\nKl D Kj [ Kl, destroying Kj\n7\nreturn extracted\nb. Argue that the array extracted returned by OFF-LINE-MINIMUM is correct.\nc. Describe how to implement OFF-LINE-MINIMUM efﬁciently with a disjoint-\nset data structure. Give a tight bound on the worst-case running time of your\nimplementation.\n21-2\nDepth determination\nIn the depth-determination problem, we maintain a forest F D fTig of rooted\ntrees under three operations:\nMAKE-TREE.\u0003/ creates a tree whose only node is \u0003.\nFIND-DEPTH.\u0003/ returns the depth of node \u0003 within its tree.\nGRAFT.r; \u0003/ makes node r, which is assumed to be the root of a tree, become the",
    "parent_ff6c2c25-4621-4899-b267-94ffc7f01a86": "In the depth-determination problem, we maintain a forest F D fTig of rooted\ntrees under three operations:\nMAKE-TREE.\u0003/ creates a tree whose only node is \u0003.\nFIND-DEPTH.\u0003/ returns the depth of node \u0003 within its tree.\nGRAFT.r; \u0003/ makes node r, which is assumed to be the root of a tree, become the\nchild of node \u0003, which is assumed to be in a different tree than r but may or may\nnot itself be a root.\na. Suppose that we use a tree representation similar to a disjoint-set forest: \u0003:p\nis the parent of node \u0003, except that \u0003:p D \u0003 if \u0003 is a root. Suppose further\nthat we implement GRAFT.r; \u0003/ by setting r:p D \u0003 and FIND-DEPTH.\u0003/ by\nfollowing the ﬁnd path up to the root, returning a count of all nodes other than \u0003\nencountered. Show that the worst-case running time of a sequence of m MAKE-\nTREE, FIND-DEPTH, and GRAFT operations is ‚.m2/.\nBy using the union-by-rank and path-compression heuristics, we can reduce the\nworst-case running time. We use the disjoint-set forest S D fSig, where each\nset Si (which is itself a tree) corresponds to a tree Ti in the forest F . The tree\nstructure within a set Si, however, does not necessarily correspond to that of Ti. In\nfact, the implementation of Si does not record the exact parent-child relationships\nbut nevertheless allows us to determine any node’s depth in Ti.\nThe key idea is to maintain in each node \u0003 a “pseudodistance” \u0003:d, which is\ndeﬁned so that the sum of the pseudodistances along the simple path from \u0003 to the\n584\nChapter 21\nData Structures for Disjoint Sets\nroot of its set Si equals the depth of \u0003 in Ti. That is, if the simple path from \u0003 to its\nroot in Si is \u00030; \u00031; : : : ; \u0003k, where \u00030 D \u0003 and \u0003k is Si’s root, then the depth of \u0003\nin Ti is Pk\njD0 \u0003j:d.\nb. Give an implementation of MAKE-TREE.\nc. Show how to modify FIND-SET to implement FIND-DEPTH. Your implemen-\ntation should perform path compression, and its running time should be linear\nin the length of the ﬁnd path. Make sure that your implementation updates",
    "parent_a6d9a5a2-5dcd-482c-b2fc-14dc2a50019a": "in Ti is Pk\njD0 \u0003j:d.\nb. Give an implementation of MAKE-TREE.\nc. Show how to modify FIND-SET to implement FIND-DEPTH. Your implemen-\ntation should perform path compression, and its running time should be linear\nin the length of the ﬁnd path. Make sure that your implementation updates\npseudodistances correctly.\nd. Show how to implement GRAFT.r; \u0003/, which combines the sets containing r\nand \u0003, by modifying the UNION and LINK procedures. Make sure that your\nimplementation updates pseudodistances correctly. Note that the root of a set Si\nis not necessarily the root of the corresponding tree Ti.\ne. Give a tight bound on the worst-case running time of a sequence of m MAKE-\nTREE, FIND-DEPTH, and GRAFT operations, n of which are MAKE-TREE op-\nerations.\n21-3\nTarjan’s off-line least-common-ancestors algorithm\nThe least common ancestor of two nodes u and \u0003 in a rooted tree T is the node w\nthat is an ancestor of both u and \u0003 and that has the greatest depth in T . In the\noff-line least-common-ancestors problem, we are given a rooted tree T and an\narbitrary set P D ffu; \u0003gg of unordered pairs of nodes in T , and we wish to deter-\nmine the least common ancestor of each pair in P .\nTo solve the off-line least-common-ancestors problem, the following procedure\nperforms a tree walk of T with the initial call LCA.T:root/. We assume that each\nnode is colored WHITE prior to the walk.\nLCA.u/\n1\nMAKE-SET.u/\n2\nFIND-SET.u/:ancestor D u\n3\nfor each child \u0003 of u in T\n4\nLCA.\u0003/\n5\nUNION.u; \u0003/\n6\nFIND-SET.u/:ancestor D u\n7\nu:color D BLACK\n8\nfor each node \u0003 such that fu; \u0003g 2 P\n9\nif \u0003:color == BLACK\n10\nprint “The least common ancestor of”\nu “and” \u0003 “is” FIND-SET.\u0003/:ancestor\nNotes for Chapter 21\n585\na. Argue that line 10 executes exactly once for each pair fu; \u0003g 2 P .\nb. Argue that at the time of the call LCA.u/, the number of sets in the disjoint-set\ndata structure equals the depth of u in T .\nc. Prove that LCA correctly prints the least common ancestor of u and \u0003 for each\npair fu; \u0003g 2 P .",
    "parent_2ad51805-eec0-4e28-8e47-cc59a56a4d36": "a. Argue that line 10 executes exactly once for each pair fu; \u0003g 2 P .\nb. Argue that at the time of the call LCA.u/, the number of sets in the disjoint-set\ndata structure equals the depth of u in T .\nc. Prove that LCA correctly prints the least common ancestor of u and \u0003 for each\npair fu; \u0003g 2 P .\nd. Analyze the running time of LCA, assuming that we use the implementation of\nthe disjoint-set data structure in Section 21.3.\nChapter notes\nMany of the important results for disjoint-set data structures are due at least in part\nto R. E. Tarjan. Using aggregate analysis, Tarjan [328, 330] gave the ﬁrst tight\nupper bound in terms of the very slowly growing inverse y˛.m; n/ of Ackermann’s\nfunction. (The function Ak.j / given in Section 21.4 is similar to Ackermann’s\nfunction, and the function ˛.n/ is similar to the inverse. Both ˛.n/ and y˛.m; n/\nare at most 4 for all conceivable values of m and n.) An O.m lg\u0004 n/ upper bound\nwas proven earlier by Hopcroft and Ullman [5, 179]. The treatment in Section 21.4\nis adapted from a later analysis by Tarjan [332], which is in turn based on an anal-\nysis by Kozen [220]. Harfst and Reingold [161] give a potential-based version of\nTarjan’s earlier bound.\nTarjan and van Leeuwen [333] discuss variants on the path-compression heuris-\ntic, including “one-pass methods,” which sometimes offer better constant factors\nin their performance than do two-pass methods. As with Tarjan’s earlier analyses\nof the basic path-compression heuristic, the analyses by Tarjan and van Leeuwen\nare aggregate. Harfst and Reingold [161] later showed how to make a small change\nto the potential function to adapt their path-compression analysis to these one-pass\nvariants. Gabow and Tarjan [121] show that in certain applications, the disjoint-set\noperations can be made to run in O.m/ time.\nTarjan [329] showed that a lower bound of \u0004.m y˛.m; n// time is required for\noperations on any disjoint-set data structure satisfying certain technical conditions.",
    "parent_304e7dd7-b61a-4bfb-a654-029ffec84c6c": "variants. Gabow and Tarjan [121] show that in certain applications, the disjoint-set\noperations can be made to run in O.m/ time.\nTarjan [329] showed that a lower bound of \u0004.m y˛.m; n// time is required for\noperations on any disjoint-set data structure satisfying certain technical conditions.\nThis lower bound was later generalized by Fredman and Saks [113], who showed\nthat in the worst case, \u0004.m y˛.m; n// .lg n/-bit words of memory must be accessed.\nVI\nGraph Algorithms\nIntroduction\nGraph problems pervade computer science, and algorithms for working with them\nare fundamental to the ﬁeld. Hundreds of interesting computational problems are\ncouched in terms of graphs. In this part, we touch on a few of the more signiﬁcant\nones.\nChapter 22 shows how we can represent a graph in a computer and then discusses\nalgorithms based on searching a graph using either breadth-ﬁrst search or depth-\nﬁrst search. The chapter gives two applications of depth-ﬁrst search: topologically\nsorting a directed acyclic graph and decomposing a directed graph into its strongly\nconnected components.\nChapter 23 describes how to compute a minimum-weight spanning tree of a\ngraph: the least-weight way of connecting all of the vertices together when each\nedge has an associated weight. The algorithms for computing minimum spanning\ntrees serve as good examples of greedy algorithms (see Chapter 16).\nChapters 24 and 25 consider how to compute shortest paths between vertices\nwhen each edge has an associated length or “weight.” Chapter 24 shows how to\nﬁnd shortest paths from a given source vertex to all other vertices, and Chapter 25\nexamines methods to compute shortest paths between every pair of vertices.\nFinally, Chapter 26 shows how to compute a maximum ﬂow of material in a ﬂow\nnetwork, which is a directed graph having a speciﬁed source vertex of material, a\nspeciﬁed sink vertex, and speciﬁed capacities for the amount of material that can",
    "parent_8a54babe-9eeb-4b95-9e5d-1bdf3014d6b8": "Finally, Chapter 26 shows how to compute a maximum ﬂow of material in a ﬂow\nnetwork, which is a directed graph having a speciﬁed source vertex of material, a\nspeciﬁed sink vertex, and speciﬁed capacities for the amount of material that can\ntraverse each directed edge. This general problem arises in many forms, and a\ngood algorithm for computing maximum ﬂows can help solve a variety of related\nproblems efﬁciently.\n588\nPart VI\nGraph Algorithms\nWhen we characterize the running time of a graph algorithm on a given graph\nG D .V; E/, we usually measure the size of the input in terms of the number of\nvertices jV j and the number of edges jEj of the graph. That is, we describe the\nsize of the input with two parameters, not just one. We adopt a common notational\nconvention for these parameters. Inside asymptotic notation (such as O-notation\nor ‚-notation), and only inside such notation, the symbol V denotes jV j and\nthe symbol E denotes jEj. For example, we might say, “the algorithm runs in\ntime O.VE/,” meaning that the algorithm runs in time O.jV j jEj/. This conven-\ntion makes the running-time formulas easier to read, without risk of ambiguity.\nAnother convention we adopt appears in pseudocode. We denote the vertex set\nof a graph G by G:V and its edge set by G:E. That is, the pseudocode views vertex\nand edge sets as attributes of a graph.\n22\nElementary Graph Algorithms\nThis chapter presents methods for representing a graph and for searching a graph.\nSearching a graph means systematically following the edges of the graph so as to\nvisit the vertices of the graph. A graph-searching algorithm can discover much\nabout the structure of a graph. Many algorithms begin by searching their input\ngraph to obtain this structural information. Several other graph algorithms elabo-\nrate on basic graph searching. Techniques for searching a graph lie at the heart of\nthe ﬁeld of graph algorithms.\nSection 22.1 discusses the two most common computational representations of",
    "parent_b2e5ec41-0f2a-4888-9333-e0fb34d8df9a": "graph to obtain this structural information. Several other graph algorithms elabo-\nrate on basic graph searching. Techniques for searching a graph lie at the heart of\nthe ﬁeld of graph algorithms.\nSection 22.1 discusses the two most common computational representations of\ngraphs: as adjacency lists and as adjacency matrices. Section 22.2 presents a sim-\nple graph-searching algorithm called breadth-ﬁrst search and shows how to cre-\nate a breadth-ﬁrst tree. Section 22.3 presents depth-ﬁrst search and proves some\nstandard results about the order in which depth-ﬁrst search visits vertices. Sec-\ntion 22.4 provides our ﬁrst real application of depth-ﬁrst search: topologically sort-\ning a directed acyclic graph. A second application of depth-ﬁrst search, ﬁnding the\nstrongly connected components of a directed graph, is the topic of Section 22.5.\n22.1\nRepresentations of graphs\nWe can choose between two standard ways to represent a graph G D .V; E/:\nas a collection of adjacency lists or as an adjacency matrix. Either way applies\nto both directed and undirected graphs. Because the adjacency-list representation\nprovides a compact way to represent sparse graphs—those for which jEj is much\nless than jV j2—it is usually the method of choice. Most of the graph algorithms\npresented in this book assume that an input graph is represented in adjacency-\nlist form. We may prefer an adjacency-matrix representation, however, when the\ngraph is dense—jEj is close to jV j2—or when we need to be able to tell quickly\nif there is an edge connecting two given vertices. For example, two of the all-pairs\n590\nChapter 22\nElementary Graph Algorithms\n1\n2\n3\n4\n5\n1\n2\n3\n4\n5\n2\n5\n1\n2\n2\n4\n1\n2\n5\n3\n4\n4\n5\n3\n1\n0\n0\n1\n0\n1\n1\n1\n1\n0\n1\n0\n1\n1\n0\n1\n1\n0\n1\n0\n0\n1\n0\n0\n1\n1\n2\n3\n4\n5\n1\n2\n3\n4\n5\n(a)\n(b)\n(c)\nFigure 22.1\nTwo representations of an undirected graph. (a) An undirected graph G with 5 vertices\nand 7 edges. (b) An adjacency-list representation of G. (c) The adjacency-matrix representation\nof G.\n1\n2\n5\n4\n1\n2\n3\n4\n5\n2\n4\n5\n6\n2",
    "parent_a9d1cd83-2ba5-451c-a9b7-1dd4c8ce822e": "1\n1\n1\n1\n0\n1\n0\n1\n1\n0\n1\n1\n0\n1\n0\n0\n1\n0\n0\n1\n1\n2\n3\n4\n5\n1\n2\n3\n4\n5\n(a)\n(b)\n(c)\nFigure 22.1\nTwo representations of an undirected graph. (a) An undirected graph G with 5 vertices\nand 7 edges. (b) An adjacency-list representation of G. (c) The adjacency-matrix representation\nof G.\n1\n2\n5\n4\n1\n2\n3\n4\n5\n2\n4\n5\n6\n2\n4\n6\n5\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\n0\n1\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n1\n2\n3\n4\n5\n1\n2\n3\n4\n5\n(a)\n(b)\n(c)\n3\n6\n6\n6\n6\n0\n0\n0\n0\n0\n1\n0\n0\n1\n0\n0\nFigure 22.2\nTwo representations of a directed graph. (a) A directed graph G with 6 vertices and 8\nedges. (b) An adjacency-list representation of G. (c) The adjacency-matrix representation of G.\nshortest-paths algorithms presented in Chapter 25 assume that their input graphs\nare represented by adjacency matrices.\nThe adjacency-list representation of a graph G D .V; E/ consists of an ar-\nray Adj of jV j lists, one for each vertex in V . For each u 2 V , the adjacency list\nAdjŒu\u0002 contains all the vertices \u0003 such that there is an edge .u; \u0003/ 2 E. That is,\nAdjŒu\u0002 consists of all the vertices adjacent to u in G. (Alternatively, it may contain\npointers to these vertices.) Since the adjacency lists represent the edges of a graph,\nin pseudocode we treat the array Adj as an attribute of the graph, just as we treat\nthe edge set E. In pseudocode, therefore, we will see notation such as G:AdjŒu\u0002.\nFigure 22.1(b) is an adjacency-list representation of the undirected graph in Fig-\nure 22.1(a). Similarly, Figure 22.2(b) is an adjacency-list representation of the\ndirected graph in Figure 22.2(a).\nIf G is a directed graph, the sum of the lengths of all the adjacency lists is jEj,\nsince an edge of the form .u; \u0003/ is represented by having \u0003 appear in AdjŒu\u0002. If G is\n22.1\nRepresentations of graphs\n591\nan undirected graph, the sum of the lengths of all the adjacency lists is 2 jEj, since\nif .u; \u0003/ is an undirected edge, then u appears in \u0003’s adjacency list and vice versa.\nFor both directed and undirected graphs, the adjacency-list representation has the",
    "parent_64f809f7-ad3d-44e6-9cb4-00fe46996aac": "22.1\nRepresentations of graphs\n591\nan undirected graph, the sum of the lengths of all the adjacency lists is 2 jEj, since\nif .u; \u0003/ is an undirected edge, then u appears in \u0003’s adjacency list and vice versa.\nFor both directed and undirected graphs, the adjacency-list representation has the\ndesirable property that the amount of memory it requires is ‚.V C E/.\nWe can readily adapt adjacency lists to represent weighted graphs, that is, graphs\nfor which each edge has an associated weight, typically given by a weight function\nw W E ! R. For example, let G D .V; E/ be a weighted graph with weight\nfunction w. We simply store the weight w.u; \u0003/ of the edge .u; \u0003/ 2 E with\nvertex \u0003 in u’s adjacency list. The adjacency-list representation is quite robust in\nthat we can modify it to support many other graph variants.\nA potential disadvantage of the adjacency-list representation is that it provides\nno quicker way to determine whether a given edge .u; \u0003/ is present in the graph\nthan to search for \u0003 in the adjacency list AdjŒu\u0002. An adjacency-matrix representa-\ntion of the graph remedies this disadvantage, but at the cost of using asymptotically\nmore memory. (See Exercise 22.1-8 for suggestions of variations on adjacency lists\nthat permit faster edge lookup.)\nFor the adjacency-matrix representation of a graph G D .V; E/, we assume\nthat the vertices are numbered 1; 2; : : : ; jV j in some arbitrary manner. Then the\nadjacency-matrix representation of a graph G consists of a jV j \t jV j matrix\nA D .aij/ such that\naij D\n(\n1\nif .i; j / 2 E ;\n0\notherwise :\nFigures 22.1(c) and 22.2(c) are the adjacency matrices of the undirected and di-\nrected graphs in Figures 22.1(a) and 22.2(a), respectively. The adjacency matrix of\na graph requires ‚.V 2/ memory, independent of the number of edges in the graph.\nObserve the symmetry along the main diagonal of the adjacency matrix in Fig-\nure 22.1(c). Since in an undirected graph, .u; \u0003/ and .\u0003; u/ represent the same",
    "parent_68f4578b-0f3c-4bfc-b815-296153e7bc31": "a graph requires ‚.V 2/ memory, independent of the number of edges in the graph.\nObserve the symmetry along the main diagonal of the adjacency matrix in Fig-\nure 22.1(c). Since in an undirected graph, .u; \u0003/ and .\u0003; u/ represent the same\nedge, the adjacency matrix A of an undirected graph is its own transpose: A D AT.\nIn some applications, it pays to store only the entries on and above the diagonal of\nthe adjacency matrix, thereby cutting the memory needed to store the graph almost\nin half.\nLike the adjacency-list representation of a graph, an adjacency matrix can repre-\nsent a weighted graph. For example, if G D .V; E/ is a weighted graph with edge-\nweight function w, we can simply store the weight w.u; \u0003/ of the edge .u; \u0003/ 2 E\nas the entry in row u and column \u0003 of the adjacency matrix. If an edge does not\nexist, we can store a NIL value as its corresponding matrix entry, though for many\nproblems it is convenient to use a value such as 0 or 1.\nAlthough the adjacency-list representation is asymptotically at least as space-\nefﬁcient as the adjacency-matrix representation, adjacency matrices are simpler,\nand so we may prefer them when graphs are reasonably small. Moreover, adja-\n592\nChapter 22\nElementary Graph Algorithms\ncency matrices carry a further advantage for unweighted graphs: they require only\none bit per entry.\nRepresenting attributes\nMost algorithms that operate on graphs need to maintain attributes for vertices\nand/or edges. We indicate these attributes using our usual notation, such as \u0003:d\nfor an attribute d of a vertex \u0003. When we indicate edges as pairs of vertices, we\nuse the same style of notation. For example, if edges have an attribute f , then we\ndenote this attribute for edge .u; \u0003/ by .u; \u0003/:f. For the purpose of presenting and\nunderstanding algorithms, our attribute notation sufﬁces.\nImplementing vertex and edge attributes in real programs can be another story\nentirely. There is no one best way to store and access vertex and edge attributes.",
    "parent_e6b3af37-2904-4826-b09f-f04cb68b9cf4": "understanding algorithms, our attribute notation sufﬁces.\nImplementing vertex and edge attributes in real programs can be another story\nentirely. There is no one best way to store and access vertex and edge attributes.\nFor a given situation, your decision will likely depend on the programming lan-\nguage you are using, the algorithm you are implementing, and how the rest of your\nprogram uses the graph. If you represent a graph using adjacency lists, one design\nrepresents vertex attributes in additional arrays, such as an array dŒ1 : : jV j\u0002 that\nparallels the Adj array. If the vertices adjacent to u are in AdjŒu\u0002, then what we call\nthe attribute u:d would actually be stored in the array entry dŒu\u0002. Many other ways\nof implementing attributes are possible. For example, in an object-oriented pro-\ngramming language, vertex attributes might be represented as instance variables\nwithin a subclass of a Vertex class.\nExercises\n22.1-1\nGiven an adjacency-list representation of a directed graph, how long does it take\nto compute the out-degree of every vertex? How long does it take to compute the\nin-degrees?\n22.1-2\nGive an adjacency-list representation for a complete binary tree on 7 vertices. Give\nan equivalent adjacency-matrix representation. Assume that vertices are numbered\nfrom 1 to 7 as in a binary heap.\n22.1-3\nThe transpose of a directed graph G D .V; E/ is the graph GT D .V; ET/, where\nET D f.\u0003; u/ 2 V \t V W .u; \u0003/ 2 Eg. Thus, GT is G with all its edges reversed.\nDescribe efﬁcient algorithms for computing GT from G, for both the adjacency-\nlist and adjacency-matrix representations of G. Analyze the running times of your\nalgorithms.\n22.1\nRepresentations of graphs\n593\n22.1-4\nGiven an adjacency-list representation of a multigraph G D .V; E/, describe an\nO.V C E/-time algorithm to compute the adjacency-list representation of the\n“equivalent” undirected graph G0 D .V; E0/, where E0 consists of the edges in E",
    "parent_ea683b6a-4c12-4f67-a3a3-cb336a14fe5f": "algorithms.\n22.1\nRepresentations of graphs\n593\n22.1-4\nGiven an adjacency-list representation of a multigraph G D .V; E/, describe an\nO.V C E/-time algorithm to compute the adjacency-list representation of the\n“equivalent” undirected graph G0 D .V; E0/, where E0 consists of the edges in E\nwith all multiple edges between two vertices replaced by a single edge and with all\nself-loops removed.\n22.1-5\nThe square of a directed graph G D .V; E/ is the graph G2 D .V; E2/ such that\n.u; \u0003/ 2 E2 if and only G contains a path with at most two edges between u and \u0003.\nDescribe efﬁcient algorithms for computing G2 from G for both the adjacency-\nlist and adjacency-matrix representations of G. Analyze the running times of your\nalgorithms.\n22.1-6\nMost graph algorithms that take an adjacency-matrix representation as input re-\nquire time \u0004.V 2/, but there are some exceptions. Show how to determine whether\na directed graph G contains a universal sink—a vertex with in-degree jV j \u0005 1 and\nout-degree 0—in time O.V /, given an adjacency matrix for G.\n22.1-7\nThe incidence matrix of a directed graph G D .V; E/ with no self-loops is a\njV j \t jEj matrix B D .bij/ such that\nbij D\n\u0002\n\u00051\nif edge j leaves vertex i ;\n1\nif edge j enters vertex i ;\n0\notherwise :\nDescribe what the entries of the matrix product BBT represent, where BT is the\ntranspose of B.\n22.1-8\nSuppose that instead of a linked list, each array entry AdjŒu\u0002 is a hash table contain-\ning the vertices \u0003 for which .u; \u0003/ 2 E. If all edge lookups are equally likely, what\nis the expected time to determine whether an edge is in the graph? What disadvan-\ntages does this scheme have? Suggest an alternate data structure for each edge list\nthat solves these problems. Does your alternative have disadvantages compared to\nthe hash table?\n594\nChapter 22\nElementary Graph Algorithms\n22.2\nBreadth-ﬁrst search\nBreadth-ﬁrst search is one of the simplest algorithms for searching a graph and",
    "parent_6ed4b3c0-385d-4ac3-b1fa-b56526be398a": "that solves these problems. Does your alternative have disadvantages compared to\nthe hash table?\n594\nChapter 22\nElementary Graph Algorithms\n22.2\nBreadth-ﬁrst search\nBreadth-ﬁrst search is one of the simplest algorithms for searching a graph and\nthe archetype for many important graph algorithms. Prim’s minimum-spanning-\ntree algorithm (Section 23.2) and Dijkstra’s single-source shortest-paths algorithm\n(Section 24.3) use ideas similar to those in breadth-ﬁrst search.\nGiven a graph G D .V; E/ and a distinguished source vertex s, breadth-ﬁrst\nsearch systematically explores the edges of G to “discover” every vertex that is\nreachable from s. It computes the distance (smallest number of edges) from s\nto each reachable vertex. It also produces a “breadth-ﬁrst tree” with root s that\ncontains all reachable vertices. For any vertex \u0003 reachable from s, the simple path\nin the breadth-ﬁrst tree from s to \u0003 corresponds to a “shortest path” from s to \u0003\nin G, that is, a path containing the smallest number of edges. The algorithm works\non both directed and undirected graphs.\nBreadth-ﬁrst search is so named because it expands the frontier between discov-\nered and undiscovered vertices uniformly across the breadth of the frontier. That\nis, the algorithm discovers all vertices at distance k from s before discovering any\nvertices at distance k C 1.\nTo keep track of progress, breadth-ﬁrst search colors each vertex white, gray, or\nblack. All vertices start out white and may later become gray and then black. A\nvertex is discovered the ﬁrst time it is encountered during the search, at which time\nit becomes nonwhite. Gray and black vertices, therefore, have been discovered, but\nbreadth-ﬁrst search distinguishes between them to ensure that the search proceeds\nin a breadth-ﬁrst manner.1 If .u; \u0003/ 2 E and vertex u is black, then vertex \u0003\nis either gray or black; that is, all vertices adjacent to black vertices have been",
    "parent_e6a35c34-3c58-4763-a38f-b0f55e206ca5": "breadth-ﬁrst search distinguishes between them to ensure that the search proceeds\nin a breadth-ﬁrst manner.1 If .u; \u0003/ 2 E and vertex u is black, then vertex \u0003\nis either gray or black; that is, all vertices adjacent to black vertices have been\ndiscovered. Gray vertices may have some adjacent white vertices; they represent\nthe frontier between discovered and undiscovered vertices.\nBreadth-ﬁrst search constructs a breadth-ﬁrst tree, initially containing only its\nroot, which is the source vertex s. Whenever the search discovers a white vertex \u0003\nin the course of scanning the adjacency list of an already discovered vertex u, the\nvertex \u0003 and the edge .u; \u0003/ are added to the tree. We say that u is the predecessor\nor parent of \u0003 in the breadth-ﬁrst tree. Since a vertex is discovered at most once, it\nhas at most one parent. Ancestor and descendant relationships in the breadth-ﬁrst\ntree are deﬁned relative to the root s as usual: if u is on the simple path in the tree\nfrom the root s to vertex \u0003, then u is an ancestor of \u0003 and \u0003 is a descendant of u.\n1We distinguish between gray and black vertices to help us understand how breadth-ﬁrst search op-\nerates. In fact, as Exercise 22.2-3 shows, we would get the same result even if we did not distinguish\nbetween gray and black vertices.\n22.2\nBreadth-ﬁrst search\n595\nThe breadth-ﬁrst-search procedure BFS below assumes that the input graph\nG D .V; E/ is represented using adjacency lists. It attaches several additional\nattributes to each vertex in the graph. We store the color of each vertex u 2 V\nin the attribute u:color and the predecessor of u in the attribute u:\u0006. If u has no\npredecessor (for example, if u D s or u has not been discovered), then u:\u0006 D NIL.\nThe attribute u:d holds the distance from the source s to vertex u computed by the\nalgorithm. The algorithm also uses a ﬁrst-in, ﬁrst-out queue Q (see Section 10.1)\nto manage the set of gray vertices.\nBFS.G; s/\n1\nfor each vertex u 2 G:V \u0005 fsg\n2\nu:color D WHITE\n3\nu:d D 1\n4",
    "parent_2109ed5a-d4f8-4325-b125-5523bd906cc7": "The attribute u:d holds the distance from the source s to vertex u computed by the\nalgorithm. The algorithm also uses a ﬁrst-in, ﬁrst-out queue Q (see Section 10.1)\nto manage the set of gray vertices.\nBFS.G; s/\n1\nfor each vertex u 2 G:V \u0005 fsg\n2\nu:color D WHITE\n3\nu:d D 1\n4\nu:\u0006 D NIL\n5\ns:color D GRAY\n6\ns:d D 0\n7\ns:\u0006 D NIL\n8\nQ D ;\n9\nENQUEUE.Q; s/\n10\nwhile Q ¤ ;\n11\nu D DEQUEUE.Q/\n12\nfor each \u0003 2 G:AdjŒu\u0002\n13\nif \u0003:color == WHITE\n14\n\u0003:color D GRAY\n15\n\u0003:d D u:d C 1\n16\n\u0003:\u0006 D u\n17\nENQUEUE.Q; \u0003/\n18\nu:color D BLACK\nFigure 22.3 illustrates the progress of BFS on a sample graph.\nThe procedure BFS works as follows. With the exception of the source vertex s,\nlines 1–4 paint every vertex white, set u:d to be inﬁnity for each vertex u, and set\nthe parent of every vertex to be NIL. Line 5 paints s gray, since we consider it to be\ndiscovered as the procedure begins. Line 6 initializes s:d to 0, and line 7 sets the\npredecessor of the source to be NIL. Lines 8–9 initialize Q to the queue containing\njust the vertex s.\nThe while loop of lines 10–18 iterates as long as there remain gray vertices,\nwhich are discovered vertices that have not yet had their adjacency lists fully ex-\namined. This while loop maintains the following invariant:\nAt the test in line 10, the queue Q consists of the set of gray vertices.\n596\nChapter 22\nElementary Graph Algorithms\nr\ns\nt\nu\nv\nw\nx\ny\n0\n∞\n∞\n∞\n∞\n∞\n∞\n∞\ns\n0\nQ\n(a)\nt\nu\nv\nw\nx\ny\n0\n1\n∞\n∞\n∞\n∞\n∞\n1\nw\n1\nQ\n(b)\nr\n1\nt\nu\nv\nw\nx\ny\n0\n1\n2\n∞\n∞\n2\n∞\n1\nQ\n(c)\nr\n1\nt\nu\nv\nw\nx\ny\n0\n1\n∞\n∞\nQ\n(d)\n(e)\n(f)\n(g)\n(h)\nQ\n(i)\nr\ns\nr\ns\nr\ns\nt\n2\nx\n2\n2\n2\n1\n2\nt\n2\nx\n2\nv\n2\nt\nu\nv\nw\nx\ny\n0\n1\n∞\nQ\nr\ns\n2\n2\n1\n2\nx\n2\nv\n2\nu\n3\n3\nt\nu\nv\nw\nx\ny\n0\n1\n3\nQ\nr\ns\n2\n2\n1\n2\nv\n2\nu\n3\n3\ny\n3\nt\nu\nv\nw\nx\ny\n0\n1\n3\nQ\nr\ns\n2\n2\n1\nu\n3\n3\ny\n3\n2\nt\nu\nv\nw\nx\ny\n0\n1\n3\nQ\nr\ns\n2\n2\n1\n3\ny\n3\n2\nt\nu\nv\nw\nx\ny\n0\n1\nr\ns\n2\n2\n1\n3\n2\n3\n;\nFigure 22.3\nThe operation of BFS on an undirected graph. Tree edges are shown shaded as they\nare produced by BFS. The value of u:d appears within each vertex u. The queue Q is shown at the",
    "parent_4b6e3df3-b050-48db-b9dc-63b827c10653": "v\nw\nx\ny\n0\n1\n3\nQ\nr\ns\n2\n2\n1\nu\n3\n3\ny\n3\n2\nt\nu\nv\nw\nx\ny\n0\n1\n3\nQ\nr\ns\n2\n2\n1\n3\ny\n3\n2\nt\nu\nv\nw\nx\ny\n0\n1\nr\ns\n2\n2\n1\n3\n2\n3\n;\nFigure 22.3\nThe operation of BFS on an undirected graph. Tree edges are shown shaded as they\nare produced by BFS. The value of u:d appears within each vertex u. The queue Q is shown at the\nbeginning of each iteration of the while loop of lines 10–18. Vertex distances appear below vertices\nin the queue.\nAlthough we won’t use this loop invariant to prove correctness, it is easy to see\nthat it holds prior to the ﬁrst iteration and that each iteration of the loop maintains\nthe invariant. Prior to the ﬁrst iteration, the only gray vertex, and the only vertex\nin Q, is the source vertex s. Line 11 determines the gray vertex u at the head of\nthe queue Q and removes it from Q. The for loop of lines 12–17 considers each\nvertex \u0003 in the adjacency list of u. If \u0003 is white, then it has not yet been discovered,\nand the procedure discovers it by executing lines 14–17. The procedure paints\nvertex \u0003 gray, sets its distance \u0003:d to u:dC1, records u as its parent \u0003:\u0006, and places\nit at the tail of the queue Q. Once the procedure has examined all the vertices on u’s\n22.2\nBreadth-ﬁrst search\n597\nadjacency list, it blackens u in line 18. The loop invariant is maintained because\nwhenever a vertex is painted gray (in line 14) it is also enqueued (in line 17), and\nwhenever a vertex is dequeued (in line 11) it is also painted black (in line 18).\nThe results of breadth-ﬁrst search may depend upon the order in which the neigh-\nbors of a given vertex are visited in line 12: the breadth-ﬁrst tree may vary, but the\ndistances d computed by the algorithm will not. (See Exercise 22.2-5.)\nAnalysis\nBefore proving the various properties of breadth-ﬁrst search, we take on the some-\nwhat easier job of analyzing its running time on an input graph G D .V; E/. We\nuse aggregate analysis, as we saw in Section 17.1. After initialization, breadth-ﬁrst",
    "parent_c1834f39-3608-4e5a-8a7b-51fb03164640": "Analysis\nBefore proving the various properties of breadth-ﬁrst search, we take on the some-\nwhat easier job of analyzing its running time on an input graph G D .V; E/. We\nuse aggregate analysis, as we saw in Section 17.1. After initialization, breadth-ﬁrst\nsearch never whitens a vertex, and thus the test in line 13 ensures that each vertex\nis enqueued at most once, and hence dequeued at most once. The operations of\nenqueuing and dequeuing take O.1/ time, and so the total time devoted to queue\noperations is O.V /. Because the procedure scans the adjacency list of each vertex\nonly when the vertex is dequeued, it scans each adjacency list at most once. Since\nthe sum of the lengths of all the adjacency lists is ‚.E/, the total time spent in\nscanning adjacency lists is O.E/. The overhead for initialization is O.V /, and\nthus the total running time of the BFS procedure is O.V C E/. Thus, breadth-ﬁrst\nsearch runs in time linear in the size of the adjacency-list representation of G.\nShortest paths\nAt the beginning of this section, we claimed that breadth-ﬁrst search ﬁnds the dis-\ntance to each reachable vertex in a graph G D .V; E/ from a given source vertex\ns 2 V . Deﬁne the shortest-path distance ı.s; \u0003/ from s to \u0003 as the minimum num-\nber of edges in any path from vertex s to vertex \u0003; if there is no path from s to \u0003,\nthen ı.s; \u0003/ D 1. We call a path of length ı.s; \u0003/ from s to \u0003 a shortest path2\nfrom s to \u0003. Before showing that breadth-ﬁrst search correctly computes shortest-\npath distances, we investigate an important property of shortest-path distances.\n2In Chapters 24 and 25, we shall generalize our study of shortest paths to weighted graphs, in which\nevery edge has a real-valued weight and the weight of a path is the sum of the weights of its con-\nstituent edges. The graphs considered in the present chapter are unweighted or, equivalently, all\nedges have unit weight.\n598\nChapter 22\nElementary Graph Algorithms\nLemma 22.1",
    "parent_68b1189a-5b18-4eba-b679-d0aff234f5c0": "every edge has a real-valued weight and the weight of a path is the sum of the weights of its con-\nstituent edges. The graphs considered in the present chapter are unweighted or, equivalently, all\nedges have unit weight.\n598\nChapter 22\nElementary Graph Algorithms\nLemma 22.1\nLet G D .V; E/ be a directed or undirected graph, and let s 2 V be an arbitrary\nvertex. Then, for any edge .u; \u0003/ 2 E,\nı.s; \u0003/ \u0002 ı.s; u/ C 1 :\nProof\nIf u is reachable from s, then so is \u0003. In this case, the shortest path from s\nto \u0003 cannot be longer than the shortest path from s to u followed by the edge .u; \u0003/,\nand thus the inequality holds. If u is not reachable from s, then ı.s; u/ D 1, and\nthe inequality holds.\nWe want to show that BFS properly computes \u0003:d D ı.s; \u0003/ for each ver-\ntex \u0003 2 V . We ﬁrst show that \u0003:d bounds ı.s; \u0003/ from above.\nLemma 22.2\nLet G D .V; E/ be a directed or undirected graph, and suppose that BFS is run\non G from a given source vertex s 2 V . Then upon termination, for each ver-\ntex \u0003 2 V , the value \u0003:d computed by BFS satisﬁes \u0003:d \u0006 ı.s; \u0003/.\nProof\nWe use induction on the number of ENQUEUE operations. Our inductive\nhypothesis is that \u0003:d \u0006 ı.s; \u0003/ for all \u0003 2 V .\nThe basis of the induction is the situation immediately after enqueuing s in line 9\nof BFS. The inductive hypothesis holds here, because s:d D 0 D ı.s; s/ and\n\u0003:d D 1 \u0006 ı.s; \u0003/ for all \u0003 2 V \u0005 fsg.\nFor the inductive step, consider a white vertex \u0003 that is discovered during the\nsearch from a vertex u. The inductive hypothesis implies that u:d \u0006 ı.s; u/. From\nthe assignment performed by line 15 and from Lemma 22.1, we obtain\n\u0003:d\nD\nu:d C 1\n\u0006\nı.s; u/ C 1\n\u0006\nı.s; \u0003/ :\nVertex \u0003 is then enqueued, and it is never enqueued again because it is also grayed\nand the then clause of lines 14–17 is executed only for white vertices. Thus, the\nvalue of \u0003:d never changes again, and the inductive hypothesis is maintained.\nTo prove that \u0003:d D ı.s; \u0003/, we must ﬁrst show more precisely how the queue Q",
    "parent_79d6c224-990e-4cdc-979e-a707a73f35ec": "and the then clause of lines 14–17 is executed only for white vertices. Thus, the\nvalue of \u0003:d never changes again, and the inductive hypothesis is maintained.\nTo prove that \u0003:d D ı.s; \u0003/, we must ﬁrst show more precisely how the queue Q\noperates during the course of BFS. The next lemma shows that at all times, the\nqueue holds at most two distinct d values.\n22.2\nBreadth-ﬁrst search\n599\nLemma 22.3\nSuppose that during the execution of BFS on a graph G D .V; E/, the queue Q\ncontains the vertices h\u00031; \u00032; : : : ; \u0003ri, where \u00031 is the head of Q and \u0003r is the tail.\nThen, \u0003r:d \u0002 \u00031:d C 1 and \u0003i:d \u0002 \u0003iC1:d for i D 1; 2; : : : ; r \u0005 1.\nProof\nThe proof is by induction on the number of queue operations. Initially,\nwhen the queue contains only s, the lemma certainly holds.\nFor the inductive step, we must prove that the lemma holds after both dequeuing\nand enqueuing a vertex. If the head \u00031 of the queue is dequeued, \u00032 becomes the\nnew head. (If the queue becomes empty, then the lemma holds vacuously.) By the\ninductive hypothesis, \u00031:d \u0002 \u00032:d. But then we have \u0003r:d \u0002 \u00031:d C 1 \u0002 \u00032:d C 1,\nand the remaining inequalities are unaffected. Thus, the lemma follows with \u00032 as\nthe head.\nIn order to understand what happens upon enqueuing a vertex, we need to ex-\namine the code more closely. When we enqueue a vertex \u0003 in line 17 of BFS, it\nbecomes \u0003rC1. At that time, we have already removed vertex u, whose adjacency\nlist is currently being scanned, from the queue Q, and by the inductive hypothesis,\nthe new head \u00031 has \u00031:d \u0006 u:d. Thus, \u0003rC1:d D \u0003:d D u:dC1 \u0002 \u00031:dC1. From\nthe inductive hypothesis, we also have \u0003r:d \u0002 u:d C 1, and so \u0003r:d \u0002 u:d C 1 D\n\u0003:d D \u0003rC1:d, and the remaining inequalities are unaffected. Thus, the lemma\nfollows when \u0003 is enqueued.\nThe following corollary shows that the d values at the time that vertices are\nenqueued are monotonically increasing over time.\nCorollary 22.4\nSuppose that vertices \u0003i and \u0003j are enqueued during the execution of BFS, and",
    "parent_1a1dfa8b-f85a-43d7-9b06-6ed22e3c8ab0": "follows when \u0003 is enqueued.\nThe following corollary shows that the d values at the time that vertices are\nenqueued are monotonically increasing over time.\nCorollary 22.4\nSuppose that vertices \u0003i and \u0003j are enqueued during the execution of BFS, and\nthat \u0003i is enqueued before \u0003j. Then \u0003i:d \u0002 \u0003j:d at the time that \u0003j is enqueued.\nProof\nImmediate from Lemma 22.3 and the property that each vertex receives a\nﬁnite d value at most once during the course of BFS.\nWe can now prove that breadth-ﬁrst search correctly ﬁnds shortest-path dis-\ntances.\nTheorem 22.5 (Correctness of breadth-ﬁrst search)\nLet G D .V; E/ be a directed or undirected graph, and suppose that BFS is run\non G from a given source vertex s 2 V . Then, during its execution, BFS discovers\nevery vertex \u0003 2 V that is reachable from the source s, and upon termination,\n\u0003:d D ı.s; \u0003/ for all \u0003 2 V . Moreover, for any vertex \u0003 ¤ s that is reachable\n600\nChapter 22\nElementary Graph Algorithms\nfrom s, one of the shortest paths from s to \u0003 is a shortest path from s to \u0003:\u0006\nfollowed by the edge .\u0003:\u0006; \u0003/.\nProof\nAssume, for the purpose of contradiction, that some vertex receives a d\nvalue not equal to its shortest-path distance.\nLet \u0003 be the vertex with min-\nimum ı.s; \u0003/ that receives such an incorrect d value; clearly \u0003\n¤ s.\nBy\nLemma 22.2, \u0003:d \u0006 ı.s; \u0003/, and thus we have that \u0003:d > ı.s; \u0003/. Vertex \u0003 must be\nreachable from s, for if it is not, then ı.s; \u0003/ D 1 \u0006 \u0003:d. Let u be the vertex im-\nmediately preceding \u0003 on a shortest path from s to \u0003, so that ı.s; \u0003/ D ı.s; u/ C 1.\nBecause ı.s; u/ < ı.s; \u0003/, and because of how we chose \u0003, we have u:d D ı.s; u/.\nPutting these properties together, we have\n\u0003:d > ı.s; \u0003/ D ı.s; u/ C 1 D u:d C 1 :\n(22.1)\nNow consider the time when BFS chooses to dequeue vertex u from Q in\nline 11. At this time, vertex \u0003 is either white, gray, or black. We shall show\nthat in each of these cases, we derive a contradiction to inequality (22.1). If \u0003 is",
    "parent_66d61578-c4ee-4533-bda3-ab7fd223e063": "\u0003:d > ı.s; \u0003/ D ı.s; u/ C 1 D u:d C 1 :\n(22.1)\nNow consider the time when BFS chooses to dequeue vertex u from Q in\nline 11. At this time, vertex \u0003 is either white, gray, or black. We shall show\nthat in each of these cases, we derive a contradiction to inequality (22.1). If \u0003 is\nwhite, then line 15 sets \u0003:d D u:d C 1, contradicting inequality (22.1). If \u0003 is\nblack, then it was already removed from the queue and, by Corollary 22.4, we have\n\u0003:d \u0002 u:d, again contradicting inequality (22.1). If \u0003 is gray, then it was painted\ngray upon dequeuing some vertex w, which was removed from Q earlier than u\nand for which \u0003:d D w:d C 1. By Corollary 22.4, however, w:d \u0002 u:d, and so we\nhave \u0003:d D w:d C 1 \u0002 u:d C 1, once again contradicting inequality (22.1).\nThus we conclude that \u0003:d D ı.s; \u0003/ for all \u0003 2 V . All vertices \u0003 reachable\nfrom s must be discovered, for otherwise they would have 1 D \u0003:d > ı.s; \u0003/. To\nconclude the proof of the theorem, observe that if \u0003:\u0006 D u, then \u0003:d D u:d C 1.\nThus, we can obtain a shortest path from s to \u0003 by taking a shortest path from s\nto \u0003:\u0006 and then traversing the edge .\u0003:\u0006; \u0003/.\nBreadth-ﬁrst trees\nThe procedure BFS builds a breadth-ﬁrst tree as it searches the graph, as Fig-\nure 22.3 illustrates. The tree corresponds to the \u0006 attributes. More formally, for\na graph G D .V; E/ with source s, we deﬁne the predecessor subgraph of G as\nG\u0003 D .V\u0003; E\u0003/, where\nV\u0003 D f\u0003 2 V W \u0003:\u0006 ¤ NILg [ fsg\nand\nE\u0003 D f.\u0003:\u0006; \u0003/ W \u0003 2 V\u0003 \u0005 fsgg :\nThe predecessor subgraph G\u0003 is a breadth-ﬁrst tree if V\u0003 consists of the vertices\nreachable from s and, for all \u0003 2 V\u0003, the subgraph G\u0003 contains a unique simple\n22.2\nBreadth-ﬁrst search\n601\npath from s to \u0003 that is also a shortest path from s to \u0003 in G. A breadth-ﬁrst tree\nis in fact a tree, since it is connected and jE\u0003j D jV\u0003j \u0005 1 (see Theorem B.2). We\ncall the edges in E\u0003 tree edges.\nThe following lemma shows that the predecessor subgraph produced by the BFS\nprocedure is a breadth-ﬁrst tree.\nLemma 22.6",
    "parent_e3e4db81-8a89-4bd1-a5cb-c8ffc4219edc": "is in fact a tree, since it is connected and jE\u0003j D jV\u0003j \u0005 1 (see Theorem B.2). We\ncall the edges in E\u0003 tree edges.\nThe following lemma shows that the predecessor subgraph produced by the BFS\nprocedure is a breadth-ﬁrst tree.\nLemma 22.6\nWhen applied to a directed or undirected graph G D .V; E/, procedure BFS con-\nstructs \u0006 so that the predecessor subgraph G\u0003 D .V\u0003; E\u0003/ is a breadth-ﬁrst tree.\nProof\nLine 16 of BFS sets \u0003:\u0006 D u if and only if .u; \u0003/ 2 E and ı.s; \u0003/ < 1—\nthat is, if \u0003 is reachable from s—and thus V\u0003 consists of the vertices in V reachable\nfrom s. Since G\u0003 forms a tree, by Theorem B.2, it contains a unique simple path\nfrom s to each vertex in V\u0003. By applying Theorem 22.5 inductively, we conclude\nthat every such path is a shortest path in G.\nThe following procedure prints out the vertices on a shortest path from s to \u0003,\nassuming that BFS has already computed a breadth-ﬁrst tree:\nPRINT-PATH.G; s; \u0003/\n1\nif \u0003 == s\n2\nprint s\n3\nelseif \u0003:\u0006 == NIL\n4\nprint “no path from” s “to” \u0003 “exists”\n5\nelse PRINT-PATH.G; s; \u0003:\u0006/\n6\nprint \u0003\nThis procedure runs in time linear in the number of vertices in the path printed,\nsince each recursive call is for a path one vertex shorter.\nExercises\n22.2-1\nShow the d and \u0006 values that result from running breadth-ﬁrst search on the di-\nrected graph of Figure 22.2(a), using vertex 3 as the source.\n22.2-2\nShow the d and \u0006 values that result from running breadth-ﬁrst search on the undi-\nrected graph of Figure 22.3, using vertex u as the source.\n602\nChapter 22\nElementary Graph Algorithms\n22.2-3\nShow that using a single bit to store each vertex color sufﬁces by arguing that the\nBFS procedure would produce the same result if lines 5 and 14 were removed.\n22.2-4\nWhat is the running time of BFS if we represent its input graph by an adjacency\nmatrix and modify the algorithm to handle this form of input?\n22.2-5\nArgue that in a breadth-ﬁrst search, the value u:d assigned to a vertex u is inde-",
    "parent_d9d9d00f-a32c-4c77-b465-1741822163ac": "22.2-4\nWhat is the running time of BFS if we represent its input graph by an adjacency\nmatrix and modify the algorithm to handle this form of input?\n22.2-5\nArgue that in a breadth-ﬁrst search, the value u:d assigned to a vertex u is inde-\npendent of the order in which the vertices appear in each adjacency list. Using\nFigure 22.3 as an example, show that the breadth-ﬁrst tree computed by BFS can\ndepend on the ordering within adjacency lists.\n22.2-6\nGive an example of a directed graph G D .V; E/, a source vertex s 2 V , and a\nset of tree edges E\u0003 \u0007 E such that for each vertex \u0003 2 V , the unique simple path\nin the graph .V; E\u0003/ from s to \u0003 is a shortest path in G, yet the set of edges E\u0003\ncannot be produced by running BFS on G, no matter how the vertices are ordered\nin each adjacency list.\n22.2-7\nThere are two types of professional wrestlers: “babyfaces” (“good guys”) and\n“heels” (“bad guys”). Between any pair of professional wrestlers, there may or\nmay not be a rivalry. Suppose we have n professional wrestlers and we have a list\nof r pairs of wrestlers for which there are rivalries. Give an O.n C r/-time algo-\nrithm that determines whether it is possible to designate some of the wrestlers as\nbabyfaces and the remainder as heels such that each rivalry is between a babyface\nand a heel. If it is possible to perform such a designation, your algorithm should\nproduce it.\n22.2-8\n?\nThe diameter of a tree T D .V; E/ is deﬁned as maxu;\u00052V ı.u; \u0003/, that is, the\nlargest of all shortest-path distances in the tree. Give an efﬁcient algorithm to\ncompute the diameter of a tree, and analyze the running time of your algorithm.\n22.2-9\nLet G D .V; E/ be a connected, undirected graph. Give an O.V C E/-time algo-\nrithm to compute a path in G that traverses each edge in E exactly once in each\ndirection. Describe how you can ﬁnd your way out of a maze if you are given a\nlarge supply of pennies.\n22.3\nDepth-ﬁrst search\n603\n22.3\nDepth-ﬁrst search",
    "parent_90c43550-f93c-4dd4-ba6b-e8494eeb774e": "rithm to compute a path in G that traverses each edge in E exactly once in each\ndirection. Describe how you can ﬁnd your way out of a maze if you are given a\nlarge supply of pennies.\n22.3\nDepth-ﬁrst search\n603\n22.3\nDepth-ﬁrst search\nThe strategy followed by depth-ﬁrst search is, as its name implies, to search\n“deeper” in the graph whenever possible. Depth-ﬁrst search explores edges out\nof the most recently discovered vertex \u0003 that still has unexplored edges leaving it.\nOnce all of \u0003’s edges have been explored, the search “backtracks” to explore edges\nleaving the vertex from which \u0003 was discovered. This process continues until we\nhave discovered all the vertices that are reachable from the original source vertex.\nIf any undiscovered vertices remain, then depth-ﬁrst search selects one of them as\na new source, and it repeats the search from that source. The algorithm repeats this\nentire process until it has discovered every vertex.3\nAs in breadth-ﬁrst search, whenever depth-ﬁrst search discovers a vertex \u0003 dur-\ning a scan of the adjacency list of an already discovered vertex u, it records this\nevent by setting \u0003’s predecessor attribute \u0003:\u0006 to u. Unlike breadth-ﬁrst search,\nwhose predecessor subgraph forms a tree, the predecessor subgraph produced by\na depth-ﬁrst search may be composed of several trees, because the search may\nrepeat from multiple sources. Therefore, we deﬁne the predecessor subgraph of\na depth-ﬁrst search slightly differently from that of a breadth-ﬁrst search: we let\nG\u0003 D .V; E\u0003/, where\nE\u0003 D f.\u0003:\u0006; \u0003/ W \u0003 2 V and \u0003:\u0006 ¤ NILg :\nThe predecessor subgraph of a depth-ﬁrst search forms a depth-ﬁrst forest com-\nprising several depth-ﬁrst trees. The edges in E\u0003 are tree edges.\nAs in breadth-ﬁrst search, depth-ﬁrst search colors vertices during the search to\nindicate their state. Each vertex is initially white, is grayed when it is discovered\nin the search, and is blackened when it is ﬁnished, that is, when its adjacency list",
    "parent_e4e77024-175d-4bb5-849b-264a5190a98c": "As in breadth-ﬁrst search, depth-ﬁrst search colors vertices during the search to\nindicate their state. Each vertex is initially white, is grayed when it is discovered\nin the search, and is blackened when it is ﬁnished, that is, when its adjacency list\nhas been examined completely. This technique guarantees that each vertex ends up\nin exactly one depth-ﬁrst tree, so that these trees are disjoint.\nBesides creating a depth-ﬁrst forest, depth-ﬁrst search also timestamps each ver-\ntex. Each vertex \u0003 has two timestamps: the ﬁrst timestamp \u0003:d records when \u0003\nis ﬁrst discovered (and grayed), and the second timestamp \u0003:f records when the\nsearch ﬁnishes examining \u0003’s adjacency list (and blackens \u0003). These timestamps\n3It may seem arbitrary that breadth-ﬁrst search is limited to only one source whereas depth-ﬁrst\nsearch may search from multiple sources. Although conceptually, breadth-ﬁrst search could proceed\nfrom multiple sources and depth-ﬁrst search could be limited to one source, our approach reﬂects how\nthe results of these searches are typically used. Breadth-ﬁrst search usually serves to ﬁnd shortest-\npath distances (and the associated predecessor subgraph) from a given source. Depth-ﬁrst search is\noften a subroutine in another algorithm, as we shall see later in this chapter.\n604\nChapter 22\nElementary Graph Algorithms\nprovide important information about the structure of the graph and are generally\nhelpful in reasoning about the behavior of depth-ﬁrst search.\nThe procedure DFS below records when it discovers vertex u in the attribute u:d\nand when it ﬁnishes vertex u in the attribute u:f. These timestamps are integers\nbetween 1 and 2 jV j, since there is one discovery event and one ﬁnishing event for\neach of the jV j vertices. For every vertex u,\nu:d < u:f :\n(22.2)\nVertex u is WHITE before time u:d, GRAY between time u:d and time u:f, and\nBLACK thereafter.\nThe following pseudocode is the basic depth-ﬁrst-search algorithm. The input",
    "parent_536a1b63-56e9-49e3-964b-ebc6b00b12d5": "each of the jV j vertices. For every vertex u,\nu:d < u:f :\n(22.2)\nVertex u is WHITE before time u:d, GRAY between time u:d and time u:f, and\nBLACK thereafter.\nThe following pseudocode is the basic depth-ﬁrst-search algorithm. The input\ngraph G may be undirected or directed. The variable time is a global variable that\nwe use for timestamping.\nDFS.G/\n1\nfor each vertex u 2 G:V\n2\nu:color D WHITE\n3\nu:\u0006 D NIL\n4\ntime D 0\n5\nfor each vertex u 2 G:V\n6\nif u:color == WHITE\n7\nDFS-VISIT.G; u/\nDFS-VISIT.G; u/\n1\ntime D time C 1\n// white vertex u has just been discovered\n2\nu:d D time\n3\nu:color D GRAY\n4\nfor each \u0003 2 G:AdjŒu\u0002\n// explore edge .u; \u0003/\n5\nif \u0003:color == WHITE\n6\n\u0003:\u0006 D u\n7\nDFS-VISIT.G; \u0003/\n8\nu:color D BLACK\n// blacken u; it is ﬁnished\n9\ntime D time C 1\n10\nu:f D time\nFigure 22.4 illustrates the progress of DFS on the graph shown in Figure 22.2.\nProcedure DFS works as follows. Lines 1–3 paint all vertices white and ini-\ntialize their \u0006 attributes to NIL. Line 4 resets the global time counter. Lines 5–7\ncheck each vertex in V in turn and, when a white vertex is found, visit it using\nDFS-VISIT. Every time DFS-VISIT.G; u/ is called in line 7, vertex u becomes\n22.3\nDepth-ﬁrst search\n605\nu\nv\nw\nx\ny\nz\n1/\n1/\n2/\n1/\n2/\n3/\n1/\n2/\n3/\n4/\n1/\n2/\n3/\n4/\nB\n1/\n2/\n3/\nB\n4/5\n1/\n2/\nB\n4/5\n3/6\n1/\nB\n4/5\n3/6\n2/7\n1/\nB\n4/5\n3/6\n2/7\nF\nB\n4/5\n3/6\n2/7\nF\n1/8\nB\n4/5\n3/6\n2/7\nF\n1/8\n9/\nB\n4/5\n3/6\n2/7\nF\n1/8\n9/\nC\nB\n4/5\n3/6\n2/7\nF\n1/8\n9/\nC\nB\n4/5\n3/6\n2/7\nF\n1/8\n9/\nC\nB\nB\n4/5\n3/6\n2/7\nF\n1/8\n9/\nC\nB\n10/11\nB\n4/5\n3/6\n2/7\nF\n1/8\nC\nB\n10/11\n9/12\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\n(m)\n(n)\n(o)\n(p)\n(i)\n(j)\n(k)\n(l)\n(e)\n(f)\n(g)\n(h)\n(a)\n(b)\n(c)\n(d)\n10/\n10/\nFigure 22.4\nThe progress of the depth-ﬁrst-search algorithm DFS on a directed graph. As edges\nare explored by the algorithm, they are shown as either shaded (if they are tree edges) or dashed",
    "parent_e99116cb-acf0-43bd-a832-fb82651fc8c2": "u\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\nu\nv\nw\nx\ny\nz\n(m)\n(n)\n(o)\n(p)\n(i)\n(j)\n(k)\n(l)\n(e)\n(f)\n(g)\n(h)\n(a)\n(b)\n(c)\n(d)\n10/\n10/\nFigure 22.4\nThe progress of the depth-ﬁrst-search algorithm DFS on a directed graph. As edges\nare explored by the algorithm, they are shown as either shaded (if they are tree edges) or dashed\n(otherwise). Nontree edges are labeled B, C, or F according to whether they are back, cross, or\nforward edges. Timestamps within vertices indicate discovery time/ﬁnishing times.\nthe root of a new tree in the depth-ﬁrst forest. When DFS returns, every vertex u\nhas been assigned a discovery time u:d and a ﬁnishing time u:f.\nIn each call DFS-VISIT.G; u/, vertex u is initially white. Line 1 increments\nthe global variable time, line 2 records the new value of time as the discovery\ntime u:d, and line 3 paints u gray. Lines 4–7 examine each vertex \u0003 adjacent to u\nand recursively visit \u0003 if it is white. As each vertex \u0003 2 AdjŒu\u0002 is considered in\nline 4, we say that edge .u; \u0003/ is explored by the depth-ﬁrst search. Finally, after\nevery edge leaving u has been explored, lines 8–10 paint u black, increment time,\nand record the ﬁnishing time in u:f.\nNote that the results of depth-ﬁrst search may depend upon the order in which\nline 5 of DFS examines the vertices and upon the order in which line 4 of DFS-\nVISIT visits the neighbors of a vertex. These different visitation orders tend not\n606\nChapter 22\nElementary Graph Algorithms\nto cause problems in practice, as we can usually use any depth-ﬁrst search result\neffectively, with essentially equivalent results.\nWhat is the running time of DFS? The loops on lines 1–3 and lines 5–7 of DFS\ntake time ‚.V /, exclusive of the time to execute the calls to DFS-VISIT. As we did\nfor breadth-ﬁrst search, we use aggregate analysis. The procedure DFS-VISIT is\ncalled exactly once for each vertex \u0003 2 V , since the vertex u on which DFS-VISIT\nis invoked must be white and the ﬁrst thing DFS-VISIT does is paint vertex u gray.",
    "parent_489b24a5-5e7b-4b54-b935-df0b87265154": "for breadth-ﬁrst search, we use aggregate analysis. The procedure DFS-VISIT is\ncalled exactly once for each vertex \u0003 2 V , since the vertex u on which DFS-VISIT\nis invoked must be white and the ﬁrst thing DFS-VISIT does is paint vertex u gray.\nDuring an execution of DFS-VISIT.G; \u0003/, the loop on lines 4–7 executes jAdjŒ\u0003\u0002j\ntimes. Since\nX\n\u00052V\njAdjŒ\u0003\u0002j D ‚.E/ ;\nthe total cost of executing lines 4–7 of DFS-VISIT is ‚.E/. The running time of\nDFS is therefore ‚.V C E/.\nProperties of depth-ﬁrst search\nDepth-ﬁrst search yields valuable information about the structure of a graph. Per-\nhaps the most basic property of depth-ﬁrst search is that the predecessor sub-\ngraph G\u0003 does indeed form a forest of trees, since the structure of the depth-\nﬁrst trees exactly mirrors the structure of recursive calls of DFS-VISIT. That is,\nu D \u0003:\u0006 if and only if DFS-VISIT.G; \u0003/ was called during a search of u’s ad-\njacency list. Additionally, vertex \u0003 is a descendant of vertex u in the depth-ﬁrst\nforest if and only if \u0003 is discovered during the time in which u is gray.\nAnother important property of depth-ﬁrst search is that discovery and ﬁnishing\ntimes have parenthesis structure. If we represent the discovery of vertex u with\na left parenthesis “.u” and represent its ﬁnishing by a right parenthesis “u/”, then\nthe history of discoveries and ﬁnishings makes a well-formed expression in the\nsense that the parentheses are properly nested. For example, the depth-ﬁrst search\nof Figure 22.5(a) corresponds to the parenthesization shown in Figure 22.5(b). The\nfollowing theorem provides another way to characterize the parenthesis structure.\nTheorem 22.7 (Parenthesis theorem)\nIn any depth-ﬁrst search of a (directed or undirected) graph G D .V; E/, for any\ntwo vertices u and \u0003, exactly one of the following three conditions holds:\n\u0002\nthe intervals Œu:d; u:f\u0002 and Œ\u0003:d; \u0003:f\u0002 are entirely disjoint, and neither u nor \u0003\nis a descendant of the other in the depth-ﬁrst forest,\n\u0002",
    "parent_b0dd3921-ae35-4738-acde-6620a2544c32": "In any depth-ﬁrst search of a (directed or undirected) graph G D .V; E/, for any\ntwo vertices u and \u0003, exactly one of the following three conditions holds:\n\u0002\nthe intervals Œu:d; u:f\u0002 and Œ\u0003:d; \u0003:f\u0002 are entirely disjoint, and neither u nor \u0003\nis a descendant of the other in the depth-ﬁrst forest,\n\u0002\nthe interval Œu:d; u:f\u0002 is contained entirely within the interval Œ\u0003:d; \u0003:f\u0002, and u\nis a descendant of \u0003 in a depth-ﬁrst tree, or\n\u0002\nthe interval Œ\u0003:d; \u0003:f\u0002 is contained entirely within the interval Œu:d; u:f\u0002, and \u0003\nis a descendant of u in a depth-ﬁrst tree.\n22.3\nDepth-ﬁrst search\n607\n3/6\n2/9\n1/10\n11/16\n14/15\n12/13\n7/8\n4/5\ny\nz\ns\nt\nu\nv\nw\nx\nB\nC\nF\nC\nC\nC\nB\n1\n2\n3\n4\n5\n6\n7\n8\n9 10 11 12 13 14 15 16\ns\nt\nz\ny\nw\nx\nv\nu\ns\nz\ny\nw\nx\nt\nv\nu\nC\nF\nB\nC\nC\nB\nC\n(a)\n(b)\n(c)\n(s (z (y (x\nx) y) (w w) z) s) (t\n(v v) (u u)\nt)\nFigure 22.5\nProperties of depth-ﬁrst search. (a) The result of a depth-ﬁrst search of a directed\ngraph. Vertices are timestamped and edge types are indicated as in Figure 22.4. (b) Intervals for\nthe discovery time and ﬁnishing time of each vertex correspond to the parenthesization shown. Each\nrectangle spans the interval given by the discovery and ﬁnishing times of the corresponding vertex.\nOnly tree edges are shown. If two intervals overlap, then one is nested within the other, and the\nvertex corresponding to the smaller interval is a descendant of the vertex corresponding to the larger.\n(c) The graph of part (a) redrawn with all tree and forward edges going down within a depth-ﬁrst tree\nand all back edges going up from a descendant to an ancestor.\n608\nChapter 22\nElementary Graph Algorithms\nProof\nWe begin with the case in which u:d < \u0003:d. We consider two subcases,\naccording to whether \u0003:d < u:f or not. The ﬁrst subcase occurs when \u0003:d < u:f,\nso \u0003 was discovered while u was still gray, which implies that \u0003 is a descendant\nof u. Moreover, since \u0003 was discovered more recently than u, all of its outgo-\ning edges are explored, and \u0003 is ﬁnished, before the search returns to and ﬁn-",
    "parent_d29fa500-6519-4716-a142-f08ac1dc0512": "so \u0003 was discovered while u was still gray, which implies that \u0003 is a descendant\nof u. Moreover, since \u0003 was discovered more recently than u, all of its outgo-\ning edges are explored, and \u0003 is ﬁnished, before the search returns to and ﬁn-\nishes u. In this case, therefore, the interval Œ\u0003:d; \u0003:f\u0002 is entirely contained within\nthe interval Œu:d; u:f\u0002. In the other subcase, u:f < \u0003:d, and by inequality (22.2),\nu:d < u:f < \u0003:d < \u0003:f; thus the intervals Œu:d; u:f\u0002 and Œ\u0003:d; \u0003:f\u0002 are disjoint.\nBecause the intervals are disjoint, neither vertex was discovered while the other\nwas gray, and so neither vertex is a descendant of the other.\nThe case in which \u0003:d < u:d is similar, with the roles of u and \u0003 reversed in the\nabove argument.\nCorollary 22.8 (Nesting of descendants’ intervals)\nVertex \u0003 is a proper descendant of vertex u in the depth-ﬁrst forest for a (directed\nor undirected) graph G if and only if u:d < \u0003:d < \u0003:f < u:f.\nProof\nImmediate from Theorem 22.7.\nThe next theorem gives another important characterization of when one vertex\nis a descendant of another in the depth-ﬁrst forest.\nTheorem 22.9 (White-path theorem)\nIn a depth-ﬁrst forest of a (directed or undirected) graph G D .V; E/, vertex \u0003 is\na descendant of vertex u if and only if at the time u:d that the search discovers u,\nthere is a path from u to \u0003 consisting entirely of white vertices.\nProof\n): If \u0003 D u, then the path from u to \u0003 contains just vertex u, which is still\nwhite when we set the value of u:d. Now, suppose that \u0003 is a proper descendant\nof u in the depth-ﬁrst forest. By Corollary 22.8, u:d < \u0003:d, and so \u0003 is white at\ntime u:d. Since \u0003 can be any descendant of u, all vertices on the unique simple\npath from u to \u0003 in the depth-ﬁrst forest are white at time u:d.\n(: Suppose that there is a path of white vertices from u to \u0003 at time u:d, but \u0003\ndoes not become a descendant of u in the depth-ﬁrst tree. Without loss of general-",
    "parent_414377e9-6719-46a7-9965-c6a6be7828c3": "path from u to \u0003 in the depth-ﬁrst forest are white at time u:d.\n(: Suppose that there is a path of white vertices from u to \u0003 at time u:d, but \u0003\ndoes not become a descendant of u in the depth-ﬁrst tree. Without loss of general-\nity, assume that every vertex other than \u0003 along the path becomes a descendant of u.\n(Otherwise, let \u0003 be the closest vertex to u along the path that doesn’t become a de-\nscendant of u.) Let w be the predecessor of \u0003 in the path, so that w is a descendant\nof u (w and u may in fact be the same vertex). By Corollary 22.8, w:f \u0002 u:f. Be-\ncause \u0003 must be discovered after u is discovered, but before w is ﬁnished, we have\nu:d < \u0003:d < w:f \u0002 u:f. Theorem 22.7 then implies that the interval Œ\u0003:d; \u0003:f\u0002\n22.3\nDepth-ﬁrst search\n609\nis contained entirely within the interval Œu:d; u:f\u0002. By Corollary 22.8, \u0003 must after\nall be a descendant of u.\nClassiﬁcation of edges\nAnother interesting property of depth-ﬁrst search is that the search can be used\nto classify the edges of the input graph G D .V; E/. The type of each edge can\nprovide important information about a graph. For example, in the next section, we\nshall see that a directed graph is acyclic if and only if a depth-ﬁrst search yields no\n“back” edges (Lemma 22.11).\nWe can deﬁne four edge types in terms of the depth-ﬁrst forest G\u0003 produced by\na depth-ﬁrst search on G:\n1. Tree edges are edges in the depth-ﬁrst forest G\u0003. Edge .u; \u0003/ is a tree edge if \u0003\nwas ﬁrst discovered by exploring edge .u; \u0003/.\n2. Back edges are those edges .u; \u0003/ connecting a vertex u to an ancestor \u0003 in a\ndepth-ﬁrst tree. We consider self-loops, which may occur in directed graphs, to\nbe back edges.\n3. Forward edges are those nontree edges .u; \u0003/ connecting a vertex u to a de-\nscendant \u0003 in a depth-ﬁrst tree.\n4. Cross edges are all other edges. They can go between vertices in the same\ndepth-ﬁrst tree, as long as one vertex is not an ancestor of the other, or they can\ngo between vertices in different depth-ﬁrst trees.",
    "parent_18a836fc-233e-42d1-8918-8c616dbc16e1": "scendant \u0003 in a depth-ﬁrst tree.\n4. Cross edges are all other edges. They can go between vertices in the same\ndepth-ﬁrst tree, as long as one vertex is not an ancestor of the other, or they can\ngo between vertices in different depth-ﬁrst trees.\nIn Figures 22.4 and 22.5, edge labels indicate edge types. Figure 22.5(c) also shows\nhow to redraw the graph of Figure 22.5(a) so that all tree and forward edges head\ndownward in a depth-ﬁrst tree and all back edges go up. We can redraw any graph\nin this fashion.\nThe DFS algorithm has enough information to classify some edges as it encoun-\nters them. The key idea is that when we ﬁrst explore an edge .u; \u0003/, the color of\nvertex \u0003 tells us something about the edge:\n1.\nWHITE indicates a tree edge,\n2.\nGRAY indicates a back edge, and\n3.\nBLACK indicates a forward or cross edge.\nThe ﬁrst case is immediate from the speciﬁcation of the algorithm. For the sec-\nond case, observe that the gray vertices always form a linear chain of descendants\ncorresponding to the stack of active DFS-VISIT invocations; the number of gray\nvertices is one more than the depth in the depth-ﬁrst forest of the vertex most re-\ncently discovered. Exploration always proceeds from the deepest gray vertex, so\n610\nChapter 22\nElementary Graph Algorithms\nan edge that reaches another gray vertex has reached an ancestor. The third case\nhandles the remaining possibility; Exercise 22.3-5 asks you to show that such an\nedge .u; \u0003/ is a forward edge if u:d < \u0003:d and a cross edge if u:d > \u0003:d.\nAn undirected graph may entail some ambiguity in how we classify edges,\nsince .u; \u0003/ and .\u0003; u/ are really the same edge. In such a case, we classify the\nedge as the ﬁrst type in the classiﬁcation list that applies. Equivalently (see Ex-\nercise 22.3-6), we classify the edge according to whichever of .u; \u0003/ or .\u0003; u/ the\nsearch encounters ﬁrst.\nWe now show that forward and cross edges never occur in a depth-ﬁrst search of\nan undirected graph.\nTheorem 22.10",
    "parent_52caf63a-1236-4790-aa18-279264a6065b": "ercise 22.3-6), we classify the edge according to whichever of .u; \u0003/ or .\u0003; u/ the\nsearch encounters ﬁrst.\nWe now show that forward and cross edges never occur in a depth-ﬁrst search of\nan undirected graph.\nTheorem 22.10\nIn a depth-ﬁrst search of an undirected graph G, every edge of G is either a tree\nedge or a back edge.\nProof\nLet .u; \u0003/ be an arbitrary edge of G, and suppose without loss of generality\nthat u:d < \u0003:d. Then the search must discover and ﬁnish \u0003 before it ﬁnishes u\n(while u is gray), since \u0003 is on u’s adjacency list. If the ﬁrst time that the search\nexplores edge .u; \u0003/, it is in the direction from u to \u0003, then \u0003 is undiscovered\n(white) until that time, for otherwise the search would have explored this edge\nalready in the direction from \u0003 to u. Thus, .u; \u0003/ becomes a tree edge. If the\nsearch explores .u; \u0003/ ﬁrst in the direction from \u0003 to u, then .u; \u0003/ is a back edge,\nsince u is still gray at the time the edge is ﬁrst explored.\nWe shall see several applications of these theorems in the following sections.\nExercises\n22.3-1\nMake a 3-by-3 chart with row and column labels WHITE, GRAY, and BLACK. In\neach cell .i; j /, indicate whether, at any point during a depth-ﬁrst search of a di-\nrected graph, there can be an edge from a vertex of color i to a vertex of color j .\nFor each possible edge, indicate what edge types it can be. Make a second such\nchart for depth-ﬁrst search of an undirected graph.\n22.3-2\nShow how depth-ﬁrst search works on the graph of Figure 22.6. Assume that the\nfor loop of lines 5–7 of the DFS procedure considers the vertices in alphabetical\norder, and assume that each adjacency list is ordered alphabetically. Show the\ndiscovery and ﬁnishing times for each vertex, and show the classiﬁcation of each\nedge.\n22.3\nDepth-ﬁrst search\n611\nq\nr\ns\nt\nu\nv\nw\nx\ny\nz\nFigure 22.6\nA directed graph for use in Exercises 22.3-2 and 22.5-2.\n22.3-3\nShow the parenthesis structure of the depth-ﬁrst search of Figure 22.4.\n22.3-4",
    "parent_4e5f42ca-a31f-4a13-95e9-ddc491b8670d": "discovery and ﬁnishing times for each vertex, and show the classiﬁcation of each\nedge.\n22.3\nDepth-ﬁrst search\n611\nq\nr\ns\nt\nu\nv\nw\nx\ny\nz\nFigure 22.6\nA directed graph for use in Exercises 22.3-2 and 22.5-2.\n22.3-3\nShow the parenthesis structure of the depth-ﬁrst search of Figure 22.4.\n22.3-4\nShow that using a single bit to store each vertex color sufﬁces by arguing that\nthe DFS procedure would produce the same result if line 3 of DFS-VISIT was\nremoved.\n22.3-5\nShow that edge .u; \u0003/ is\na. a tree edge or forward edge if and only if u:d < \u0003:d < \u0003:f < u:f,\nb. a back edge if and only if \u0003:d \u0002 u:d < u:f \u0002 \u0003:f, and\nc. a cross edge if and only if \u0003:d < \u0003:f < u:d < u:f.\n22.3-6\nShow that in an undirected graph, classifying an edge .u; \u0003/ as a tree edge or a back\nedge according to whether .u; \u0003/ or .\u0003; u/ is encountered ﬁrst during the depth-ﬁrst\nsearch is equivalent to classifying it according to the ordering of the four types in\nthe classiﬁcation scheme.\n22.3-7\nRewrite the procedure DFS, using a stack to eliminate recursion.\n22.3-8\nGive a counterexample to the conjecture that if a directed graph G contains a path\nfrom u to \u0003, and if u:d < \u0003:d in a depth-ﬁrst search of G, then \u0003 is a descendant\nof u in the depth-ﬁrst forest produced.\n612\nChapter 22\nElementary Graph Algorithms\n22.3-9\nGive a counterexample to the conjecture that if a directed graph G contains a path\nfrom u to \u0003, then any depth-ﬁrst search must result in \u0003:d \u0002 u:f.\n22.3-10\nModify the pseudocode for depth-ﬁrst search so that it prints out every edge in the\ndirected graph G, together with its type. Show what modiﬁcations, if any, you need\nto make if G is undirected.\n22.3-11\nExplain how a vertex u of a directed graph can end up in a depth-ﬁrst tree contain-\ning only u, even though u has both incoming and outgoing edges in G.\n22.3-12\nShow that we can use a depth-ﬁrst search of an undirected graph G to identify the\nconnected components of G, and that the depth-ﬁrst forest contains as many trees",
    "parent_332e82e2-6203-41e6-a355-333fece65c20": "ing only u, even though u has both incoming and outgoing edges in G.\n22.3-12\nShow that we can use a depth-ﬁrst search of an undirected graph G to identify the\nconnected components of G, and that the depth-ﬁrst forest contains as many trees\nas G has connected components. More precisely, show how to modify depth-ﬁrst\nsearch so that it assigns to each vertex \u0003 an integer label \u0003:cc between 1 and k,\nwhere k is the number of connected components of G, such that u:cc D \u0003:cc if\nand only if u and \u0003 are in the same connected component.\n22.3-13\n?\nA directed graph G D .V; E/ is singly connected if u ; \u0003 implies that G contains\nat most one simple path from u to \u0003 for all vertices u; \u0003 2 V . Give an efﬁcient\nalgorithm to determine whether or not a directed graph is singly connected.\n22.4\nTopological sort\nThis section shows how we can use depth-ﬁrst search to perform a topological sort\nof a directed acyclic graph, or a “dag” as it is sometimes called. A topological sort\nof a dag G D .V; E/ is a linear ordering of all its vertices such that if G contains an\nedge .u; \u0003/, then u appears before \u0003 in the ordering. (If the graph contains a cycle,\nthen no linear ordering is possible.) We can view a topological sort of a graph as\nan ordering of its vertices along a horizontal line so that all directed edges go from\nleft to right. Topological sorting is thus different from the usual kind of “sorting”\nstudied in Part II.\nMany applications use directed acyclic graphs to indicate precedences among\nevents. Figure 22.7 gives an example that arises when Professor Bumstead gets\ndressed in the morning. The professor must don certain garments before others\n(e.g., socks before shoes). Other items may be put on in any order (e.g., socks and\n22.4\nTopological sort\n613\n11/16\n12/15\n6/7\n1/8\n2/5\n3/4\n17/18\n13/14\n9/10\n17/18\n11/16\n12/15\n13/14\n9/10\n1/8\n6/7\n2/5\n3/4\n(a)\n(b)\nundershorts\npants\nbelt\nshirt\ntie\njacket\nsocks\nshoes\nwatch\nsocks\nundershorts\npants\nshoes\nwatch\nshirt\nbelt\ntie\njacket\nFigure 22.7",
    "parent_46b93219-fc18-4f2b-9ff4-b5e0a13bf272": "22.4\nTopological sort\n613\n11/16\n12/15\n6/7\n1/8\n2/5\n3/4\n17/18\n13/14\n9/10\n17/18\n11/16\n12/15\n13/14\n9/10\n1/8\n6/7\n2/5\n3/4\n(a)\n(b)\nundershorts\npants\nbelt\nshirt\ntie\njacket\nsocks\nshoes\nwatch\nsocks\nundershorts\npants\nshoes\nwatch\nshirt\nbelt\ntie\njacket\nFigure 22.7\n(a) Professor Bumstead topologically sorts his clothing when getting dressed. Each\ndirected edge .u; \u0003/ means that garment u must be put on before garment \u0003. The discovery and\nﬁnishing times from a depth-ﬁrst search are shown next to each vertex. (b) The same graph shown\ntopologically sorted, with its vertices arranged from left to right in order of decreasing ﬁnishing time.\nAll directed edges go from left to right.\npants). A directed edge .u; \u0003/ in the dag of Figure 22.7(a) indicates that garment u\nmust be donned before garment \u0003. A topological sort of this dag therefore gives an\norder for getting dressed. Figure 22.7(b) shows the topologically sorted dag as an\nordering of vertices along a horizontal line such that all directed edges go from left\nto right.\nThe following simple algorithm topologically sorts a dag:\nTOPOLOGICAL-SORT.G/\n1\ncall DFS.G/ to compute ﬁnishing times \u0003:f for each vertex \u0003\n2\nas each vertex is ﬁnished, insert it onto the front of a linked list\n3\nreturn the linked list of vertices\nFigure 22.7(b) shows how the topologically sorted vertices appear in reverse order\nof their ﬁnishing times.\nWe can perform a topological sort in time ‚.V C E/, since depth-ﬁrst search\ntakes ‚.V C E/ time and it takes O.1/ time to insert each of the jV j vertices onto\nthe front of the linked list.\nWe prove the correctness of this algorithm using the following key lemma char-\nacterizing directed acyclic graphs.\n614\nChapter 22\nElementary Graph Algorithms\nLemma 22.11\nA directed graph G is acyclic if and only if a depth-ﬁrst search of G yields no back\nedges.\nProof\n): Suppose that a depth-ﬁrst search produces a back edge .u; \u0003/. Then\nvertex \u0003 is an ancestor of vertex u in the depth-ﬁrst forest. Thus, G contains a path",
    "parent_ab469db5-a7ad-47b8-ab1d-cd857bdd1756": "Elementary Graph Algorithms\nLemma 22.11\nA directed graph G is acyclic if and only if a depth-ﬁrst search of G yields no back\nedges.\nProof\n): Suppose that a depth-ﬁrst search produces a back edge .u; \u0003/. Then\nvertex \u0003 is an ancestor of vertex u in the depth-ﬁrst forest. Thus, G contains a path\nfrom \u0003 to u, and the back edge .u; \u0003/ completes a cycle.\n(: Suppose that G contains a cycle c. We show that a depth-ﬁrst search of G\nyields a back edge. Let \u0003 be the ﬁrst vertex to be discovered in c, and let .u; \u0003/ be\nthe preceding edge in c. At time \u0003:d, the vertices of c form a path of white vertices\nfrom \u0003 to u. By the white-path theorem, vertex u becomes a descendant of \u0003 in the\ndepth-ﬁrst forest. Therefore, .u; \u0003/ is a back edge.\nTheorem 22.12\nTOPOLOGICAL-SORT produces a topological sort of the directed acyclic graph\nprovided as its input.\nProof\nSuppose that DFS is run on a given dag G D .V; E/ to determine ﬁn-\nishing times for its vertices. It sufﬁces to show that for any pair of distinct ver-\ntices u; \u0003 2 V , if G contains an edge from u to \u0003, then \u0003:f < u:f. Consider any\nedge .u; \u0003/ explored by DFS.G/. When this edge is explored, \u0003 cannot be gray,\nsince then \u0003 would be an ancestor of u and .u; \u0003/ would be a back edge, contra-\ndicting Lemma 22.11. Therefore, \u0003 must be either white or black. If \u0003 is white,\nit becomes a descendant of u, and so \u0003:f < u:f. If \u0003 is black, it has already been\nﬁnished, so that \u0003:f has already been set. Because we are still exploring from u, we\nhave yet to assign a timestamp to u:f, and so once we do, we will have \u0003:f < u:f\nas well. Thus, for any edge .u; \u0003/ in the dag, we have \u0003:f < u:f, proving the\ntheorem.\nExercises\n22.4-1\nShow the ordering of vertices produced by TOPOLOGICAL-SORT when it is run on\nthe dag of Figure 22.8, under the assumption of Exercise 22.3-2.\n22.4-2\nGive a linear-time algorithm that takes as input a directed acyclic graph G D\n.V; E/ and two vertices s and t, and returns the number of simple paths from s",
    "parent_d496c7a8-a4a4-41a9-b9df-546caf785748": "the dag of Figure 22.8, under the assumption of Exercise 22.3-2.\n22.4-2\nGive a linear-time algorithm that takes as input a directed acyclic graph G D\n.V; E/ and two vertices s and t, and returns the number of simple paths from s\nto t in G. For example, the directed acyclic graph of Figure 22.8 contains exactly\nfour simple paths from vertex p to vertex \u0003: po\u0003, pory\u0003, posry\u0003, and psry\u0003.\n(Your algorithm needs only to count the simple paths, not list them.)\n22.5\nStrongly connected components\n615\nz\ny\nx\nw\nv\nu\nt\ns\nr\nq\np\no\nn\nm\nFigure 22.8\nA dag for topological sorting.\n22.4-3\nGive an algorithm that determines whether or not a given undirected graph G D\n.V; E/ contains a cycle. Your algorithm should run in O.V / time, independent\nof jEj.\n22.4-4\nProve or disprove: If a directed graph G contains cycles, then TOPOLOGICAL-\nSORT.G/ produces a vertex ordering that minimizes the number of “bad” edges\nthat are inconsistent with the ordering produced.\n22.4-5\nAnother way to perform topological sorting on a directed acyclic graph G D\n.V; E/ is to repeatedly ﬁnd a vertex of in-degree 0, output it, and remove it and\nall of its outgoing edges from the graph. Explain how to implement this idea so\nthat it runs in time O.V C E/. What happens to this algorithm if G has cycles?\n22.5\nStrongly connected components\nWe now consider a classic application of depth-ﬁrst search: decomposing a di-\nrected graph into its strongly connected components. This section shows how to do\nso using two depth-ﬁrst searches. Many algorithms that work with directed graphs\nbegin with such a decomposition. After decomposing the graph into strongly con-\nnected components, such algorithms run separately on each one and then combine\nthe solutions according to the structure of connections among components.\nRecall from Appendix B that a strongly connected component of a directed\ngraph G D .V; E/ is a maximal set of vertices C \u0007 V such that for every pair",
    "parent_299eb421-6d0b-4b66-9c5d-f2bcb7d26894": "the solutions according to the structure of connections among components.\nRecall from Appendix B that a strongly connected component of a directed\ngraph G D .V; E/ is a maximal set of vertices C \u0007 V such that for every pair\nof vertices u and \u0003 in C, we have both u ; \u0003 and \u0003 ; u; that is, vertices u and \u0003\nare reachable from each other. Figure 22.9 shows an example.\n616\nChapter 22\nElementary Graph Algorithms\n13/14\n11/16\n12/15\n3/4\n1/10\n2/7\n8/9\n5/6\na\nb\nc\nd\ne\nf\ng\nh\na\nb\nc\nd\ne\nf\ng\nh\nabe\ncd\nfg\nh\n(c)\n(b)\n(a)\nFigure 22.9\n(a) A directed graph G. Each shaded region is a strongly connected component of G.\nEach vertex is labeled with its discovery and ﬁnishing times in a depth-ﬁrst search, and tree edges\nare shaded. (b) The graph GT, the transpose of G, with the depth-ﬁrst forest computed in line 3\nof STRONGLY-CONNECTED-COMPONENTS shown and tree edges shaded. Each strongly connected\ncomponent corresponds to one depth-ﬁrst tree. Vertices b, c, g, and h, which are heavily shaded, are\nthe roots of the depth-ﬁrst trees produced by the depth-ﬁrst search of GT. (c) The acyclic component\ngraph GSCC obtained by contracting all edges within each strongly connected component of G so\nthat only a single vertex remains in each component.\nOur algorithm for ﬁnding strongly connected components of a graph G D\n.V; E/ uses the transpose of G, which we deﬁned in Exercise 22.1-3 to be the\ngraph GT D .V; ET/, where ET D f.u; \u0003/ W .\u0003; u/ 2 Eg. That is, ET consists of\nthe edges of G with their directions reversed. Given an adjacency-list representa-\ntion of G, the time to create GT is O.V C E/. It is interesting to observe that G\nand GT have exactly the same strongly connected components: u and \u0003 are reach-\nable from each other in G if and only if they are reachable from each other in GT.\nFigure 22.9(b) shows the transpose of the graph in Figure 22.9(a), with the strongly\nconnected components shaded.\n22.5\nStrongly connected components\n617",
    "parent_cfc40b72-4ada-4f37-af23-a34c3eb6a36b": "able from each other in G if and only if they are reachable from each other in GT.\nFigure 22.9(b) shows the transpose of the graph in Figure 22.9(a), with the strongly\nconnected components shaded.\n22.5\nStrongly connected components\n617\nThe following linear-time (i.e., ‚.V CE/-time) algorithm computes the strongly\nconnected components of a directed graph G D .V; E/ using two depth-ﬁrst\nsearches, one on G and one on GT.\nSTRONGLY-CONNECTED-COMPONENTS.G/\n1\ncall DFS.G/ to compute ﬁnishing times u:f for each vertex u\n2\ncompute GT\n3\ncall DFS.GT/, but in the main loop of DFS, consider the vertices\nin order of decreasing u:f (as computed in line 1)\n4\noutput the vertices of each tree in the depth-ﬁrst forest formed in line 3 as a\nseparate strongly connected component\nThe idea behind this algorithm comes from a key property of the component\ngraph GSCC D .V SCC; ESCC/, which we deﬁne as follows.\nSuppose that G\nhas strongly connected components C1; C2; : : : ; Ck.\nThe vertex set V SCC is\nf\u00031; \u00032; : : : ; \u0003kg, and it contains a vertex \u0003i for each strongly connected compo-\nnent Ci of G. There is an edge .\u0003i; \u0003j/ 2 ESCC if G contains a directed edge .x; y/\nfor some x 2 Ci and some y 2 Cj. Looked at another way, by contracting all\nedges whose incident vertices are within the same strongly connected component\nof G, the resulting graph is GSCC. Figure 22.9(c) shows the component graph of\nthe graph in Figure 22.9(a).\nThe key property is that the component graph is a dag, which the following\nlemma implies.\nLemma 22.13\nLet C and C 0 be distinct strongly connected components in directed graph G D\n.V; E/, let u; \u0003 2 C, let u0; \u00030 2 C 0, and suppose that G contains a path u ; u0.\nThen G cannot also contain a path \u00030 ; \u0003.\nProof\nIf G contains a path \u00030 ; \u0003, then it contains paths u ; u0 ; \u00030 and\n\u00030 ; \u0003 ; u. Thus, u and \u00030 are reachable from each other, thereby contradicting\nthe assumption that C and C 0 are distinct strongly connected components.",
    "parent_34a2700c-57a3-42e1-b63c-abd36002928e": "Then G cannot also contain a path \u00030 ; \u0003.\nProof\nIf G contains a path \u00030 ; \u0003, then it contains paths u ; u0 ; \u00030 and\n\u00030 ; \u0003 ; u. Thus, u and \u00030 are reachable from each other, thereby contradicting\nthe assumption that C and C 0 are distinct strongly connected components.\nWe shall see that by considering vertices in the second depth-ﬁrst search in de-\ncreasing order of the ﬁnishing times that were computed in the ﬁrst depth-ﬁrst\nsearch, we are, in essence, visiting the vertices of the component graph (each of\nwhich corresponds to a strongly connected component of G) in topologically sorted\norder.\nBecause the STRONGLY-CONNECTED-COMPONENTS procedure performs two\ndepth-ﬁrst searches, there is the potential for ambiguity when we discuss u:d\nor u:f. In this section, these values always refer to the discovery and ﬁnishing\ntimes as computed by the ﬁrst call of DFS, in line 1.\n618\nChapter 22\nElementary Graph Algorithms\nWe extend the notation for discovery and ﬁnishing times to sets of vertices.\nIf U \u0007 V , then we deﬁne d.U / D minu2U fu:dg and f .U / D maxu2U fu:fg.\nThat is, d.U / and f .U / are the earliest discovery time and latest ﬁnishing time,\nrespectively, of any vertex in U .\nThe following lemma and its corollary give a key property relating strongly con-\nnected components and ﬁnishing times in the ﬁrst depth-ﬁrst search.\nLemma 22.14\nLet C and C 0 be distinct strongly connected components in directed graph G D\n.V; E/. Suppose that there is an edge .u; \u0003/ 2 E, where u 2 C and \u0003 2 C 0. Then\nf .C/ > f .C 0/.\nProof\nWe consider two cases, depending on which strongly connected compo-\nnent, C or C 0, had the ﬁrst discovered vertex during the depth-ﬁrst search.\nIf d.C/ < d.C 0/, let x be the ﬁrst vertex discovered in C. At time x:d, all ver-\ntices in C and C 0 are white. At that time, G contains a path from x to each vertex\nin C consisting only of white vertices. Because .u; \u0003/ 2 E, for any vertex w 2 C 0,",
    "parent_92681006-4ad7-4a7a-8447-895b7d10aa41": "If d.C/ < d.C 0/, let x be the ﬁrst vertex discovered in C. At time x:d, all ver-\ntices in C and C 0 are white. At that time, G contains a path from x to each vertex\nin C consisting only of white vertices. Because .u; \u0003/ 2 E, for any vertex w 2 C 0,\nthere is also a path in G at time x:d from x to w consisting only of white vertices:\nx ; u ! \u0003 ; w. By the white-path theorem, all vertices in C and C 0 become\ndescendants of x in the depth-ﬁrst tree. By Corollary 22.8, x has the latest ﬁnishing\ntime of any of its descendants, and so x:f D f .C/ > f .C 0/.\nIf instead we have d.C/ > d.C 0/, let y be the ﬁrst vertex discovered in C 0.\nAt time y:d, all vertices in C 0 are white and G contains a path from y to each\nvertex in C 0 consisting only of white vertices. By the white-path theorem, all ver-\ntices in C 0 become descendants of y in the depth-ﬁrst tree, and by Corollary 22.8,\ny:f D f .C 0/. At time y:d, all vertices in C are white. Since there is an edge .u; \u0003/\nfrom C to C 0, Lemma 22.13 implies that there cannot be a path from C 0 to C.\nHence, no vertex in C is reachable from y. At time y:f, therefore, all vertices in C\nare still white. Thus, for any vertex w 2 C, we have w:f > y:f, which implies\nthat f .C/ > f .C 0/.\nThe following corollary tells us that each edge in GT that goes between different\nstrongly connected components goes from a component with an earlier ﬁnishing\ntime (in the ﬁrst depth-ﬁrst search) to a component with a later ﬁnishing time.\nCorollary 22.15\nLet C and C 0 be distinct strongly connected components in directed graph G D\n.V; E/. Suppose that there is an edge .u; \u0003/ 2 ET, where u 2 C and \u0003 2 C 0. Then\nf .C/ < f .C 0/.\n22.5\nStrongly connected components\n619\nProof\nSince .u; \u0003/ 2 ET, we have .\u0003; u/ 2 E.\nBecause the strongly con-\nnected components of G and GT are the same, Lemma 22.14 implies that\nf .C/ < f .C 0/.\nCorollary 22.15 provides the key to understanding why the strongly connected",
    "parent_0d9eadc1-7e1c-43ab-8690-a844294953c5": "f .C/ < f .C 0/.\n22.5\nStrongly connected components\n619\nProof\nSince .u; \u0003/ 2 ET, we have .\u0003; u/ 2 E.\nBecause the strongly con-\nnected components of G and GT are the same, Lemma 22.14 implies that\nf .C/ < f .C 0/.\nCorollary 22.15 provides the key to understanding why the strongly connected\ncomponents algorithm works. Let us examine what happens when we perform the\nsecond depth-ﬁrst search, which is on GT. We start with the strongly connected\ncomponent C whose ﬁnishing time f .C/ is maximum. The search starts from\nsome vertex x 2 C, and it visits all vertices in C. By Corollary 22.15, GT contains\nno edges from C to any other strongly connected component, and so the search\nfrom x will not visit vertices in any other component. Thus, the tree rooted at x\ncontains exactly the vertices of C. Having completed visiting all vertices in C,\nthe search in line 3 selects as a root a vertex from some other strongly connected\ncomponent C 0 whose ﬁnishing time f .C 0/ is maximum over all components other\nthan C. Again, the search will visit all vertices in C 0, but by Corollary 22.15,\nthe only edges in GT from C 0 to any other component must be to C, which we\nhave already visited. In general, when the depth-ﬁrst search of GT in line 3 visits\nany strongly connected component, any edges out of that component must be to\ncomponents that the search already visited. Each depth-ﬁrst tree, therefore, will be\nexactly one strongly connected component. The following theorem formalizes this\nargument.\nTheorem 22.16\nThe STRONGLY-CONNECTED-COMPONENTS procedure correctly computes the\nstrongly connected components of the directed graph G provided as its input.\nProof\nWe argue by induction on the number of depth-ﬁrst trees found in the\ndepth-ﬁrst search of GT in line 3 that the vertices of each tree form a strongly\nconnected component. The inductive hypothesis is that the ﬁrst k trees produced\nin line 3 are strongly connected components. The basis for the induction, when\nk D 0, is trivial.",
    "parent_a8de902e-66d0-4136-9d1b-21ea053698b1": "depth-ﬁrst search of GT in line 3 that the vertices of each tree form a strongly\nconnected component. The inductive hypothesis is that the ﬁrst k trees produced\nin line 3 are strongly connected components. The basis for the induction, when\nk D 0, is trivial.\nIn the inductive step, we assume that each of the ﬁrst k depth-ﬁrst trees produced\nin line 3 is a strongly connected component, and we consider the .k C 1/st tree\nproduced. Let the root of this tree be vertex u, and let u be in strongly connected\ncomponent C. Because of how we choose roots in the depth-ﬁrst search in line 3,\nu:f D f .C/ > f .C 0/ for any strongly connected component C 0 other than C\nthat has yet to be visited. By the inductive hypothesis, at the time that the search\nvisits u, all other vertices of C are white. By the white-path theorem, therefore, all\nother vertices of C are descendants of u in its depth-ﬁrst tree. Moreover, by the\ninductive hypothesis and by Corollary 22.15, any edges in GT that leave C must be\nto strongly connected components that have already been visited. Thus, no vertex\n620\nChapter 22\nElementary Graph Algorithms\nin any strongly connected component other than C will be a descendant of u during\nthe depth-ﬁrst search of GT. Thus, the vertices of the depth-ﬁrst tree in GT that is\nrooted at u form exactly one strongly connected component, which completes the\ninductive step and the proof.\nHere is another way to look at how the second depth-ﬁrst search operates. Con-\nsider the component graph .GT/SCC of GT. If we map each strongly connected\ncomponent visited in the second depth-ﬁrst search to a vertex of .GT/SCC, the sec-\nond depth-ﬁrst search visits vertices of .GT/SCC in the reverse of a topologically\nsorted order. If we reverse the edges of .GT/SCC, we get the graph ..GT/SCC/T.\nBecause ..GT/SCC/T D GSCC (see Exercise 22.5-4), the second depth-ﬁrst search\nvisits the vertices of GSCC in topologically sorted order.\nExercises\n22.5-1",
    "parent_daf6d131-339a-42c0-8ca6-b95377a3261b": "sorted order. If we reverse the edges of .GT/SCC, we get the graph ..GT/SCC/T.\nBecause ..GT/SCC/T D GSCC (see Exercise 22.5-4), the second depth-ﬁrst search\nvisits the vertices of GSCC in topologically sorted order.\nExercises\n22.5-1\nHow can the number of strongly connected components of a graph change if a new\nedge is added?\n22.5-2\nShow how the procedure STRONGLY-CONNECTED-COMPONENTS works on the\ngraph of Figure 22.6. Speciﬁcally, show the ﬁnishing times computed in line 1 and\nthe forest produced in line 3. Assume that the loop of lines 5–7 of DFS considers\nvertices in alphabetical order and that the adjacency lists are in alphabetical order.\n22.5-3\nProfessor Bacon claims that the algorithm for strongly connected components\nwould be simpler if it used the original (instead of the transpose) graph in the\nsecond depth-ﬁrst search and scanned the vertices in order of increasing ﬁnishing\ntimes. Does this simpler algorithm always produce correct results?\n22.5-4\nProve that for any directed graph G, we have ..GT/SCC/T D GSCC. That is, the\ntranspose of the component graph of GT is the same as the component graph of G.\n22.5-5\nGive an O.V C E/-time algorithm to compute the component graph of a directed\ngraph G D .V; E/. Make sure that there is at most one edge between two vertices\nin the component graph your algorithm produces.\nProblems for Chapter 22\n621\n22.5-6\nGiven a directed graph G D .V; E/, explain how to create another graph G0 D\n.V; E0/ such that (a) G0 has the same strongly connected components as G, (b) G0\nhas the same component graph as G, and (c) E0 is as small as possible. Describe a\nfast algorithm to compute G0.\n22.5-7\nA directed graph G D .V; E/ is semiconnected if, for all pairs of vertices u; \u0003 2 V ,\nwe have u ; \u0003 or \u0003 ; u. Give an efﬁcient algorithm to determine whether\nor not G is semiconnected. Prove that your algorithm is correct, and analyze its\nrunning time.\nProblems\n22-1\nClassifying edges by breadth-ﬁrst search",
    "parent_0687c5e1-69eb-463d-b302-4c98966567fc": "we have u ; \u0003 or \u0003 ; u. Give an efﬁcient algorithm to determine whether\nor not G is semiconnected. Prove that your algorithm is correct, and analyze its\nrunning time.\nProblems\n22-1\nClassifying edges by breadth-ﬁrst search\nA depth-ﬁrst forest classiﬁes the edges of a graph into tree, back, forward, and\ncross edges. A breadth-ﬁrst tree can also be used to classify the edges reachable\nfrom the source of the search into the same four categories.\na. Prove that in a breadth-ﬁrst search of an undirected graph, the following prop-\nerties hold:\n1. There are no back edges and no forward edges.\n2. For each tree edge .u; \u0003/, we have \u0003:d D u:d C 1.\n3. For each cross edge .u; \u0003/, we have \u0003:d D u:d or \u0003:d D u:d C 1.\nb. Prove that in a breadth-ﬁrst search of a directed graph, the following properties\nhold:\n1. There are no forward edges.\n2. For each tree edge .u; \u0003/, we have \u0003:d D u:d C 1.\n3. For each cross edge .u; \u0003/, we have \u0003:d \u0002 u:d C 1.\n4. For each back edge .u; \u0003/, we have 0 \u0002 \u0003:d \u0002 u:d.\n22-2\nArticulation points, bridges, and biconnected components\nLet G D .V; E/ be a connected, undirected graph. An articulation point of G is\na vertex whose removal disconnects G. A bridge of G is an edge whose removal\ndisconnects G. A biconnected component of G is a maximal set of edges such\nthat any two edges in the set lie on a common simple cycle. Figure 22.10 illustrates\n622\nChapter 22\nElementary Graph Algorithms\n1\n2\n3\n4\n5\n6\nFigure 22.10\nThe articulation points, bridges, and biconnected components of a connected, undi-\nrected graph for use in Problem 22-2. The articulation points are the heavily shaded vertices, the\nbridges are the heavily shaded edges, and the biconnected components are the edges in the shaded\nregions, with a bcc numbering shown.\nthese deﬁnitions. We can determine articulation points, bridges, and biconnected\ncomponents using depth-ﬁrst search. Let G\u0003 D .V; E\u0003/ be a depth-ﬁrst tree of G.\na. Prove that the root of G\u0003 is an articulation point of G if and only if it has at",
    "parent_13242897-8434-4a12-a8bc-338e0093299f": "regions, with a bcc numbering shown.\nthese deﬁnitions. We can determine articulation points, bridges, and biconnected\ncomponents using depth-ﬁrst search. Let G\u0003 D .V; E\u0003/ be a depth-ﬁrst tree of G.\na. Prove that the root of G\u0003 is an articulation point of G if and only if it has at\nleast two children in G\u0003.\nb. Let \u0003 be a nonroot vertex of G\u0003. Prove that \u0003 is an articulation point of G if and\nonly if \u0003 has a child s such that there is no back edge from s or any descendant\nof s to a proper ancestor of \u0003.\nc. Let\n\u0003:low D min\n(\n\u0003:d ;\nw:d W .u; w/ is a back edge for some descendant u of \u0003 :\nShow how to compute \u0003:low for all vertices \u0003 2 V in O.E/ time.\nd. Show how to compute all articulation points in O.E/ time.\ne. Prove that an edge of G is a bridge if and only if it does not lie on any simple\ncycle of G.\nf.\nShow how to compute all the bridges of G in O.E/ time.\ng. Prove that the biconnected components of G partition the nonbridge edges of G.\nh. Give an O.E/-time algorithm to label each edge e of G with a positive in-\nteger e:bcc such that e:bcc D e0:bcc if and only if e and e0 are in the same\nbiconnected component.\nNotes for Chapter 22\n623\n22-3\nEuler tour\nAn Euler tour of a strongly connected, directed graph G D .V; E/ is a cycle that\ntraverses each edge of G exactly once, although it may visit a vertex more than\nonce.\na. Show that G has an Euler tour if and only if in-degree.\u0003/ D out-degree.\u0003/ for\neach vertex \u0003 2 V .\nb. Describe an O.E/-time algorithm to ﬁnd an Euler tour of G if one exists. (Hint:\nMerge edge-disjoint cycles.)\n22-4\nReachability\nLet G D .V; E/ be a directed graph in which each vertex u 2 V is labeled with\na unique integer L.u/ from the set f1; 2; : : : ; jV jg. For each vertex u 2 V , let\nR.u/ D f\u0003 2 V W u ; \u0003g be the set of vertices that are reachable from u. Deﬁne\nmin.u/ to be the vertex in R.u/ whose label is minimum, i.e., min.u/ is the vertex \u0003\nsuch that L.\u0003/ D min fL.w/ W w 2 R.u/g. Give an O.V CE/-time algorithm that",
    "parent_8a339810-9a04-4b31-8948-b11a1a463a7c": "R.u/ D f\u0003 2 V W u ; \u0003g be the set of vertices that are reachable from u. Deﬁne\nmin.u/ to be the vertex in R.u/ whose label is minimum, i.e., min.u/ is the vertex \u0003\nsuch that L.\u0003/ D min fL.w/ W w 2 R.u/g. Give an O.V CE/-time algorithm that\ncomputes min.u/ for all vertices u 2 V .\nChapter notes\nEven [103] and Tarjan [330] are excellent references for graph algorithms.\nBreadth-ﬁrst search was discovered by Moore [260] in the context of ﬁnding\npaths through mazes. Lee [226] independently discovered the same algorithm in\nthe context of routing wires on circuit boards.\nHopcroft and Tarjan [178] advocated the use of the adjacency-list representation\nover the adjacency-matrix representation for sparse graphs and were the ﬁrst to\nrecognize the algorithmic importance of depth-ﬁrst search. Depth-ﬁrst search has\nbeen widely used since the late 1950s, especially in artiﬁcial intelligence programs.\nTarjan [327] gave a linear-time algorithm for ﬁnding strongly connected compo-\nnents. The algorithm for strongly connected components in Section 22.5 is adapted\nfrom Aho, Hopcroft, and Ullman [6], who credit it to S. R. Kosaraju (unpublished)\nand M. Sharir [314]. Gabow [119] also developed an algorithm for strongly con-\nnected components that is based on contracting cycles and uses two stacks to make\nit run in linear time. Knuth [209] was the ﬁrst to give a linear-time algorithm for\ntopological sorting.\n23\nMinimum Spanning Trees\nElectronic circuit designs often need to make the pins of several components elec-\ntrically equivalent by wiring them together. To interconnect a set of n pins, we can\nuse an arrangement of n \u0005 1 wires, each connecting two pins. Of all such arrange-\nments, the one that uses the least amount of wire is usually the most desirable.\nWe can model this wiring problem with a connected, undirected graph G D\n.V; E/, where V is the set of pins, E is the set of possible interconnections between",
    "parent_c6440307-64b6-42cc-9259-2c438f08fc41": "ments, the one that uses the least amount of wire is usually the most desirable.\nWe can model this wiring problem with a connected, undirected graph G D\n.V; E/, where V is the set of pins, E is the set of possible interconnections between\npairs of pins, and for each edge .u; \u0003/ 2 E, we have a weight w.u; \u0003/ specifying\nthe cost (amount of wire needed) to connect u and \u0003. We then wish to ﬁnd an\nacyclic subset T \u0007 E that connects all of the vertices and whose total weight\nw.T / D\nX\n.u;\u0005/2T\nw.u; \u0003/\nis minimized. Since T is acyclic and connects all of the vertices, it must form a tree,\nwhich we call a spanning tree since it “spans” the graph G. We call the problem of\ndetermining the tree T the minimum-spanning-tree problem.1 Figure 23.1 shows\nan example of a connected graph and a minimum spanning tree.\nIn this chapter, we shall examine two algorithms for solving the minimum-\nspanning-tree problem: Kruskal’s algorithm and Prim’s algorithm. We can easily\nmake each of them run in time O.E lg V / using ordinary binary heaps. By using\nFibonacci heaps, Prim’s algorithm runs in time O.E C V lg V /, which improves\nover the binary-heap implementation if jV j is much smaller than jEj.\nThe two algorithms are greedy algorithms, as described in Chapter 16. Each\nstep of a greedy algorithm must make one of several possible choices. The greedy\nstrategy advocates making the choice that is the best at the moment. Such a strat-\negy does not generally guarantee that it will always ﬁnd globally optimal solutions\n1The phrase “minimum spanning tree” is a shortened form of the phrase “minimum-weight spanning\ntree.” We are not, for example, minimizing the number of edges in T , since all spanning trees have\nexactly jV j \u0005 1 edges by Theorem B.2.\n23.1\nGrowing a minimum spanning tree\n625\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nFigure 23.1\nA minimum spanning tree for a connected graph. The weights on edges are shown,",
    "parent_6ea99f2a-c58a-48c6-ab06-30bf6e15f751": "exactly jV j \u0005 1 edges by Theorem B.2.\n23.1\nGrowing a minimum spanning tree\n625\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nFigure 23.1\nA minimum spanning tree for a connected graph. The weights on edges are shown,\nand the edges in a minimum spanning tree are shaded. The total weight of the tree shown is 37. This\nminimum spanning tree is not unique: removing the edge .b; c/ and replacing it with the edge .a; h/\nyields another spanning tree with weight 37.\nto problems. For the minimum-spanning-tree problem, however, we can prove that\ncertain greedy strategies do yield a spanning tree with minimum weight. Although\nyou can read this chapter independently of Chapter 16, the greedy methods pre-\nsented here are a classic application of the theoretical notions introduced there.\nSection 23.1 introduces a “generic” minimum-spanning-tree method that grows\na spanning tree by adding one edge at a time. Section 23.2 gives two algorithms\nthat implement the generic method. The ﬁrst algorithm, due to Kruskal, is similar\nto the connected-components algorithm from Section 21.1. The second, due to\nPrim, resembles Dijkstra’s shortest-paths algorithm (Section 24.3).\nBecause a tree is a type of graph, in order to be precise we must deﬁne a tree in\nterms of not just its edges, but its vertices as well. Although this chapter focuses\non trees in terms of their edges, we shall operate with the understanding that the\nvertices of a tree T are those that some edge of T is incident on.\n23.1\nGrowing a minimum spanning tree\nAssume that we have a connected, undirected graph G D .V; E/ with a weight\nfunction w W E ! R, and we wish to ﬁnd a minimum spanning tree for G. The\ntwo algorithms we consider in this chapter use a greedy approach to the problem,\nalthough they differ in how they apply this approach.\nThis greedy strategy is captured by the following generic method, which grows\nthe minimum spanning tree one edge at a time. The generic method manages a set",
    "parent_7143bfa6-c92a-41ec-b2a8-e01d88ef1c33": "two algorithms we consider in this chapter use a greedy approach to the problem,\nalthough they differ in how they apply this approach.\nThis greedy strategy is captured by the following generic method, which grows\nthe minimum spanning tree one edge at a time. The generic method manages a set\nof edges A, maintaining the following loop invariant:\nPrior to each iteration, A is a subset of some minimum spanning tree.\nAt each step, we determine an edge .u; \u0003/ that we can add to A without violating\nthis invariant, in the sense that A[f.u; \u0003/g is also a subset of a minimum spanning\n626\nChapter 23\nMinimum Spanning Trees\ntree. We call such an edge a safe edge for A, since we can add it safely to A while\nmaintaining the invariant.\nGENERIC-MST.G; w/\n1\nA D ;\n2\nwhile A does not form a spanning tree\n3\nﬁnd an edge .u; \u0003/ that is safe for A\n4\nA D A [ f.u; \u0003/g\n5\nreturn A\nWe use the loop invariant as follows:\nInitialization: After line 1, the set A trivially satisﬁes the loop invariant.\nMaintenance: The loop in lines 2–4 maintains the invariant by adding only safe\nedges.\nTermination: All edges added to A are in a minimum spanning tree, and so the\nset A returned in line 5 must be a minimum spanning tree.\nThe tricky part is, of course, ﬁnding a safe edge in line 3. One must exist, since\nwhen line 3 is executed, the invariant dictates that there is a spanning tree T such\nthat A \u0007 T . Within the while loop body, A must be a proper subset of T , and\ntherefore there must be an edge .u; \u0003/ 2 T such that .u; \u0003/ 62 A and .u; \u0003/ is safe\nfor A.\nIn the remainder of this section, we provide a rule (Theorem 23.1) for recogniz-\ning safe edges. The next section describes two algorithms that use this rule to ﬁnd\nsafe edges efﬁciently.\nWe ﬁrst need some deﬁnitions. A cut .S; V \u0005 S/ of an undirected graph G D\n.V; E/ is a partition of V . Figure 23.2 illustrates this notion. We say that an edge\n.u; \u0003/ 2 E crosses the cut .S; V \u0005 S/ if one of its endpoints is in S and the other",
    "parent_f796ec78-a66a-4cb5-900f-d0ea82ef29a7": "safe edges efﬁciently.\nWe ﬁrst need some deﬁnitions. A cut .S; V \u0005 S/ of an undirected graph G D\n.V; E/ is a partition of V . Figure 23.2 illustrates this notion. We say that an edge\n.u; \u0003/ 2 E crosses the cut .S; V \u0005 S/ if one of its endpoints is in S and the other\nis in V \u0005 S. We say that a cut respects a set A of edges if no edge in A crosses the\ncut. An edge is a light edge crossing a cut if its weight is the minimum of any edge\ncrossing the cut. Note that there can be more than one light edge crossing a cut in\nthe case of ties. More generally, we say that an edge is a light edge satisfying a\ngiven property if its weight is the minimum of any edge satisfying the property.\nOur rule for recognizing safe edges is given by the following theorem.\nTheorem 23.1\nLet G D .V; E/ be a connected, undirected graph with a real-valued weight func-\ntion w deﬁned on E. Let A be a subset of E that is included in some minimum\nspanning tree for G, let .S; V \u0005 S/ be any cut of G that respects A, and let .u; \u0003/\nbe a light edge crossing .S; V \u0005 S/. Then, edge .u; \u0003/ is safe for A.\n23.1\nGrowing a minimum spanning tree\n627\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\na\nb\nd\ne\nh\ni\ng\nc\nf\n8\n11\n8\n7\n14\n10\n4\n6\n7\n4\n9\n2\n1\n2\nS\n(a)\n(b)\nV – S\nS\nV – S\nS\nV – S\nFigure 23.2\nTwo ways of viewing a cut .S; V \u0005 S/ of the graph from Figure 23.1. (a) Black\nvertices are in the set S, and white vertices are in V \u0005 S. The edges crossing the cut are those\nconnecting white vertices with black vertices. The edge .d; c/ is the unique light edge crossing the\ncut. A subset A of the edges is shaded; note that the cut .S; V \u0005 S/ respects A, since no edge of A\ncrosses the cut. (b) The same graph with the vertices in the set S on the left and the vertices in the\nset V \u0005 S on the right. An edge crosses the cut if it connects a vertex on the left with a vertex on the\nright.\nProof\nLet T be a minimum spanning tree that includes A, and assume that T",
    "parent_48f36246-5fe5-460c-a550-dd010ccbdbcb": "crosses the cut. (b) The same graph with the vertices in the set S on the left and the vertices in the\nset V \u0005 S on the right. An edge crosses the cut if it connects a vertex on the left with a vertex on the\nright.\nProof\nLet T be a minimum spanning tree that includes A, and assume that T\ndoes not contain the light edge .u; \u0003/, since if it does, we are done. We shall\nconstruct another minimum spanning tree T 0 that includes A [ f.u; \u0003/g by using a\ncut-and-paste technique, thereby showing that .u; \u0003/ is a safe edge for A.\nThe edge .u; \u0003/ forms a cycle with the edges on the simple path p from u\nto \u0003 in T , as Figure 23.3 illustrates. Since u and \u0003 are on opposite sides of the\ncut .S; V \u0005 S/, at least one edge in T lies on the simple path p and also crosses\nthe cut. Let .x; y/ be any such edge. The edge .x; y/ is not in A, because the cut\nrespects A. Since .x; y/ is on the unique simple path from u to \u0003 in T , remov-\ning .x; y/ breaks T into two components. Adding .u; \u0003/ reconnects them to form\na new spanning tree T 0 D T \u0005 f.x; y/g [ f.u; \u0003/g.\nWe next show that T 0 is a minimum spanning tree. Since .u; \u0003/ is a light edge\ncrossing .S; V \u0005S/ and .x; y/ also crosses this cut, w.u; \u0003/ \u0002 w.x; y/. Therefore,\nw.T 0/\nD\nw.T / \u0005 w.x; y/ C w.u; \u0003/\n\u0002\nw.T / :\n628\nChapter 23\nMinimum Spanning Trees\ny\nv\nu\nx\np\nFigure 23.3\nThe proof of Theorem 23.1. Black vertices are in S, and white vertices are in V \u0005 S.\nThe edges in the minimum spanning tree T are shown, but the edges in the graph G are not. The\nedges in A are shaded, and .u;\u0003/ is a light edge crossing the cut .S; V \u0005 S/. The edge .x; y/ is\nan edge on the unique simple path p from u to \u0003 in T . To form a minimum spanning tree T 0 that\ncontains .u; \u0003/, remove the edge .x; y/ from T and add the edge .u; \u0003/.\nBut T is a minimum spanning tree, so that w.T / \u0002 w.T 0/; thus, T 0 must be a\nminimum spanning tree also.\nIt remains to show that .u; \u0003/ is actually a safe edge for A. We have A \u0007 T 0,",
    "parent_270d3a82-b37a-4eae-b2c8-a3fd69fea716": "contains .u; \u0003/, remove the edge .x; y/ from T and add the edge .u; \u0003/.\nBut T is a minimum spanning tree, so that w.T / \u0002 w.T 0/; thus, T 0 must be a\nminimum spanning tree also.\nIt remains to show that .u; \u0003/ is actually a safe edge for A. We have A \u0007 T 0,\nsince A \u0007 T and .x; y/ 62 A; thus, A [ f.u; \u0003/g \u0007 T 0. Consequently, since T 0 is a\nminimum spanning tree, .u; \u0003/ is safe for A.\nTheorem 23.1 gives us a better understanding of the workings of the GENERIC-\nMST method on a connected graph G D .V; E/. As the method proceeds, the\nset A is always acyclic; otherwise, a minimum spanning tree including A would\ncontain a cycle, which is a contradiction. At any point in the execution, the graph\nGA D .V; A/ is a forest, and each of the connected components of GA is a tree.\n(Some of the trees may contain just one vertex, as is the case, for example, when\nthe method begins: A is empty and the forest contains jV j trees, one for each\nvertex.) Moreover, any safe edge .u; \u0003/ for A connects distinct components of GA,\nsince A [ f.u; \u0003/g must be acyclic.\nThe while loop in lines 2–4 of GENERIC-MST executes jV j \u0005 1 times because\nit ﬁnds one of the jV j \u0005 1 edges of a minimum spanning tree in each iteration.\nInitially, when A D ;, there are jV j trees in GA, and each iteration reduces that\nnumber by 1. When the forest contains only a single tree, the method terminates.\nThe two algorithms in Section 23.2 use the following corollary to Theorem 23.1.\n23.1\nGrowing a minimum spanning tree\n629\nCorollary 23.2\nLet G D .V; E/ be a connected, undirected graph with a real-valued weight func-\ntion w deﬁned on E. Let A be a subset of E that is included in some minimum\nspanning tree for G, and let C D .VC; EC/ be a connected component (tree) in the\nforest GA D .V; A/. If .u; \u0003/ is a light edge connecting C to some other component\nin GA, then .u; \u0003/ is safe for A.\nProof\nThe cut .VC; V \u0005 VC/ respects A, and .u; \u0003/ is a light edge for this cut.\nTherefore, .u; \u0003/ is safe for A.\nExercises\n23.1-1",
    "parent_b86c5add-5305-4090-987d-36ca053257f4": "forest GA D .V; A/. If .u; \u0003/ is a light edge connecting C to some other component\nin GA, then .u; \u0003/ is safe for A.\nProof\nThe cut .VC; V \u0005 VC/ respects A, and .u; \u0003/ is a light edge for this cut.\nTherefore, .u; \u0003/ is safe for A.\nExercises\n23.1-1\nLet .u; \u0003/ be a minimum-weight edge in a connected graph G. Show that .u; \u0003/\nbelongs to some minimum spanning tree of G.\n23.1-2\nProfessor Sabatier conjectures the following converse of Theorem 23.1. Let G D\n.V; E/ be a connected, undirected graph with a real-valued weight function w de-\nﬁned on E. Let A be a subset of E that is included in some minimum spanning\ntree for G, let .S; V \u0005 S/ be any cut of G that respects A, and let .u; \u0003/ be a safe\nedge for A crossing .S; V \u0005 S/. Then, .u; \u0003/ is a light edge for the cut. Show that\nthe professor’s conjecture is incorrect by giving a counterexample.\n23.1-3\nShow that if an edge .u; \u0003/ is contained in some minimum spanning tree, then it is\na light edge crossing some cut of the graph.\n23.1-4\nGive a simple example of a connected graph such that the set of edges f.u; \u0003/ W\nthere exists a cut .S; V \u0005 S/ such that .u; \u0003/ is a light edge crossing .S; V \u0005 S/g\ndoes not form a minimum spanning tree.\n23.1-5\nLet e be a maximum-weight edge on some cycle of connected graph G D .V; E/.\nProve that there is a minimum spanning tree of G0 D .V; E \u0005 feg/ that is also a\nminimum spanning tree of G. That is, there is a minimum spanning tree of G that\ndoes not include e.\n630\nChapter 23\nMinimum Spanning Trees\n23.1-6\nShow that a graph has a unique minimum spanning tree if, for every cut of the\ngraph, there is a unique light edge crossing the cut. Show that the converse is not\ntrue by giving a counterexample.\n23.1-7\nArgue that if all edge weights of a graph are positive, then any subset of edges that\nconnects all vertices and has minimum total weight must be a tree. Give an example\nto show that the same conclusion does not follow if we allow some weights to be\nnonpositive.\n23.1-8",
    "parent_cd35669e-1197-4583-9e3e-9f243407dcd7": "23.1-7\nArgue that if all edge weights of a graph are positive, then any subset of edges that\nconnects all vertices and has minimum total weight must be a tree. Give an example\nto show that the same conclusion does not follow if we allow some weights to be\nnonpositive.\n23.1-8\nLet T be a minimum spanning tree of a graph G, and let L be the sorted list of the\nedge weights of T . Show that for any other minimum spanning tree T 0 of G, the\nlist L is also the sorted list of edge weights of T 0.\n23.1-9\nLet T be a minimum spanning tree of a graph G D .V; E/, and let V 0 be a subset\nof V . Let T 0 be the subgraph of T induced by V 0, and let G0 be the subgraph of G\ninduced by V 0. Show that if T 0 is connected, then T 0 is a minimum spanning tree\nof G0.\n23.1-10\nGiven a graph G and a minimum spanning tree T , suppose that we decrease the\nweight of one of the edges in T . Show that T is still a minimum spanning tree\nfor G. More formally, let T be a minimum spanning tree for G with edge weights\ngiven by weight function w. Choose one edge .x; y/ 2 T and a positive number k,\nand deﬁne the weight function w0 by\nw0.u; \u0003/ D\n(\nw.u; \u0003/\nif .u; \u0003/ ¤ .x; y/ ;\nw.x; y/ \u0005 k\nif .u; \u0003/ D .x; y/ :\nShow that T is a minimum spanning tree for G with edge weights given by w0.\n23.1-11\n?\nGiven a graph G and a minimum spanning tree T , suppose that we decrease the\nweight of one of the edges not in T . Give an algorithm for ﬁnding the minimum\nspanning tree in the modiﬁed graph.\n23.2\nThe algorithms of Kruskal and Prim\n631\n23.2\nThe algorithms of Kruskal and Prim\nThe two minimum-spanning-tree algorithms described in this section elaborate on\nthe generic method. They each use a speciﬁc rule to determine a safe edge in line 3\nof GENERIC-MST. In Kruskal’s algorithm, the set A is a forest whose vertices are\nall those of the given graph. The safe edge added to A is always a least-weight\nedge in the graph that connects two distinct components. In Prim’s algorithm, the",
    "parent_60d28161-59e8-4d9a-b8c3-93522671a31e": "of GENERIC-MST. In Kruskal’s algorithm, the set A is a forest whose vertices are\nall those of the given graph. The safe edge added to A is always a least-weight\nedge in the graph that connects two distinct components. In Prim’s algorithm, the\nset A forms a single tree. The safe edge added to A is always a least-weight edge\nconnecting the tree to a vertex not in the tree.\nKruskal’s algorithm\nKruskal’s algorithm ﬁnds a safe edge to add to the growing forest by ﬁnding, of all\nthe edges that connect any two trees in the forest, an edge .u; \u0003/ of least weight.\nLet C1 and C2 denote the two trees that are connected by .u; \u0003/. Since .u; \u0003/ must\nbe a light edge connecting C1 to some other tree, Corollary 23.2 implies that .u; \u0003/\nis a safe edge for C1. Kruskal’s algorithm qualiﬁes as a greedy algorithm because\nat each step it adds to the forest an edge of least possible weight.\nOur implementation of Kruskal’s algorithm is like the algorithm to compute\nconnected components from Section 21.1. It uses a disjoint-set data structure to\nmaintain several disjoint sets of elements. Each set contains the vertices in one tree\nof the current forest. The operation FIND-SET.u/ returns a representative element\nfrom the set that contains u. Thus, we can determine whether two vertices u and \u0003\nbelong to the same tree by testing whether FIND-SET.u/ equals FIND-SET.\u0003/. To\ncombine trees, Kruskal’s algorithm calls the UNION procedure.\nMST-KRUSKAL.G; w/\n1\nA D ;\n2\nfor each vertex \u0003 2 G:V\n3\nMAKE-SET.\u0003/\n4\nsort the edges of G:E into nondecreasing order by weight w\n5\nfor each edge .u; \u0003/ 2 G:E, taken in nondecreasing order by weight\n6\nif FIND-SET.u/ ¤ FIND-SET.\u0003/\n7\nA D A [ f.u; \u0003/g\n8\nUNION.u; \u0003/\n9\nreturn A\nFigure 23.4 shows how Kruskal’s algorithm works. Lines 1–3 initialize the set A\nto the empty set and create jV j trees, one containing each vertex. The for loop in\nlines 5–8 examines edges in order of weight, from lowest to highest. The loop\n632\nChapter 23\nMinimum Spanning Trees\nb\na\nh\nc\ng\ni\nd\nf\ne\n4",
    "parent_253816f7-8fe2-41fe-ba68-1df519faee6d": "Figure 23.4 shows how Kruskal’s algorithm works. Lines 1–3 initialize the set A\nto the empty set and create jV j trees, one containing each vertex. The for loop in\nlines 5–8 examines edges in order of weight, from lowest to highest. The loop\n632\nChapter 23\nMinimum Spanning Trees\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\n(a)\n(b)\n(c)\n(d)\n(e)\n(g)\n(f)\n(h)\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nFigure 23.4\nThe execution of Kruskal’s algorithm on the graph from Figure 23.1. Shaded edges\nbelong to the forest A being grown. The algorithm considers each edge in sorted order by weight.\nAn arrow points to the edge under consideration at each step of the algorithm. If the edge joins two\ndistinct trees in the forest, it is added to the forest, thereby merging the two trees.\nchecks, for each edge .u; \u0003/, whether the endpoints u and \u0003 belong to the same\ntree. If they do, then the edge .u; \u0003/ cannot be added to the forest without creating\na cycle, and the edge is discarded. Otherwise, the two vertices belong to different\ntrees. In this case, line 7 adds the edge .u; \u0003/ to A, and line 8 merges the vertices\nin the two trees.\n23.2\nThe algorithms of Kruskal and Prim\n633\n(i)\n(j)\n(k)\n(l)\n(n)\n(m)\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\n2\n2\nFigure 23.4, continued\nFurther steps in the execution of Kruskal’s algorithm.\nThe running time of Kruskal’s algorithm for a graph G D .V; E/ depends\non how we implement the disjoint-set data structure.",
    "parent_8fa389b5-f783-4955-a771-4ffd5ceca156": "a\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\n2\n2\nFigure 23.4, continued\nFurther steps in the execution of Kruskal’s algorithm.\nThe running time of Kruskal’s algorithm for a graph G D .V; E/ depends\non how we implement the disjoint-set data structure.\nWe assume that we use\nthe disjoint-set-forest implementation of Section 21.3 with the union-by-rank and\npath-compression heuristics, since it is the asymptotically fastest implementation\nknown. Initializing the set A in line 1 takes O.1/ time, and the time to sort the\nedges in line 4 is O.E lg E/. (We will account for the cost of the jV j MAKE-SET\noperations in the for loop of lines 2–3 in a moment.) The for loop of lines 5–8\nperforms O.E/ FIND-SET and UNION operations on the disjoint-set forest. Along\nwith the jV j MAKE-SET operations, these take a total of O..V C E/ ˛.V // time,\nwhere ˛ is the very slowly growing function deﬁned in Section 21.4. Because we\nassume that G is connected, we have jEj \u0006 jV j \u0005 1, and so the disjoint-set opera-\ntions take O.E˛.V // time. Moreover, since ˛.jV j/ D O.lg V / D O.lg E/, the to-\ntal running time of Kruskal’s algorithm is O.E lg E/. Observing that jEj < jV j2,\nwe have lg jEj D O.lg V /, and so we can restate the running time of Kruskal’s\nalgorithm as O.E lg V /.\n634\nChapter 23\nMinimum Spanning Trees\nPrim’s algorithm\nLike Kruskal’s algorithm, Prim’s algorithm is a special case of the generic min-\nimum-spanning-tree method from Section 23.1. Prim’s algorithm operates much\nlike Dijkstra’s algorithm for ﬁnding shortest paths in a graph, which we shall see in\nSection 24.3. Prim’s algorithm has the property that the edges in the set A always\nform a single tree. As Figure 23.5 shows, the tree starts from an arbitrary root\nvertex r and grows until the tree spans all the vertices in V . Each step adds to the\ntree A a light edge that connects A to an isolated vertex—one on which no edge",
    "parent_bd23541a-7709-4daa-aded-ec7945334b84": "form a single tree. As Figure 23.5 shows, the tree starts from an arbitrary root\nvertex r and grows until the tree spans all the vertices in V . Each step adds to the\ntree A a light edge that connects A to an isolated vertex—one on which no edge\nof A is incident. By Corollary 23.2, this rule adds only edges that are safe for A;\ntherefore, when the algorithm terminates, the edges in A form a minimum spanning\ntree. This strategy qualiﬁes as greedy since at each step it adds to the tree an edge\nthat contributes the minimum amount possible to the tree’s weight.\nIn order to implement Prim’s algorithm efﬁciently, we need a fast way to select\na new edge to add to the tree formed by the edges in A. In the pseudocode below,\nthe connected graph G and the root r of the minimum spanning tree to be grown\nare inputs to the algorithm. During execution of the algorithm, all vertices that\nare not in the tree reside in a min-priority queue Q based on a key attribute. For\neach vertex \u0003, the attribute \u0003:key is the minimum weight of any edge connecting \u0003\nto a vertex in the tree; by convention, \u0003:key D 1 if there is no such edge. The\nattribute \u0003:\u0006 names the parent of \u0003 in the tree. The algorithm implicitly maintains\nthe set A from GENERIC-MST as\nA D f.\u0003; \u0003:\u0006/ W \u0003 2 V \u0005 frg \u0005 Qg :\nWhen the algorithm terminates, the min-priority queue Q is empty; the minimum\nspanning tree A for G is thus\nA D f.\u0003; \u0003:\u0006/ W \u0003 2 V \u0005 frgg :\nMST-PRIM.G; w; r/\n1\nfor each u 2 G:V\n2\nu:key D 1\n3\nu:\u0006 D NIL\n4\nr:key D 0\n5\nQ D G:V\n6\nwhile Q ¤ ;\n7\nu D EXTRACT-MIN.Q/\n8\nfor each \u0003 2 G:AdjŒu\u0002\n9\nif \u0003 2 Q and w.u; \u0003/ < \u0003:key\n10\n\u0003:\u0006 D u\n11\n\u0003:key D w.u; \u0003/\n23.2\nThe algorithms of Kruskal and Prim\n635\n(a)\n(b)\n(c)\n(d)\n(e)\n(f)\n(g)\n(h)\n(i)\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na",
    "parent_9b058dc1-2533-4886-81cf-2eb9db018c43": "b\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n2\n7\n6\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nb\na\nh\nc\ng\ni\nd\nf\ne\n4\n8\n11\n8\n7\n9\n10\n14\n4\n2\n1\n7\n6\n2\nFigure 23.5\nThe execution of Prim’s algorithm on the graph from Figure 23.1. The root vertex\nis a. Shaded edges are in the tree being grown, and black vertices are in the tree. At each step of\nthe algorithm, the vertices in the tree determine a cut of the graph, and a light edge crossing the cut\nis added to the tree. In the second step, for example, the algorithm has a choice of adding either\nedge .b; c/ or edge .a; h/ to the tree since both are light edges crossing the cut.\n636\nChapter 23\nMinimum Spanning Trees\nFigure 23.5 shows how Prim’s algorithm works. Lines 1–5 set the key of each\nvertex to 1 (except for the root r, whose key is set to 0 so that it will be the\nﬁrst vertex processed), set the parent of each vertex to NIL, and initialize the min-\npriority queue Q to contain all the vertices. The algorithm maintains the following\nthree-part loop invariant:\nPrior to each iteration of the while loop of lines 6–11,\n1. A D f.\u0003; \u0003:\u0006/ W \u0003 2 V \u0005 frg \u0005 Qg.\n2. The vertices already placed into the minimum spanning tree are those in\nV \u0005 Q.\n3. For all vertices \u0003 2 Q, if \u0003:\u0006 ¤ NIL, then \u0003:key < 1 and \u0003:key is\nthe weight of a light edge .\u0003; \u0003:\u0006/ connecting \u0003 to some vertex already\nplaced into the minimum spanning tree.\nLine 7 identiﬁes a vertex u 2 Q incident on a light edge that crosses the cut\n.V \u0005 Q; Q/ (with the exception of the ﬁrst iteration, in which u D r due to line 4).\nRemoving u from the set Q adds it to the set V \u0005 Q of vertices in the tree, thus\nadding .u; u:\u0006/ to A. The for loop of lines 8–11 updates the key and \u0006 attributes",
    "parent_b7f95b7b-1f9c-4ddf-a5ab-18fd3fe351da": ".V \u0005 Q; Q/ (with the exception of the ﬁrst iteration, in which u D r due to line 4).\nRemoving u from the set Q adds it to the set V \u0005 Q of vertices in the tree, thus\nadding .u; u:\u0006/ to A. The for loop of lines 8–11 updates the key and \u0006 attributes\nof every vertex \u0003 adjacent to u but not in the tree, thereby maintaining the third\npart of the loop invariant.\nThe running time of Prim’s algorithm depends on how we implement the min-\npriority queue Q. If we implement Q as a binary min-heap (see Chapter 6), we\ncan use the BUILD-MIN-HEAP procedure to perform lines 1–5 in O.V / time. The\nbody of the while loop executes jV j times, and since each EXTRACT-MIN opera-\ntion takes O.lg V / time, the total time for all calls to EXTRACT-MIN is O.V lg V /.\nThe for loop in lines 8–11 executes O.E/ times altogether, since the sum of the\nlengths of all adjacency lists is 2 jEj. Within the for loop, we can implement the\ntest for membership in Q in line 9 in constant time by keeping a bit for each vertex\nthat tells whether or not it is in Q, and updating the bit when the vertex is removed\nfrom Q. The assignment in line 11 involves an implicit DECREASE-KEY opera-\ntion on the min-heap, which a binary min-heap supports in O.lg V / time. Thus,\nthe total time for Prim’s algorithm is O.V lg V C E lg V / D O.E lg V /, which is\nasymptotically the same as for our implementation of Kruskal’s algorithm.\nWe can improve the asymptotic running time of Prim’s algorithm by using Fi-\nbonacci heaps. Chapter 19 shows that if a Fibonacci heap holds jV j elements, an\nEXTRACT-MIN operation takes O.lg V / amortized time and a DECREASE-KEY\noperation (to implement line 11) takes O.1/ amortized time. Therefore, if we use a\nFibonacci heap to implement the min-priority queue Q, the running time of Prim’s\nalgorithm improves to O.E C V lg V /.\n23.2\nThe algorithms of Kruskal and Prim\n637\nExercises\n23.2-1\nKruskal’s algorithm can return different spanning trees for the same input graph G,",
    "parent_a2d1830e-9d7d-48ec-a364-81a3383edf43": "Fibonacci heap to implement the min-priority queue Q, the running time of Prim’s\nalgorithm improves to O.E C V lg V /.\n23.2\nThe algorithms of Kruskal and Prim\n637\nExercises\n23.2-1\nKruskal’s algorithm can return different spanning trees for the same input graph G,\ndepending on how it breaks ties when the edges are sorted into order. Show that\nfor each minimum spanning tree T of G, there is a way to sort the edges of G in\nKruskal’s algorithm so that the algorithm returns T .\n23.2-2\nSuppose that we represent the graph G D .V; E/ as an adjacency matrix. Give a\nsimple implementation of Prim’s algorithm for this case that runs in O.V 2/ time.\n23.2-3\nFor a sparse graph G D .V; E/, where jEj D ‚.V /, is the implementation of\nPrim’s algorithm with a Fibonacci heap asymptotically faster than the binary-heap\nimplementation?\nWhat about for a dense graph, where jEj D ‚.V 2/? How\nmust the sizes jEj and jV j be related for the Fibonacci-heap implementation to\nbe asymptotically faster than the binary-heap implementation?\n23.2-4\nSuppose that all edge weights in a graph are integers in the range from 1 to jV j.\nHow fast can you make Kruskal’s algorithm run? What if the edge weights are\nintegers in the range from 1 to W for some constant W ?\n23.2-5\nSuppose that all edge weights in a graph are integers in the range from 1 to jV j.\nHow fast can you make Prim’s algorithm run? What if the edge weights are integers\nin the range from 1 to W for some constant W ?\n23.2-6\n?\nSuppose that the edge weights in a graph are uniformly distributed over the half-\nopen interval Œ0; 1/. Which algorithm, Kruskal’s or Prim’s, can you make run\nfaster?\n23.2-7\n?\nSuppose that a graph G has a minimum spanning tree already computed. How\nquickly can we update the minimum spanning tree if we add a new vertex and\nincident edges to G?\n23.2-8\nProfessor Borden proposes a new divide-and-conquer algorithm for computing\nminimum spanning trees, which goes as follows. Given a graph G D .V; E/,",
    "parent_fed302d1-c626-4628-9076-6bacd7e83e61": "quickly can we update the minimum spanning tree if we add a new vertex and\nincident edges to G?\n23.2-8\nProfessor Borden proposes a new divide-and-conquer algorithm for computing\nminimum spanning trees, which goes as follows. Given a graph G D .V; E/,\npartition the set V of vertices into two sets V1 and V2 such that jV1j and jV2j differ\n638\nChapter 23\nMinimum Spanning Trees\nby at most 1. Let E1 be the set of edges that are incident only on vertices in V1, and\nlet E2 be the set of edges that are incident only on vertices in V2. Recursively solve\na minimum-spanning-tree problem on each of the two subgraphs G1 D .V1; E1/\nand G2 D .V2; E2/. Finally, select the minimum-weight edge in E that crosses the\ncut .V1; V2/, and use this edge to unite the resulting two minimum spanning trees\ninto a single spanning tree.\nEither argue that the algorithm correctly computes a minimum spanning tree\nof G, or provide an example for which the algorithm fails.\nProblems\n23-1\nSecond-best minimum spanning tree\nLet G D .V; E/ be an undirected, connected graph whose weight function is\nw W E ! R, and suppose that jEj \u0006 jV j and all edge weights are distinct.\nWe deﬁne a second-best minimum spanning tree as follows. Let T be the set\nof all spanning trees of G, and let T 0 be a minimum spanning tree of G. Then\na second-best minimum spanning tree is a spanning tree T such that w.T / D\nminT 002T \u0003fT 0g fw.T 00/g.\na. Show that the minimum spanning tree is unique, but that the second-best mini-\nmum spanning tree need not be unique.\nb. Let T be the minimum spanning tree of G.\nProve that G contains edges\n.u; \u0003/ 2 T and .x; y/ 62 T such that T \u0005 f.u; \u0003/g [ f.x; y/g is a second-best\nminimum spanning tree of G.\nc. Let T be a spanning tree of G and, for any two vertices u; \u0003 2 V , let maxŒu; \u0003\u0002\ndenote an edge of maximum weight on the unique simple path between u and \u0003\nin T . Describe an O.V 2/-time algorithm that, given T , computes maxŒu; \u0003\u0002 for\nall u; \u0003 2 V .",
    "parent_90e03ac9-f310-42b4-ab94-d4c973e2a1f6": "minimum spanning tree of G.\nc. Let T be a spanning tree of G and, for any two vertices u; \u0003 2 V , let maxŒu; \u0003\u0002\ndenote an edge of maximum weight on the unique simple path between u and \u0003\nin T . Describe an O.V 2/-time algorithm that, given T , computes maxŒu; \u0003\u0002 for\nall u; \u0003 2 V .\nd. Give an efﬁcient algorithm to compute the second-best minimum spanning tree\nof G.\n23-2\nMinimum spanning tree in sparse graphs\nFor a very sparse connected graph G D .V; E/, we can further improve upon the\nO.E C V lg V / running time of Prim’s algorithm with Fibonacci heaps by prepro-\ncessing G to decrease the number of vertices before running Prim’s algorithm. In\nparticular, we choose, for each vertex u, the minimum-weight edge .u; \u0003/ incident\non u, and we put .u; \u0003/ into the minimum spanning tree under construction. We\nProblems for Chapter 23\n639\nthen contract all chosen edges (see Section B.4). Rather than contracting these\nedges one at a time, we ﬁrst identify sets of vertices that are united into the same\nnew vertex. Then we create the graph that would have resulted from contracting\nthese edges one at a time, but we do so by “renaming” edges according to the sets\ninto which their endpoints were placed. Several edges from the original graph may\nbe renamed the same as each other. In such a case, only one edge results, and its\nweight is the minimum of the weights of the corresponding original edges.\nInitially, we set the minimum spanning tree T being constructed to be empty,\nand for each edge .u; \u0003/ 2 E, we initialize the attributes .u; \u0003/:orig D .u; \u0003/\nand .u; \u0003/:c D w.u; \u0003/. We use the orig attribute to reference the edge from the\ninitial graph that is associated with an edge in the contracted graph. The c attribute\nholds the weight of an edge, and as edges are contracted, we update it according to\nthe above scheme for choosing edge weights. The procedure MST-REDUCE takes\ninputs G and T , and it returns a contracted graph G0 with updated attributes orig0",
    "parent_9157990b-d626-455a-9ec3-4281b698f77a": "holds the weight of an edge, and as edges are contracted, we update it according to\nthe above scheme for choosing edge weights. The procedure MST-REDUCE takes\ninputs G and T , and it returns a contracted graph G0 with updated attributes orig0\nand c0. The procedure also accumulates edges of G into the minimum spanning\ntree T .\nMST-REDUCE.G; T /\n1\nfor each \u0003 2 G:V\n2\n\u0003:mark D FALSE\n3\nMAKE-SET.\u0003/\n4\nfor each u 2 G:V\n5\nif u:mark == FALSE\n6\nchoose \u0003 2 G:AdjŒu\u0002 such that .u; \u0003/:c is minimized\n7\nUNION.u; \u0003/\n8\nT D T [ f.u; \u0003/:origg\n9\nu:mark D \u0003:mark D TRUE\n10\nG0:V D fFIND-SET.\u0003/ W \u0003 2 G:Vg\n11\nG0:E D ;\n12\nfor each .x; y/ 2 G:E\n13\nu D FIND-SET.x/\n14\n\u0003 D FIND-SET.y/\n15\nif .u; \u0003/ 62 G0:E\n16\nG0:E D G0:E [ f.u; \u0003/g\n17\n.u; \u0003/:orig0 D .x; y/:orig\n18\n.u; \u0003/:c0 D .x; y/:c\n19\nelse if .x; y/:c < .u; \u0003/:c0\n20\n.u; \u0003/:orig0 D .x; y/:orig\n21\n.u; \u0003/:c0 D .x; y/:c\n22\nconstruct adjacency lists G0:Adj for G0\n23\nreturn G0 and T\n640\nChapter 23\nMinimum Spanning Trees\na. Let T be the set of edges returned by MST-REDUCE, and let A be the minimum\nspanning tree of the graph G0 formed by the call MST-PRIM.G0; c0; r/, where c0\nis the weight attribute on the edges of G0:E and r is any vertex in G0:V. Prove\nthat T [ f.x; y/:orig0 W .x; y/ 2 Ag is a minimum spanning tree of G.\nb. Argue that jG0:Vj \u0002 jV j =2.\nc. Show how to implement MST-REDUCE so that it runs in O.E/ time. (Hint:\nUse simple data structures.)\nd. Suppose that we run k phases of MST-REDUCE, using the output G0 produced\nby one phase as the input G to the next phase and accumulating edges in T .\nArgue that the overall running time of the k phases is O.kE/.\ne. Suppose that after running k phases of MST-REDUCE, as in part (d), we run\nPrim’s algorithm by calling MST-PRIM.G0; c0; r/, where G0, with weight at-\ntribute c0, is returned by the last phase and r is any vertex in G0:V. Show how\nto pick k so that the overall running time is O.E lg lg V /. Argue that your\nchoice of k minimizes the overall asymptotic running time.\nf.",
    "parent_f2a7e8af-4713-48e8-8f7d-3cd539c01118": "Prim’s algorithm by calling MST-PRIM.G0; c0; r/, where G0, with weight at-\ntribute c0, is returned by the last phase and r is any vertex in G0:V. Show how\nto pick k so that the overall running time is O.E lg lg V /. Argue that your\nchoice of k minimizes the overall asymptotic running time.\nf.\nFor what values of jEj (in terms of jV j) does Prim’s algorithm with preprocess-\ning asymptotically beat Prim’s algorithm without preprocessing?\n23-3\nBottleneck spanning tree\nA bottleneck spanning tree T of an undirected graph G is a spanning tree of G\nwhose largest edge weight is minimum over all spanning trees of G. We say that\nthe value of the bottleneck spanning tree is the weight of the maximum-weight\nedge in T .\na. Argue that a minimum spanning tree is a bottleneck spanning tree.\nPart (a) shows that ﬁnding a bottleneck spanning tree is no harder than ﬁnding\na minimum spanning tree. In the remaining parts, we will show how to ﬁnd a\nbottleneck spanning tree in linear time.\nb. Give a linear-time algorithm that given a graph G and an integer b, determines\nwhether the value of the bottleneck spanning tree is at most b.\nc. Use your algorithm for part (b) as a subroutine in a linear-time algorithm for\nthe bottleneck-spanning-tree problem. (Hint: You may want to use a subroutine\nthat contracts sets of edges, as in the MST-REDUCE procedure described in\nProblem 23-2.)\nNotes for Chapter 23\n641\n23-4\nAlternative minimum-spanning-tree algorithms\nIn this problem, we give pseudocode for three different algorithms. Each one takes\na connected graph and a weight function as input and returns a set of edges T . For\neach algorithm, either prove that T is a minimum spanning tree or prove that T is\nnot a minimum spanning tree. Also describe the most efﬁcient implementation of\neach algorithm, whether or not it computes a minimum spanning tree.\na. MAYBE-MST-A.G; w/\n1\nsort the edges into nonincreasing order of edge weights w\n2\nT D E\n3\nfor each edge e, taken in nonincreasing order by weight\n4",
    "parent_725febc7-81ea-421b-acb1-923b59ef9a05": "not a minimum spanning tree. Also describe the most efﬁcient implementation of\neach algorithm, whether or not it computes a minimum spanning tree.\na. MAYBE-MST-A.G; w/\n1\nsort the edges into nonincreasing order of edge weights w\n2\nT D E\n3\nfor each edge e, taken in nonincreasing order by weight\n4\nif T \u0005 feg is a connected graph\n5\nT D T \u0005 feg\n6\nreturn T\nb. MAYBE-MST-B.G; w/\n1\nT D ;\n2\nfor each edge e, taken in arbitrary order\n3\nif T [ feg has no cycles\n4\nT D T [ feg\n5\nreturn T\nc. MAYBE-MST-C.G; w/\n1\nT D ;\n2\nfor each edge e, taken in arbitrary order\n3\nT D T [ feg\n4\nif T has a cycle c\n5\nlet e0 be a maximum-weight edge on c\n6\nT D T \u0005 fe0g\n7\nreturn T\nChapter notes\nTarjan [330] surveys the minimum-spanning-tree problem and provides excellent\nadvanced material. Graham and Hell [151] compiled a history of the minimum-\nspanning-tree problem.\nTarjan attributes the ﬁrst minimum-spanning-tree algorithm to a 1926 paper by\nO. Bor˙uvka. Bor˙uvka’s algorithm consists of running O.lg V / iterations of the\n642\nChapter 23\nMinimum Spanning Trees\nprocedure MST-REDUCE described in Problem 23-2. Kruskal’s algorithm was\nreported by Kruskal [222] in 1956. The algorithm commonly known as Prim’s\nalgorithm was indeed invented by Prim [285], but it was also invented earlier by\nV. Jarn´ık in 1930.\nThe reason underlying why greedy algorithms are effective at ﬁnding minimum\nspanning trees is that the set of forests of a graph forms a graphic matroid. (See\nSection 16.4.)\nWhen jEj D \u0004.V lg V /, Prim’s algorithm, implemented with Fibonacci heaps,\nruns in O.E/ time. For sparser graphs, using a combination of the ideas from\nPrim’s algorithm, Kruskal’s algorithm, and Bor˙uvka’s algorithm, together with ad-\nvanced data structures, Fredman and Tarjan [114] give an algorithm that runs in\nO.E lg\u0004 V / time. Gabow, Galil, Spencer, and Tarjan [120] improved this algo-\nrithm to run in O.E lg lg\u0004 V / time. Chazelle [60] gives an algorithm that runs",
    "parent_fe441c9f-e24d-4dec-b45b-f161de17a99f": "vanced data structures, Fredman and Tarjan [114] give an algorithm that runs in\nO.E lg\u0004 V / time. Gabow, Galil, Spencer, and Tarjan [120] improved this algo-\nrithm to run in O.E lg lg\u0004 V / time. Chazelle [60] gives an algorithm that runs\nin O.E y˛.E; V // time, where y˛.E; V / is the functional inverse of Ackermann’s\nfunction. (See the chapter notes for Chapter 21 for a brief discussion of Acker-\nmann’s function and its inverse.) Unlike previous minimum-spanning-tree algo-\nrithms, Chazelle’s algorithm does not follow the greedy method.\nA related problem is spanning-tree veriﬁcation, in which we are given a graph\nG D .V; E/ and a tree T \u0007 E, and we wish to determine whether T is a minimum\nspanning tree of G. King [203] gives a linear-time algorithm to verify a spanning\ntree, building on earlier work of Koml´os [215] and Dixon, Rauch, and Tarjan [90].\nThe above algorithms are all deterministic and fall into the comparison-based\nmodel described in Chapter 8. Karger, Klein, and Tarjan [195] give a randomized\nminimum-spanning-tree algorithm that runs in O.V C E/ expected time. This\nalgorithm uses recursion in a manner similar to the linear-time selection algorithm\nin Section 9.3: a recursive call on an auxiliary problem identiﬁes a subset of the\nedges E0 that cannot be in any minimum spanning tree. Another recursive call\non E \u0005 E0 then ﬁnds the minimum spanning tree. The algorithm also uses ideas\nfrom Bor˙uvka’s algorithm and King’s algorithm for spanning-tree veriﬁcation.\nFredman and Willard [116] showed how to ﬁnd a minimum spanning tree in\nO.V CE/ time using a deterministic algorithm that is not comparison based. Their\nalgorithm assumes that the data are b-bit integers and that the computer memory\nconsists of addressable b-bit words.\n24\nSingle-Source Shortest Paths\nProfessor Patrick wishes to ﬁnd the shortest possible route from Phoenix to Indi-\nanapolis. Given a road map of the United States on which the distance between",
    "parent_e8946b14-d3f9-4399-8fac-109226593140": "consists of addressable b-bit words.\n24\nSingle-Source Shortest Paths\nProfessor Patrick wishes to ﬁnd the shortest possible route from Phoenix to Indi-\nanapolis. Given a road map of the United States on which the distance between\neach pair of adjacent intersections is marked, how can she determine this shortest\nroute?\nOne possible way would be to enumerate all the routes from Phoenix to Indi-\nanapolis, add up the distances on each route, and select the shortest. It is easy to\nsee, however, that even disallowing routes that contain cycles, Professor Patrick\nwould have to examine an enormous number of possibilities, most of which are\nsimply not worth considering. For example, a route from Phoenix to Indianapolis\nthat passes through Seattle is obviously a poor choice, because Seattle is several\nhundred miles out of the way.\nIn this chapter and in Chapter 25, we show how to solve such problems ef-\nﬁciently. In a shortest-paths problem, we are given a weighted, directed graph\nG D .V; E/, with weight function w W E ! R mapping edges to real-valued\nweights. The weight w.p/ of path p D h\u00030; \u00031; : : : ; \u0003ki is the sum of the weights\nof its constituent edges:\nw.p/ D\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ :\nWe deﬁne the shortest-path weight ı.u; \u0003/ from u to \u0003 by\nı.u; \u0003/ D\n(\nminfw.p/ W u\np; \u0003g\nif there is a path from u to \u0003 ;\n1\notherwise :\nA shortest path from vertex u to vertex \u0003 is then deﬁned as any path p with weight\nw.p/ D ı.u; \u0003/.\nIn the Phoenix-to-Indianapolis example, we can model the road map as a graph:\nvertices represent intersections, edges represent road segments between intersec-\ntions, and edge weights represent road distances. Our goal is to ﬁnd a shortest path\nfrom a given intersection in Phoenix to a given intersection in Indianapolis.\n644\nChapter 24\nSingle-Source Shortest Paths\nEdge weights can represent metrics other than distances, such as time, cost,\npenalties, loss, or any other quantity that accumulates linearly along a path and\nthat we would want to minimize.",
    "parent_de5fd44f-cced-4cbe-9a77-20ddadd102cb": "644\nChapter 24\nSingle-Source Shortest Paths\nEdge weights can represent metrics other than distances, such as time, cost,\npenalties, loss, or any other quantity that accumulates linearly along a path and\nthat we would want to minimize.\nThe breadth-ﬁrst-search algorithm from Section 22.2 is a shortest-paths algo-\nrithm that works on unweighted graphs, that is, graphs in which each edge has unit\nweight. Because many of the concepts from breadth-ﬁrst search arise in the study\nof shortest paths in weighted graphs, you might want to review Section 22.2 before\nproceeding.\nVariants\nIn this chapter, we shall focus on the single-source shortest-paths problem: given\na graph G D .V; E/, we want to ﬁnd a shortest path from a given source vertex\ns 2 V to each vertex \u0003 2 V . The algorithm for the single-source problem can\nsolve many other problems, including the following variants.\nSingle-destination shortest-paths problem: Find a shortest path to a given des-\ntination vertex t from each vertex \u0003. By reversing the direction of each edge in\nthe graph, we can reduce this problem to a single-source problem.\nSingle-pair shortest-path problem: Find a shortest path from u to \u0003 for given\nvertices u and \u0003. If we solve the single-source problem with source vertex u,\nwe solve this problem also. Moreover, all known algorithms for this problem\nhave the same worst-case asymptotic running time as the best single-source\nalgorithms.\nAll-pairs shortest-paths problem: Find a shortest path from u to \u0003 for every pair\nof vertices u and \u0003. Although we can solve this problem by running a single-\nsource algorithm once from each vertex, we usually can solve it faster. Addi-\ntionally, its structure is interesting in its own right. Chapter 25 addresses the\nall-pairs problem in detail.\nOptimal substructure of a shortest path\nShortest-paths algorithms typically rely on the property that a shortest path be-\ntween two vertices contains other shortest paths within it. (The Edmonds-Karp",
    "parent_879797b3-e995-4f2c-a982-5ce5502b47ee": "all-pairs problem in detail.\nOptimal substructure of a shortest path\nShortest-paths algorithms typically rely on the property that a shortest path be-\ntween two vertices contains other shortest paths within it. (The Edmonds-Karp\nmaximum-ﬂow algorithm in Chapter 26 also relies on this property.)\nRecall\nthat optimal substructure is one of the key indicators that dynamic programming\n(Chapter 15) and the greedy method (Chapter 16) might apply. Dijkstra’s algo-\nrithm, which we shall see in Section 24.3, is a greedy algorithm, and the Floyd-\nWarshall algorithm, which ﬁnds shortest paths between all pairs of vertices (see\nSection 25.2), is a dynamic-programming algorithm. The following lemma states\nthe optimal-substructure property of shortest paths more precisely.\nChapter 24\nSingle-Source Shortest Paths\n645\nLemma 24.1 (Subpaths of shortest paths are shortest paths)\nGiven a weighted, directed graph G D .V; E/ with weight function w W E ! R,\nlet p D h\u00030; \u00031; : : : ; \u0003ki be a shortest path from vertex \u00030 to vertex \u0003k and, for any\ni and j such that 0 \u0002 i \u0002 j \u0002 k, let pij D h\u0003i; \u0003iC1; : : : ; \u0003ji be the subpath of p\nfrom vertex \u0003i to vertex \u0003j. Then, pij is a shortest path from \u0003i to \u0003j.\nProof\nIf we decompose path p into \u00030\np0i\n; \u0003i\npij\n; \u0003j\npjk\n; \u0003k, then we have that\nw.p/ D w.p0i/ C w.pij/ C w.pjk/. Now, assume that there is a path p0\nij from \u0003i\nto \u0003j with weight w.p0\nij/ < w.pij/. Then, \u00030\np0i\n; \u0003i\np0\nij\n; \u0003j\npjk\n; \u0003k is a path from \u00030\nto \u0003k whose weight w.p0i/Cw.p0\nij /Cw.pjk/ is less than w.p/, which contradicts\nthe assumption that p is a shortest path from \u00030 to \u0003k.\nNegative-weight edges\nSome instances of the single-source shortest-paths problem may include edges\nwhose weights are negative.\nIf the graph G D .V; E/ contains no negative-\nweight cycles reachable from the source s, then for all \u0003 2 V , the shortest-path\nweight ı.s; \u0003/ remains well deﬁned, even if it has a negative value. If the graph",
    "parent_155e1f30-c1ce-4a41-876b-d3703695ee4a": "whose weights are negative.\nIf the graph G D .V; E/ contains no negative-\nweight cycles reachable from the source s, then for all \u0003 2 V , the shortest-path\nweight ı.s; \u0003/ remains well deﬁned, even if it has a negative value. If the graph\ncontains a negative-weight cycle reachable from s, however, shortest-path weights\nare not well deﬁned. No path from s to a vertex on the cycle can be a short-\nest path—we can always ﬁnd a path with lower weight by following the proposed\n“shortest” path and then traversing the negative-weight cycle. If there is a negative-\nweight cycle on some path from s to \u0003, we deﬁne ı.s; \u0003/ D \u00051.\nFigure 24.1 illustrates the effect of negative weights and negative-weight cy-\ncles on shortest-path weights. Because there is only one path from s to a (the\npath hs; ai), we have ı.s; a/ D w.s; a/ D 3. Similarly, there is only one path\nfrom s to b, and so ı.s; b/ D w.s; a/ C w.a; b/ D 3 C .\u00054/ D \u00051. There are\ninﬁnitely many paths from s to c: hs; ci, hs; c; d; ci, hs; c; d; c; d; ci, and so on.\nBecause the cycle hc; d; ci has weight 6 C .\u00053/ D 3 > 0, the shortest path from s\nto c is hs;ci, with weight ı.s; c/ D w.s; c/ D 5. Similarly, the shortest path from s\nto d is hs;c;di, with weight ı.s; d/ D w.s; c/Cw.c; d/ D 11. Analogously, there\nare inﬁnitely many paths from s to e: hs; ei, hs; e; f; ei, hs; e; f; e; f; ei, and so\non. Because the cycle he; f; ei has weight 3 C .\u00056/ D \u00053 < 0, however, there\nis no shortest path from s to e. By traversing the negative-weight cycle he; f; ei\narbitrarily many times, we can ﬁnd paths from s to e with arbitrarily large negative\nweights, and so ı.s; e/ D \u00051. Similarly, ı.s; f / D \u00051. Because g is reachable\nfrom f , we can also ﬁnd paths with arbitrarily large negative weights from s to g,\nand so ı.s; g/ D \u00051. Vertices h, i, and j also form a negative-weight cycle. They\nare not reachable from s, however, and so ı.s; h/ D ı.s; i/ D ı.s; j / D 1.\n646\nChapter 24\nSingle-Source Shortest Paths\n5\nc\n11\nd\n6\n–3\n–∞\ne\n–∞\nf\n3\n–6\n3",
    "parent_0acc76f6-1ddb-4432-aa00-8e4d789a7999": "and so ı.s; g/ D \u00051. Vertices h, i, and j also form a negative-weight cycle. They\nare not reachable from s, however, and so ı.s; h/ D ı.s; i/ D ı.s; j / D 1.\n646\nChapter 24\nSingle-Source Shortest Paths\n5\nc\n11\nd\n6\n–3\n–∞\ne\n–∞\nf\n3\n–6\n3\na\n–1\nb\n0\ns\n–∞\ng\n–4\n5\n3\n2\n8\n4\n7\n∞\nh\n∞\ni\n2\n∞\nj\n–8\n3\nFigure 24.1\nNegative edge weights in a directed graph. The shortest-path weight from source s\nappears within each vertex. Because vertices e and f form a negative-weight cycle reachable from s,\nthey have shortest-path weights of \u00051. Because vertex g is reachable from a vertex whose shortest-\npath weight is \u00051, it, too, has a shortest-path weight of \u00051. Vertices such as h, i, and j are not\nreachable from s, and so their shortest-path weights are 1, even though they lie on a negative-weight\ncycle.\nSome shortest-paths algorithms, such as Dijkstra’s algorithm, assume that all\nedge weights in the input graph are nonnegative, as in the road-map example. Oth-\ners, such as the Bellman-Ford algorithm, allow negative-weight edges in the in-\nput graph and produce a correct answer as long as no negative-weight cycles are\nreachable from the source. Typically, if there is such a negative-weight cycle, the\nalgorithm can detect and report its existence.\nCycles\nCan a shortest path contain a cycle? As we have just seen, it cannot contain a\nnegative-weight cycle. Nor can it contain a positive-weight cycle, since remov-\ning the cycle from the path produces a path with the same source and destination\nvertices and a lower path weight. That is, if p D h\u00030; \u00031; : : : ; \u0003ki is a path and\nc D h\u0003i; \u0003iC1; : : : ; \u0003ji is a positive-weight cycle on this path (so that \u0003i D \u0003j and\nw.c/ > 0), then the path p0 D h\u00030; \u00031; : : : ; \u0003i; \u0003jC1; \u0003jC2; : : : ; \u0003ki has weight\nw.p0/ D w.p/ \u0005 w.c/ < w.p/, and so p cannot be a shortest path from \u00030 to \u0003k.\nThat leaves only 0-weight cycles. We can remove a 0-weight cycle from any\npath to produce another path whose weight is the same. Thus, if there is a shortest",
    "parent_4edb4433-b024-4b06-bd06-974d1e81a4f3": "w.p0/ D w.p/ \u0005 w.c/ < w.p/, and so p cannot be a shortest path from \u00030 to \u0003k.\nThat leaves only 0-weight cycles. We can remove a 0-weight cycle from any\npath to produce another path whose weight is the same. Thus, if there is a shortest\npath from a source vertex s to a destination vertex \u0003 that contains a 0-weight cycle,\nthen there is another shortest path from s to \u0003 without this cycle. As long as a\nshortest path has 0-weight cycles, we can repeatedly remove these cycles from the\npath until we have a shortest path that is cycle-free. Therefore, without loss of\ngenerality we can assume that when we are ﬁnding shortest paths, they have no\ncycles, i.e., they are simple paths. Since any acyclic path in a graph G D .V; E/\nChapter 24\nSingle-Source Shortest Paths\n647\ncontains at most jV j distinct vertices, it also contains at most jV j \u0005 1 edges. Thus,\nwe can restrict our attention to shortest paths of at most jV j \u0005 1 edges.\nRepresenting shortest paths\nWe often wish to compute not only shortest-path weights, but the vertices on short-\nest paths as well. We represent shortest paths similarly to how we represented\nbreadth-ﬁrst trees in Section 22.2. Given a graph G D .V; E/, we maintain for\neach vertex \u0003 2 V a predecessor \u0003:\u0006 that is either another vertex or NIL. The\nshortest-paths algorithms in this chapter set the \u0006 attributes so that the chain of pre-\ndecessors originating at a vertex \u0003 runs backwards along a shortest path from s to \u0003.\nThus, given a vertex \u0003 for which \u0003:\u0006 ¤ NIL, the procedure PRINT-PATH.G; s; \u0003/\nfrom Section 22.2 will print a shortest path from s to \u0003.\nIn the midst of executing a shortest-paths algorithm, however, the \u0006 values might\nnot indicate shortest paths. As in breadth-ﬁrst search, we shall be interested in the\npredecessor subgraph G\u0003 D .V\u0003; E\u0003/ induced by the \u0006 values. Here again, we\ndeﬁne the vertex set V\u0003 to be the set of vertices of G with non-NIL predecessors,\nplus the source s:\nV\u0003 D f\u0003 2 V W \u0003:\u0006 ¤ NILg [ fsg :",
    "parent_d8f4dcbb-09cf-44be-9ccc-2d1eddb3a601": "not indicate shortest paths. As in breadth-ﬁrst search, we shall be interested in the\npredecessor subgraph G\u0003 D .V\u0003; E\u0003/ induced by the \u0006 values. Here again, we\ndeﬁne the vertex set V\u0003 to be the set of vertices of G with non-NIL predecessors,\nplus the source s:\nV\u0003 D f\u0003 2 V W \u0003:\u0006 ¤ NILg [ fsg :\nThe directed edge set E\u0003 is the set of edges induced by the \u0006 values for vertices\nin V\u0003:\nE\u0003 D f.\u0003:\u0006; \u0003/ 2 E W \u0003 2 V\u0003 \u0005 fsgg :\nWe shall prove that the \u0006 values produced by the algorithms in this chapter have\nthe property that at termination G\u0003 is a “shortest-paths tree”—informally, a rooted\ntree containing a shortest path from the source s to every vertex that is reachable\nfrom s. A shortest-paths tree is like the breadth-ﬁrst tree from Section 22.2, but it\ncontains shortest paths from the source deﬁned in terms of edge weights instead of\nnumbers of edges. To be precise, let G D .V; E/ be a weighted, directed graph\nwith weight function w W E ! R, and assume that G contains no negative-weight\ncycles reachable from the source vertex s 2 V , so that shortest paths are well\ndeﬁned. A shortest-paths tree rooted at s is a directed subgraph G0 D .V 0; E0/,\nwhere V 0 \u0007 V and E0 \u0007 E, such that\n1. V 0 is the set of vertices reachable from s in G,\n2. G0 forms a rooted tree with root s, and\n3. for all \u0003 2 V 0, the unique simple path from s to \u0003 in G0 is a shortest path from s\nto \u0003 in G.\n648\nChapter 24\nSingle-Source Shortest Paths\n(a)\n(b)\n(c)\n0\n6\n6\n7\n2\n1\n2\n4\n3\n5\n3\ns\nt\nx\ny\nz\n3\n9\n5\n11\n0\n6\n6\n7\n2\n1\n2\n4\n3\n5\n3\ns\nt\nx\ny\nz\n3\n9\n5\n11\n0\n6\n6\n7\n2\n1\n2\n4\n3\n5\n3\ns\nt\nx\ny\nz\n3\n9\n5\n11\nFigure 24.2\n(a) A weighted, directed graph with shortest-path weights from source s. (b) The\nshaded edges form a shortest-paths tree rooted at the source s. (c) Another shortest-paths tree with\nthe same root.\nShortest paths are not necessarily unique, and neither are shortest-paths trees. For\nexample, Figure 24.2 shows a weighted, directed graph and two shortest-paths trees\nwith the same root.\nRelaxation",
    "parent_a75af022-c649-44ef-8ae2-a4935f63d916": "the same root.\nShortest paths are not necessarily unique, and neither are shortest-paths trees. For\nexample, Figure 24.2 shows a weighted, directed graph and two shortest-paths trees\nwith the same root.\nRelaxation\nThe algorithms in this chapter use the technique of relaxation. For each vertex\n\u0003 2 V , we maintain an attribute \u0003:d, which is an upper bound on the weight of\na shortest path from source s to \u0003. We call \u0003:d a shortest-path estimate. We\ninitialize the shortest-path estimates and predecessors by the following ‚.V /-time\nprocedure:\nINITIALIZE-SINGLE-SOURCE.G; s/\n1\nfor each vertex \u0003 2 G:V\n2\n\u0003:d D 1\n3\n\u0003:\u0006 D NIL\n4\ns:d D 0\nAfter initialization, we have \u0003:\u0006 D NIL for all \u0003 2 V , s:d D 0, and \u0003:d D 1 for\n\u0003 2 V \u0005 fsg.\nThe process of relaxing an edge .u; \u0003/ consists of testing whether we can im-\nprove the shortest path to \u0003 found so far by going through u and, if so, updat-\ning \u0003:d and \u0003:\u0006. A relaxation step1 may decrease the value of the shortest-path\n1\nThe use of the term is historical. The outcome of a relaxation step can be viewed as a relaxation\nof the constraint \u0003:d \u0002 u:d C w.u;\u0003/, which, by the triangle inequality (Lemma 24.10), must be\nsatisﬁed if u:d D ı.s; u/ and \u0003:d D ı.s; \u0003/. That is, if \u0003:d \u0002 u:d C w.u; \u0003/, there is no “pressure”\nIt may seem strange that the term “relaxation” is used for an operation that tightens an upper bound.\nso the constraint is “relaxed.”\nto satisfy this constraint,\nChapter 24\nSingle-Source Shortest Paths\n649\nu\nv\n5\n9\n2\nu\nv\n5\n7\n2\nRELAX(u,v,w)\n(a)\n(b)\nu\nv\n5\n6\n2\nu\nv\n5\n6\n2\nRELAX(u,v,w)\nFigure 24.3\nRelaxing an edge .u; \u0003/ with weight w.u; \u0003/ D 2. The shortest-path estimate of each\nvertex appears within the vertex. (a) Because \u0003:d > u:d C w.u;\u0003/ prior to relaxation, the value\nof \u0003:d decreases. (b) Here, \u0003:d \u0002 u:d C w.u;\u0003/ before relaxing the edge, and so the relaxation step\nleaves \u0003:d unchanged.\nestimate \u0003:d and update \u0003’s predecessor attribute \u0003:\u0006. The following code per-\nforms a relaxation step on edge .u; \u0003/ in O.1/ time:",
    "parent_ae44b4ff-f8be-4e4f-837e-535e7e012d33": "of \u0003:d decreases. (b) Here, \u0003:d \u0002 u:d C w.u;\u0003/ before relaxing the edge, and so the relaxation step\nleaves \u0003:d unchanged.\nestimate \u0003:d and update \u0003’s predecessor attribute \u0003:\u0006. The following code per-\nforms a relaxation step on edge .u; \u0003/ in O.1/ time:\nRELAX.u; \u0003; w/\n1\nif \u0003:d > u:d C w.u; \u0003/\n2\n\u0003:d D u:d C w.u; \u0003/\n3\n\u0003:\u0006 D u\nFigure 24.3 shows two examples of relaxing an edge, one in which a shortest-path\nestimate decreases and one in which no estimate changes.\nEach algorithm in this chapter calls INITIALIZE-SINGLE-SOURCE and then re-\npeatedly relaxes edges. Moreover, relaxation is the only means by which shortest-\npath estimates and predecessors change. The algorithms in this chapter differ in\nhow many times they relax each edge and the order in which they relax edges. Dijk-\nstra’s algorithm and the shortest-paths algorithm for directed acyclic graphs relax\neach edge exactly once. The Bellman-Ford algorithm relaxes each edge jV j \u0005 1\ntimes.\nProperties of shortest paths and relaxation\nTo prove the algorithms in this chapter correct, we shall appeal to several prop-\nerties of shortest paths and relaxation. We state these properties here, and Sec-\ntion 24.5 proves them formally. For your reference, each property stated here in-\ncludes the appropriate lemma or corollary number from Section 24.5. The latter\nﬁve of these properties, which refer to shortest-path estimates or the predecessor\nsubgraph, implicitly assume that the graph is initialized with a call to INITIALIZE-\nSINGLE-SOURCE.G; s/ and that the only way that shortest-path estimates and the\npredecessor subgraph change are by some sequence of relaxation steps.\n650\nChapter 24\nSingle-Source Shortest Paths\nTriangle inequality (Lemma 24.10)\nFor any edge .u; \u0003/ 2 E, we have ı.s; \u0003/ \u0002 ı.s; u/ C w.u; \u0003/.\nUpper-bound property (Lemma 24.11)\nWe always have \u0003:d \u0006 ı.s; \u0003/ for all vertices \u0003 2 V , and once \u0003:d achieves the\nvalue ı.s; \u0003/, it never changes.\nNo-path property (Corollary 24.12)",
    "parent_356433cb-1e6a-45ba-ab50-60ba88a6a604": "Triangle inequality (Lemma 24.10)\nFor any edge .u; \u0003/ 2 E, we have ı.s; \u0003/ \u0002 ı.s; u/ C w.u; \u0003/.\nUpper-bound property (Lemma 24.11)\nWe always have \u0003:d \u0006 ı.s; \u0003/ for all vertices \u0003 2 V , and once \u0003:d achieves the\nvalue ı.s; \u0003/, it never changes.\nNo-path property (Corollary 24.12)\nIf there is no path from s to \u0003, then we always have \u0003:d D ı.s; \u0003/ D 1.\nConvergence property (Lemma 24.14)\nIf s ; u ! \u0003 is a shortest path in G for some u; \u0003 2 V , and if u:d D ı.s; u/ at\nany time prior to relaxing edge .u; \u0003/, then \u0003:d D ı.s; \u0003/ at all times afterward.\nPath-relaxation property (Lemma 24.15)\nIf p D h\u00030; \u00031; : : : ; \u0003ki is a shortest path from s D \u00030 to \u0003k, and we relax the\nedges of p in the order .\u00030; \u00031/; .\u00031; \u00032/; : : : ; .\u0003k\u00031; \u0003k/, then \u0003k:d D ı.s; \u0003k/.\nThis property holds regardless of any other relaxation steps that occur, even if\nthey are intermixed with relaxations of the edges of p.\nPredecessor-subgraph property (Lemma 24.17)\nOnce \u0003:d D ı.s; \u0003/ for all \u0003 2 V , the predecessor subgraph is a shortest-paths\ntree rooted at s.\nChapter outline\nSection 24.1 presents the Bellman-Ford algorithm, which solves the single-source\nshortest-paths problem in the general case in which edges can have negative weight.\nThe Bellman-Ford algorithm is remarkably simple, and it has the further beneﬁt\nof detecting whether a negative-weight cycle is reachable from the source. Sec-\ntion 24.2 gives a linear-time algorithm for computing shortest paths from a single\nsource in a directed acyclic graph. Section 24.3 covers Dijkstra’s algorithm, which\nhas a lower running time than the Bellman-Ford algorithm but requires the edge\nweights to be nonnegative. Section 24.4 shows how we can use the Bellman-Ford\nalgorithm to solve a special case of linear programming. Finally, Section 24.5\nproves the properties of shortest paths and relaxation stated above.\nWe require some conventions for doing arithmetic with inﬁnities. We shall as-",
    "parent_bd8d8531-0f55-42cc-b07d-0d58cbc803c6": "algorithm to solve a special case of linear programming. Finally, Section 24.5\nproves the properties of shortest paths and relaxation stated above.\nWe require some conventions for doing arithmetic with inﬁnities. We shall as-\nsume that for any real number a ¤ \u00051, we have a C 1 D 1 C a D 1. Also, to\nmake our proofs hold in the presence of negative-weight cycles, we shall assume\nthat for any real number a ¤ 1, we have a C .\u00051/ D .\u00051/ C a D \u00051.\nAll algorithms in this chapter assume that the directed graph G is stored in the\nadjacency-list representation. Additionally, stored with each edge is its weight, so\nthat as we traverse each adjacency list, we can determine the edge weights in O.1/\ntime per edge.\n24.1\nThe Bellman-Ford algorithm\n651\n24.1\nThe Bellman-Ford algorithm\nThe Bellman-Ford algorithm solves the single-source shortest-paths problem in\nthe general case in which edge weights may be negative. Given a weighted, di-\nrected graph G D .V; E/ with source s and weight function w W E ! R, the\nBellman-Ford algorithm returns a boolean value indicating whether or not there is\na negative-weight cycle that is reachable from the source. If there is such a cy-\ncle, the algorithm indicates that no solution exists. If there is no such cycle, the\nalgorithm produces the shortest paths and their weights.\nThe algorithm relaxes edges, progressively decreasing an estimate \u0003:d on the\nweight of a shortest path from the source s to each vertex \u0003 2 V until it achieves\nthe actual shortest-path weight ı.s; \u0003/. The algorithm returns TRUE if and only if\nthe graph contains no negative-weight cycles that are reachable from the source.\nBELLMAN-FORD.G; w; s/\n1\nINITIALIZE-SINGLE-SOURCE.G; s/\n2\nfor i D 1 to jG:Vj \u0005 1\n3\nfor each edge .u; \u0003/ 2 G:E\n4\nRELAX.u; \u0003; w/\n5\nfor each edge .u; \u0003/ 2 G:E\n6\nif \u0003:d > u:d C w.u; \u0003/\n7\nreturn FALSE\n8\nreturn TRUE\nFigure 24.4 shows the execution of the Bellman-Ford algorithm on a graph",
    "parent_b44644c0-669d-4592-8539-060a8902fb97": "BELLMAN-FORD.G; w; s/\n1\nINITIALIZE-SINGLE-SOURCE.G; s/\n2\nfor i D 1 to jG:Vj \u0005 1\n3\nfor each edge .u; \u0003/ 2 G:E\n4\nRELAX.u; \u0003; w/\n5\nfor each edge .u; \u0003/ 2 G:E\n6\nif \u0003:d > u:d C w.u; \u0003/\n7\nreturn FALSE\n8\nreturn TRUE\nFigure 24.4 shows the execution of the Bellman-Ford algorithm on a graph\nwith 5 vertices. After initializing the d and \u0006 values of all vertices in line 1,\nthe algorithm makes jV j \u0005 1 passes over the edges of the graph. Each pass is\none iteration of the for loop of lines 2–4 and consists of relaxing each edge of the\ngraph once. Figures 24.4(b)–(e) show the state of the algorithm after each of the\nfour passes over the edges. After making jV j \u0005 1 passes, lines 5–8 check for a\nnegative-weight cycle and return the appropriate boolean value. (We’ll see a little\nlater why this check works.)\nThe Bellman-Ford algorithm runs in time O.VE/, since the initialization in\nline 1 takes ‚.V / time, each of the jV j \u0005 1 passes over the edges in lines 2–4\ntakes ‚.E/ time, and the for loop of lines 5–7 takes O.E/ time.\nTo prove the correctness of the Bellman-Ford algorithm, we start by showing that\nif there are no negative-weight cycles, the algorithm computes correct shortest-path\nweights for all vertices reachable from the source.\n652\nChapter 24\nSingle-Source Shortest Paths\n(a)\n(b)\n(c)\n(d)\n0\n5\n9\n7\n8\n6\n7\n(e)\nt\nx\ns\ny\nz\n –4\n –3\n –2\n2\n7\n4\n–2\n2\n0\n5\n9\n7\n8\n6\n7\nt\nx\ns\ny\nz\n –4\n –3\n –2\n2\n7\n4\n2\n2\n0\n5\n9\n7\n8\n6\n7\nt\nx\ns\ny\nz\n –4\n –3\n –2\n6\n7\n4\n2\n2\n0\n5\n9\n7\n8\n6\n7\nt\nx\ns\ny\nz\n –4\n –3\n –2\n6\n7\n∞\n∞\n2\n0\n5\n9\n7\n8\n6\n7\nt\nx\ns\ny\nz\n –4\n –3\n –2\n∞\n∞\n2\n∞\n∞\nFigure 24.4\nThe execution of the Bellman-Ford algorithm. The source is vertex s. The d val-\nues appear within the vertices, and shaded edges indicate predecessor values: if edge .u; \u0003/ is\nshaded, then \u0003:\u0006 D u.\nIn this particular example, each pass relaxes the edges in the order\n.t; x/;.t; y/; .t; ´/; .x; t/; .y; x/; .y; ´/; .´; x/; .´; s/; .s; t/; .s; y/. (a) The situation just before the",
    "parent_d954156a-6d7a-468f-8125-d70fb90abcd9": "ues appear within the vertices, and shaded edges indicate predecessor values: if edge .u; \u0003/ is\nshaded, then \u0003:\u0006 D u.\nIn this particular example, each pass relaxes the edges in the order\n.t; x/;.t; y/; .t; ´/; .x; t/; .y; x/; .y; ´/; .´; x/; .´; s/; .s; t/; .s; y/. (a) The situation just before the\nﬁrst pass over the edges. (b)–(e) The situation after each successive pass over the edges. The d\nand \u0006 values in part (e) are the ﬁnal values. The Bellman-Ford algorithm returns TRUE in this\nexample.\nLemma 24.2\nLet G D .V; E/ be a weighted, directed graph with source s and weight func-\ntion w W E ! R, and assume that G contains no negative-weight cycles that are\nreachable from s. Then, after the jV j \u0005 1 iterations of the for loop of lines 2–4\nof BELLMAN-FORD, we have \u0003:d D ı.s; \u0003/ for all vertices \u0003 that are reachable\nfrom s.\nProof\nWe prove the lemma by appealing to the path-relaxation property. Con-\nsider any vertex \u0003 that is reachable from s, and let p D h\u00030; \u00031; : : : ; \u0003ki, where\n\u00030 D s and \u0003k D \u0003, be any shortest path from s to \u0003. Because shortest paths are\nsimple, p has at most jV j \u0005 1 edges, and so k \u0002 jV j \u0005 1. Each of the jV j \u0005 1 itera-\ntions of the for loop of lines 2–4 relaxes all jEj edges. Among the edges relaxed in\nthe ith iteration, for i D 1; 2; : : : ; k, is .\u0003i\u00031; \u0003i/. By the path-relaxation property,\ntherefore, \u0003:d D \u0003k:d D ı.s; \u0003k/ D ı.s; \u0003/.\n24.1\nThe Bellman-Ford algorithm\n653\nCorollary 24.3\nLet G D .V; E/ be a weighted, directed graph with source vertex s and weight\nfunction w W E ! R, and assume that G contains no negative-weight cycles that\nare reachable from s. Then, for each vertex \u0003 2 V , there is a path from s to \u0003 if\nand only if BELLMAN-FORD terminates with \u0003:d < 1 when it is run on G.\nProof\nThe proof is left as Exercise 24.1-2.\nTheorem 24.4 (Correctness of the Bellman-Ford algorithm)\nLet BELLMAN-FORD be run on a weighted, directed graph G D .V; E/ with\nsource s and weight function w W E ! R. If G contains no negative-weight cycles",
    "parent_717c34ff-71e9-42ad-8664-caec1dc92932": "Proof\nThe proof is left as Exercise 24.1-2.\nTheorem 24.4 (Correctness of the Bellman-Ford algorithm)\nLet BELLMAN-FORD be run on a weighted, directed graph G D .V; E/ with\nsource s and weight function w W E ! R. If G contains no negative-weight cycles\nthat are reachable from s, then the algorithm returns TRUE, we have \u0003:d D ı.s; \u0003/\nfor all vertices \u0003 2 V , and the predecessor subgraph G\u0003 is a shortest-paths tree\nrooted at s. If G does contain a negative-weight cycle reachable from s, then the\nalgorithm returns FALSE.\nProof\nSuppose that graph G contains no negative-weight cycles that are reach-\nable from the source s. We ﬁrst prove the claim that at termination, \u0003:d D ı.s; \u0003/\nfor all vertices \u0003 2 V . If vertex \u0003 is reachable from s, then Lemma 24.2 proves this\nclaim. If \u0003 is not reachable from s, then the claim follows from the no-path prop-\nerty. Thus, the claim is proven. The predecessor-subgraph property, along with the\nclaim, implies that G\u0003 is a shortest-paths tree. Now we use the claim to show that\nBELLMAN-FORD returns TRUE. At termination, we have for all edges .u; \u0003/ 2 E,\n\u0003:d\nD\nı.s; \u0003/\n\u0002\nı.s; u/ C w.u; \u0003/\n(by the triangle inequality)\nD\nu:d C w.u; \u0003/ ;\nand so none of the tests in line 6 causes BELLMAN-FORD to return FALSE. There-\nfore, it returns TRUE.\nNow, suppose that graph G contains a negative-weight cycle that is reachable\nfrom the source s; let this cycle be c D h\u00030; \u00031; : : : ; \u0003ki, where \u00030 D \u0003k. Then,\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ < 0 :\n(24.1)\nAssume for the purpose of contradiction that the Bellman-Ford algorithm returns\nTRUE. Thus, \u0003i:d \u0002 \u0003i\u00031:d C w.\u0003i\u00031; \u0003i/ for i D 1; 2; : : : ; k. Summing the\ninequalities around cycle c gives us\n654\nChapter 24\nSingle-Source Shortest Paths\nk\nX\niD1\n\u0003i:d\n\u0002\nk\nX\niD1\n.\u0003i\u00031:d C w.\u0003i\u00031; \u0003i//\nD\nk\nX\niD1\n\u0003i\u00031:d C\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ :\nSince \u00030 D \u0003k, each vertex in c appears exactly once in each of the summations\nPk\niD1 \u0003i:d and Pk\niD1 \u0003i\u00031:d, and so\nk\nX\niD1\n\u0003i:d D\nk\nX\niD1\n\u0003i\u00031:d :",
    "parent_d89c0adf-f06e-4ac9-89fa-5011a8fed5ff": "654\nChapter 24\nSingle-Source Shortest Paths\nk\nX\niD1\n\u0003i:d\n\u0002\nk\nX\niD1\n.\u0003i\u00031:d C w.\u0003i\u00031; \u0003i//\nD\nk\nX\niD1\n\u0003i\u00031:d C\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ :\nSince \u00030 D \u0003k, each vertex in c appears exactly once in each of the summations\nPk\niD1 \u0003i:d and Pk\niD1 \u0003i\u00031:d, and so\nk\nX\niD1\n\u0003i:d D\nk\nX\niD1\n\u0003i\u00031:d :\nMoreover, by Corollary 24.3, \u0003i:d is ﬁnite for i D 1; 2; : : : ; k. Thus,\n0 \u0002\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ ;\nwhich contradicts inequality (24.1). We conclude that the Bellman-Ford algorithm\nreturns TRUE if graph G contains no negative-weight cycles reachable from the\nsource, and FALSE otherwise.\nExercises\n24.1-1\nRun the Bellman-Ford algorithm on the directed graph of Figure 24.4, using ver-\ntex ´ as the source. In each pass, relax edges in the same order as in the ﬁgure, and\nshow the d and \u0006 values after each pass. Now, change the weight of edge .´; x/\nto 4 and run the algorithm again, using s as the source.\n24.1-2\nProve Corollary 24.3.\n24.1-3\nGiven a weighted, directed graph G D .V; E/ with no negative-weight cycles,\nlet m be the maximum over all vertices \u0003 2 V of the minimum number of edges\nin a shortest path from the source s to \u0003. (Here, the shortest path is by weight, not\nthe number of edges.) Suggest a simple change to the Bellman-Ford algorithm that\nallows it to terminate in m C 1 passes, even if m is not known in advance.\n24.1-4\nModify the Bellman-Ford algorithm so that it sets \u0003:d to \u00051 for all vertices \u0003 for\nwhich there is a negative-weight cycle on some path from the source to \u0003.\n24.2\nSingle-source shortest paths in directed acyclic graphs\n655\n24.1-5\n?\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R.\nGive an O.VE/-time algorithm to ﬁnd, for each vertex \u0003 2 V , the value ı\u0004.\u0003/ D\nminu2V fı.u; \u0003/g.\n24.1-6\n?\nSuppose that a weighted, directed graph G D .V; E/ has a negative-weight cycle.\nGive an efﬁcient algorithm to list the vertices of one such cycle. Prove that your\nalgorithm is correct.\n24.2\nSingle-source shortest paths in directed acyclic graphs",
    "parent_a4315282-77da-4b0a-8661-b784178186ea": "minu2V fı.u; \u0003/g.\n24.1-6\n?\nSuppose that a weighted, directed graph G D .V; E/ has a negative-weight cycle.\nGive an efﬁcient algorithm to list the vertices of one such cycle. Prove that your\nalgorithm is correct.\n24.2\nSingle-source shortest paths in directed acyclic graphs\nBy relaxing the edges of a weighted dag (directed acyclic graph) G D .V; E/\naccording to a topological sort of its vertices, we can compute shortest paths from\na single source in ‚.V C E/ time. Shortest paths are always well deﬁned in a dag,\nsince even if there are negative-weight edges, no negative-weight cycles can exist.\nThe algorithm starts by topologically sorting the dag (see Section 22.4) to im-\npose a linear ordering on the vertices. If the dag contains a path from vertex u to\nvertex \u0003, then u precedes \u0003 in the topological sort. We make just one pass over the\nvertices in the topologically sorted order. As we process each vertex, we relax each\nedge that leaves the vertex.\nDAG-SHORTEST-PATHS.G; w; s/\n1\ntopologically sort the vertices of G\n2\nINITIALIZE-SINGLE-SOURCE.G; s/\n3\nfor each vertex u, taken in topologically sorted order\n4\nfor each vertex \u0003 2 G:AdjŒu\u0002\n5\nRELAX.u; \u0003; w/\nFigure 24.5 shows the execution of this algorithm.\nThe running time of this algorithm is easy to analyze. As shown in Section 22.4,\nthe topological sort of line 1 takes ‚.V C E/ time. The call of INITIALIZE-\nSINGLE-SOURCE in line 2 takes ‚.V / time. The for loop of lines 3–5 makes one\niteration per vertex. Altogether, the for loop of lines 4–5 relaxes each edge exactly\nonce. (We have used an aggregate analysis here.) Because each iteration of the\ninner for loop takes ‚.1/ time, the total running time is ‚.V CE/, which is linear\nin the size of an adjacency-list representation of the graph.\nThe following theorem shows that the DAG-SHORTEST-PATHS procedure cor-\nrectly computes the shortest paths.\n656\nChapter 24\nSingle-Source Shortest Paths\n2\n∞\n∞\n0\n5\n1\n6\n3\n4\n∞\n∞\n∞\n7\n–1\n–2\n2\n(a)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(c)\nx\nt\ns\nr\ny",
    "parent_6bba865f-68bc-48dc-ae0b-46797e18dc9c": "in the size of an adjacency-list representation of the graph.\nThe following theorem shows that the DAG-SHORTEST-PATHS procedure cor-\nrectly computes the shortest paths.\n656\nChapter 24\nSingle-Source Shortest Paths\n2\n∞\n∞\n0\n5\n1\n6\n3\n4\n∞\n∞\n∞\n7\n–1\n–2\n2\n(a)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(c)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(e)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(g)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(b)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(d)\nx\nt\ns\nr\ny\nz\n2\n5\n1\n6\n3\n4\n7\n–1\n–2\n2\n(f)\nx\nt\ns\nr\ny\nz\n∞\n0\n∞\n∞\n2\n6\n∞\n0\n2\n6\n5\n4\n∞\n0\n2\n6\n5\n3\n∞\n0\n2\n6\n5\n3\n∞\n0\n2\n6\n6\n4\n∞\n∞\n0\n∞\n∞\n∞\nFigure 24.5\nThe execution of the algorithm for shortest paths in a directed acyclic graph. The\nvertices are topologically sorted from left to right. The source vertex is s. The d values appear\nwithin the vertices, and shaded edges indicate the \u0006 values. (a) The situation before the ﬁrst iteration\nof the for loop of lines 3–5. (b)–(g) The situation after each iteration of the for loop of lines 3–5.\nThe newly blackened vertex in each iteration was used as u in that iteration. The values shown in\npart (g) are the ﬁnal values.\nTheorem 24.5\nIf a weighted, directed graph G D .V; E/ has source vertex s and no cycles, then\nat the termination of the DAG-SHORTEST-PATHS procedure, \u0003:d D ı.s; \u0003/ for all\nvertices \u0003 2 V , and the predecessor subgraph G\u0003 is a shortest-paths tree.\nProof\nWe ﬁrst show that \u0003:d D ı.s; \u0003/ for all vertices \u0003 2 V at termina-\ntion.\nIf \u0003 is not reachable from s, then \u0003:d D ı.s; \u0003/ D 1 by the no-path\nproperty.\nNow, suppose that \u0003 is reachable from s, so that there is a short-\nest path p D h\u00030; \u00031; : : : ; \u0003ki, where \u00030 D s and \u0003k D \u0003. Because we pro-\n24.2\nSingle-source shortest paths in directed acyclic graphs\n657\ncess the vertices in topologically sorted order, we relax the edges on p in the\norder .\u00030; \u00031/; .\u00031; \u00032/; : : : ; .\u0003k\u00031; \u0003k/. The path-relaxation property implies that\n\u0003i:d D ı.s; \u0003i/ at termination for i D 0; 1; : : : ; k. Finally, by the predecessor-",
    "parent_2e3b446b-9417-49ca-8d60-e5f3ed327415": "657\ncess the vertices in topologically sorted order, we relax the edges on p in the\norder .\u00030; \u00031/; .\u00031; \u00032/; : : : ; .\u0003k\u00031; \u0003k/. The path-relaxation property implies that\n\u0003i:d D ı.s; \u0003i/ at termination for i D 0; 1; : : : ; k. Finally, by the predecessor-\nsubgraph property, G\u0003 is a shortest-paths tree.\nAn interesting application of this algorithm arises in determining critical paths\nin PERT chart2 analysis. Edges represent jobs to be performed, and edge weights\nrepresent the times required to perform particular jobs. If edge .u; \u0003/ enters ver-\ntex \u0003 and edge .\u0003; x/ leaves \u0003, then job .u; \u0003/ must be performed before job .\u0003; x/.\nA path through this dag represents a sequence of jobs that must be performed in a\nparticular order. A critical path is a longest path through the dag, corresponding\nto the longest time to perform any sequence of jobs. Thus, the weight of a critical\npath provides a lower bound on the total time to perform all the jobs. We can ﬁnd\na critical path by either\n\u0002\nnegating the edge weights and running DAG-SHORTEST-PATHS, or\n\u0002\nrunning DAG-SHORTEST-PATHS, with the modiﬁcation that we replace “1”\nby “\u00051” in line 2 of INITIALIZE-SINGLE-SOURCE and “>” by “<” in the\nRELAX procedure.\nExercises\n24.2-1\nRun DAG-SHORTEST-PATHS on the directed graph of Figure 24.5, using vertex r\nas the source.\n24.2-2\nSuppose we change line 3 of DAG-SHORTEST-PATHS to read\n3\nfor the ﬁrst jV j \u0005 1 vertices, taken in topologically sorted order\nShow that the procedure would remain correct.\n24.2-3\nThe PERT chart formulation given above is somewhat unnatural. In a more natu-\nral structure, vertices would represent jobs and edges would represent sequencing\nconstraints; that is, edge .u; \u0003/ would indicate that job u must be performed before\njob \u0003. We would then assign weights to vertices, not edges. Modify the DAG-\nSHORTEST-PATHS procedure so that it ﬁnds a longest path in a directed acyclic\ngraph with weighted vertices in linear time.",
    "parent_72713614-34b7-4515-9dac-38b16dea17af": "constraints; that is, edge .u; \u0003/ would indicate that job u must be performed before\njob \u0003. We would then assign weights to vertices, not edges. Modify the DAG-\nSHORTEST-PATHS procedure so that it ﬁnds a longest path in a directed acyclic\ngraph with weighted vertices in linear time.\n2“PERT” is an acronym for “program evaluation and review technique.”\n658\nChapter 24\nSingle-Source Shortest Paths\n24.2-4\nGive an efﬁcient algorithm to count the total number of paths in a directed acyclic\ngraph. Analyze your algorithm.\n24.3\nDijkstra’s algorithm\nDijkstra’s algorithm solves the single-source shortest-paths problem on a weighted,\ndirected graph G D .V; E/ for the case in which all edge weights are nonnegative.\nIn this section, therefore, we assume that w.u; \u0003/ \u0006 0 for each edge .u; \u0003/ 2 E. As\nwe shall see, with a good implementation, the running time of Dijkstra’s algorithm\nis lower than that of the Bellman-Ford algorithm.\nDijkstra’s algorithm maintains a set S of vertices whose ﬁnal shortest-path\nweights from the source s have already been determined. The algorithm repeat-\nedly selects the vertex u 2 V \u0005S with the minimum shortest-path estimate, adds u\nto S, and relaxes all edges leaving u. In the following implementation, we use a\nmin-priority queue Q of vertices, keyed by their d values.\nDIJKSTRA.G; w; s/\n1\nINITIALIZE-SINGLE-SOURCE.G; s/\n2\nS D ;\n3\nQ D G:V\n4\nwhile Q ¤ ;\n5\nu D EXTRACT-MIN.Q/\n6\nS D S [ fug\n7\nfor each vertex \u0003 2 G:AdjŒu\u0002\n8\nRELAX.u; \u0003; w/\nDijkstra’s algorithm relaxes edges as shown in Figure 24.6. Line 1 initializes\nthe d and \u0006 values in the usual way, and line 2 initializes the set S to the empty\nset. The algorithm maintains the invariant that Q D V \u0005 S at the start of each\niteration of the while loop of lines 4–8. Line 3 initializes the min-priority queue Q\nto contain all the vertices in V ; since S D ; at that time, the invariant is true after\nline 3. Each time through the while loop of lines 4–8, line 5 extracts a vertex u from",
    "parent_5199ce14-19a3-4bfe-9407-758ee00167a1": "iteration of the while loop of lines 4–8. Line 3 initializes the min-priority queue Q\nto contain all the vertices in V ; since S D ; at that time, the invariant is true after\nline 3. Each time through the while loop of lines 4–8, line 5 extracts a vertex u from\nQ D V \u0005S and line 6 adds it to set S, thereby maintaining the invariant. (The ﬁrst\ntime through this loop, u D s.) Vertex u, therefore, has the smallest shortest-path\nestimate of any vertex in V \u0005 S. Then, lines 7–8 relax each edge .u; \u0003/ leaving u,\nthus updating the estimate \u0003:d and the predecessor \u0003:\u0006 if we can improve the\nshortest path to \u0003 found so far by going through u. Observe that the algorithm\nnever inserts vertices into Q after line 3 and that each vertex is extracted from Q\n24.3\nDijkstra’s algorithm\n659\n0\n∞\n∞\n∞\n∞\n0\n∞\n∞\n1\n2\n10\n5\n(c)\n10\n5\n0\n8\n5\n14\n7\n0\n8\n5\n13\n7\n0\n8\n5\n9\n7\n0\n5\n9\n7\n8\n6\n4\n3\n2\n9\n7\ns\nt\nx\ny\nz\n1\n2\n10\n5\n(f)\n6\n4\n3\n2\n9\n7\ns\nt\nx\ny\nz\n1\n2\n10\n5\n(b)\n6\n4\n3\n2\n9\n7\ns\nt\nx\ny\nz\n1\n2\n10\n5\n(e)\n6\n4\n3\n2\n9\n7\ns\nt\nx\ny\nz\n1\n2\n10\n5\n(a)\n6\n4\n3\n2\n9\n7\ns\nt\nx\ny\nz\n1\n2\n10\n5\n(d)\n6\n4\n3\n2\n9\n7\ns\nt\nx\ny\nz\nFigure 24.6\nThe execution of Dijkstra’s algorithm.\nThe source s is the leftmost vertex. The\nshortest-path estimates appear within the vertices, and shaded edges indicate predecessor values.\nBlack vertices are in the set S, and white vertices are in the min-priority queue Q D V \u0005 S. (a) The\nsituation just before the ﬁrst iteration of the while loop of lines 4–8. The shaded vertex has the mini-\nmum d value and is chosen as vertex u in line 5. (b)–(f) The situation after each successive iteration\nof the while loop. The shaded vertex in each part is chosen as vertex u in line 5 of the next iteration.\nThe d values and predecessors shown in part (f) are the ﬁnal values.\nand added to S exactly once, so that the while loop of lines 4–8 iterates exactly jV j\ntimes.\nBecause Dijkstra’s algorithm always chooses the “lightest” or “closest” vertex\nin V \u0005 S to add to set S, we say that it uses a greedy strategy. Chapter 16 explains",
    "parent_00ca7939-369e-42b3-8c57-600669377aa1": "and added to S exactly once, so that the while loop of lines 4–8 iterates exactly jV j\ntimes.\nBecause Dijkstra’s algorithm always chooses the “lightest” or “closest” vertex\nin V \u0005 S to add to set S, we say that it uses a greedy strategy. Chapter 16 explains\ngreedy strategies in detail, but you need not have read that chapter to understand\nDijkstra’s algorithm. Greedy strategies do not always yield optimal results in gen-\neral, but as the following theorem and its corollary show, Dijkstra’s algorithm does\nindeed compute shortest paths. The key is to show that each time it adds a vertex u\nto set S, we have u:d D ı.s; u/.\nTheorem 24.6 (Correctness of Dijkstra’s algorithm)\nDijkstra’s algorithm, run on a weighted, directed graph G D .V; E/ with non-\nnegative weight function w and source s, terminates with u:d D ı.s; u/ for all\nvertices u 2 V .\n660\nChapter 24\nSingle-Source Shortest Paths\np1\nS\np2\nu\ny\ns\nx\nFigure 24.7\nThe proof of Theorem 24.6. Set S is nonempty just before vertex u is added to it. We\ndecompose a shortest path p from source s to vertex u into s\np1\n; x ! y\np2\n; u, where y is the ﬁrst\nvertex on the path that is not in S and x 2 S immediately precedes y. Vertices x and y are distinct,\nbut we may have s D x or y D u. Path p2 may or may not reenter set S.\nProof\nWe use the following loop invariant:\nAt the start of each iteration of the while loop of lines 4–8, \u0003:d D ı.s; \u0003/\nfor each vertex \u0003 2 S.\nIt sufﬁces to show for each vertex u 2 V , we have u:d D ı.s; u/ at the time when u\nis added to set S. Once we show that u:d D ı.s; u/, we rely on the upper-bound\nproperty to show that the equality holds at all times thereafter.\nInitialization: Initially, S D ;, and so the invariant is trivially true.\nMaintenance: We wish to show that in each iteration, u:d D ı.s; u/ for the vertex\nadded to set S. For the purpose of contradiction, let u be the ﬁrst vertex for\nwhich u:d ¤ ı.s; u/ when it is added to set S. We shall focus our attention",
    "parent_1cce84c9-cf08-499e-a400-1078042ac663": "Maintenance: We wish to show that in each iteration, u:d D ı.s; u/ for the vertex\nadded to set S. For the purpose of contradiction, let u be the ﬁrst vertex for\nwhich u:d ¤ ı.s; u/ when it is added to set S. We shall focus our attention\non the situation at the beginning of the iteration of the while loop in which u\nis added to S and derive the contradiction that u:d D ı.s; u/ at that time by\nexamining a shortest path from s to u. We must have u ¤ s because s is the\nﬁrst vertex added to set S and s:d D ı.s; s/ D 0 at that time. Because u ¤ s,\nwe also have that S ¤ ; just before u is added to S. There must be some\npath from s to u, for otherwise u:d D ı.s; u/ D 1 by the no-path property,\nwhich would violate our assumption that u:d ¤ ı.s; u/. Because there is at\nleast one path, there is a shortest path p from s to u. Prior to adding u to S,\npath p connects a vertex in S, namely s, to a vertex in V \u0005 S, namely u. Let us\nconsider the ﬁrst vertex y along p such that y 2 V \u0005 S, and let x 2 S be y’s\npredecessor along p. Thus, as Figure 24.7 illustrates, we can decompose path p\ninto s\np1\n; x ! y\np2\n; u. (Either of paths p1 or p2 may have no edges.)\nWe claim that y:d D ı.s; y/ when u is added to S. To prove this claim, ob-\nserve that x 2 S. Then, because we chose u as the ﬁrst vertex for which\nu:d ¤ ı.s; u/ when it is added to S, we had x:d D ı.s; x/ when x was added\n24.3\nDijkstra’s algorithm\n661\nto S. Edge .x; y/ was relaxed at that time, and the claim follows from the\nconvergence property.\nWe can now obtain a contradiction to prove that u:d D ı.s; u/. Because y\nappears before u on a shortest path from s to u and all edge weights are non-\nnegative (notably those on path p2), we have ı.s; y/ \u0002 ı.s; u/, and thus\ny:d\nD\nı.s; y/\n\u0002\nı.s; u/\n(24.2)\n\u0002\nu:d\n(by the upper-bound property) .\nBut because both vertices u and y were in V \u0005 S when u was chosen in line 5,\nwe have u:d \u0002 y:d. Thus, the two inequalities in (24.2) are in fact equalities,\ngiving\ny:d D ı.s; y/ D ı.s; u/ D u:d :",
    "parent_bb23f9b0-199e-4a46-91d1-fd0fbae90e1b": "y:d\nD\nı.s; y/\n\u0002\nı.s; u/\n(24.2)\n\u0002\nu:d\n(by the upper-bound property) .\nBut because both vertices u and y were in V \u0005 S when u was chosen in line 5,\nwe have u:d \u0002 y:d. Thus, the two inequalities in (24.2) are in fact equalities,\ngiving\ny:d D ı.s; y/ D ı.s; u/ D u:d :\nConsequently, u:d D ı.s; u/, which contradicts our choice of u. We conclude\nthat u:d D ı.s; u/ when u is added to S, and that this equality is maintained at\nall times thereafter.\nTermination: At termination, Q D ; which, along with our earlier invariant that\nQ D V \u0005S, implies that S D V . Thus, u:d D ı.s; u/ for all vertices u 2 V .\nCorollary 24.7\nIf we run Dijkstra’s algorithm on a weighted, directed graph G D .V; E/ with\nnonnegative weight function w and source s, then at termination, the predecessor\nsubgraph G\u0003 is a shortest-paths tree rooted at s.\nProof\nImmediate from Theorem 24.6 and the predecessor-subgraph property.\nAnalysis\nHow fast is Dijkstra’s algorithm? It maintains the min-priority queue Q by call-\ning three priority-queue operations: INSERT (implicit in line 3), EXTRACT-MIN\n(line 5), and DECREASE-KEY (implicit in RELAX, which is called in line 8). The\nalgorithm calls both INSERT and EXTRACT-MIN once per vertex. Because each\nvertex u 2 V is added to set S exactly once, each edge in the adjacency list AdjŒu\u0002\nis examined in the for loop of lines 7–8 exactly once during the course of the al-\ngorithm. Since the total number of edges in all the adjacency lists is jEj, this for\nloop iterates a total of jEj times, and thus the algorithm calls DECREASE-KEY at\nmost jEj times overall. (Observe once again that we are using aggregate analysis.)\nThe running time of Dijkstra’s algorithm depends on how we implement the\nmin-priority queue. Consider ﬁrst the case in which we maintain the min-priority\n662\nChapter 24\nSingle-Source Shortest Paths\nqueue by taking advantage of the vertices being numbered 1 to jV j. We simply\nstore \u0003:d in the \u0003th entry of an array. Each INSERT and DECREASE-KEY operation",
    "parent_b2176ccc-adbc-4f10-9acc-77d18397d41b": "min-priority queue. Consider ﬁrst the case in which we maintain the min-priority\n662\nChapter 24\nSingle-Source Shortest Paths\nqueue by taking advantage of the vertices being numbered 1 to jV j. We simply\nstore \u0003:d in the \u0003th entry of an array. Each INSERT and DECREASE-KEY operation\ntakes O.1/ time, and each EXTRACT-MIN operation takes O.V / time (since we\nhave to search through the entire array), for a total time of O.V 2 C E/ D O.V 2/.\nIf the graph is sufﬁciently sparse—in particular, E D o.V 2= lg V /—we can\nimprove the algorithm by implementing the min-priority queue with a binary min-\nheap. (As discussed in Section 6.5, the implementation should make sure that\nvertices and corresponding heap elements maintain handles to each other.) Each\nEXTRACT-MIN operation then takes time O.lg V /. As before, there are jV j such\noperations. The time to build the binary min-heap is O.V /. Each DECREASE-KEY\noperation takes time O.lg V /, and there are still at most jEj such operations. The\ntotal running time is therefore O..V C E/ lg V /, which is O.E lg V / if all vertices\nare reachable from the source. This running time improves upon the straightfor-\nward O.V 2/-time implementation if E D o.V 2= lg V /.\nWe can in fact achieve a running time of O.V lg V C E/ by implementing the\nmin-priority queue with a Fibonacci heap (see Chapter 19). The amortized cost\nof each of the jV j EXTRACT-MIN operations is O.lg V /, and each DECREASE-\nKEY call, of which there are at most jEj, takes only O.1/ amortized time. His-\ntorically, the development of Fibonacci heaps was motivated by the observation\nthat Dijkstra’s algorithm typically makes many more DECREASE-KEY calls than\nEXTRACT-MIN calls, so that any method of reducing the amortized time of each\nDECREASE-KEY operation to o.lg V / without increasing the amortized time of\nEXTRACT-MIN would yield an asymptotically faster implementation than with bi-\nnary heaps.\nDijkstra’s algorithm resembles both breadth-ﬁrst search (see Section 22.2) and",
    "parent_836cf846-41a5-40af-9111-e7767de42e9b": "DECREASE-KEY operation to o.lg V / without increasing the amortized time of\nEXTRACT-MIN would yield an asymptotically faster implementation than with bi-\nnary heaps.\nDijkstra’s algorithm resembles both breadth-ﬁrst search (see Section 22.2) and\nPrim’s algorithm for computing minimum spanning trees (see Section 23.2). It is\nlike breadth-ﬁrst search in that set S corresponds to the set of black vertices in a\nbreadth-ﬁrst search; just as vertices in S have their ﬁnal shortest-path weights, so\ndo black vertices in a breadth-ﬁrst search have their correct breadth-ﬁrst distances.\nDijkstra’s algorithm is like Prim’s algorithm in that both algorithms use a min-\npriority queue to ﬁnd the “lightest” vertex outside a given set (the set S in Dijkstra’s\nalgorithm and the tree being grown in Prim’s algorithm), add this vertex into the\nset, and adjust the weights of the remaining vertices outside the set accordingly.\nExercises\n24.3-1\nRun Dijkstra’s algorithm on the directed graph of Figure 24.2, ﬁrst using vertex s\nas the source and then using vertex ´ as the source. In the style of Figure 24.6,\nshow the d and \u0006 values and the vertices in set S after each iteration of the while\nloop.\n24.3\nDijkstra’s algorithm\n663\n24.3-2\nGive a simple example of a directed graph with negative-weight edges for which\nDijkstra’s algorithm produces incorrect answers. Why doesn’t the proof of Theo-\nrem 24.6 go through when negative-weight edges are allowed?\n24.3-3\nSuppose we change line 4 of Dijkstra’s algorithm to the following.\n4\nwhile jQj > 1\nThis change causes the while loop to execute jV j \u0005 1 times instead of jV j times. Is\nthis proposed algorithm correct?\n24.3-4\nProfessor Gaedel has written a program that he claims implements Dijkstra’s al-\ngorithm. The program produces \u0003:d and \u0003:\u0006 for each vertex \u0003 2 V . Give an\nO.V CE/-time algorithm to check the output of the professor’s program. It should\ndetermine whether the d and \u0006 attributes match those of some shortest-paths tree.",
    "parent_3a977f73-39af-4af1-9966-764a24f27873": "gorithm. The program produces \u0003:d and \u0003:\u0006 for each vertex \u0003 2 V . Give an\nO.V CE/-time algorithm to check the output of the professor’s program. It should\ndetermine whether the d and \u0006 attributes match those of some shortest-paths tree.\nYou may assume that all edge weights are nonnegative.\n24.3-5\nProfessor Newman thinks that he has worked out a simpler proof of correctness\nfor Dijkstra’s algorithm. He claims that Dijkstra’s algorithm relaxes the edges of\nevery shortest path in the graph in the order in which they appear on the path, and\ntherefore the path-relaxation property applies to every vertex reachable from the\nsource. Show that the professor is mistaken by constructing a directed graph for\nwhich Dijkstra’s algorithm could relax the edges of a shortest path out of order.\n24.3-6\nWe are given a directed graph G D .V; E/ on which each edge .u; \u0003/ 2 E has an\nassociated value r.u; \u0003/, which is a real number in the range 0 \u0002 r.u; \u0003/ \u0002 1 that\nrepresents the reliability of a communication channel from vertex u to vertex \u0003.\nWe interpret r.u; \u0003/ as the probability that the channel from u to \u0003 will not fail,\nand we assume that these probabilities are independent. Give an efﬁcient algorithm\nto ﬁnd the most reliable path between two given vertices.\n24.3-7\nLet G D .V; E/ be a weighted, directed graph with positive weight function\nw W E ! f1; 2; : : : ; W g for some positive integer W , and assume that no two ver-\ntices have the same shortest-path weights from source vertex s. Now suppose that\nwe deﬁne an unweighted, directed graph G0 D .V [ V 0; E0/ by replacing each\nedge .u; \u0003/ 2 E with w.u; \u0003/ unit-weight edges in series. How many vertices\ndoes G0 have? Now suppose that we run a breadth-ﬁrst search on G0. Show that\n664\nChapter 24\nSingle-Source Shortest Paths\nthe order in which the breadth-ﬁrst search of G0 colors vertices in V black is the\nsame as the order in which Dijkstra’s algorithm extracts the vertices of V from the\npriority queue when it runs on G.\n24.3-8",
    "parent_589e7d6f-24cf-49b8-8878-374295df54d9": "664\nChapter 24\nSingle-Source Shortest Paths\nthe order in which the breadth-ﬁrst search of G0 colors vertices in V black is the\nsame as the order in which Dijkstra’s algorithm extracts the vertices of V from the\npriority queue when it runs on G.\n24.3-8\nLet G D .V; E/ be a weighted, directed graph with nonnegative weight function\nw W E ! f0; 1; : : : ; W g for some nonnegative integer W . Modify Dijkstra’s algo-\nrithm to compute the shortest paths from a given source vertex s in O.W V C E/\ntime.\n24.3-9\nModify your algorithm from Exercise 24.3-8 to run in O..V C E/ lg W / time.\n(Hint: How many distinct shortest-path estimates can there be in V \u0005 S at any\npoint in time?)\n24.3-10\nSuppose that we are given a weighted, directed graph G D .V; E/ in which edges\nthat leave the source vertex s may have negative weights, all other edge weights\nare nonnegative, and there are no negative-weight cycles. Argue that Dijkstra’s\nalgorithm correctly ﬁnds shortest paths from s in this graph.\n24.4\nDifference constraints and shortest paths\nChapter 29 studies the general linear-programming problem, in which we wish to\noptimize a linear function subject to a set of linear inequalities. In this section, we\ninvestigate a special case of linear programming that we reduce to ﬁnding shortest\npaths from a single source. We can then solve the single-source shortest-paths\nproblem that results by running the Bellman-Ford algorithm, thereby also solving\nthe linear-programming problem.\nLinear programming\nIn the general linear-programming problem, we are given an m \t n matrix A,\nan m-vector b, and an n-vector c. We wish to ﬁnd a vector x of n elements that\nmaximizes the objective function Pn\niD1 cixi subject to the m constraints given by\nAx \u0002 b.\nAlthough the simplex algorithm, which is the focus of Chapter 29, does not\nalways run in time polynomial in the size of its input, there are other linear-\nprogramming algorithms that do run in polynomial time. We offer here two reasons",
    "parent_5ac53a0b-f78d-4ba8-a499-1a9536c926ea": "iD1 cixi subject to the m constraints given by\nAx \u0002 b.\nAlthough the simplex algorithm, which is the focus of Chapter 29, does not\nalways run in time polynomial in the size of its input, there are other linear-\nprogramming algorithms that do run in polynomial time. We offer here two reasons\nto understand the setup of linear-programming problems. First, if we know that we\n24.4\nDifference constraints and shortest paths\n665\ncan cast a given problem as a polynomial-sized linear-programming problem, then\nwe immediately have a polynomial-time algorithm to solve the problem. Second,\nfaster algorithms exist for many special cases of linear programming. For exam-\nple, the single-pair shortest-path problem (Exercise 24.4-4) and the maximum-ﬂow\nproblem (Exercise 26.1-5) are special cases of linear programming.\nSometimes we don’t really care about the objective function; we just wish to ﬁnd\nany feasible solution, that is, any vector x that satisﬁes Ax \u0002 b, or to determine\nthat no feasible solution exists. We shall focus on one such feasibility problem.\nSystems of difference constraints\nIn a system of difference constraints, each row of the linear-programming matrix A\ncontains one 1 and one \u00051, and all other entries of A are 0. Thus, the constraints\ngiven by Ax \u0002 b are a set of m difference constraints involving n unknowns, in\nwhich each constraint is a simple linear inequality of the form\nxj \u0005 xi \u0002 bk ;\nwhere 1 \u0002 i; j \u0002 n, i ¤ j , and 1 \u0002 k \u0002 m.\nFor example, consider the problem of ﬁnding a 5-vector x D .xi/ that satisﬁes\n\u0002\n1\n\u00051\n0\n0\n0\n1\n0\n0\n0\n\u00051\n0\n1\n0\n0\n\u00051\n\u00051\n0\n1\n0\n0\n\u00051\n0\n0\n1\n0\n0\n0\n\u00051\n1\n0\n0\n0\n\u00051\n0\n1\n0\n0\n0\n\u00051\n1\n˘\nˇ\nx1\nx2\nx3\nx4\nx5\n\u0003\n\u0002\n\u0002\n0\n\u00051\n1\n5\n4\n\u00051\n\u00053\n\u00053\n˘\n:\nThis problem is equivalent to ﬁnding values for the unknowns x1; x2; x3; x4; x5,\nsatisfying the following 8 difference constraints:\nx1 \u0005 x2\n\u0002\n0 ,\n(24.3)\nx1 \u0005 x5\n\u0002\n\u00051 ,\n(24.4)\nx2 \u0005 x5\n\u0002\n1 ,\n(24.5)\nx3 \u0005 x1\n\u0002\n5 ,\n(24.6)\nx4 \u0005 x1\n\u0002\n4 ,\n(24.7)\nx4 \u0005 x3\n\u0002\n\u00051 ,\n(24.8)\nx5 \u0005 x3\n\u0002\n\u00053 ,\n(24.9)\nx5 \u0005 x4\n\u0002\n\u00053 .\n(24.10)\n666\nChapter 24",
    "parent_653370fc-992b-4aba-9ddb-a42838a072c4": "satisfying the following 8 difference constraints:\nx1 \u0005 x2\n\u0002\n0 ,\n(24.3)\nx1 \u0005 x5\n\u0002\n\u00051 ,\n(24.4)\nx2 \u0005 x5\n\u0002\n1 ,\n(24.5)\nx3 \u0005 x1\n\u0002\n5 ,\n(24.6)\nx4 \u0005 x1\n\u0002\n4 ,\n(24.7)\nx4 \u0005 x3\n\u0002\n\u00051 ,\n(24.8)\nx5 \u0005 x3\n\u0002\n\u00053 ,\n(24.9)\nx5 \u0005 x4\n\u0002\n\u00053 .\n(24.10)\n666\nChapter 24\nSingle-Source Shortest Paths\nOne solution to this problem is x D .\u00055; \u00053; 0; \u00051; \u00054/, which you can verify di-\nrectly by checking each inequality. In fact, this problem has more than one solution.\nAnother is x0 D .0; 2; 5; 4; 1/. These two solutions are related: each component\nof x0 is 5 larger than the corresponding component of x. This fact is not mere\ncoincidence.\nLemma 24.8\nLet x D .x1; x2; : : : ; xn/ be a solution to a system Ax \u0002 b of difference con-\nstraints, and let d be any constant. Then x C d D .x1 C d; x2 C d; : : : ; xn C d/\nis a solution to Ax \u0002 b as well.\nProof\nFor each xi and xj, we have .xj C d/ \u0005 .xi C d/ D xj \u0005 xi. Thus, if x\nsatisﬁes Ax \u0002 b, so does x C d.\nSystems of difference constraints occur in many different applications. For ex-\nample, the unknowns xi may be times at which events are to occur. Each constraint\nstates that at least a certain amount of time, or at most a certain amount of time,\nmust elapse between two events. Perhaps the events are jobs to be performed dur-\ning the assembly of a product. If we apply an adhesive that takes 2 hours to set at\ntime x1 and we have to wait until it sets to install a part at time x2, then we have the\nconstraint that x2 \u0006 x1 C 2 or, equivalently, that x1 \u0005 x2 \u0002 \u00052. Alternatively, we\nmight require that the part be installed after the adhesive has been applied but no\nlater than the time that the adhesive has set halfway. In this case, we get the pair of\nconstraints x2 \u0006 x1 and x2 \u0002 x1 C1 or, equivalently, x1 \u0005x2 \u0002 0 and x2 \u0005x1 \u0002 1.\nConstraint graphs\nWe can interpret systems of difference constraints from a graph-theoretic point\nof view.\nIn a system Ax \u0002 b of difference constraints, we view the m \t n",
    "parent_2219c0f7-8128-434d-acbe-384a80796a08": "constraints x2 \u0006 x1 and x2 \u0002 x1 C1 or, equivalently, x1 \u0005x2 \u0002 0 and x2 \u0005x1 \u0002 1.\nConstraint graphs\nWe can interpret systems of difference constraints from a graph-theoretic point\nof view.\nIn a system Ax \u0002 b of difference constraints, we view the m \t n\nlinear-programming matrix A as the transpose of an incidence matrix (see Exer-\ncise 22.1-7) for a graph with n vertices and m edges. Each vertex \u0003i in the graph,\nfor i D 1; 2; : : : ; n, corresponds to one of the n unknown variables xi. Each di-\nrected edge in the graph corresponds to one of the m inequalities involving two\nunknowns.\nMore formally, given a system Ax \u0002 b of difference constraints, the correspond-\ning constraint graph is a weighted, directed graph G D .V; E/, where\nV D f\u00030; \u00031; : : : ; \u0003ng\nand\nE D f.\u0003i; \u0003j/ W xj \u0005 xi \u0002 bk is a constraintg\n[ f.\u00030; \u00031/; .\u00030; \u00032/; .\u00030; \u00033/; : : : ; .\u00030; \u0003n/g :\n24.4\nDifference constraints and shortest paths\n667\n0\n0\n0\n0\n0\n0\n–1\n1\n5\n4\n–1\n–3\n–3\n0\n–5\n–3\n0\n–1\n–4\nv3\nv2\nv1\nv5\nv0\nv4\nFigure 24.8\nThe constraint graph corresponding to the system (24.3)–(24.10) of difference con-\nstraints. The value of ı.\u00030; \u0003i/ appears in each vertex \u0003i. One feasible solution to the system is\nx D .\u00055; \u00053; 0; \u00051; \u00054/.\nThe constraint graph contains the additional vertex \u00030, as we shall see shortly, to\nguarantee that the graph has some vertex which can reach all other vertices. Thus,\nthe vertex set V consists of a vertex \u0003i for each unknown xi, plus an additional\nvertex \u00030. The edge set E contains an edge for each difference constraint, plus\nan edge .\u00030; \u0003i/ for each unknown xi. If xj \u0005 xi \u0002 bk is a difference constraint,\nthen the weight of edge .\u0003i; \u0003j/ is w.\u0003i; \u0003j/ D bk. The weight of each edge leav-\ning \u00030 is 0. Figure 24.8 shows the constraint graph for the system (24.3)–(24.10)\nof difference constraints.\nThe following theorem shows that we can ﬁnd a solution to a system of differ-\nence constraints by ﬁnding shortest-path weights in the corresponding constraint\ngraph.\nTheorem 24.9",
    "parent_e22183f2-aaa7-429a-a776-3856312105a1": "ing \u00030 is 0. Figure 24.8 shows the constraint graph for the system (24.3)–(24.10)\nof difference constraints.\nThe following theorem shows that we can ﬁnd a solution to a system of differ-\nence constraints by ﬁnding shortest-path weights in the corresponding constraint\ngraph.\nTheorem 24.9\nGiven a system Ax \u0002 b of difference constraints, let G D .V; E/ be the corre-\nsponding constraint graph. If G contains no negative-weight cycles, then\nx D .ı.\u00030; \u00031/; ı.\u00030; \u00032/; ı.\u00030; \u00033/; : : : ; ı.\u00030; \u0003n//\n(24.11)\nis a feasible solution for the system. If G contains a negative-weight cycle, then\nthere is no feasible solution for the system.\nProof\nWe ﬁrst show that if the constraint graph contains no negative-weight\ncycles, then equation (24.11) gives a feasible solution.\nConsider any edge\n.\u0003i; \u0003j/ 2 E. By the triangle inequality, ı.\u00030; \u0003j/ \u0002 ı.\u00030; \u0003i/ C w.\u0003i; \u0003j/ or,\nequivalently, ı.\u00030; \u0003j/ \u0005 ı.\u00030; \u0003i/ \u0002 w.\u0003i; \u0003j/. Thus, letting xi D ı.\u00030; \u0003i/ and\n668\nChapter 24\nSingle-Source Shortest Paths\nxj D ı.\u00030; \u0003j/ satisﬁes the difference constraint xj \u0005 xi \u0002 w.\u0003i; \u0003j/ that corre-\nsponds to edge .\u0003i; \u0003j/.\nNow we show that if the constraint graph contains a negative-weight cycle, then\nthe system of difference constraints has no feasible solution. Without loss of gen-\nerality, let the negative-weight cycle be c D h\u00031; \u00032; : : : ; \u0003ki, where \u00031 D \u0003k.\n(The vertex \u00030 cannot be on cycle c, because it has no entering edges.) Cycle c\ncorresponds to the following difference constraints:\nx2 \u0005 x1\n\u0002\nw.\u00031; \u00032/ ;\nx3 \u0005 x2\n\u0002\nw.\u00032; \u00033/ ;\n:::\nxk\u00031 \u0005 xk\u00032\n\u0002\nw.\u0003k\u00032; \u0003k\u00031/ ;\nxk \u0005 xk\u00031\n\u0002\nw.\u0003k\u00031; \u0003k/ :\nWe will assume that x has a solution satisfying each of these k inequalities and then\nderive a contradiction. The solution must also satisfy the inequality that results\nwhen we sum the k inequalities together. If we sum the left-hand sides, each\nunknown xi is added in once and subtracted out once (remember that \u00031 D \u0003k\nimplies x1 D xk), so that the left-hand side of the sum is 0. The right-hand side",
    "parent_236b1750-0f54-4fcf-b639-ab098c13f4c6": "when we sum the k inequalities together. If we sum the left-hand sides, each\nunknown xi is added in once and subtracted out once (remember that \u00031 D \u0003k\nimplies x1 D xk), so that the left-hand side of the sum is 0. The right-hand side\nsums to w.c/, and thus we obtain 0 \u0002 w.c/. But since c is a negative-weight cycle,\nw.c/ < 0, and we obtain the contradiction that 0 \u0002 w.c/ < 0.\nSolving systems of difference constraints\nTheorem 24.9 tells us that we can use the Bellman-Ford algorithm to solve a\nsystem of difference constraints.\nBecause the constraint graph contains edges\nfrom the source vertex \u00030 to all other vertices, any negative-weight cycle in the\nconstraint graph is reachable from \u00030.\nIf the Bellman-Ford algorithm returns\nTRUE, then the shortest-path weights give a feasible solution to the system. In\nFigure 24.8, for example, the shortest-path weights provide the feasible solution\nx D .\u00055; \u00053; 0; \u00051; \u00054/, and by Lemma 24.8, x D .d \u0005 5; d \u0005 3; d; d \u0005 1; d \u0005 4/\nis also a feasible solution for any constant d. If the Bellman-Ford algorithm returns\nFALSE, there is no feasible solution to the system of difference constraints.\nA system of difference constraints with m constraints on n unknowns produces\na graph with n C 1 vertices and n C m edges. Thus, using the Bellman-Ford\nalgorithm, we can solve the system in O..n C 1/.n C m// D O.n2 C nm/ time.\nExercise 24.4-5 asks you to modify the algorithm to run in O.nm/ time, even if m\nis much less than n.\n24.4\nDifference constraints and shortest paths\n669\nExercises\n24.4-1\nFind a feasible solution or determine that no feasible solution exists for the follow-\ning system of difference constraints:\nx1 \u0005 x2\n\u0002\n1 ,\nx1 \u0005 x4\n\u0002\n\u00054 ,\nx2 \u0005 x3\n\u0002\n2 ,\nx2 \u0005 x5\n\u0002\n7 ,\nx2 \u0005 x6\n\u0002\n5 ,\nx3 \u0005 x6\n\u0002\n10 ,\nx4 \u0005 x2\n\u0002\n2 ,\nx5 \u0005 x1\n\u0002\n\u00051 ,\nx5 \u0005 x4\n\u0002\n3 ,\nx6 \u0005 x3\n\u0002\n\u00058 .\n24.4-2\nFind a feasible solution or determine that no feasible solution exists for the follow-\ning system of difference constraints:\nx1 \u0005 x2\n\u0002\n4 ,\nx1 \u0005 x5\n\u0002\n5 ,\nx2 \u0005 x4\n\u0002\n\u00056 ,\nx3 \u0005 x2\n\u0002\n1 ,",
    "parent_96af7356-ea06-4522-8ebe-9223a97e2059": "\u0002\n2 ,\nx2 \u0005 x5\n\u0002\n7 ,\nx2 \u0005 x6\n\u0002\n5 ,\nx3 \u0005 x6\n\u0002\n10 ,\nx4 \u0005 x2\n\u0002\n2 ,\nx5 \u0005 x1\n\u0002\n\u00051 ,\nx5 \u0005 x4\n\u0002\n3 ,\nx6 \u0005 x3\n\u0002\n\u00058 .\n24.4-2\nFind a feasible solution or determine that no feasible solution exists for the follow-\ning system of difference constraints:\nx1 \u0005 x2\n\u0002\n4 ,\nx1 \u0005 x5\n\u0002\n5 ,\nx2 \u0005 x4\n\u0002\n\u00056 ,\nx3 \u0005 x2\n\u0002\n1 ,\nx4 \u0005 x1\n\u0002\n3 ,\nx4 \u0005 x3\n\u0002\n5 ,\nx4 \u0005 x5\n\u0002\n10 ,\nx5 \u0005 x3\n\u0002\n\u00054 ,\nx5 \u0005 x4\n\u0002\n\u00058 .\n24.4-3\nCan any shortest-path weight from the new vertex \u00030 in a constraint graph be posi-\ntive? Explain.\n24.4-4\nExpress the single-pair shortest-path problem as a linear program.\n670\nChapter 24\nSingle-Source Shortest Paths\n24.4-5\nShow how to modify the Bellman-Ford algorithm slightly so that when we use it\nto solve a system of difference constraints with m inequalities on n unknowns, the\nrunning time is O.nm/.\n24.4-6\nSuppose that in addition to a system of difference constraints, we want to handle\nequality constraints of the form xi D xj C bk. Show how to adapt the Bellman-\nFord algorithm to solve this variety of constraint system.\n24.4-7\nShow how to solve a system of difference constraints by a Bellman-Ford-like algo-\nrithm that runs on a constraint graph without the extra vertex \u00030.\n24.4-8\n?\nLet Ax \u0002 b be a system of m difference constraints in n unknowns. Show that the\nBellman-Ford algorithm, when run on the corresponding constraint graph, maxi-\nmizes Pn\niD1 xi subject to Ax \u0002 b and xi \u0002 0 for all xi.\n24.4-9\n?\nShow that the Bellman-Ford algorithm, when run on the constraint graph for a sys-\ntem Ax \u0002 b of difference constraints, minimizes the quantity .max fxig\u0005min fxig/\nsubject to Ax \u0002 b. Explain how this fact might come in handy if the algorithm is\nused to schedule construction jobs.\n24.4-10\nSuppose that every row in the matrix A of a linear program Ax \u0002 b corresponds to\na difference constraint, a single-variable constraint of the form xi \u0002 bk, or a single-\nvariable constraint of the form \u0005xi \u0002 bk. Show how to adapt the Bellman-Ford\nalgorithm to solve this variety of constraint system.\n24.4-11",
    "parent_2ba1de20-955a-4467-afe4-bf3eb6b40335": "a difference constraint, a single-variable constraint of the form xi \u0002 bk, or a single-\nvariable constraint of the form \u0005xi \u0002 bk. Show how to adapt the Bellman-Ford\nalgorithm to solve this variety of constraint system.\n24.4-11\nGive an efﬁcient algorithm to solve a system Ax \u0002 b of difference constraints\nwhen all of the elements of b are real-valued and all of the unknowns xi must be\nintegers.\n24.4-12\n?\nGive an efﬁcient algorithm to solve a system Ax \u0002 b of difference constraints\nwhen all of the elements of b are real-valued and a speciﬁed subset of some, but\nnot necessarily all, of the unknowns xi must be integers.\n24.5\nProofs of shortest-paths properties\n671\n24.5\nProofs of shortest-paths properties\nThroughout this chapter, our correctness arguments have relied on the triangle\ninequality, upper-bound property, no-path property, convergence property, path-\nrelaxation property, and predecessor-subgraph property. We stated these properties\nwithout proof at the beginning of this chapter. In this section, we prove them.\nThe triangle inequality\nIn studying breadth-ﬁrst search (Section 22.2), we proved as Lemma 22.1 a sim-\nple property of shortest distances in unweighted graphs. The triangle inequality\ngeneralizes the property to weighted graphs.\nLemma 24.10 (Triangle inequality)\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R\nand source vertex s. Then, for all edges .u; \u0003/ 2 E, we have\nı.s; \u0003/ \u0002 ı.s; u/ C w.u; \u0003/ :\nProof\nSuppose that p is a shortest path from source s to vertex \u0003. Then p has\nno more weight than any other path from s to \u0003. Speciﬁcally, path p has no more\nweight than the particular path that takes a shortest path from source s to vertex u\nand then takes edge .u; \u0003/.\nExercise 24.5-3 asks you to handle the case in which there is no shortest path\nfrom s to \u0003.\nEffects of relaxation on shortest-path estimates\nThe next group of lemmas describes how shortest-path estimates are affected when",
    "parent_1e5e2a56-0341-4b1c-af29-cd018b0a2b70": "and then takes edge .u; \u0003/.\nExercise 24.5-3 asks you to handle the case in which there is no shortest path\nfrom s to \u0003.\nEffects of relaxation on shortest-path estimates\nThe next group of lemmas describes how shortest-path estimates are affected when\nwe execute a sequence of relaxation steps on the edges of a weighted, directed\ngraph that has been initialized by INITIALIZE-SINGLE-SOURCE.\nLemma 24.11 (Upper-bound property)\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R.\nLet s 2 V be the source vertex, and let the graph be initialized by INITIALIZE-\nSINGLE-SOURCE.G; s/. Then, \u0003:d \u0006 ı.s; \u0003/ for all \u0003 2 V , and this invariant is\nmaintained over any sequence of relaxation steps on the edges of G. Moreover,\nonce \u0003:d achieves its lower bound ı.s; \u0003/, it never changes.\n672\nChapter 24\nSingle-Source Shortest Paths\nProof\nWe prove the invariant \u0003:d \u0006 ı.s; \u0003/ for all vertices \u0003 2 V by induction\nover the number of relaxation steps.\nFor the basis, \u0003:d \u0006 ı.s; \u0003/ is certainly true after initialization, since \u0003:d D 1\nimplies \u0003:d \u0006 ı.s; \u0003/ for all \u0003 2 V \u0005 fsg, and since s:d D 0 \u0006 ı.s; s/ (note that\nı.s; s/ D \u00051 if s is on a negative-weight cycle and 0 otherwise).\nFor the inductive step, consider the relaxation of an edge .u; \u0003/. By the inductive\nhypothesis, x:d \u0006 ı.s; x/ for all x 2 V prior to the relaxation. The only d value\nthat may change is \u0003:d. If it changes, we have\n\u0003:d\nD\nu:d C w.u; \u0003/\n\u0006\nı.s; u/ C w.u; \u0003/\n(by the inductive hypothesis)\n\u0006\nı.s; \u0003/\n(by the triangle inequality) ,\nand so the invariant is maintained.\nTo see that the value of \u0003:d never changes once \u0003:d D ı.s; \u0003/, note that having\nachieved its lower bound, \u0003:d cannot decrease because we have just shown that\n\u0003:d \u0006 ı.s; \u0003/, and it cannot increase because relaxation steps do not increase d\nvalues.\nCorollary 24.12 (No-path property)\nSuppose that in a weighted, directed graph G D .V; E/ with weight function\nw W E ! R, no path connects a source vertex s 2 V to a given vertex \u0003 2 V .",
    "parent_6256a8df-9d09-474c-836d-e358d3cd9caa": "\u0003:d \u0006 ı.s; \u0003/, and it cannot increase because relaxation steps do not increase d\nvalues.\nCorollary 24.12 (No-path property)\nSuppose that in a weighted, directed graph G D .V; E/ with weight function\nw W E ! R, no path connects a source vertex s 2 V to a given vertex \u0003 2 V .\nThen, after the graph is initialized by INITIALIZE-SINGLE-SOURCE.G; s/, we\nhave \u0003:d D ı.s; \u0003/ D 1, and this equality is maintained as an invariant over\nany sequence of relaxation steps on the edges of G.\nProof\nBy the upper-bound property, we always have 1 D ı.s; \u0003/ \u0002 \u0003:d, and\nthus \u0003:d D 1 D ı.s; \u0003/.\nLemma 24.13\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R,\nand let .u; \u0003/ 2 E. Then, immediately after relaxing edge .u; \u0003/ by executing\nRELAX.u; \u0003; w/, we have \u0003:d \u0002 u:d C w.u; \u0003/.\nProof\nIf, just prior to relaxing edge .u; \u0003/, we have \u0003:d > u:d C w.u; \u0003/, then\n\u0003:d D u:d C w.u; \u0003/ afterward. If, instead, \u0003:d \u0002 u:d C w.u; \u0003/ just before\nthe relaxation, then neither u:d nor \u0003:d changes, and so \u0003:d \u0002 u:d C w.u; \u0003/\nafterward.\nLemma 24.14 (Convergence property)\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R,\nlet s 2 V be a source vertex, and let s ; u ! \u0003 be a shortest path in G for\n24.5\nProofs of shortest-paths properties\n673\nsome vertices u; \u0003 2 V . Suppose that G is initialized by INITIALIZE-SINGLE-\nSOURCE.G; s/ and then a sequence of relaxation steps that includes the call\nRELAX.u; \u0003; w/ is executed on the edges of G. If u:d D ı.s; u/ at any time\nprior to the call, then \u0003:d D ı.s; \u0003/ at all times after the call.\nProof\nBy the upper-bound property, if u:d D ı.s; u/ at some point prior to re-\nlaxing edge .u; \u0003/, then this equality holds thereafter. In particular, after relaxing\nedge .u; \u0003/, we have\n\u0003:d\n\u0002\nu:d C w.u; \u0003/\n(by Lemma 24.13)\nD\nı.s; u/ C w.u; \u0003/\nD\nı.s; \u0003/\n(by Lemma 24.1) .\nBy the upper-bound property, \u0003:d \u0006 ı.s; \u0003/, from which we conclude that\n\u0003:d D ı.s; \u0003/, and this equality is maintained thereafter.",
    "parent_07c1d486-c56b-44fc-822d-a000fe0c90b7": "edge .u; \u0003/, we have\n\u0003:d\n\u0002\nu:d C w.u; \u0003/\n(by Lemma 24.13)\nD\nı.s; u/ C w.u; \u0003/\nD\nı.s; \u0003/\n(by Lemma 24.1) .\nBy the upper-bound property, \u0003:d \u0006 ı.s; \u0003/, from which we conclude that\n\u0003:d D ı.s; \u0003/, and this equality is maintained thereafter.\nLemma 24.15 (Path-relaxation property)\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R,\nand let s 2 V be a source vertex. Consider any shortest path p D h\u00030; \u00031; : : : ; \u0003ki\nfrom s D \u00030 to \u0003k. If G is initialized by INITIALIZE-SINGLE-SOURCE.G; s/ and\nthen a sequence of relaxation steps occurs that includes, in order, relaxing the edges\n.\u00030; \u00031/; .\u00031; \u00032/; : : : ; .\u0003k\u00031; \u0003k/, then \u0003k:d D ı.s; \u0003k/ after these relaxations and\nat all times afterward. This property holds no matter what other edge relaxations\noccur, including relaxations that are intermixed with relaxations of the edges of p.\nProof\nWe show by induction that after the ith edge of path p is relaxed, we have\n\u0003i:d D ı.s; \u0003i/. For the basis, i D 0, and before any edges of p have been relaxed,\nwe have from the initialization that \u00030:d D s:d D 0 D ı.s; s/. By the upper-bound\nproperty, the value of s:d never changes after initialization.\nFor the inductive step, we assume that \u0003i\u00031:d D ı.s; \u0003i\u00031/, and we examine\nwhat happens when we relax edge .\u0003i\u00031; \u0003i/. By the convergence property, after\nrelaxing this edge, we have \u0003i:d D ı.s; \u0003i/, and this equality is maintained at all\ntimes thereafter.\nRelaxation and shortest-paths trees\nWe now show that once a sequence of relaxations has caused the shortest-path es-\ntimates to converge to shortest-path weights, the predecessor subgraph G\u0003 induced\nby the resulting \u0006 values is a shortest-paths tree for G. We start with the follow-\ning lemma, which shows that the predecessor subgraph always forms a rooted tree\nwhose root is the source.\n674\nChapter 24\nSingle-Source Shortest Paths\nLemma 24.16\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R,",
    "parent_e4df519b-eccc-466e-b887-45a00bbbe533": "ing lemma, which shows that the predecessor subgraph always forms a rooted tree\nwhose root is the source.\n674\nChapter 24\nSingle-Source Shortest Paths\nLemma 24.16\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R,\nlet s 2 V be a source vertex, and assume that G contains no negative-weight\ncycles that are reachable from s. Then, after the graph is initialized by INITIALIZE-\nSINGLE-SOURCE.G; s/, the predecessor subgraph G\u0003 forms a rooted tree with\nroot s, and any sequence of relaxation steps on edges of G maintains this property\nas an invariant.\nProof\nInitially, the only vertex in G\u0003 is the source vertex, and the lemma is triv-\nially true. Consider a predecessor subgraph G\u0003 that arises after a sequence of\nrelaxation steps. We shall ﬁrst prove that G\u0003 is acyclic. Suppose for the sake of\ncontradiction that some relaxation step creates a cycle in the graph G\u0003. Let the cy-\ncle be c D h\u00030;\u00031;: : : ;\u0003ki, where \u0003k D \u00030. Then, \u0003i:\u0006 D \u0003i\u00031 for i D 1; 2; : : : ; k\nand, without loss of generality, we can assume that relaxing edge .\u0003k\u00031; \u0003k/ created\nthe cycle in G\u0003.\nWe claim that all vertices on cycle c are reachable from the source s. Why?\nEach vertex on c has a non-NIL predecessor, and so each vertex on c was assigned\na ﬁnite shortest-path estimate when it was assigned its non-NIL \u0006 value. By the\nupper-bound property, each vertex on cycle c has a ﬁnite shortest-path weight,\nwhich implies that it is reachable from s.\nWe shall examine the shortest-path estimates on c just prior to the call\nRELAX.\u0003k\u00031; \u0003k; w/ and show that c is a negative-weight cycle, thereby contra-\ndicting the assumption that G contains no negative-weight cycles that are reachable\nfrom the source. Just before the call, we have \u0003i:\u0006 D \u0003i\u00031 for i D 1; 2; : : : ; k \u0005 1.\nThus, for i D 1; 2; : : : ; k \u0005 1, the last update to \u0003i:d was by the assignment\n\u0003i:d D \u0003i\u00031:dCw.\u0003i\u00031; \u0003i/. If \u0003i\u00031:d changed since then, it decreased. Therefore,\njust before the call RELAX.\u0003k\u00031; \u0003k; w/, we have",
    "parent_669cafc3-cbc9-4538-8c6c-4bcda6c2797c": "from the source. Just before the call, we have \u0003i:\u0006 D \u0003i\u00031 for i D 1; 2; : : : ; k \u0005 1.\nThus, for i D 1; 2; : : : ; k \u0005 1, the last update to \u0003i:d was by the assignment\n\u0003i:d D \u0003i\u00031:dCw.\u0003i\u00031; \u0003i/. If \u0003i\u00031:d changed since then, it decreased. Therefore,\njust before the call RELAX.\u0003k\u00031; \u0003k; w/, we have\n\u0003i:d \u0006 \u0003i\u00031:d C w.\u0003i\u00031; \u0003i/\nfor all i D 1; 2; : : : ; k \u0005 1 :\n(24.12)\nBecause \u0003k:\u0006 is changed by the call, immediately beforehand we also have the\nstrict inequality\n\u0003k:d > \u0003k\u00031:d C w.\u0003k\u00031; \u0003k/ :\nSumming this strict inequality with the k \u0005 1 inequalities (24.12), we obtain the\nsum of the shortest-path estimates around cycle c:\nk\nX\niD1\n\u0003i:d\n>\nk\nX\niD1\n.\u0003i\u00031:d C w.\u0003i\u00031; \u0003i//\nD\nk\nX\niD1\n\u0003i\u00031:d C\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ :\n24.5\nProofs of shortest-paths properties\n675\ns\nu\nx\ny\nz\nv\nFigure 24.9\nShowing that a simple path in G\u0003 from source s to vertex \u0003 is unique. If there are two\npaths p1 (s ; u ; x ! ´ ; \u0003) and p2 (s ; u ; y ! ´ ; \u0003), where x ¤ y, then ´:\u0006 D x\nand ´:\u0006 D y, a contradiction.\nBut\nk\nX\niD1\n\u0003i:d D\nk\nX\niD1\n\u0003i\u00031:d ;\nsince each vertex in the cycle c appears exactly once in each summation. This\nequality implies\n0 >\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ :\nThus, the sum of weights around the cycle c is negative, which provides the desired\ncontradiction.\nWe have now proven that G\u0003 is a directed, acyclic graph. To show that it forms\na rooted tree with root s, it sufﬁces (see Exercise B.5-2) to prove that for each\nvertex \u0003 2 V\u0003, there is a unique simple path from s to \u0003 in G\u0003.\nWe ﬁrst must show that a path from s exists for each vertex in V\u0003. The ver-\ntices in V\u0003 are those with non-NIL \u0006 values, plus s. The idea here is to prove by\ninduction that a path exists from s to all vertices in V\u0003. We leave the details as\nExercise 24.5-6.\nTo complete the proof of the lemma, we must now show that for any vertex\n\u0003 2 V\u0003, the graph G\u0003 contains at most one simple path from s to \u0003. Suppose other-\nwise. That is, suppose that, as Figure 24.9 illustrates, G\u0003 contains two simple paths",
    "parent_49263af6-f1e6-406b-aec3-d8379bfb8665": "Exercise 24.5-6.\nTo complete the proof of the lemma, we must now show that for any vertex\n\u0003 2 V\u0003, the graph G\u0003 contains at most one simple path from s to \u0003. Suppose other-\nwise. That is, suppose that, as Figure 24.9 illustrates, G\u0003 contains two simple paths\nfrom s to some vertex \u0003: p1, which we decompose into s ; u ; x ! ´ ; \u0003,\nand p2, which we decompose into s ; u ; y ! ´ ; \u0003, where x ¤ y (though u\ncould be s and ´ could be \u0003). But then, ´:\u0006 D x and ´:\u0006 D y, which implies\nthe contradiction that x D y. We conclude that G\u0003 contains a unique simple path\nfrom s to \u0003, and thus G\u0003 forms a rooted tree with root s.\nWe can now show that if, after we have performed a sequence of relaxation steps,\nall vertices have been assigned their true shortest-path weights, then the predeces-\nsor subgraph G\u0003 is a shortest-paths tree.\n676\nChapter 24\nSingle-Source Shortest Paths\nLemma 24.17 (Predecessor-subgraph property)\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R,\nlet s 2 V be a source vertex, and assume that G contains no negative-weight cycles\nthat are reachable from s. Let us call INITIALIZE-SINGLE-SOURCE.G; s/ and then\nexecute any sequence of relaxation steps on edges of G that produces \u0003:d D ı.s; \u0003/\nfor all \u0003 2 V . Then, the predecessor subgraph G\u0003 is a shortest-paths tree rooted\nat s.\nProof\nWe must prove that the three properties of shortest-paths trees given on\npage 647 hold for G\u0003. To show the ﬁrst property, we must show that V\u0003 is the set\nof vertices reachable from s. By deﬁnition, a shortest-path weight ı.s; \u0003/ is ﬁnite\nif and only if \u0003 is reachable from s, and thus the vertices that are reachable from s\nare exactly those with ﬁnite d values. But a vertex \u0003 2 V \u0005 fsg has been assigned\na ﬁnite value for \u0003:d if and only if \u0003:\u0006 ¤ NIL. Thus, the vertices in V\u0003 are exactly\nthose reachable from s.\nThe second property follows directly from Lemma 24.16.\nIt remains, therefore, to prove the last property of shortest-paths trees: for each",
    "parent_fb235bc4-7cc4-4b6d-b556-3723041750cb": "a ﬁnite value for \u0003:d if and only if \u0003:\u0006 ¤ NIL. Thus, the vertices in V\u0003 are exactly\nthose reachable from s.\nThe second property follows directly from Lemma 24.16.\nIt remains, therefore, to prove the last property of shortest-paths trees: for each\nvertex \u0003 2 V\u0003, the unique simple path s\np; \u0003 in G\u0003 is a shortest path from s to \u0003\nin G. Let p D h\u00030; \u00031; : : : ; \u0003ki, where \u00030 D s and \u0003k D \u0003. For i D 1; 2; : : : ; k,\nwe have both \u0003i:d D ı.s; \u0003i/ and \u0003i:d \u0006 \u0003i\u00031:d C w.\u0003i\u00031; \u0003i/, from which we\nconclude w.\u0003i\u00031; \u0003i/ \u0002 ı.s; \u0003i/ \u0005 ı.s; \u0003i\u00031/. Summing the weights along path p\nyields\nw.p/\nD\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/\n\u0002\nk\nX\niD1\n.ı.s; \u0003i/ \u0005 ı.s; \u0003i\u00031//\nD\nı.s; \u0003k/ \u0005 ı.s; \u00030/\n(because the sum telescopes)\nD\nı.s; \u0003k/\n(because ı.s; \u00030/ D ı.s; s/ D 0) .\nThus, w.p/ \u0002 ı.s; \u0003k/. Since ı.s; \u0003k/ is a lower bound on the weight of any path\nfrom s to \u0003k, we conclude that w.p/ D ı.s; \u0003k/, and thus p is a shortest path\nfrom s to \u0003 D \u0003k.\nExercises\n24.5-1\nGive two shortest-paths trees for the directed graph of Figure 24.2 (on page 648)\nother than the two shown.\n24.5\nProofs of shortest-paths properties\n677\n24.5-2\nGive an example of a weighted, directed graph G D .V; E/ with weight function\nw W E ! R and source vertex s such that G satisﬁes the following property: For\nevery edge .u; \u0003/ 2 E, there is a shortest-paths tree rooted at s that contains .u; \u0003/\nand another shortest-paths tree rooted at s that does not contain .u; \u0003/.\n24.5-3\nEmbellish the proof of Lemma 24.10 to handle cases in which shortest-path\nweights are 1 or \u00051.\n24.5-4\nLet G D .V; E/ be a weighted, directed graph with source vertex s, and let G\nbe initialized by INITIALIZE-SINGLE-SOURCE.G; s/. Prove that if a sequence of\nrelaxation steps sets s:\u0006 to a non-NIL value, then G contains a negative-weight\ncycle.\n24.5-5\nLet G D .V; E/ be a weighted, directed graph with no negative-weight edges. Let\ns 2 V be the source vertex, and suppose that we allow \u0003:\u0006 to be the predecessor",
    "parent_cdcaa0e1-dd41-4962-9113-ae275df74c46": "relaxation steps sets s:\u0006 to a non-NIL value, then G contains a negative-weight\ncycle.\n24.5-5\nLet G D .V; E/ be a weighted, directed graph with no negative-weight edges. Let\ns 2 V be the source vertex, and suppose that we allow \u0003:\u0006 to be the predecessor\nof \u0003 on any shortest path to \u0003 from source s if \u0003 2 V \u0005 fsg is reachable from s,\nand NIL otherwise. Give an example of such a graph G and an assignment of \u0006\nvalues that produces a cycle in G\u0003. (By Lemma 24.16, such an assignment cannot\nbe produced by a sequence of relaxation steps.)\n24.5-6\nLet G D .V; E/ be a weighted, directed graph with weight function w W E ! R\nand no negative-weight cycles. Let s 2 V be the source vertex, and let G be initial-\nized by INITIALIZE-SINGLE-SOURCE.G; s/. Prove that for every vertex \u0003 2 V\u0003,\nthere exists a path from s to \u0003 in G\u0003 and that this property is maintained as an\ninvariant over any sequence of relaxations.\n24.5-7\nLet G D .V; E/ be a weighted, directed graph that contains no negative-weight\ncycles. Let s 2 V be the source vertex, and let G be initialized by INITIALIZE-\nSINGLE-SOURCE.G; s/. Prove that there exists a sequence of jV j \u0005 1 relaxation\nsteps that produces \u0003:d D ı.s; \u0003/ for all \u0003 2 V .\n24.5-8\nLet G be an arbitrary weighted, directed graph with a negative-weight cycle reach-\nable from the source vertex s. Show how to construct an inﬁnite sequence of relax-\nations of the edges of G such that every relaxation causes a shortest-path estimate\nto change.\n678\nChapter 24\nSingle-Source Shortest Paths\nProblems\n24-1\nYen’s improvement to Bellman-Ford\nSuppose that we order the edge relaxations in each pass of the Bellman-Ford al-\ngorithm as follows.\nBefore the ﬁrst pass, we assign an arbitrary linear order\n\u00031; \u00032; : : : ; \u0003jV j to the vertices of the input graph G D .V; E/. Then, we parti-\ntion the edge set E into Ef [ Eb, where Ef D f.\u0003i; \u0003j/ 2 E W i < j g and\nEb D f.\u0003i; \u0003j/ 2 E W i > j g. (Assume that G contains no self-loops, so that every",
    "parent_2d0cdb94-5493-4ac9-b15d-30d638dbab55": "Before the ﬁrst pass, we assign an arbitrary linear order\n\u00031; \u00032; : : : ; \u0003jV j to the vertices of the input graph G D .V; E/. Then, we parti-\ntion the edge set E into Ef [ Eb, where Ef D f.\u0003i; \u0003j/ 2 E W i < j g and\nEb D f.\u0003i; \u0003j/ 2 E W i > j g. (Assume that G contains no self-loops, so that every\nedge is in either Ef or Eb.) Deﬁne Gf D .V; Ef / and Gb D .V; Eb/.\na. Prove that Gf is acyclic with topological sort h\u00031; \u00032; : : : ; \u0003jV ji and that Gb is\nacyclic with topological sort h\u0003jV j; \u0003jV j\u00031; : : : ; \u00031i.\nSuppose that we implement each pass of the Bellman-Ford algorithm in the fol-\nlowing way. We visit each vertex in the order \u00031; \u00032; : : : ; \u0003jV j, relaxing edges of Ef\nthat leave the vertex. We then visit each vertex in the order \u0003jV j; \u0003jV j\u00031; : : : ; \u00031,\nrelaxing edges of Eb that leave the vertex.\nb. Prove that with this scheme, if G contains no negative-weight cycles that are\nreachable from the source vertex s, then after only djV j =2e passes over the\nedges, \u0003:d D ı.s; \u0003/ for all vertices \u0003 2 V .\nc. Does this scheme improve the asymptotic running time of the Bellman-Ford\nalgorithm?\n24-2\nNesting boxes\nA d-dimensional box with dimensions .x1; x2; : : : ; xd/ nests within another box\nwith dimensions .y1; y2; : : : ; yd/ if there exists a permutation \u0006 on f1; 2; : : : ; dg\nsuch that x\u0003.1/ < y1, x\u0003.2/ < y2, . . . , x\u0003.d/ < yd.\na. Argue that the nesting relation is transitive.\nb. Describe an efﬁcient method to determine whether or not one d-dimensional\nbox nests inside another.\nc. Suppose that you are given a set of n d-dimensional boxes fB1; B2; : : : ; Bng.\nGive an efﬁcient algorithm to ﬁnd the longest sequence hBi1; Bi2; : : : ; Biki of\nboxes such that Bij nests within BijC1 for j D 1; 2; : : : ; k \u0005 1. Express the\nrunning time of your algorithm in terms of n and d.\nProblems for Chapter 24\n679\n24-3\nArbitrage\nArbitrage is the use of discrepancies in currency exchange rates to transform one",
    "parent_85d6c833-3070-4d36-8173-95106eb7528e": "boxes such that Bij nests within BijC1 for j D 1; 2; : : : ; k \u0005 1. Express the\nrunning time of your algorithm in terms of n and d.\nProblems for Chapter 24\n679\n24-3\nArbitrage\nArbitrage is the use of discrepancies in currency exchange rates to transform one\nunit of a currency into more than one unit of the same currency. For example,\nsuppose that 1 U.S. dollar buys 49 Indian rupees, 1 Indian rupee buys 2 Japanese\nyen, and 1 Japanese yen buys 0:0107 U.S. dollars. Then, by converting currencies,\na trader can start with 1 U.S. dollar and buy 49\t2\t0:0107 D 1:0486 U.S. dollars,\nthus turning a proﬁt of 4:86 percent.\nSuppose that we are given n currencies c1; c2; : : : ; cn and an n \t n table R of\nexchange rates, such that one unit of currency ci buys RŒi; j \u0002 units of currency cj.\na. Give an efﬁcient algorithm to determine whether or not there exists a sequence\nof currencies hci1; ci2; : : : ; ciki such that\nRŒi1; i2\u0002 \u0003 RŒi2; i3\u0002 \u0003 \u0003 \u0003 RŒik\u00031; ik\u0002 \u0003 RŒik; i1\u0002 > 1 :\nAnalyze the running time of your algorithm.\nb. Give an efﬁcient algorithm to print out such a sequence if one exists. Analyze\nthe running time of your algorithm.\n24-4\nGabow’s scaling algorithm for single-source shortest paths\nA scaling algorithm solves a problem by initially considering only the highest-\norder bit of each relevant input value (such as an edge weight). It then reﬁnes the\ninitial solution by looking at the two highest-order bits. It progressively looks at\nmore and more high-order bits, reﬁning the solution each time, until it has exam-\nined all bits and computed the correct solution.\nIn this problem, we examine an algorithm for computing the shortest paths from\na single source by scaling edge weights. We are given a directed graph G D .V; E/\nwith nonnegative integer edge weights w. Let W D max.u;\u0005/2E fw.u; \u0003/g. Our\ngoal is to develop an algorithm that runs in O.E lg W / time. We assume that all\nvertices are reachable from the source.",
    "parent_5d92b74a-8fbc-4827-848a-7774bc3aa5c3": "a single source by scaling edge weights. We are given a directed graph G D .V; E/\nwith nonnegative integer edge weights w. Let W D max.u;\u0005/2E fw.u; \u0003/g. Our\ngoal is to develop an algorithm that runs in O.E lg W / time. We assume that all\nvertices are reachable from the source.\nThe algorithm uncovers the bits in the binary representation of the edge weights\none at a time, from the most signiﬁcant bit to the least signiﬁcant bit. Speciﬁcally,\nlet k D dlg.W C 1/e be the number of bits in the binary representation of W ,\nand for i D 1; 2; : : : ; k, let wi.u; \u0003/ D\n\r\nw.u; \u0003/=2k\u0003i˘\n. That is, wi.u; \u0003/ is the\n“scaled-down” version of w.u; \u0003/ given by the i most signiﬁcant bits of w.u; \u0003/.\n(Thus, wk.u; \u0003/ D w.u; \u0003/ for all .u; \u0003/ 2 E.) For example, if k D 5 and\nw.u; \u0003/ D 25, which has the binary representation h11001i, then w3.u; \u0003/ D\nh110i D 6. As another example with k D 5, if w.u; \u0003/ D h00100i D 4, then\nw3.u; \u0003/ D h001i D 1. Let us deﬁne ıi.u; \u0003/ as the shortest-path weight from\nvertex u to vertex \u0003 using weight function wi. Thus, ık.u; \u0003/ D ı.u; \u0003/ for all\nu; \u0003 2 V . For a given source vertex s, the scaling algorithm ﬁrst computes the\n680\nChapter 24\nSingle-Source Shortest Paths\nshortest-path weights ı1.s; \u0003/ for all \u0003 2 V , then computes ı2.s; \u0003/ for all \u0003 2 V ,\nand so on, until it computes ık.s; \u0003/ for all \u0003 2 V . We assume throughout that\njEj \u0006 jV j \u0005 1, and we shall see that computing ıi from ıi\u00031 takes O.E/ time, so\nthat the entire algorithm takes O.kE/ D O.E lg W / time.\na. Suppose that for all vertices \u0003 2 V , we have ı.s; \u0003/ \u0002 jEj. Show that we can\ncompute ı.s; \u0003/ for all \u0003 2 V in O.E/ time.\nb. Show that we can compute ı1.s; \u0003/ for all \u0003 2 V in O.E/ time.\nLet us now focus on computing ıi from ıi\u00031.\nc. Prove that for i D 2; 3; : : : ; k, we have either wi.u; \u0003/ D 2wi\u00031.u; \u0003/ or\nwi.u; \u0003/ D 2wi\u00031.u; \u0003/ C 1. Then, prove that\n2ıi\u00031.s; \u0003/ \u0002 ıi.s; \u0003/ \u0002 2ıi\u00031.s; \u0003/ C jV j \u0005 1\nfor all \u0003 2 V .\nd. Deﬁne for i D 2; 3; : : : ; k and all .u; \u0003/ 2 E,",
    "parent_6f44a7d2-ef68-4fe1-872e-662ed5a06fc8": "Let us now focus on computing ıi from ıi\u00031.\nc. Prove that for i D 2; 3; : : : ; k, we have either wi.u; \u0003/ D 2wi\u00031.u; \u0003/ or\nwi.u; \u0003/ D 2wi\u00031.u; \u0003/ C 1. Then, prove that\n2ıi\u00031.s; \u0003/ \u0002 ıi.s; \u0003/ \u0002 2ıi\u00031.s; \u0003/ C jV j \u0005 1\nfor all \u0003 2 V .\nd. Deﬁne for i D 2; 3; : : : ; k and all .u; \u0003/ 2 E,\nywi.u; \u0003/ D wi.u; \u0003/ C 2ıi\u00031.s; u/ \u0005 2ıi\u00031.s; \u0003/ :\nProve that for i D 2; 3; : : : ; k and all u; \u0003 2 V , the “reweighted” value ywi.u; \u0003/\nof edge .u; \u0003/ is a nonnegative integer.\ne. Now, deﬁne yıi.s; \u0003/ as the shortest-path weight from s to \u0003 using the weight\nfunction ywi. Prove that for i D 2; 3; : : : ; k and all \u0003 2 V ,\nıi.s; \u0003/ D yıi.s; \u0003/ C 2ıi\u00031.s; \u0003/\nand that yıi.s; \u0003/ \u0002 jEj.\nf.\nShow how to compute ıi.s; \u0003/ from ıi\u00031.s; \u0003/ for all \u0003 2 V in O.E/ time, and\nconclude that we can compute ı.s; \u0003/ for all \u0003 2 V in O.E lg W / time.\n24-5\nKarp’s minimum mean-weight cycle algorithm\nLet G D .V; E/ be a directed graph with weight function w W E ! R, and let\nn D jV j. We deﬁne the mean weight of a cycle c D he1; e2; : : : ; eki of edges in E\nto be\n\r.c/ D 1\nk\nk\nX\niD1\nw.ei/ :\nProblems for Chapter 24\n681\nLet \r\u0004 D minc \r.c/, where c ranges over all directed cycles in G. We call a cycle c\nfor which \r.c/ D \r\u0004 a minimum mean-weight cycle. This problem investigates\nan efﬁcient algorithm for computing \r\u0004.\nAssume without loss of generality that every vertex \u0003 2 V is reachable from a\nsource vertex s 2 V . Let ı.s; \u0003/ be the weight of a shortest path from s to \u0003, and let\nık.s; \u0003/ be the weight of a shortest path from s to \u0003 consisting of exactly k edges.\nIf there is no path from s to \u0003 with exactly k edges, then ık.s; \u0003/ D 1.\na. Show that if \r\u0004 D 0, then G contains no negative-weight cycles and ı.s; \u0003/ D\nmin0\u0005k\u0005n\u00031 ık.s; \u0003/ for all vertices \u0003 2 V .\nb. Show that if \r\u0004 D 0, then\nmax\n0\u0005k\u0005n\u00031\nın.s; \u0003/ \u0005 ık.s; \u0003/\nn \u0005 k\n\u0006 0\nfor all vertices \u0003 2 V . (Hint: Use both properties from part (a).)\nc. Let c be a 0-weight cycle, and let u and \u0003 be any two vertices on c. Suppose",
    "parent_6022f8e2-0c80-4308-9cb3-23add8e72d4a": "min0\u0005k\u0005n\u00031 ık.s; \u0003/ for all vertices \u0003 2 V .\nb. Show that if \r\u0004 D 0, then\nmax\n0\u0005k\u0005n\u00031\nın.s; \u0003/ \u0005 ık.s; \u0003/\nn \u0005 k\n\u0006 0\nfor all vertices \u0003 2 V . (Hint: Use both properties from part (a).)\nc. Let c be a 0-weight cycle, and let u and \u0003 be any two vertices on c. Suppose\nthat \r\u0004 D 0 and that the weight of the simple path from u to \u0003 along the cycle\nis x. Prove that ı.s; \u0003/ D ı.s; u/ C x. (Hint: The weight of the simple path\nfrom \u0003 to u along the cycle is \u0005x.)\nd. Show that if \r\u0004 D 0, then on each minimum mean-weight cycle there exists a\nvertex \u0003 such that\nmax\n0\u0005k\u0005n\u00031\nın.s; \u0003/ \u0005 ık.s; \u0003/\nn \u0005 k\nD 0 :\n(Hint: Show how to extend a shortest path to any vertex on a minimum mean-\nweight cycle along the cycle to make a shortest path to the next vertex on the\ncycle.)\ne. Show that if \r\u0004 D 0, then\nmin\n\u00052V\nmax\n0\u0005k\u0005n\u00031\nın.s; \u0003/ \u0005 ık.s; \u0003/\nn \u0005 k\nD 0 :\nf. Show that if we add a constant t to the weight of each edge of G, then \r\u0004\nincreases by t. Use this fact to show that\n\r\u0004 D min\n\u00052V\nmax\n0\u0005k\u0005n\u00031\nın.s; \u0003/ \u0005 ık.s; \u0003/\nn \u0005 k\n:\ng. Give an O.VE/-time algorithm to compute \r\u0004.\n682\nChapter 24\nSingle-Source Shortest Paths\n24-6\nBitonic shortest paths\nA sequence is bitonic if it monotonically increases and then monotonically de-\ncreases, or if by a circular shift it monotonically increases and then monotonically\ndecreases. For example the sequences h1; 4; 6; 8; 3; \u00052i, h9; 2; \u00054; \u000510; \u00055i, and\nh1; 2; 3; 4i are bitonic, but h1; 3; 12; 4; 2; 10i is not bitonic. (See Problem 15-3 for\nthe bitonic euclidean traveling-salesman problem.)\nSuppose that we are given a directed graph G D .V; E/ with weight function\nw W E ! R, where all edge weights are unique, and we wish to ﬁnd single-source\nshortest paths from a source vertex s. We are given one additional piece of infor-\nmation: for each vertex \u0003 2 V , the weights of the edges along any shortest path\nfrom s to \u0003 form a bitonic sequence.\nGive the most efﬁcient algorithm you can to solve this problem, and analyze its\nrunning time.\nChapter notes",
    "parent_ad70dd8e-43a2-4166-99f1-95f2168c0e69": "mation: for each vertex \u0003 2 V , the weights of the edges along any shortest path\nfrom s to \u0003 form a bitonic sequence.\nGive the most efﬁcient algorithm you can to solve this problem, and analyze its\nrunning time.\nChapter notes\nDijkstra’s algorithm [88] appeared in 1959, but it contained no mention of a priority\nqueue. The Bellman-Ford algorithm is based on separate algorithms by Bellman\n[38] and Ford [109]. Bellman describes the relation of shortest paths to difference\nconstraints. Lawler [224] describes the linear-time algorithm for shortest paths in\na dag, which he considers part of the folklore.\nWhen edge weights are relatively small nonnegative integers, we have more ef-\nﬁcient algorithms to solve the single-source shortest-paths problem. The sequence\nof values returned by the EXTRACT-MIN calls in Dijkstra’s algorithm monoton-\nically increases over time. As discussed in the chapter notes for Chapter 6, in\nthis case several data structures can implement the various priority-queue opera-\ntions more efﬁciently than a binary heap or a Fibonacci heap. Ahuja, Mehlhorn,\nOrlin, and Tarjan [8] give an algorithm that runs in O.E C V\np\nlg W / time on\ngraphs with nonnegative edge weights, where W is the largest weight of any edge\nin the graph. The best bounds are by Thorup [337], who gives an algorithm that\nruns in O.E lg lg V / time, and by Raman [291], who gives an algorithm that runs\nin O\n\u000b\nE C V min\n˚\n.lg V /1=3C\u0002; .lg W /1=4C\u0002\n\f\ntime. These two algorithms use an\namount of space that depends on the word size of the underlying machine. Al-\nthough the amount of space used can be unbounded in the size of the input, it can\nbe reduced to be linear in the size of the input using randomized hashing.\nFor undirected graphs with integer weights, Thorup [336] gives an O.V C E/-\ntime algorithm for single-source shortest paths. In contrast to the algorithms men-\ntioned in the previous paragraph, this algorithm is not an implementation of Dijk-\nNotes for Chapter 24\n683",
    "parent_eee667be-da2e-40fd-8967-e11790766cdb": "For undirected graphs with integer weights, Thorup [336] gives an O.V C E/-\ntime algorithm for single-source shortest paths. In contrast to the algorithms men-\ntioned in the previous paragraph, this algorithm is not an implementation of Dijk-\nNotes for Chapter 24\n683\nstra’s algorithm, since the sequence of values returned by EXTRACT-MIN calls\ndoes not monotonically increase over time.\nFor graphs with negative edge weights, an algorithm due to Gabow and Tar-\njan [122] runs in O.\np\nV E lg.V W // time, and one by Goldberg [137] runs in\nO.\np\nV E lg W / time, where W D max.u;\u0005/2E fjw.u; \u0003/jg.\nCherkassky, Goldberg, and Radzik [64] conducted extensive experiments com-\nparing various shortest-path algorithms.\n25\nAll-Pairs Shortest Paths\nIn this chapter, we consider the problem of ﬁnding shortest paths between all pairs\nof vertices in a graph. This problem might arise in making a table of distances be-\ntween all pairs of cities for a road atlas. As in Chapter 24, we are given a weighted,\ndirected graph G D .V; E/ with a weight function w W E ! R that maps edges\nto real-valued weights. We wish to ﬁnd, for every pair of vertices u; \u0003 2 V , a\nshortest (least-weight) path from u to \u0003, where the weight of a path is the sum of\nthe weights of its constituent edges. We typically want the output in tabular form:\nthe entry in u’s row and \u0003’s column should be the weight of a shortest path from u\nto \u0003.\nWe can solve an all-pairs shortest-paths problem by running a single-source\nshortest-paths algorithm jV j times, once for each vertex as the source.\nIf all\nedge weights are nonnegative, we can use Dijkstra’s algorithm.\nIf we use\nthe linear-array implementation of the min-priority queue, the running time is\nO.V 3 C VE/ D O.V 3/. The binary min-heap implementation of the min-priority\nqueue yields a running time of O.VE lg V /, which is an improvement if the graph\nis sparse. Alternatively, we can implement the min-priority queue with a Fibonacci",
    "parent_d9295526-3af5-4ed6-aac7-e8c54d2a149e": "O.V 3 C VE/ D O.V 3/. The binary min-heap implementation of the min-priority\nqueue yields a running time of O.VE lg V /, which is an improvement if the graph\nis sparse. Alternatively, we can implement the min-priority queue with a Fibonacci\nheap, yielding a running time of O.V 2 lg V C VE/.\nIf the graph has negative-weight edges, we cannot use Dijkstra’s algorithm. In-\nstead, we must run the slower Bellman-Ford algorithm once from each vertex. The\nresulting running time is O.V 2E/, which on a dense graph is O.V 4/. In this chap-\nter we shall see how to do better. We also investigate the relation of the all-pairs\nshortest-paths problem to matrix multiplication and study its algebraic structure.\nUnlike the single-source algorithms, which assume an adjacency-list represen-\ntation of the graph, most of the algorithms in this chapter use an adjacency-\nmatrix representation. (Johnson’s algorithm for sparse graphs, in Section 25.3,\nuses adjacency lists.) For convenience, we assume that the vertices are numbered\n1; 2; : : : ; jV j, so that the input is an n \t n matrix W representing the edge weights\nof an n-vertex directed graph G D .V; E/. That is, W D .wij/, where\nChapter 25\nAll-Pairs Shortest Paths\n685\nwij D\n\u0002\n0\nif i D j ;\nthe weight of directed edge .i; j /\nif i ¤ j and .i; j / 2 E ;\n1\nif i ¤ j and .i; j / 62 E :\n(25.1)\nWe allow negative-weight edges, but we assume for the time being that the input\ngraph contains no negative-weight cycles.\nThe tabular output of the all-pairs shortest-paths algorithms presented in this\nchapter is an n \t n matrix D D .dij/, where entry dij contains the weight of a\nshortest path from vertex i to vertex j . That is, if we let ı.i; j / denote the shortest-\npath weight from vertex i to vertex j (as in Chapter 24), then dij D ı.i; j / at\ntermination.\nTo solve the all-pairs shortest-paths problem on an input adjacency matrix, we\nneed to compute not only the shortest-path weights but also a predecessor matrix",
    "parent_cec5199a-1886-4bfc-84ba-9991d7073976": "path weight from vertex i to vertex j (as in Chapter 24), then dij D ı.i; j / at\ntermination.\nTo solve the all-pairs shortest-paths problem on an input adjacency matrix, we\nneed to compute not only the shortest-path weights but also a predecessor matrix\n… D .\u0006ij /, where \u0006ij is NIL if either i D j or there is no path from i to j ,\nand otherwise \u0006ij is the predecessor of j on some shortest path from i. Just as\nthe predecessor subgraph G\u0003 from Chapter 24 is a shortest-paths tree for a given\nsource vertex, the subgraph induced by the ith row of the … matrix should be a\nshortest-paths tree with root i. For each vertex i 2 V , we deﬁne the predecessor\nsubgraph of G for i as G\u0003;i D .V\u0003;i; E\u0003;i/ , where\nV\u0003;i D fj 2 V W \u0006ij ¤ NILg [ fig\nand\nE\u0003;i D f.\u0006ij; j / W j 2 V\u0003;i \u0005 figg :\nIf G\u0003;i is a shortest-paths tree, then the following procedure, which is a modiﬁed\nversion of the PRINT-PATH procedure from Chapter 22, prints a shortest path from\nvertex i to vertex j .\nPRINT-ALL-PAIRS-SHORTEST-PATH.…; i; j /\n1\nif i == j\n2\nprint i\n3\nelseif \u0006ij == NIL\n4\nprint “no path from” i “to” j “exists”\n5\nelse PRINT-ALL-PAIRS-SHORTEST-PATH.…; i; \u0006ij /\n6\nprint j\nIn order to highlight the essential features of the all-pairs algorithms in this chapter,\nwe won’t cover the creation and properties of predecessor matrices as extensively\nas we dealt with predecessor subgraphs in Chapter 24. Some of the exercises cover\nthe basics.\n686\nChapter 25\nAll-Pairs Shortest Paths\nChapter outline\nSection 25.1 presents a dynamic-programming algorithm based on matrix multi-\nplication to solve the all-pairs shortest-paths problem. Using the technique of “re-\npeated squaring,” we can achieve a running time of ‚.V 3 lg V /. Section 25.2 gives\nanother dynamic-programming algorithm, the Floyd-Warshall algorithm, which\nruns in time ‚.V 3/. Section 25.2 also covers the problem of ﬁnding the tran-\nsitive closure of a directed graph, which is related to the all-pairs shortest-paths",
    "parent_52a17429-70ae-4810-be5e-7bae2550c7fa": "another dynamic-programming algorithm, the Floyd-Warshall algorithm, which\nruns in time ‚.V 3/. Section 25.2 also covers the problem of ﬁnding the tran-\nsitive closure of a directed graph, which is related to the all-pairs shortest-paths\nproblem. Finally, Section 25.3 presents Johnson’s algorithm, which solves the all-\npairs shortest-paths problem in O.V 2 lg V C VE/ time and is a good choice for\nlarge, sparse graphs.\nBefore proceeding, we need to establish some conventions for adjacency-matrix\nrepresentations. First, we shall generally assume that the input graph G D .V; E/\nhas n vertices, so that n D jV j. Second, we shall use the convention of denoting\nmatrices by uppercase letters, such as W , L, or D, and their individual elements\nby subscripted lowercase letters, such as wij, lij, or dij. Some matrices will have\nparenthesized superscripts, as in L.m/ D\n\u000b\nl.m/\nij\n\f\nor D.m/ D\n\u000b\nd .m/\nij\n\f\n, to indicate\niterates. Finally, for a given n \t n matrix A, we shall assume that the value of n is\nstored in the attribute A:rows.\n25.1\nShortest paths and matrix multiplication\nThis section presents a dynamic-programming algorithm for the all-pairs shortest-\npaths problem on a directed graph G D .V; E/. Each major loop of the dynamic\nprogram will invoke an operation that is very similar to matrix multiplication, so\nthat the algorithm will look like repeated matrix multiplication. We shall start by\ndeveloping a ‚.V 4/-time algorithm for the all-pairs shortest-paths problem and\nthen improve its running time to ‚.V 3 lg V /.\nBefore proceeding, let us brieﬂy recap the steps given in Chapter 15 for devel-\noping a dynamic-programming algorithm.\n1. Characterize the structure of an optimal solution.\n2. Recursively deﬁne the value of an optimal solution.\n3. Compute the value of an optimal solution in a bottom-up fashion.\nWe reserve the fourth step—constructing an optimal solution from computed in-\nformation—for the exercises.\n25.1\nShortest paths and matrix multiplication\n687",
    "parent_df3e23d8-459b-4fb4-8824-df3bbcecaf55": "2. Recursively deﬁne the value of an optimal solution.\n3. Compute the value of an optimal solution in a bottom-up fashion.\nWe reserve the fourth step—constructing an optimal solution from computed in-\nformation—for the exercises.\n25.1\nShortest paths and matrix multiplication\n687\nThe structure of a shortest path\nWe start by characterizing the structure of an optimal solution. For the all-pairs\nshortest-paths problem on a graph G D .V; E/, we have proven (Lemma 24.1)\nthat all subpaths of a shortest path are shortest paths. Suppose that we represent\nthe graph by an adjacency matrix W D .wij/. Consider a shortest path p from\nvertex i to vertex j , and suppose that p contains at most m edges. Assuming that\nthere are no negative-weight cycles, m is ﬁnite. If i D j , then p has weight 0\nand no edges. If vertices i and j are distinct, then we decompose path p into\ni\np0\n; k ! j , where path p0 now contains at most m \u0005 1 edges. By Lemma 24.1,\np0 is a shortest path from i to k, and so ı.i; j / D ı.i; k/ C wkj.\nA recursive solution to the all-pairs shortest-paths problem\nNow, let l.m/\nij\nbe the minimum weight of any path from vertex i to vertex j that\ncontains at most m edges. When m D 0, there is a shortest path from i to j with\nno edges if and only if i D j . Thus,\nl.0/\nij\nD\n(\n0\nif i D j ;\n1\nif i ¤ j :\nFor m \u0006 1, we compute l.m/\nij\nas the minimum of l.m\u00031/\nij\n(the weight of a shortest\npath from i to j consisting of at most m\u00051 edges) and the minimum weight of any\npath from i to j consisting of at most m edges, obtained by looking at all possible\npredecessors k of j . Thus, we recursively deﬁne\nl.m/\nij\nD\nmin\n\u0004\nl.m\u00031/\nij\n; min\n1\u0005k\u0005n\n˚\nl.m\u00031/\nik\nC wkj",
    "parent_7230d703-a8f0-4dfc-8777-28260d09fe94": "\u0005\nD\nmin\n1\u0005k\u0005n\n˚\nl.m\u00031/\nik\nC wkj",
    "parent_41dcc1c6-3e0a-4f55-a8d6-844dac074290": ":\n(25.2)\nThe latter equality follows since wjj D 0 for all j .\nWhat are the actual shortest-path weights ı.i; j /?\nIf the graph contains\nno negative-weight cycles, then for every pair of vertices i and j for which\nı.i; j / < 1, there is a shortest path from i to j that is simple and thus contains at\nmost n \u0005 1 edges. A path from vertex i to vertex j with more than n \u0005 1 edges\ncannot have lower weight than a shortest path from i to j . The actual shortest-path\nweights are therefore given by\nı.i; j / D l.n\u00031/\nij\nD l.n/\nij\nD l.nC1/\nij\nD \u0003 \u0003 \u0003 :\n(25.3)\n688\nChapter 25\nAll-Pairs Shortest Paths\nComputing the shortest-path weights bottom up\nTaking as our input the matrix W D .wij/, we now compute a series of matrices\nL.1/; L.2/; : : : ; L.n\u00031/, where for m D 1; 2; : : : ; n \u0005 1, we have L.m/ D\n\u000b\nl.m/\nij\n\f\n.\nThe ﬁnal matrix L.n\u00031/ contains the actual shortest-path weights. Observe that\nl.1/\nij\nD wij for all vertices i; j 2 V , and so L.1/ D W .\nThe heart of the algorithm is the following procedure, which, given matrices\nL.m\u00031/ and W , returns the matrix L.m/. That is, it extends the shortest paths com-\nputed so far by one more edge.\nEXTEND-SHORTEST-PATHS.L; W /\n1\nn D L:rows\n2\nlet L0 D\n\u000b\nl0\nij\n\f\nbe a new n \t n matrix\n3\nfor i D 1 to n\n4\nfor j D 1 to n\n5\nl0\nij D 1\n6\nfor k D 1 to n\n7\nl0\nij D min.l0\nij; lik C wkj/\n8\nreturn L0\nThe procedure computes a matrix L0 D .l0\nij /, which it returns at the end. It does so\nby computing equation (25.2) for all i and j , using L for L.m\u00031/ and L0 for L.m/.\n(It is written without the superscripts to make its input and output matrices inde-\npendent of m.) Its running time is ‚.n3/ due to the three nested for loops.\nNow we can see the relation to matrix multiplication. Suppose we wish to com-\npute the matrix product C D A \u0003 B of two n \t n matrices A and B. Then, for\ni; j D 1; 2; : : : ; n, we compute\ncij D\nn\nX\nkD1\naik \u0003 bkj :\n(25.4)\nObserve that if we make the substitutions\nl.m\u00031/\n!\na ;\nw\n!\nb ;\nl.m/\n!\nc ;\nmin\n!\nC ;\nC\n!\n\u0003",
    "parent_981192b0-a549-4149-8d98-c35439145c67": "pute the matrix product C D A \u0003 B of two n \t n matrices A and B. Then, for\ni; j D 1; 2; : : : ; n, we compute\ncij D\nn\nX\nkD1\naik \u0003 bkj :\n(25.4)\nObserve that if we make the substitutions\nl.m\u00031/\n!\na ;\nw\n!\nb ;\nl.m/\n!\nc ;\nmin\n!\nC ;\nC\n!\n\u0003\nin equation (25.2), we obtain equation (25.4). Thus, if we make these changes to\nEXTEND-SHORTEST-PATHS and also replace 1 (the identity for min) by 0 (the\n25.1\nShortest paths and matrix multiplication\n689\nidentity for C), we obtain the same ‚.n3/-time procedure for multiplying square\nmatrices that we saw in Section 4.2:\nSQUARE-MATRIX-MULTIPLY.A; B/\n1\nn D A:rows\n2\nlet C be a new n \t n matrix\n3\nfor i D 1 to n\n4\nfor j D 1 to n\n5\ncij D 0\n6\nfor k D 1 to n\n7\ncij D cij C aik \u0003 bkj\n8\nreturn C\nReturning to the all-pairs shortest-paths problem, we compute the shortest-path\nweights by extending shortest paths edge by edge. Letting A \u0003 B denote the ma-\ntrix “product” returned by EXTEND-SHORTEST-PATHS.A; B/, we compute the se-\nquence of n \u0005 1 matrices\nL.1/\nD\nL.0/ \u0003 W\nD\nW ;\nL.2/\nD\nL.1/ \u0003 W\nD\nW 2 ;\nL.3/\nD\nL.2/ \u0003 W\nD\nW 3 ;\n:::\nL.n\u00031/\nD\nL.n\u00032/ \u0003 W\nD\nW n\u00031 :\nAs we argued above, the matrix L.n\u00031/ D W n\u00031 contains the shortest-path weights.\nThe following procedure computes this sequence in ‚.n4/ time.\nSLOW-ALL-PAIRS-SHORTEST-PATHS.W /\n1\nn D W:rows\n2\nL.1/ D W\n3\nfor m D 2 to n \u0005 1\n4\nlet L.m/ be a new n \t n matrix\n5\nL.m/ D EXTEND-SHORTEST-PATHS.L.m\u00031/; W /\n6\nreturn L.n\u00031/\nFigure 25.1 shows a graph and the matrices L.m/ computed by the procedure\nSLOW-ALL-PAIRS-SHORTEST-PATHS.\nImproving the running time\nOur goal, however, is not to compute all the L.m/ matrices: we are interested\nonly in matrix L.n\u00031/. Recall that in the absence of negative-weight cycles, equa-\n690\nChapter 25\nAll-Pairs Shortest Paths\n2\n1\n3\n5\n4\n3\n4\n8\n2\n6\n7\n1\n–4\n–5\nL.1/ D\n\u0004\n0\n3\n8\n1\n\u00054\n1\n0\n1\n1\n7\n1\n4\n0\n1\n1\n2\n1\n\u00055\n0\n1\n1\n1\n1\n6\n0\n˘\nL.2/ D\n\u0004\n0\n3\n8\n2\n\u00054\n3\n0\n\u00054\n1\n7\n1\n4\n0\n5\n11\n2\n\u00051\n\u00055\n0\n\u00052\n8\n1\n1\n6\n0\n˘\nL.3/ D\n\u0004 0\n3\n\u00053\n2\n\u00054\n3\n0\n\u00054\n1\n\u00051\n7\n4\n0\n5\n11\n2\n\u00051\n\u00055\n0\n\u00052\n8\n5\n1\n6\n0\n˘\nL.4/ D\n\u0004 0\n1\n\u00053\n2\n\u00054\n3\n0\n\u00054\n1\n\u00051\n7\n4",
    "parent_786f3c8f-6292-4323-93b3-530d48ab3ce8": "All-Pairs Shortest Paths\n2\n1\n3\n5\n4\n3\n4\n8\n2\n6\n7\n1\n–4\n–5\nL.1/ D\n\u0004\n0\n3\n8\n1\n\u00054\n1\n0\n1\n1\n7\n1\n4\n0\n1\n1\n2\n1\n\u00055\n0\n1\n1\n1\n1\n6\n0\n˘\nL.2/ D\n\u0004\n0\n3\n8\n2\n\u00054\n3\n0\n\u00054\n1\n7\n1\n4\n0\n5\n11\n2\n\u00051\n\u00055\n0\n\u00052\n8\n1\n1\n6\n0\n˘\nL.3/ D\n\u0004 0\n3\n\u00053\n2\n\u00054\n3\n0\n\u00054\n1\n\u00051\n7\n4\n0\n5\n11\n2\n\u00051\n\u00055\n0\n\u00052\n8\n5\n1\n6\n0\n˘\nL.4/ D\n\u0004 0\n1\n\u00053\n2\n\u00054\n3\n0\n\u00054\n1\n\u00051\n7\n4\n0\n5\n3\n2\n\u00051\n\u00055\n0\n\u00052\n8\n5\n1\n6\n0\n˘\nFigure 25.1\nA directed graph and the sequence of matrices L.m/ computed by SLOW-ALL-PAIRS-\nSHORTEST-PATHS. You might want to verify that L.5/, deﬁned as L.4/ \u0003 W , equals L.4/, and thus\nL.m/ D L.4/ for all m \u0006 4.\ntion (25.3) implies L.m/ D L.n\u00031/ for all integers m \u0006 n \u0005 1. Just as tradi-\ntional matrix multiplication is associative, so is matrix multiplication deﬁned by\nthe EXTEND-SHORTEST-PATHS procedure (see Exercise 25.1-4). Therefore, we\ncan compute L.n\u00031/ with only dlg.n \u0005 1/e matrix products by computing the se-\nquence\nL.1/\nD\nW ;\nL.2/\nD\nW 2\nD\nW \u0003 W ;\nL.4/\nD\nW 4\nD\nW 2 \u0003 W 2\nL.8/\nD\nW 8\nD\nW 4 \u0003 W 4 ;\n:::\nL.2dlg.n\u00041/e/\nD\nW 2dlg.n\u00041/e\nD\nW 2dlg.n\u00041/e\u00041 \u0003 W 2dlg.n\u00041/e\u00041 :\nSince 2dlg.n\u00031/e \u0006 n \u0005 1, the ﬁnal product L.2dlg.n\u00041/e/ is equal to L.n\u00031/.\nThe following procedure computes the above sequence of matrices by using this\ntechnique of repeated squaring.\n25.1\nShortest paths and matrix multiplication\n691\n1\n2\n3\n5\n–1\n2\n1\n2\n3\n4\n5\n6\n–4\n–8\n10\n7\nFigure 25.2\nA weighted, directed graph for use in Exercises 25.1-1, 25.2-1, and 25.3-1.\nFASTER-ALL-PAIRS-SHORTEST-PATHS.W /\n1\nn D W:rows\n2\nL.1/ D W\n3\nm D 1\n4\nwhile m < n \u0005 1\n5\nlet L.2m/ be a new n \t n matrix\n6\nL.2m/ D EXTEND-SHORTEST-PATHS.L.m/; L.m//\n7\nm D 2m\n8\nreturn L.m/\nIn each iteration of the while loop of lines 4–7, we compute L.2m/ D\n\u000b\nL.m/\f2,\nstarting with m D 1.\nAt the end of each iteration, we double the value\nof m. The ﬁnal iteration computes L.n\u00031/ by actually computing L.2m/ for some\nn \u0005 1 \u0002 2m < 2n \u0005 2. By equation (25.3), L.2m/ D L.n\u00031/. The next time the test\nin line 4 is performed, m has been doubled, so now m \u0006 n \u0005 1, the test fails, and\nthe procedure returns the last matrix it computed.",
    "parent_4e30c127-6aac-4c7c-9ab2-00bc9e9969d8": "of m. The ﬁnal iteration computes L.n\u00031/ by actually computing L.2m/ for some\nn \u0005 1 \u0002 2m < 2n \u0005 2. By equation (25.3), L.2m/ D L.n\u00031/. The next time the test\nin line 4 is performed, m has been doubled, so now m \u0006 n \u0005 1, the test fails, and\nthe procedure returns the last matrix it computed.\nBecause each of the dlg.n \u0005 1/e matrix products takes ‚.n3/ time, FASTER-\nALL-PAIRS-SHORTEST-PATHS runs in ‚.n3 lg n/ time. Observe that the code\nis tight, containing no elaborate data structures, and the constant hidden in the\n‚-notation is therefore small.\nExercises\n25.1-1\nRun SLOW-ALL-PAIRS-SHORTEST-PATHS on the weighted, directed graph of\nFigure 25.2, showing the matrices that result for each iteration of the loop. Then\ndo the same for FASTER-ALL-PAIRS-SHORTEST-PATHS.\n25.1-2\nWhy do we require that wii D 0 for all 1 \u0002 i \u0002 n?\n692\nChapter 25\nAll-Pairs Shortest Paths\n25.1-3\nWhat does the matrix\nL.0/ D\n\u0003\n0\n1\n1\n\u0003 \u0003 \u0003\n1\n1\n0\n1\n\u0003 \u0003 \u0003\n1\n1\n1\n0\n\u0003 \u0003 \u0003\n1\n:::\n:::\n:::\n:::\n:::\n1\n1\n1\n\u0003 \u0003 \u0003\n0\n\u0004\nused in the shortest-paths algorithms correspond to in regular matrix multiplica-\ntion?\n25.1-4\nShow that matrix multiplication deﬁned by EXTEND-SHORTEST-PATHS is asso-\nciative.\n25.1-5\nShow how to express the single-source shortest-paths problem as a product of ma-\ntrices and a vector. Describe how evaluating this product corresponds to a Bellman-\nFord-like algorithm (see Section 24.1).\n25.1-6\nSuppose we also wish to compute the vertices on shortest paths in the algorithms of\nthis section. Show how to compute the predecessor matrix … from the completed\nmatrix L of shortest-path weights in O.n3/ time.\n25.1-7\nWe can also compute the vertices on shortest paths as we compute the shortest-\npath weights. Deﬁne \u0006.m/\nij\nas the predecessor of vertex j on any minimum-weight\npath from i to j that contains at most m edges. Modify the EXTEND-SHORTEST-\nPATHS and SLOW-ALL-PAIRS-SHORTEST-PATHS procedures to compute the ma-\ntrices ….1/; ….2/; : : : ; ….n\u00031/ as the matrices L.1/; L.2/; : : : ; L.n\u00031/ are computed.\n25.1-8",
    "parent_a52fd2dc-2f4e-4a77-a9e9-8430104ee0b7": "ij\nas the predecessor of vertex j on any minimum-weight\npath from i to j that contains at most m edges. Modify the EXTEND-SHORTEST-\nPATHS and SLOW-ALL-PAIRS-SHORTEST-PATHS procedures to compute the ma-\ntrices ….1/; ….2/; : : : ; ….n\u00031/ as the matrices L.1/; L.2/; : : : ; L.n\u00031/ are computed.\n25.1-8\nThe FASTER-ALL-PAIRS-SHORTEST-PATHS procedure, as written, requires us to\nstore dlg.n \u0005 1/e matrices, each with n2 elements, for a total space requirement of\n‚.n2 lg n/. Modify the procedure to require only ‚.n2/ space by using only two\nn \t n matrices.\n25.1-9\nModify FASTER-ALL-PAIRS-SHORTEST-PATHS so that it can determine whether\nthe graph contains a negative-weight cycle.\n25.2\nThe Floyd-Warshall algorithm\n693\n25.1-10\nGive an efﬁcient algorithm to ﬁnd the length (number of edges) of a minimum-\nlength negative-weight cycle in a graph.\n25.2\nThe Floyd-Warshall algorithm\nIn this section, we shall use a different dynamic-programming formulation to solve\nthe all-pairs shortest-paths problem on a directed graph G D .V; E/. The result-\ning algorithm, known as the Floyd-Warshall algorithm, runs in ‚.V 3/ time. As\nbefore, negative-weight edges may be present, but we assume that there are no\nnegative-weight cycles. As in Section 25.1, we follow the dynamic-programming\nprocess to develop the algorithm.\nAfter studying the resulting algorithm, we\npresent a similar method for ﬁnding the transitive closure of a directed graph.\nThe structure of a shortest path\nIn the Floyd-Warshall algorithm, we characterize the structure of a shortest path\ndifferently from how we characterized it in Section 25.1. The Floyd-Warshall algo-\nrithm considers the intermediate vertices of a shortest path, where an intermediate\nvertex of a simple path p D h\u00031; \u00032; : : : ; \u0003li is any vertex of p other than \u00031 or \u0003l,\nthat is, any vertex in the set f\u00032; \u00033; : : : ; \u0003l\u00031g.\nThe Floyd-Warshall algorithm relies on the following observation. Under our",
    "parent_109e534b-a9b7-452a-aeee-5249a5714e1a": "vertex of a simple path p D h\u00031; \u00032; : : : ; \u0003li is any vertex of p other than \u00031 or \u0003l,\nthat is, any vertex in the set f\u00032; \u00033; : : : ; \u0003l\u00031g.\nThe Floyd-Warshall algorithm relies on the following observation. Under our\nassumption that the vertices of G are V D f1; 2; : : : ; ng, let us consider a subset\nf1; 2; : : : ; kg of vertices for some k. For any pair of vertices i; j 2 V , consider all\npaths from i to j whose intermediate vertices are all drawn from f1; 2; : : : ; kg, and\nlet p be a minimum-weight path from among them. (Path p is simple.) The Floyd-\nWarshall algorithm exploits a relationship between path p and shortest paths from i\nto j with all intermediate vertices in the set f1; 2; : : : ; k \u0005 1g. The relationship\ndepends on whether or not k is an intermediate vertex of path p.\n\u0002\nIf k is not an intermediate vertex of path p, then all intermediate vertices of\npath p are in the set f1; 2; : : : ; k \u0005 1g. Thus, a shortest path from vertex i\nto vertex j with all intermediate vertices in the set f1; 2; : : : ; k \u0005 1g is also a\nshortest path from i to j with all intermediate vertices in the set f1; 2; : : : ; kg.\n\u0002\nIf k is an intermediate vertex of path p, then we decompose p into i\np1\n; k\np2\n; j ,\nas Figure 25.3 illustrates. By Lemma 24.1, p1 is a shortest path from i to k\nwith all intermediate vertices in the set f1; 2; : : : ; kg. In fact, we can make a\nslightly stronger statement. Because vertex k is not an intermediate vertex of\npath p1, all intermediate vertices of p1 are in the set f1; 2; : : : ; k \u0005 1g. There-\n694\nChapter 25\nAll-Pairs Shortest Paths\ni\nk\nj\np1\np2\np: all intermediate vertices in f1; 2; : : : ; kg\nall intermediate vertices in f1; 2; : : : ; k \u0005 1g\nall intermediate vertices in f1; 2; : : : ; k \u0005 1g\nFigure 25.3\nPath p is a shortest path from vertex i to vertex j, and k is the highest-numbered\nintermediate vertex of p. Path p1, the portion of path p from vertex i to vertex k, has all intermediate",
    "parent_c93705f6-aee8-49a6-a9c7-dc10cca23776": "all intermediate vertices in f1; 2; : : : ; k \u0005 1g\nFigure 25.3\nPath p is a shortest path from vertex i to vertex j, and k is the highest-numbered\nintermediate vertex of p. Path p1, the portion of path p from vertex i to vertex k, has all intermediate\nvertices in the set f1; 2; : : : ; k \u0005 1g. The same holds for path p2 from vertex k to vertex j.\nfore, p1 is a shortest path from i to k with all intermediate vertices in the set\nf1; 2; : : : ; k \u0005 1g. Similarly, p2 is a shortest path from vertex k to vertex j with\nall intermediate vertices in the set f1; 2; : : : ; k \u0005 1g.\nA recursive solution to the all-pairs shortest-paths problem\nBased on the above observations, we deﬁne a recursive formulation of shortest-\npath estimates that differs from the one in Section 25.1. Let d .k/\nij\nbe the weight\nof a shortest path from vertex i to vertex j for which all intermediate vertices\nare in the set f1; 2; : : : ; kg. When k D 0, a path from vertex i to vertex j with\nno intermediate vertex numbered higher than 0 has no intermediate vertices at all.\nSuch a path has at most one edge, and hence d .0/\nij\nD wij. Following the above\ndiscussion, we deﬁne d .k/\nij\nrecursively by\nd .k/\nij\nD\n(\nwij\nif k D 0 ;\nmin\n\u000b\nd .k\u00031/\nij\n; d .k\u00031/\nik\nC d .k\u00031/\nkj\n\f\nif k \u0006 1 :\n(25.5)\nBecause for any path, all intermediate vertices are in the set f1; 2; : : : ; ng, the ma-\ntrix D.n/ D\n\u000b\nd .n/\nij\n\f\ngives the ﬁnal answer: d .n/\nij\nD ı.i; j / for all i; j 2 V .\nComputing the shortest-path weights bottom up\nBased on recurrence (25.5), we can use the following bottom-up procedure to com-\npute the values d .k/\nij\nin order of increasing values of k. Its input is an n\tn matrix W\ndeﬁned as in equation (25.1). The procedure returns the matrix D.n/ of shortest-\npath weights.\n25.2\nThe Floyd-Warshall algorithm\n695\nFLOYD-WARSHALL.W /\n1\nn D W:rows\n2\nD.0/ D W\n3\nfor k D 1 to n\n4\nlet D.k/ D\n\u000b\nd .k/\nij\n\f\nbe a new n \t n matrix\n5\nfor i D 1 to n\n6\nfor j D 1 to n\n7\nd .k/\nij\nD min\n\u000b\nd .k\u00031/\nij\n; d .k\u00031/\nik\nC d .k\u00031/\nkj\n\f\n8",
    "parent_29ccefd9-993c-44af-aa87-440453e349a3": "path weights.\n25.2\nThe Floyd-Warshall algorithm\n695\nFLOYD-WARSHALL.W /\n1\nn D W:rows\n2\nD.0/ D W\n3\nfor k D 1 to n\n4\nlet D.k/ D\n\u000b\nd .k/\nij\n\f\nbe a new n \t n matrix\n5\nfor i D 1 to n\n6\nfor j D 1 to n\n7\nd .k/\nij\nD min\n\u000b\nd .k\u00031/\nij\n; d .k\u00031/\nik\nC d .k\u00031/\nkj\n\f\n8\nreturn D.n/\nFigure 25.4 shows the matrices D.k/ computed by the Floyd-Warshall algorithm\nfor the graph in Figure 25.1.\nThe running time of the Floyd-Warshall algorithm is determined by the triply\nnested for loops of lines 3–7. Because each execution of line 7 takes O.1/ time,\nthe algorithm runs in time ‚.n3/. As in the ﬁnal algorithm in Section 25.1, the\ncode is tight, with no elaborate data structures, and so the constant hidden in the\n‚-notation is small. Thus, the Floyd-Warshall algorithm is quite practical for even\nmoderate-sized input graphs.\nConstructing a shortest path\nThere are a variety of different methods for constructing shortest paths in the Floyd-\nWarshall algorithm. One way is to compute the matrix D of shortest-path weights\nand then construct the predecessor matrix … from the D matrix. Exercise 25.1-6\nasks you to implement this method so that it runs in O.n3/ time. Given the pre-\ndecessor matrix …, the PRINT-ALL-PAIRS-SHORTEST-PATH procedure will print\nthe vertices on a given shortest path.\nAlternatively, we can compute the predecessor matrix … while the algorithm\ncomputes the matrices D.k/. Speciﬁcally, we compute a sequence of matrices\n….0/; ….1/; : : : ; ….n/, where … D ….n/ and we deﬁne \u0006.k/\nij\nas the predecessor of\nvertex j on a shortest path from vertex i with all intermediate vertices in the set\nf1; 2; : : : ; kg.\nWe can give a recursive formulation of \u0006.k/\nij . When k D 0, a shortest path from i\nto j has no intermediate vertices at all. Thus,\n\u0006.0/\nij\nD\n(\nNIL\nif i D j or wij D 1 ;\ni\nif i ¤ j and wij < 1 :\n(25.6)\nFor k \u0006 1, if we take the path i ; k ; j , where k ¤ j , then the predecessor\nof j we choose is the same as the predecessor of j we chose on a shortest path",
    "parent_2ae60c04-c74b-4bf8-ae88-1dfef4b78163": "to j has no intermediate vertices at all. Thus,\n\u0006.0/\nij\nD\n(\nNIL\nif i D j or wij D 1 ;\ni\nif i ¤ j and wij < 1 :\n(25.6)\nFor k \u0006 1, if we take the path i ; k ; j , where k ¤ j , then the predecessor\nof j we choose is the same as the predecessor of j we chose on a shortest path\nfrom k with all intermediate vertices in the set f1; 2; : : : ; k \u0005 1g. Otherwise, we\n696\nChapter 25\nAll-Pairs Shortest Paths\nD.0/ D\n\u0004\n0\n3\n8\n1\n\u00054\n1\n0\n1\n1\n7\n1\n4\n0\n1\n1\n2\n1\n\u00055\n0\n1\n1\n1\n1\n6\n0\n˘\n….0/ D\n\u0004\nNIL\n1\n1\nNIL\n1\nNIL\nNIL\nNIL\n2\n2\nNIL\n3\nNIL\nNIL\nNIL\n4\nNIL\n4\nNIL\nNIL\nNIL\nNIL\nNIL\n5\nNIL\n˘\nD.1/ D\n\u0004\n0\n3\n8\n1\n\u00054\n1\n0\n1\n1\n7\n1\n4\n0\n1\n1\n2\n5\n\u00055\n0\n\u00052\n1\n1\n1\n6\n0\n˘\n….1/ D\n\u0004\nNIL\n1\n1\nNIL\n1\nNIL\nNIL\nNIL\n2\n2\nNIL\n3\nNIL\nNIL\nNIL\n4\n1\n4\nNIL\n1\nNIL\nNIL\nNIL\n5\nNIL\n˘\nD.2/ D\n\u0004\n0\n3\n8\n4\n\u00054\n1\n0\n1\n1\n7\n1\n4\n0\n5\n11\n2\n5\n\u00055\n0\n\u00052\n1\n1\n1\n6\n0\n˘\n….2/ D\n\u0004\nNIL\n1\n1\n2\n1\nNIL\nNIL\nNIL\n2\n2\nNIL\n3\nNIL\n2\n2\n4\n1\n4\nNIL\n1\nNIL\nNIL\nNIL\n5\nNIL\n˘\nD.3/ D\n\u0004\n0\n3\n8\n4\n\u00054\n1\n0\n1\n1\n7\n1\n4\n0\n5\n11\n2\n\u00051\n\u00055\n0\n\u00052\n1\n1\n1\n6\n0\n˘\n….3/ D\n\u0004\nNIL\n1\n1\n2\n1\nNIL\nNIL\nNIL\n2\n2\nNIL\n3\nNIL\n2\n2\n4\n3\n4\nNIL\n1\nNIL\nNIL\nNIL\n5\nNIL\n˘\nD.4/ D\n\u0004 0\n3\n\u00051\n4\n\u00054\n3\n0\n\u00054\n1\n\u00051\n7\n4\n0\n5\n3\n2\n\u00051\n\u00055\n0\n\u00052\n8\n5\n1\n6\n0\n˘\n….4/ D\n\u0004\nNIL\n1\n4\n2\n1\n4\nNIL\n4\n2\n1\n4\n3\nNIL\n2\n1\n4\n3\n4\nNIL\n1\n4\n3\n4\n5\nNIL\n˘\nD.5/ D\n\u0004 0\n1\n\u00053\n2\n\u00054\n3\n0\n\u00054\n1\n\u00051\n7\n4\n0\n5\n3\n2\n\u00051\n\u00055\n0\n\u00052\n8\n5\n1\n6\n0\n˘\n….5/ D\n\u0004\nNIL\n3\n4\n5\n1\n4\nNIL\n4\n2\n1\n4\n3\nNIL\n2\n1\n4\n3\n4\nNIL\n1\n4\n3\n4\n5\nNIL\n˘\nFigure 25.4\nThe sequence of matrices D.k/ and ….k/ computed by the Floyd-Warshall algorithm\nfor the graph in Figure 25.1.\n25.2\nThe Floyd-Warshall algorithm\n697\nchoose the same predecessor of j that we chose on a shortest path from i with all\nintermediate vertices in the set f1; 2; : : : ; k \u0005 1g. Formally, for k \u0006 1,\n\u0006.k/\nij\nD\n(\n\u0006.k\u00031/\nij\nif d .k\u00031/\nij\n\u0002 d .k\u00031/\nik\nC d .k\u00031/\nkj\n;\n\u0006.k\u00031/\nkj\nif d .k\u00031/\nij\n> d .k\u00031/\nik\nC d .k\u00031/\nkj\n:\n(25.7)\nWe leave the incorporation of the ….k/ matrix computations into the FLOYD-\nWARSHALL procedure as Exercise 25.2-3. Figure 25.4 shows the sequence of ….k/\nmatrices that the resulting algorithm computes for the graph of Figure 25.1. The",
    "parent_bead846a-fb34-4e9c-9b98-7b54becf71e0": "kj\n;\n\u0006.k\u00031/\nkj\nif d .k\u00031/\nij\n> d .k\u00031/\nik\nC d .k\u00031/\nkj\n:\n(25.7)\nWe leave the incorporation of the ….k/ matrix computations into the FLOYD-\nWARSHALL procedure as Exercise 25.2-3. Figure 25.4 shows the sequence of ….k/\nmatrices that the resulting algorithm computes for the graph of Figure 25.1. The\nexercise also asks for the more difﬁcult task of proving that the predecessor sub-\ngraph G\u0003;i is a shortest-paths tree with root i. Exercise 25.2-7 asks for yet another\nway to reconstruct shortest paths.\nTransitive closure of a directed graph\nGiven a directed graph G D .V; E/ with vertex set V D f1; 2; : : : ; ng, we might\nwish to determine whether G contains a path from i to j for all vertex pairs\ni; j 2 V . We deﬁne the transitive closure of G as the graph G\u0004 D .V; E\u0004/, where\nE\u0004 D f.i; j / W there is a path from vertex i to vertex j in Gg :\nOne way to compute the transitive closure of a graph in ‚.n3/ time is to assign\na weight of 1 to each edge of E and run the Floyd-Warshall algorithm. If there is a\npath from vertex i to vertex j , we get dij < n. Otherwise, we get dij D 1.\nThere is another, similar way to compute the transitive closure of G in ‚.n3/\ntime that can save time and space in practice. This method substitutes the logical\noperations _ (logical OR) and ^ (logical AND) for the arithmetic operations min\nand C in the Floyd-Warshall algorithm. For i; j; k D 1; 2; : : : ; n, we deﬁne t.k/\nij\nto\nbe 1 if there exists a path in graph G from vertex i to vertex j with all intermediate\nvertices in the set f1; 2; : : : ; kg, and 0 otherwise. We construct the transitive closure\nG\u0004 D .V; E\u0004/ by putting edge .i; j / into E\u0004 if and only if t.n/\nij\nD 1. A recursive\ndeﬁnition of t.k/\nij , analogous to recurrence (25.5), is\nt.0/\nij\nD\n(\n0\nif i ¤ j and .i; j / 62 E ;\n1\nif i D j or .i; j / 2 E ;\nand for k \u0006 1,\nt.k/\nij\nD t.k\u00031/\nij\n_\n\u000b\nt.k\u00031/\nik\n^ t.k\u00031/\nkj\n\f\n:\n(25.8)\nAs in the Floyd-Warshall algorithm, we compute the matrices T .k/ D\n\u000b\nt.k/\nij\n\f\nin\norder of increasing k.\n698",
    "parent_f3a9790c-28a8-4f08-a406-3d04d38a3f25": "ij , analogous to recurrence (25.5), is\nt.0/\nij\nD\n(\n0\nif i ¤ j and .i; j / 62 E ;\n1\nif i D j or .i; j / 2 E ;\nand for k \u0006 1,\nt.k/\nij\nD t.k\u00031/\nij\n_\n\u000b\nt.k\u00031/\nik\n^ t.k\u00031/\nkj\n\f\n:\n(25.8)\nAs in the Floyd-Warshall algorithm, we compute the matrices T .k/ D\n\u000b\nt.k/\nij\n\f\nin\norder of increasing k.\n698\nChapter 25\nAll-Pairs Shortest Paths\n1\n2\n4\n3\nT .0/ D\n\u0005 1\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n0\n1\n0\n1\n1\n\u0006\nT .1/ D\n\u0005 1\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n0\n1\n0\n1\n1\n\u0006\nT .2/ D\n\u0005 1\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\n0\n1\n1\n\u0006\nT .3/ D\n\u0005 1\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\n1\n1\n1\n\u0006\nT .4/ D\n\u0005 1\n0\n0\n0\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n\u0006\nFigure 25.5\nA directed graph and the matrices T .k/ computed by the transitive-closure algorithm.\nTRANSITIVE-CLOSURE.G/\n1\nn D jG:Vj\n2\nlet T .0/ D\n\u000b\nt.0/\nij\n\f\nbe a new n \t n matrix\n3\nfor i D 1 to n\n4\nfor j D 1 to n\n5\nif i == j or .i; j / 2 G:E\n6\nt.0/\nij\nD 1\n7\nelse t.0/\nij\nD 0\n8\nfor k D 1 to n\n9\nlet T .k/ D\n\u000b\nt.k/\nij\n\f\nbe a new n \t n matrix\n10\nfor i D 1 to n\n11\nfor j D 1 to n\n12\nt.k/\nij\nD t.k\u00031/\nij\n_\n\u000b\nt.k\u00031/\nik\n^ t.k\u00031/\nkj\n\f\n13\nreturn T .n/\nFigure 25.5 shows the matrices T .k/ computed by the TRANSITIVE-CLOSURE\nprocedure on a sample graph. The TRANSITIVE-CLOSURE procedure, like the\nFloyd-Warshall algorithm, runs in ‚.n3/ time. On some computers, though, log-\nical operations on single-bit values execute faster than arithmetic operations on\ninteger words of data. Moreover, because the direct transitive-closure algorithm\nuses only boolean values rather than integer values, its space requirement is less\n25.2\nThe Floyd-Warshall algorithm\n699\nthan the Floyd-Warshall algorithm’s by a factor corresponding to the size of a word\nof computer storage.\nExercises\n25.2-1\nRun the Floyd-Warshall algorithm on the weighted, directed graph of Figure 25.2.\nShow the matrix D.k/ that results for each iteration of the outer loop.\n25.2-2\nShow how to compute the transitive closure using the technique of Section 25.1.\n25.2-3\nModify the FLOYD-WARSHALL procedure to compute the ….k/ matrices according",
    "parent_b414f490-a926-43be-9816-311c34969311": "Show the matrix D.k/ that results for each iteration of the outer loop.\n25.2-2\nShow how to compute the transitive closure using the technique of Section 25.1.\n25.2-3\nModify the FLOYD-WARSHALL procedure to compute the ….k/ matrices according\nto equations (25.6) and (25.7). Prove rigorously that for all i 2 V , the predecessor\nsubgraph G\u0003;i is a shortest-paths tree with root i. (Hint: To show that G\u0003;i is\nacyclic, ﬁrst show that \u0006.k/\nij\nD l implies d .k/\nij\n\u0006 d .k/\nil\nC wlj, according to the\ndeﬁnition of \u0006.k/\nij . Then, adapt the proof of Lemma 24.16.)\n25.2-4\nAs it appears above, the Floyd-Warshall algorithm requires ‚.n3/ space, since we\ncompute d .k/\nij\nfor i; j; k D 1; 2; : : : ; n. Show that the following procedure, which\nsimply drops all the superscripts, is correct, and thus only ‚.n2/ space is required.\nFLOYD-WARSHALL0.W /\n1\nn D W:rows\n2\nD D W\n3\nfor k D 1 to n\n4\nfor i D 1 to n\n5\nfor j D 1 to n\n6\ndij D min .dij; dik C dkj /\n7\nreturn D\n25.2-5\nSuppose that we modify the way in which equation (25.7) handles equality:\n\u0006.k/\nij\nD\n(\n\u0006.k\u00031/\nij\nif d .k\u00031/\nij\n< d .k\u00031/\nik\nC d .k\u00031/\nkj\n;\n\u0006.k\u00031/\nkj\nif d .k\u00031/\nij\n\u0006 d .k\u00031/\nik\nC d .k\u00031/\nkj\n:\nIs this alternative deﬁnition of the predecessor matrix … correct?\n700\nChapter 25\nAll-Pairs Shortest Paths\n25.2-6\nHow can we use the output of the Floyd-Warshall algorithm to detect the presence\nof a negative-weight cycle?\n25.2-7\nAnother way to reconstruct shortest paths in the Floyd-Warshall algorithm uses\nvalues \u0007.k/\nij\nfor i; j; k D 1; 2; : : : ; n, where \u0007.k/\nij\nis the highest-numbered interme-\ndiate vertex of a shortest path from i to j in which all intermediate vertices are\nin the set f1; 2; : : : ; kg. Give a recursive formulation for \u0007.k/\nij , modify the FLOYD-\nWARSHALL procedure to compute the \u0007.k/\nij\nvalues, and rewrite the PRINT-ALL-\nPAIRS-SHORTEST-PATH procedure to take the matrix ˆ D\n\u000b\n\u0007.n/\nij\n\f\nas an input.\nHow is the matrix ˆ like the s table in the matrix-chain multiplication problem of\nSection 15.2?\n25.2-8",
    "parent_a4be2838-8002-4f85-9ddb-98cd75048b7d": "ij , modify the FLOYD-\nWARSHALL procedure to compute the \u0007.k/\nij\nvalues, and rewrite the PRINT-ALL-\nPAIRS-SHORTEST-PATH procedure to take the matrix ˆ D\n\u000b\n\u0007.n/\nij\n\f\nas an input.\nHow is the matrix ˆ like the s table in the matrix-chain multiplication problem of\nSection 15.2?\n25.2-8\nGive an O.VE/-time algorithm for computing the transitive closure of a directed\ngraph G D .V; E/.\n25.2-9\nSuppose that we can compute the transitive closure of a directed acyclic graph in\nf .jV j ; jEj/ time, where f is a monotonically increasing function of jV j and jEj.\nShow that the time to compute the transitive closure G\u0004 D .V; E\u0004/ of a general\ndirected graph G D .V; E/ is then f .jV j ; jEj/ C O.V C E\u0004/.\n25.3\nJohnson’s algorithm for sparse graphs\nJohnson’s algorithm ﬁnds shortest paths between all pairs in O.V 2 lg V C VE/\ntime. For sparse graphs, it is asymptotically faster than either repeated squaring of\nmatrices or the Floyd-Warshall algorithm. The algorithm either returns a matrix of\nshortest-path weights for all pairs of vertices or reports that the input graph contains\na negative-weight cycle. Johnson’s algorithm uses as subroutines both Dijkstra’s\nalgorithm and the Bellman-Ford algorithm, which Chapter 24 describes.\nJohnson’s algorithm uses the technique of reweighting, which works as follows.\nIf all edge weights w in a graph G D .V; E/ are nonnegative, we can ﬁnd short-\nest paths between all pairs of vertices by running Dijkstra’s algorithm once from\neach vertex; with the Fibonacci-heap min-priority queue, the running time of this\nall-pairs algorithm is O.V 2 lg V C VE/. If G has negative-weight edges but no\nnegative-weight cycles, we simply compute a new set of nonnegative edge weights\n25.3\nJohnson’s algorithm for sparse graphs\n701\nthat allows us to use the same method. The new set of edge weights yw must satisfy\ntwo important properties:\n1. For all pairs of vertices u; \u0003 2 V , a path p is a shortest path from u to \u0003 using",
    "parent_cc71bc6c-b7f2-4244-9730-9e5770443e6e": "25.3\nJohnson’s algorithm for sparse graphs\n701\nthat allows us to use the same method. The new set of edge weights yw must satisfy\ntwo important properties:\n1. For all pairs of vertices u; \u0003 2 V , a path p is a shortest path from u to \u0003 using\nweight function w if and only if p is also a shortest path from u to \u0003 using\nweight function yw.\n2. For all edges .u; \u0003/, the new weight yw.u; \u0003/ is nonnegative.\nAs we shall see in a moment, we can preprocess G to determine the new weight\nfunction yw in O.VE/ time.\nPreserving shortest paths by reweighting\nThe following lemma shows how easily we can reweight the edges to satisfy the\nﬁrst property above. We use ı to denote shortest-path weights derived from weight\nfunction w and yı to denote shortest-path weights derived from weight function yw.\nLemma 25.1 (Reweighting does not change shortest paths)\nGiven a weighted, directed graph G D .V; E/ with weight function w W E ! R,\nlet h W V ! R be any function mapping vertices to real numbers. For each edge\n.u; \u0003/ 2 E, deﬁne\nyw.u; \u0003/ D w.u; \u0003/ C h.u/ \u0005 h.\u0003/ :\n(25.9)\nLet p D h\u00030; \u00031; : : : ; \u0003ki be any path from vertex \u00030 to vertex \u0003k. Then p is a\nshortest path from \u00030 to \u0003k with weight function w if and only if it is a shortest path\nwith weight function yw. That is, w.p/ D ı.\u00030; \u0003k/ if and only if yw.p/ D yı.\u00030; \u0003k/.\nFurthermore, G has a negative-weight cycle using weight function w if and only\nif G has a negative-weight cycle using weight function yw.\nProof\nWe start by showing that\nyw.p/ D w.p/ C h.\u00030/ \u0005 h.\u0003k/ :\n(25.10)\nWe have\nyw.p/\nD\nk\nX\niD1\nyw.\u0003i\u00031; \u0003i/\nD\nk\nX\niD1\n.w.\u0003i\u00031; \u0003i/ C h.\u0003i\u00031/ \u0005 h.\u0003i//\nD\nk\nX\niD1\nw.\u0003i\u00031; \u0003i/ C h.\u00030/ \u0005 h.\u0003k/\n(because the sum telescopes)\nD\nw.p/ C h.\u00030/ \u0005 h.\u0003k/ :\n702\nChapter 25\nAll-Pairs Shortest Paths\nTherefore, any path p from \u00030 to \u0003k has yw.p/ D w.p/ C h.\u00030/ \u0005 h.\u0003k/. Be-\ncause h.\u00030/ and h.\u0003k/ do not depend on the path, if one path from \u00030 to \u0003k is\nshorter than another using weight function w, then it is also shorter using yw. Thus,",
    "parent_221297e4-47c2-42b1-81c4-6c6aee118659": "702\nChapter 25\nAll-Pairs Shortest Paths\nTherefore, any path p from \u00030 to \u0003k has yw.p/ D w.p/ C h.\u00030/ \u0005 h.\u0003k/. Be-\ncause h.\u00030/ and h.\u0003k/ do not depend on the path, if one path from \u00030 to \u0003k is\nshorter than another using weight function w, then it is also shorter using yw. Thus,\nw.p/ D ı.\u00030; \u0003k/ if and only if yw.p/ D yı.\u00030; \u0003k/.\nFinally, we show that G has a negative-weight cycle using weight function w if\nand only if G has a negative-weight cycle using weight function yw. Consider any\ncycle c D h\u00030; \u00031; : : : ; \u0003ki, where \u00030 D \u0003k. By equation (25.10),\nyw.c/\nD\nw.c/ C h.\u00030/ \u0005 h.\u0003k/\nD\nw.c/ ;\nand thus c has negative weight using w if and only if it has negative weight us-\ning yw.\nProducing nonnegative weights by reweighting\nOur next goal is to ensure that the second property holds: we want yw.u; \u0003/ to be\nnonnegative for all edges .u; \u0003/ 2 E. Given a weighted, directed graph G D\n.V; E/ with weight function w W E ! R, we make a new graph G0 D .V 0; E0/,\nwhere V 0 D V [ fsg for some new vertex s 62 V and E0 D E [ f.s; \u0003/ W \u0003 2 V g.\nWe extend the weight function w so that w.s; \u0003/ D 0 for all \u0003 2 V . Note that\nbecause s has no edges that enter it, no shortest paths in G0, other than those with\nsource s, contain s. Moreover, G0 has no negative-weight cycles if and only if G\nhas no negative-weight cycles. Figure 25.6(a) shows the graph G0 corresponding\nto the graph G of Figure 25.1.\nNow suppose that G and G0 have no negative-weight cycles.\nLet us deﬁne\nh.\u0003/ D ı.s; \u0003/ for all \u0003 2 V 0.\nBy the triangle inequality (Lemma 24.10),\nwe have h.\u0003/ \u0002 h.u/ C w.u; \u0003/ for all edges .u; \u0003/ 2 E0. Thus, if we de-\nﬁne the new weights yw by reweighting according to equation (25.9), we have\nyw.u; \u0003/ D w.u; \u0003/ C h.u/ \u0005 h.\u0003/ \u0006 0, and we have satisﬁed the second property.\nFigure 25.6(b) shows the graph G0 from Figure 25.6(a) with reweighted edges.\nComputing all-pairs shortest paths\nJohnson’s algorithm to compute all-pairs shortest paths uses the Bellman-Ford al-",
    "parent_46704a3d-1230-4539-9960-f01d04f34d19": "yw.u; \u0003/ D w.u; \u0003/ C h.u/ \u0005 h.\u0003/ \u0006 0, and we have satisﬁed the second property.\nFigure 25.6(b) shows the graph G0 from Figure 25.6(a) with reweighted edges.\nComputing all-pairs shortest paths\nJohnson’s algorithm to compute all-pairs shortest paths uses the Bellman-Ford al-\ngorithm (Section 24.1) and Dijkstra’s algorithm (Section 24.3) as subroutines. It\nassumes implicitly that the edges are stored in adjacency lists. The algorithm re-\nturns the usual jV j \t jV j matrix D D dij, where dij D ı.i; j /, or it reports that\nthe input graph contains a negative-weight cycle. As is typical for an all-pairs\nshortest-paths algorithm, we assume that the vertices are numbered from 1 to jV j.\n25.3\nJohnson’s algorithm for sparse graphs\n703\n2\n1\n5\n4\n3\n4\n8\n2\n6\n7\n1\n0\n0\n0\n0\n0\n0\n0\n2/1\n2/–3\n2/2\n0/–4\n2/3\n0/–4\n0/1\n2/–1\n2/7\n0/4\n0/5\n2/3\n2/2\n0/–1\n0/–5\n2/–2\n4/8\n2/5\n2/1\n2/6\n(a)\n(c)\n(b)\n–4\n–4\n–1\n–5\n–5\n3\n2\n1\n5\n4\n4\n0\n13\n2\n2\n10\n0\n5\n1\n0\n4\n0\n0\n0\n0\n–4\n–1\n–5\n0\n3\n2\n1\n5\n4\n4\n0\n13\n2\n2\n10\n0\n0\n0\n3\n(d)\n2\n1\n5\n4\n4\n0\n13\n2\n2\n10\n0\n0\n0\n3\n(e)\n2\n1\n5\n4\n4\n0\n13\n2\n2\n10\n0\n0\n0\n3\n(f)\n2\n1\n5\n4\n4\n0\n13\n2\n2\n10\n0\n0\n0\n3\n(g)\n2\n1\n5\n4\n4\n0\n13\n2\n2\n10\n0\n0\n0\n3\n0/0\n0/0\n0/0\n0/0\n0/0\n0\n0\nFigure 25.6\nJohnson’s all-pairs shortest-paths algorithm run on the graph of Figure 25.1. Ver-\ntex numbers appear outside the vertices. (a) The graph G0 with the original weight function w.\nThe new vertex s is black. Within each vertex \u0003 is h.\u0003/ D ı.s; \u0003/. (b) After reweighting each\nedge .u; \u0003/ with weight function yw.u; \u0003/ D w.u; \u0003/ C h.u/ \u0005 h.\u0003/. (c)–(g) The result of running\nis black, and shaded edges are in the shortest-paths tree computed by the algorithm. Within each\nvertex \u0003 are the values yı.u; \u0003/ and ı.u; \u0003/, separated by a slash. The value du\u0005 D ı.u; \u0003/ is equal to\nyı.\n\u0003/ C h.\u0003/ \u0005 h.u/\nDijkstra’s algorithm on each vertex of G using weight function wy. In each part, the source vertex u\n.\nu;\n704\nChapter 25\nAll-Pairs Shortest Paths\nJOHNSON.G; w/\n1\ncompute G0, where G0:V D G:V [ fsg,\nG0:E D G:E [ f.s; \u0003/ W \u0003 2 G:Vg, and\nw.s; \u0003/ D 0 for all \u0003 2 G:V\n2",
    "parent_98024a6d-0aa2-4d69-bfcb-6c4a03276ac2": "yı.\n\u0003/ C h.\u0003/ \u0005 h.u/\nDijkstra’s algorithm on each vertex of G using weight function wy. In each part, the source vertex u\n.\nu;\n704\nChapter 25\nAll-Pairs Shortest Paths\nJOHNSON.G; w/\n1\ncompute G0, where G0:V D G:V [ fsg,\nG0:E D G:E [ f.s; \u0003/ W \u0003 2 G:Vg, and\nw.s; \u0003/ D 0 for all \u0003 2 G:V\n2\nif BELLMAN-FORD.G0; w; s/ == FALSE\n3\nprint “the input graph contains a negative-weight cycle”\n4\nelse for each vertex \u0003 2 G0:V\n5\nset h.\u0003/ to the value of ı.s; \u0003/\ncomputed by the Bellman-Ford algorithm\n6\nfor each edge .u; \u0003/ 2 G0:E\n7\nyw.u; \u0003/ D w.u; \u0003/ C h.u/ \u0005 h.\u0003/\n8\nlet D D .du\u0005/ be a new n \t n matrix\n9\nfor each vertex u 2 G:V\n10\nrun DIJKSTRA.G; yw; u/ to compute yı.u; \u0003/ for all \u0003 2 G:V\n11\nfor each vertex \u0003 2 G:V\n12\ndu\u0005 D yı.u; \u0003/ C h.\u0003/ \u0005 h.u/\n13\nreturn D\nThis code simply performs the actions we speciﬁed earlier. Line 1 produces G0.\nLine 2 runs the Bellman-Ford algorithm on G0 with weight function w and source\nvertex s. If G0, and hence G, contains a negative-weight cycle, line 3 reports the\nproblem. Lines 4–12 assume that G0 contains no negative-weight cycles. Lines 4–5\nset h.\u0003/ to the shortest-path weight ı.s; \u0003/ computed by the Bellman-Ford algo-\nrithm for all \u0003 2 V 0. Lines 6–7 compute the new weights yw. For each pair of ver-\ntices u; \u0003 2 V , the for loop of lines 9–12 computes the shortest-path weight yı.u; \u0003/\nby calling Dijkstra’s algorithm once from each vertex in V . Line 12 stores in\nmatrix entry du\u0005 the correct shortest-path weight ı.u; \u0003/, calculated using equa-\ntion (25.10). Finally, line 13 returns the completed D matrix. Figure 25.6 depicts\nthe execution of Johnson’s algorithm.\nIf we implement the min-priority queue in Dijkstra’s algorithm by a Fibonacci\nheap, Johnson’s algorithm runs in O.V 2 lg V CVE/ time. The simpler binary min-\nheap implementation yields a running time of O.VE lg V /, which is still asymp-\ntotically faster than the Floyd-Warshall algorithm if the graph is sparse.\nExercises\n25.3-1",
    "parent_c19d1320-0bbc-4eac-ad40-04a2fd042547": "heap, Johnson’s algorithm runs in O.V 2 lg V CVE/ time. The simpler binary min-\nheap implementation yields a running time of O.VE lg V /, which is still asymp-\ntotically faster than the Floyd-Warshall algorithm if the graph is sparse.\nExercises\n25.3-1\nUse Johnson’s algorithm to ﬁnd the shortest paths between all pairs of vertices in\nthe graph of Figure 25.2. Show the values of h and yw computed by the algorithm.\nProblems for Chapter 25\n705\n25.3-2\nWhat is the purpose of adding the new vertex s to V , yielding V 0?\n25.3-3\nSuppose that w.u; \u0003/ \u0006 0 for all edges .u; \u0003/ 2 E. What is the relationship\nbetween the weight functions w and yw?\n25.3-4\nProfessor Greenstreet claims that there is a simpler way to reweight edges than\nthe method used in Johnson’s algorithm. Letting w\u0004 D min.u;\u0005/2E fw.u; \u0003/g, just\ndeﬁne yw.u; \u0003/ D w.u; \u0003/ \u0005 w\u0004 for all edges .u; \u0003/ 2 E. What is wrong with the\nprofessor’s method of reweighting?\n25.3-5\nSuppose that we run Johnson’s algorithm on a directed graph G with weight func-\ntion w. Show that if G contains a 0-weight cycle c, then yw.u; \u0003/ D 0 for every\nedge .u; \u0003/ in c.\n25.3-6\nProfessor Michener claims that there is no need to create a new source vertex in\nline 1 of JOHNSON. He claims that instead we can just use G0 D G and let s be any\nvertex. Give an example of a weighted, directed graph G for which incorporating\nthe professor’s idea into JOHNSON causes incorrect answers. Then show that if G\nis strongly connected (every vertex is reachable from every other vertex), the results\nreturned by JOHNSON with the professor’s modiﬁcation are correct.\nProblems\n25-1\nTransitive closure of a dynamic graph\nSuppose that we wish to maintain the transitive closure of a directed graph G D\n.V; E/ as we insert edges into E. That is, after each edge has been inserted, we\nwant to update the transitive closure of the edges inserted so far. Assume that the\ngraph G has no edges initially and that we represent the transitive closure as a\nboolean matrix.",
    "parent_55b32555-f27c-4eba-8921-ca2966805ff1": ".V; E/ as we insert edges into E. That is, after each edge has been inserted, we\nwant to update the transitive closure of the edges inserted so far. Assume that the\ngraph G has no edges initially and that we represent the transitive closure as a\nboolean matrix.\na. Show how to update the transitive closure G\u0004 D .V; E\u0004/ of a graph G D .V; E/\nin O.V 2/ time when a new edge is added to G.\nb. Give an example of a graph G and an edge e such that \u0004.V 2/ time is required\nto update the transitive closure after the insertion of e into G, no matter what\nalgorithm is used.\n706\nChapter 25\nAll-Pairs Shortest Paths\nc. Describe an efﬁcient algorithm for updating the transitive closure as edges are\ninserted into the graph. For any sequence of n insertions, your algorithm should\nrun in total time Pn\niD1 ti D O.V 3/, where ti is the time to update the transitive\nclosure upon inserting the ith edge. Prove that your algorithm attains this time\nbound.\n25-2\nShortest paths in \u0003-dense graphs\nA graph G D .V; E/ is \u0003-dense if jEj D ‚.V 1C\u0002/ for some constant \b in the\nrange 0 < \b \u0002 1. By using d-ary min-heaps (see Problem 6-2) in shortest-paths\nalgorithms on \b-dense graphs, we can match the running times of Fibonacci-heap-\nbased algorithms without using as complicated a data structure.\na. What are the asymptotic running times for INSERT, EXTRACT-MIN, and\nDECREASE-KEY, as a function of d and the number n of elements in a d-ary\nmin-heap? What are these running times if we choose d D ‚.n˛/ for some\nconstant 0 < ˛ \u0002 1? Compare these running times to the amortized costs of\nthese operations for a Fibonacci heap.\nb. Show how to compute shortest paths from a single source on an \b-dense directed\ngraph G D .V; E/ with no negative-weight edges in O.E/ time. (Hint: Pick d\nas a function of \b.)\nc. Show how to solve the all-pairs shortest-paths problem on an \b-dense directed\ngraph G D .V; E/ with no negative-weight edges in O.VE/ time.",
    "parent_f0430a9f-5078-4ae6-80f1-ebf83ecb7ae7": "graph G D .V; E/ with no negative-weight edges in O.E/ time. (Hint: Pick d\nas a function of \b.)\nc. Show how to solve the all-pairs shortest-paths problem on an \b-dense directed\ngraph G D .V; E/ with no negative-weight edges in O.VE/ time.\nd. Show how to solve the all-pairs shortest-paths problem in O.VE/ time on an\n\b-dense directed graph G D .V; E/ that may have negative-weight edges but\nhas no negative-weight cycles.\nChapter notes\nLawler [224] has a good discussion of the all-pairs shortest-paths problem, al-\nthough he does not analyze solutions for sparse graphs. He attributes the matrix-\nmultiplication algorithm to the folklore. The Floyd-Warshall algorithm is due to\nFloyd [105], who based it on a theorem of Warshall [349] that describes how to\ncompute the transitive closure of boolean matrices. Johnson’s algorithm is taken\nfrom [192].\nSeveral researchers have given improved algorithms for computing shortest\npaths via matrix multiplication.\nFredman [111] shows how to solve the all-\npairs shortest paths problem using O.V 5=2/ comparisons between sums of edge\nNotes for Chapter 25\n707\nweights and obtains an algorithm that runs in O.V 3.lg lg V= lg V /1=3/ time, which\nis slightly better than the running time of the Floyd-Warshall algorithm. Han [159]\nreduced the running time to O.V 3.lg lg V= lg V /5=4/. Another line of research\ndemonstrates that we can apply algorithms for fast matrix multiplication (see the\nchapter notes for Chapter 4) to the all-pairs shortest paths problem. Let O.n!/ be\nthe running time of the fastest algorithm for multiplying n \t n matrices; currently\n! < 2:376 [78]. Galil and Margalit [123, 124] and Seidel [308] designed algo-\nrithms that solve the all-pairs shortest paths problem in undirected, unweighted\ngraphs in .V !p.V // time, where p.n/ denotes a particular function that is poly-\nlogarithmically bounded in n. In dense graphs, these algorithms are faster than",
    "parent_d9cb2257-e4ac-40d7-b570-7b1315b04784": "rithms that solve the all-pairs shortest paths problem in undirected, unweighted\ngraphs in .V !p.V // time, where p.n/ denotes a particular function that is poly-\nlogarithmically bounded in n. In dense graphs, these algorithms are faster than\nthe O.VE/ time needed to perform jV j breadth-ﬁrst searches. Several researchers\nhave extended these results to give algorithms for solving the all-pairs shortest\npaths problem in undirected graphs in which the edge weights are integers in the\nrange f1; 2; : : : ; W g. The asymptotically fastest such algorithm, by Shoshan and\nZwick [316], runs in time O.W V !p.V W //.\nKarger, Koller, and Phillips [196] and independently McGeoch [247] have given\na time bound that depends on E\u0004, the set of edges in E that participate in some\nshortest path. Given a graph with nonnegative edge weights, their algorithms run in\nO.VE\u0004 C V 2 lg V / time and improve upon running Dijkstra’s algorithm jV j times\nwhen jE\u0004j D o.E/.\nBaswana, Hariharan, and Sen [33] examined decremental algorithms for main-\ntaining all-pairs shortest paths and transitive-closure information.\nDecremen-\ntal algorithms allow a sequence of intermixed edge deletions and queries; by\ncomparison, Problem 25-1, in which edges are inserted, asks for an incremen-\ntal algorithm. The algorithms by Baswana, Hariharan, and Sen are randomized\nand, when a path exists, their transitive-closure algorithm can fail to report it\nwith probability 1=nc for an arbitrary c > 0. The query times are O.1/ with\nhigh probability.\nFor transitive closure, the amortized time for each update is\nO.V 4=3 lg1=3 V /.\nFor all-pairs shortest paths, the update times depend on the\nqueries. For queries just giving the shortest-path weights, the amortized time per\nupdate is O.V 3=E lg2 V /. To report the actual shortest path, the amortized up-\ndate time is min.O.V 3=2p\nlg V /; O.V 3=E lg2 V //. Demetrescu and Italiano [84]\nshowed how to handle update and query operations when edges are both inserted",
    "parent_ca00ef2f-ed05-4025-ba9f-0e0ded51b7e2": "update is O.V 3=E lg2 V /. To report the actual shortest path, the amortized up-\ndate time is min.O.V 3=2p\nlg V /; O.V 3=E lg2 V //. Demetrescu and Italiano [84]\nshowed how to handle update and query operations when edges are both inserted\nand deleted, as long as each given edge has a bounded range of possible values\ndrawn from the real numbers.\nAho, Hopcroft, and Ullman [5] deﬁned an algebraic structure known as a “closed\nsemiring,” which serves as a general framework for solving path problems in di-\nrected graphs. Both the Floyd-Warshall algorithm and the transitive-closure algo-\nrithm from Section 25.2 are instantiations of an all-pairs algorithm based on closed\nsemirings. Maggs and Plotkin [240] showed how to ﬁnd minimum spanning trees\nusing a closed semiring.\n26\nMaximum Flow\nJust as we can model a road map as a directed graph in order to ﬁnd the shortest\npath from one point to another, we can also interpret a directed graph as a “ﬂow\nnetwork” and use it to answer questions about material ﬂows. Imagine a mate-\nrial coursing through a system from a source, where the material is produced, to\na sink, where it is consumed. The source produces the material at some steady\nrate, and the sink consumes the material at the same rate. The “ﬂow” of the mate-\nrial at any point in the system is intuitively the rate at which the material moves.\nFlow networks can model many problems, including liquids ﬂowing through pipes,\nparts through assembly lines, current through electrical networks, and information\nthrough communication networks.\nWe can think of each directed edge in a ﬂow network as a conduit for the mate-\nrial. Each conduit has a stated capacity, given as a maximum rate at which the ma-\nterial can ﬂow through the conduit, such as 200 gallons of liquid per hour through\na pipe or 20 amperes of electrical current through a wire. Vertices are conduit\njunctions, and other than the source and sink, material ﬂows through the vertices",
    "parent_05c54b9a-b4f4-47c8-8f3a-a871ae2e830d": "terial can ﬂow through the conduit, such as 200 gallons of liquid per hour through\na pipe or 20 amperes of electrical current through a wire. Vertices are conduit\njunctions, and other than the source and sink, material ﬂows through the vertices\nwithout collecting in them. In other words, the rate at which material enters a ver-\ntex must equal the rate at which it leaves the vertex. We call this property “ﬂow\nconservation,” and it is equivalent to Kirchhoff’s current law when the material is\nelectrical current.\nIn the maximum-ﬂow problem, we wish to compute the greatest rate at which\nwe can ship material from the source to the sink without violating any capacity\nconstraints. It is one of the simplest problems concerning ﬂow networks and, as\nwe shall see in this chapter, this problem can be solved by efﬁcient algorithms.\nMoreover, we can adapt the basic techniques used in maximum-ﬂow algorithms to\nsolve other network-ﬂow problems.\nThis chapter presents two general methods for solving the maximum-ﬂow prob-\nlem. Section 26.1 formalizes the notions of ﬂow networks and ﬂows, formally\ndeﬁning the maximum-ﬂow problem. Section 26.2 describes the classical method\nof Ford and Fulkerson for ﬁnding maximum ﬂows. An application of this method,\n26.1\nFlow networks\n709\nﬁnding a maximum matching in an undirected bipartite graph, appears in Sec-\ntion 26.3. Section 26.4 presents the push-relabel method, which underlies many of\nthe fastest algorithms for network-ﬂow problems. Section 26.5 covers the “relabel-\nto-front” algorithm, a particular implementation of the push-relabel method that\nruns in time O.V 3/. Although this algorithm is not the fastest algorithm known,\nit illustrates some of the techniques used in the asymptotically fastest algorithms,\nand it is reasonably efﬁcient in practice.\n26.1\nFlow networks\nIn this section, we give a graph-theoretic deﬁnition of ﬂow networks, discuss their\nproperties, and deﬁne the maximum-ﬂow problem precisely. We also introduce",
    "parent_6f47de31-7061-47b7-9ed3-0b8f97cff636": "and it is reasonably efﬁcient in practice.\n26.1\nFlow networks\nIn this section, we give a graph-theoretic deﬁnition of ﬂow networks, discuss their\nproperties, and deﬁne the maximum-ﬂow problem precisely. We also introduce\nsome helpful notation.\nFlow networks and ﬂows\nA ﬂow network G D .V; E/ is a directed graph in which each edge .u; \u0003/ 2 E\nhas a nonnegative capacity c.u; \u0003/ \u0006 0. We further require that if E contains an\nedge .u; \u0003/, then there is no edge .\u0003; u/ in the reverse direction. (We shall see\nshortly how to work around this restriction.) If .u; \u0003/ 62 E, then for convenience\nwe deﬁne c.u; \u0003/ D 0, and we disallow self-loops. We distinguish two vertices\nin a ﬂow network: a source s and a sink t. For convenience, we assume that each\nvertex lies on some path from the source to the sink. That is, for each vertex \u0003 2 V ,\nthe ﬂow network contains a path s ; \u0003 ; t. The graph is therefore connected\nand, since each vertex other than s has at least one entering edge, jEj \u0006 jV j \u0005 1.\nFigure 26.1 shows an example of a ﬂow network.\nWe are now ready to deﬁne ﬂows more formally. Let G D .V; E/ be a ﬂow\nnetwork with a capacity function c. Let s be the source of the network, and let t be\nthe sink. A ﬂow in G is a real-valued function f W V \t V ! R that satisﬁes the\nfollowing two properties:\nCapacity constraint: For all u; \u0003 2 V , we require 0 \u0002 f .u; \u0003/ \u0002 c.u; \u0003/.\nFlow conservation: For all u 2 V \u0005 fs; tg, we require\nX\n\u00052V\nf .\u0003; u/ D\nX\n\u00052V\nf .u; \u0003/ :\nWhen .u; \u0003/ 62 E, there can be no ﬂow from u to \u0003, and f .u; \u0003/ D 0.\n710\nChapter 26\nMaximum Flow\ns\nt\n16\n12\n20\n7\n9\n4\n13\n14\n4\nEdmonton\nCalgary\nSaskatoon\nRegina\nVancouver\nWinnipeg\ns\nt\n11/16\n12/12\n15/20\n7/7\n4/9\n1/4\n8/13\n11/14\n4/4\n(a)\n(b)\nv1\nv1\nv2\nv2\nv3\nv3\nv4\nv4\nFigure 26.1\n(a) A ﬂow network G D .V; E/ for the Lucky Puck Company’s trucking problem.\nThe Vancouver factory is the source s, and the Winnipeg warehouse is the sink t. The company ships",
    "parent_900f5dca-9086-4eee-89a7-666735c3bcd0": "Regina\nVancouver\nWinnipeg\ns\nt\n11/16\n12/12\n15/20\n7/7\n4/9\n1/4\n8/13\n11/14\n4/4\n(a)\n(b)\nv1\nv1\nv2\nv2\nv3\nv3\nv4\nv4\nFigure 26.1\n(a) A ﬂow network G D .V; E/ for the Lucky Puck Company’s trucking problem.\nThe Vancouver factory is the source s, and the Winnipeg warehouse is the sink t. The company ships\npucks through intermediate cities, but only c.u; \u0003/ crates per day can go from city u to city \u0003. Each\nedge is labeled with its capacity. (b) A ﬂow f in G with value jf j D 19. Each edge .u; \u0003/ is labeled\nby f .u;\u0003/=c.u; \u0003/. The slash notation merely separates the ﬂow and capacity; it does not indicate\ndivision.\nWe call the nonnegative quantity f .u; \u0003/ the ﬂow from vertex u to vertex \u0003. The\nvalue jf j of a ﬂow f is deﬁned as\njf j D\nX\n\u00052V\nf .s; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; s/ ;\n(26.1)\nthat is, the total ﬂow out of the source minus the ﬂow into the source. (Here, the j\u0003j\nnotation denotes ﬂow value, not absolute value or cardinality.) Typically, a ﬂow\nnetwork will not have any edges into the source, and the ﬂow into the source, given\nby the summation P\n\u00052V f .\u0003; s/, will be 0. We include it, however, because when\nwe introduce residual networks later in this chapter, the ﬂow into the source will\nbecome signiﬁcant. In the maximum-ﬂow problem, we are given a ﬂow network G\nwith source s and sink t, and we wish to ﬁnd a ﬂow of maximum value.\nBefore seeing an example of a network-ﬂow problem, let us brieﬂy explore the\ndeﬁnition of ﬂow and the two ﬂow properties. The capacity constraint simply\nsays that the ﬂow from one vertex to another must be nonnegative and must not\nexceed the given capacity. The ﬂow-conservation property says that the total ﬂow\ninto a vertex other than the source or sink must equal the total ﬂow out of that\nvertex—informally, “ﬂow in equals ﬂow out.”\nAn example of ﬂow\nA ﬂow network can model the trucking problem shown in Figure 26.1(a). The\nLucky Puck Company has a factory (source s) in Vancouver that manufactures",
    "parent_2802e50e-ed55-4e25-b475-33deeb76ab46": "into a vertex other than the source or sink must equal the total ﬂow out of that\nvertex—informally, “ﬂow in equals ﬂow out.”\nAn example of ﬂow\nA ﬂow network can model the trucking problem shown in Figure 26.1(a). The\nLucky Puck Company has a factory (source s) in Vancouver that manufactures\nhockey pucks, and it has a warehouse (sink t) in Winnipeg that stocks them. Lucky\n26.1\nFlow networks\n711\ns\nt\n16\n12\n20\n7\n9\n4\n13\n14\n4\n(a)\n(b)\nv1\nv2\nv3\nv4\n10\ns\nt\n16\n12\n20\n7\n9\n4\n13\n14\n4\nv1\nv2\nv3\nv4\nv′\n10\n10\nFigure 26.2\nConverting a network with antiparallel edges to an equivalent one with no antiparallel\nedges. (a) A ﬂow network containing both the edges .\u00031; \u00032/ and .\u00032; \u00031/. (b) An equivalent network\nwith no antiparallel edges. We add the new vertex \u00030, and we replace edge .\u00031; \u00032/ by the pair of\nedges .\u00031; \u00030/ and .\u00030; \u00032/, both with the same capacity as .\u00031; \u00032/.\nPuck leases space on trucks from another ﬁrm to ship the pucks from the factory\nto the warehouse. Because the trucks travel over speciﬁed routes (edges) between\ncities (vertices) and have a limited capacity, Lucky Puck can ship at most c.u; \u0003/\ncrates per day between each pair of cities u and \u0003 in Figure 26.1(a). Lucky Puck\nhas no control over these routes and capacities, and so the company cannot alter\nthe ﬂow network shown in Figure 26.1(a). They need to determine the largest\nnumber p of crates per day that they can ship and then to produce this amount, since\nthere is no point in producing more pucks than they can ship to their warehouse.\nLucky Puck is not concerned with how long it takes for a given puck to get from\nthe factory to the warehouse; they care only that p crates per day leave the factory\nand p crates per day arrive at the warehouse.\nWe can model the “ﬂow” of shipments with a ﬂow in this network because the\nnumber of crates shipped per day from one city to another is subject to a capacity\nconstraint. Additionally, the model must obey ﬂow conservation, for in a steady",
    "parent_cbc60392-bb26-46d9-881e-3d36fb995805": "and p crates per day arrive at the warehouse.\nWe can model the “ﬂow” of shipments with a ﬂow in this network because the\nnumber of crates shipped per day from one city to another is subject to a capacity\nconstraint. Additionally, the model must obey ﬂow conservation, for in a steady\nstate, the rate at which pucks enter an intermediate city must equal the rate at which\nthey leave. Otherwise, crates would accumulate at intermediate cities.\nModeling problems with antiparallel edges\nSuppose that the trucking ﬁrm offered Lucky Puck the opportunity to lease space\nfor 10 crates in trucks going from Edmonton to Calgary. It would seem natural to\nadd this opportunity to our example and form the network shown in Figure 26.2(a).\nThis network suffers from one problem, however: it violates our original assump-\ntion that if an edge .\u00031; \u00032/ 2 E, then .\u00032; \u00031/ 62 E. We call the two edges .\u00031; \u00032/\nand .\u00032; \u00031/ antiparallel. Thus, if we wish to model a ﬂow problem with antipar-\nallel edges, we must transform the network into an equivalent one containing no\n712\nChapter 26\nMaximum Flow\nantiparallel edges. Figure 26.2(b) displays this equivalent network. We choose\none of the two antiparallel edges, in this case .\u00031; \u00032/, and split it by adding a new\nvertex \u00030 and replacing edge .\u00031; \u00032/ with the pair of edges .\u00031; \u00030/ and .\u00030; \u00032/.\nWe also set the capacity of both new edges to the capacity of the original edge.\nThe resulting network satisﬁes the property that if an edge is in the network, the\nreverse edge is not. Exercise 26.1-1 asks you to prove that the resulting network is\nequivalent to the original one.\nThus, we see that a real-world ﬂow problem might be most naturally modeled\nby a network with antiparallel edges. It will be convenient to disallow antipar-\nallel edges, however, and so we have a straightforward way to convert a network\ncontaining antiparallel edges into an equivalent one with no antiparallel edges.\nNetworks with multiple sources and sinks",
    "parent_3e42a956-8bba-4a85-bc01-2deb7e0a5566": "by a network with antiparallel edges. It will be convenient to disallow antipar-\nallel edges, however, and so we have a straightforward way to convert a network\ncontaining antiparallel edges into an equivalent one with no antiparallel edges.\nNetworks with multiple sources and sinks\nA maximum-ﬂow problem may have several sources and sinks, rather than just\none of each. The Lucky Puck Company, for example, might actually have a set\nof m factories fs1; s2; : : : ; smg and a set of n warehouses ft1; t2; : : : ; tng, as shown\nin Figure 26.3(a). Fortunately, this problem is no harder than ordinary maximum\nﬂow.\nWe can reduce the problem of determining a maximum ﬂow in a network with\nmultiple sources and multiple sinks to an ordinary maximum-ﬂow problem. Fig-\nure 26.3(b) shows how to convert the network from (a) to an ordinary ﬂow network\nwith only a single source and a single sink. We add a supersource s and add a\ndirected edge .s; si/ with capacity c.s; si/ D 1 for each i D 1; 2; : : : ; m. We also\ncreate a new supersink t and add a directed edge .ti; t/ with capacity c.ti; t/ D 1\nfor each i D 1; 2; : : : ; n. Intuitively, any ﬂow in the network in (a) corresponds to\na ﬂow in the network in (b), and vice versa. The single source s simply provides\nas much ﬂow as desired for the multiple sources si, and the single sink t likewise\nconsumes as much ﬂow as desired for the multiple sinks ti. Exercise 26.1-2 asks\nyou to prove formally that the two problems are equivalent.\nExercises\n26.1-1\nShow that splitting an edge in a ﬂow network yields an equivalent network. More\nformally, suppose that ﬂow network G contains edge .u; \u0003/, and we create a new\nﬂow network G0 by creating a new vertex x and replacing .u; \u0003/ by new edges\n.u; x/ and .x; \u0003/ with c.u; x/ D c.x; \u0003/ D c.u; \u0003/. Show that a maximum ﬂow\nin G0 has the same value as a maximum ﬂow in G.\n26.1\nFlow networks\n713\n10\n(a)\n12\n5\n8\n14\n7\n11\n2\n3\n15\n6\n20\n13\n18\n10\n12\n5\n8\n14\n7\n11\n2\n3\n15\n6\n20\n13\n18\n∞\n∞\n∞\n∞\n∞\n∞\n∞\n∞\ns1\ns1\ns2\ns2\ns3\ns3\ns4\ns4",
    "parent_6d6febcf-ee56-48e0-9354-fc71d7a2f1bb": ".u; x/ and .x; \u0003/ with c.u; x/ D c.x; \u0003/ D c.u; \u0003/. Show that a maximum ﬂow\nin G0 has the same value as a maximum ﬂow in G.\n26.1\nFlow networks\n713\n10\n(a)\n12\n5\n8\n14\n7\n11\n2\n3\n15\n6\n20\n13\n18\n10\n12\n5\n8\n14\n7\n11\n2\n3\n15\n6\n20\n13\n18\n∞\n∞\n∞\n∞\n∞\n∞\n∞\n∞\ns1\ns1\ns2\ns2\ns3\ns3\ns4\ns4\ns5\ns5\nt1\nt1\nt2\nt2\nt3\nt3\n(b)\ns\nt\nFigure 26.3\nConverting a multiple-source, multiple-sink maximum-ﬂow problem into a problem\nwith a single source and a single sink. (a) A ﬂow network with ﬁve sources S D fs1; s2; s3; s4; s5g\nand three sinks T D ft1; t2; t3g. (b) An equivalent single-source, single-sink ﬂow network. We add\na supersource s and an edge with inﬁnite capacity from s to each of the multiple sources. We also\nadd a supersink t and an edge with inﬁnite capacity from each of the multiple sinks to t.\n26.1-2\nExtend the ﬂow properties and deﬁnitions to the multiple-source, multiple-sink\nproblem. Show that any ﬂow in a multiple-source, multiple-sink ﬂow network\ncorresponds to a ﬂow of identical value in the single-source, single-sink network\nobtained by adding a supersource and a supersink, and vice versa.\n26.1-3\nSuppose that a ﬂow network G D .V; E/ violates the assumption that the network\ncontains a path s ; \u0003 ; t for all vertices \u0003 2 V . Let u be a vertex for which there\nis no path s ; u ; t. Show that there must exist a maximum ﬂow f in G such\nthat f .u; \u0003/ D f .\u0003; u/ D 0 for all vertices \u0003 2 V .\n714\nChapter 26\nMaximum Flow\n26.1-4\nLet f be a ﬂow in a network, and let ˛ be a real number. The scalar ﬂow product,\ndenoted ˛f , is a function from V \t V to R deﬁned by\n.˛f /.u; \u0003/ D ˛ \u0003 f .u; \u0003/ :\nProve that the ﬂows in a network form a convex set. That is, show that if f1 and f2\nare ﬂows, then so is ˛f1 C .1 \u0005 ˛/f2 for all ˛ in the range 0 \u0002 ˛ \u0002 1.\n26.1-5\nState the maximum-ﬂow problem as a linear-programming problem.\n26.1-6\nProfessor Adam has two children who, unfortunately, dislike each other. The prob-\nlem is so severe that not only do they refuse to walk to school together, but in fact",
    "parent_2e7be80e-f264-44b6-8b1b-2f2fa13b578d": "26.1-5\nState the maximum-ﬂow problem as a linear-programming problem.\n26.1-6\nProfessor Adam has two children who, unfortunately, dislike each other. The prob-\nlem is so severe that not only do they refuse to walk to school together, but in fact\neach one refuses to walk on any block that the other child has stepped on that day.\nThe children have no problem with their paths crossing at a corner. Fortunately\nboth the professor’s house and the school are on corners, but beyond that he is not\nsure if it is going to be possible to send both of his children to the same school.\nThe professor has a map of his town. Show how to formulate the problem of de-\ntermining whether both his children can go to the same school as a maximum-ﬂow\nproblem.\n26.1-7\nSuppose that, in addition to edge capacities, a ﬂow network has vertex capacities.\nThat is each vertex \u0003 has a limit l.\u0003/ on how much ﬂow can pass though \u0003. Show\nhow to transform a ﬂow network G D .V; E/ with vertex capacities into an equiv-\nalent ﬂow network G0 D .V 0; E0/ without vertex capacities, such that a maximum\nﬂow in G0 has the same value as a maximum ﬂow in G. How many vertices and\nedges does G0 have?\n26.2\nThe Ford-Fulkerson method\nThis section presents the Ford-Fulkerson method for solving the maximum-ﬂow\nproblem. We call it a “method” rather than an “algorithm” because it encompasses\nseveral implementations with differing running times. The Ford-Fulkerson method\ndepends on three important ideas that transcend the method and are relevant to\nmany ﬂow algorithms and problems: residual networks, augmenting paths, and\ncuts. These ideas are essential to the important max-ﬂow min-cut theorem (The-\norem 26.6), which characterizes the value of a maximum ﬂow in terms of cuts of\n26.2\nThe Ford-Fulkerson method\n715\nthe ﬂow network. We end this section by presenting one speciﬁc implementation\nof the Ford-Fulkerson method and analyzing its running time.\nThe Ford-Fulkerson method iteratively increases the value of the ﬂow. We start",
    "parent_29d54625-cb52-45d0-b40b-473a6f1a4f2e": "26.2\nThe Ford-Fulkerson method\n715\nthe ﬂow network. We end this section by presenting one speciﬁc implementation\nof the Ford-Fulkerson method and analyzing its running time.\nThe Ford-Fulkerson method iteratively increases the value of the ﬂow. We start\nwith f .u; \u0003/ D 0 for all u; \u0003 2 V , giving an initial ﬂow of value 0. At each\niteration, we increase the ﬂow value in G by ﬁnding an “augmenting path” in an\nassociated “residual network” Gf . Once we know the edges of an augmenting\npath in Gf , we can easily identify speciﬁc edges in G for which we can change\nthe ﬂow so that we increase the value of the ﬂow. Although each iteration of the\nFord-Fulkerson method increases the value of the ﬂow, we shall see that the ﬂow\non any particular edge of G may increase or decrease; decreasing the ﬂow on some\nedges may be necessary in order to enable an algorithm to send more ﬂow from the\nsource to the sink. We repeatedly augment the ﬂow until the residual network has\nno more augmenting paths. The max-ﬂow min-cut theorem will show that upon\ntermination, this process yields a maximum ﬂow.\nFORD-FULKERSON-METHOD.G; s; t/\n1\ninitialize ﬂow f to 0\n2\nwhile there exists an augmenting path p in the residual network Gf\n3\naugment ﬂow f along p\n4\nreturn f\nIn order to implement and analyze the Ford-Fulkerson method, we need to intro-\nduce several additional concepts.\nResidual networks\nIntuitively, given a ﬂow network G and a ﬂow f , the residual network Gf consists\nof edges with capacities that represent how we can change the ﬂow on edges of G.\nAn edge of the ﬂow network can admit an amount of additional ﬂow equal to the\nedge’s capacity minus the ﬂow on that edge. If that value is positive, we place\nthat edge into Gf with a “residual capacity” of cf .u; \u0003/ D c.u; \u0003/ \u0005 f .u; \u0003/.\nThe only edges of G that are in Gf are those that can admit more ﬂow; those\nedges .u; \u0003/ whose ﬂow equals their capacity have cf .u; \u0003/ D 0, and they are not\nin Gf .",
    "parent_3a2cdbde-c7d5-491d-aaf4-01a54cd0447c": "that edge into Gf with a “residual capacity” of cf .u; \u0003/ D c.u; \u0003/ \u0005 f .u; \u0003/.\nThe only edges of G that are in Gf are those that can admit more ﬂow; those\nedges .u; \u0003/ whose ﬂow equals their capacity have cf .u; \u0003/ D 0, and they are not\nin Gf .\nThe residual network Gf may also contain edges that are not in G, however.\nAs an algorithm manipulates the ﬂow, with the goal of increasing the total ﬂow, it\nmight need to decrease the ﬂow on a particular edge. In order to represent a pos-\nsible decrease of a positive ﬂow f .u; \u0003/ on an edge in G, we place an edge .\u0003; u/\ninto Gf with residual capacity cf .\u0003; u/ D f .u; \u0003/—that is, an edge that can admit\nﬂow in the opposite direction to .u; \u0003/, at most canceling out the ﬂow on .u; \u0003/.\nThese reverse edges in the residual network allow an algorithm to send back ﬂow\n716\nChapter 26\nMaximum Flow\nit has already sent along an edge. Sending ﬂow back along an edge is equiva-\nlent to decreasing the ﬂow on the edge, which is a necessary operation in many\nalgorithms.\nMore formally, suppose that we have a ﬂow network G D .V; E/ with source s\nand sink t. Let f be a ﬂow in G, and consider a pair of vertices u; \u0003 2 V . We\ndeﬁne the residual capacity cf .u; \u0003/ by\ncf .u; \u0003/ D\n\u0002\nc.u; \u0003/ \u0005 f .u; \u0003/\nif .u; \u0003/ 2 E ;\nf .\u0003; u/\nif .\u0003; u/ 2 E ;\n0\notherwise :\n(26.2)\nBecause of our assumption that .u; \u0003/ 2 E implies .\u0003; u/ 62 E, exactly one case in\nequation (26.2) applies to each ordered pair of vertices.\nAs an example of equation (26.2), if c.u; \u0003/ D 16 and f .u; \u0003/ D 11, then we\ncan increase f .u; \u0003/ by up to cf .u; \u0003/ D 5 units before we exceed the capacity\nconstraint on edge .u; \u0003/. We also wish to allow an algorithm to return up to 11\nunits of ﬂow from \u0003 to u, and hence cf .\u0003; u/ D 11.\nGiven a ﬂow network G D .V; E/ and a ﬂow f , the residual network of G\ninduced by f is Gf D .V; Ef /, where\nEf D f.u; \u0003/ 2 V \t V W cf .u; \u0003/ > 0g :\n(26.3)\nThat is, as promised above, each edge of the residual network, or residual edge,",
    "parent_2d1c053e-708b-4f5c-a48e-0cf0315e1a5a": "units of ﬂow from \u0003 to u, and hence cf .\u0003; u/ D 11.\nGiven a ﬂow network G D .V; E/ and a ﬂow f , the residual network of G\ninduced by f is Gf D .V; Ef /, where\nEf D f.u; \u0003/ 2 V \t V W cf .u; \u0003/ > 0g :\n(26.3)\nThat is, as promised above, each edge of the residual network, or residual edge,\ncan admit a ﬂow that is greater than 0. Figure 26.4(a) repeats the ﬂow network G\nand ﬂow f of Figure 26.1(b), and Figure 26.4(b) shows the corresponding residual\nnetwork Gf . The edges in Ef are either edges in E or their reversals, and thus\njEf j \u0002 2 jEj :\nObserve that the residual network Gf is similar to a ﬂow network with capacities\ngiven by cf . It does not satisfy our deﬁnition of a ﬂow network because it may\ncontain both an edge .u; \u0003/ and its reversal .\u0003; u/. Other than this difference, a\nresidual network has the same properties as a ﬂow network, and we can deﬁne a\nﬂow in the residual network as one that satisﬁes the deﬁnition of a ﬂow, but with\nrespect to capacities cf in the network Gf .\nA ﬂow in a residual network provides a roadmap for adding ﬂow to the original\nﬂow network. If f is a ﬂow in G and f 0 is a ﬂow in the corresponding residual\nnetwork Gf , we deﬁne f \" f 0, the augmentation of ﬂow f by f 0, to be a function\nfrom V \t V to R, deﬁned by\n.f \" f 0/.u; \u0003/ D\n(\nf .u; \u0003/ C f 0.u; \u0003/ \u0005 f 0.\u0003; u/\nif .u; \u0003/ 2 E ;\n0\notherwise :\n(26.4)\n26.2\nThe Ford-Fulkerson method\n717\n9\n15\ns\nt\n5\n12\n5\n7\n5\n3\n1\n8\n11\n4\ns\nt\n11/16\n12/12\n19/20\n7/7\n9\n1/4\n12/13\n11/14\n4/4\n(b)\n(c)\n11\n5\n3\n4\ns\nt\n11/16\n12/12\n15/20\n7/7\n4/9\n1/4\n8/13\n11/14\n4/4\n(d)\n19\ns\nt\n5\n12\n1\n7\n3\n1\n12\n11\n4\n11\n1\n3\nv1\nv1\nv1\nv1\nv2\nv2\nv2\nv2\nv3\nv3\nv3\nv3\nv4\nv4\nv4\nv4\n(a)\nFigure 26.4\n(a) The ﬂow network G and ﬂow f of Figure 26.1(b). (b) The residual network Gf\nwith augmenting path p shaded; its residual capacity is cf .p/ D cf .\u00032; \u00033/ D 4. Edges with\nresidual capacity equal to 0, such as .\u00031; \u00033/, are not shown, a convention we follow in the remainder",
    "parent_6c599761-5002-4ed0-bdfe-61d98d666c86": "v4\nv4\nv4\n(a)\nFigure 26.4\n(a) The ﬂow network G and ﬂow f of Figure 26.1(b). (b) The residual network Gf\nwith augmenting path p shaded; its residual capacity is cf .p/ D cf .\u00032; \u00033/ D 4. Edges with\nresidual capacity equal to 0, such as .\u00031; \u00033/, are not shown, a convention we follow in the remainder\nof this section. (c) The ﬂow in G that results from augmenting along path p by its residual capacity 4.\nEdges carrying no ﬂow, such as .\u00033; \u00032/, are labeled only by their capacity, another convention we\nfollow throughout. (d) The residual network induced by the ﬂow in (c).\nThe intuition behind this deﬁnition follows the deﬁnition of the residual network.\nWe increase the ﬂow on .u; \u0003/ by f 0.u; \u0003/ but decrease it by f 0.\u0003; u/ because\npushing ﬂow on the reverse edge in the residual network signiﬁes decreasing the\nﬂow in the original network. Pushing ﬂow on the reverse edge in the residual\nnetwork is also known as cancellation. For example, if we send 5 crates of hockey\npucks from u to \u0003 and send 2 crates from \u0003 to u, we could equivalently (from the\nperspective of the ﬁnal result) just send 3 creates from u to \u0003 and none from \u0003 to u.\nCancellation of this type is crucial for any maximum-ﬂow algorithm.\nLemma 26.1\nLet G D .V; E/ be a ﬂow network with source s and sink t, and let f be a ﬂow\nin G. Let Gf be the residual network of G induced by f , and let f 0 be a ﬂow\nin Gf . Then the function f \" f 0 deﬁned in equation (26.4) is a ﬂow in G with\nvalue jf \" f 0j D jf j C jf 0j.\nProof\nWe ﬁrst verify that f \" f 0 obeys the capacity constraint for each edge in E\nand ﬂow conservation at each vertex in V \u0005 fs; tg.\n718\nChapter 26\nMaximum Flow\nFor the capacity constraint, ﬁrst observe that if .u; \u0003/ 2 E, then cf .\u0003; u/ D\nf .u; \u0003/. Therefore, we have f 0.\u0003; u/ \u0002 cf .\u0003; u/ D f .u; \u0003/, and hence\n.f \" f 0/.u; \u0003/ D f .u; \u0003/ C f 0.u; \u0003/ \u0005 f 0.\u0003; u/ (by equation (26.4))\n\u0006 f .u; \u0003/ C f 0.u; \u0003/ \u0005 f .u; \u0003/\n(because f 0.\u0003; u/ \u0002 f .u; \u0003/)\nD f 0.u; \u0003/\n\u0006 0 :\nIn addition,\n.f \" f 0/.u; \u0003/\nD",
    "parent_9f970772-1e9e-4eef-b82d-318380c95ef2": "f .u; \u0003/. Therefore, we have f 0.\u0003; u/ \u0002 cf .\u0003; u/ D f .u; \u0003/, and hence\n.f \" f 0/.u; \u0003/ D f .u; \u0003/ C f 0.u; \u0003/ \u0005 f 0.\u0003; u/ (by equation (26.4))\n\u0006 f .u; \u0003/ C f 0.u; \u0003/ \u0005 f .u; \u0003/\n(because f 0.\u0003; u/ \u0002 f .u; \u0003/)\nD f 0.u; \u0003/\n\u0006 0 :\nIn addition,\n.f \" f 0/.u; \u0003/\nD\nf .u; \u0003/ C f 0.u; \u0003/ \u0005 f 0.\u0003; u/\n(by equation (26.4))\n\u0002\nf .u; \u0003/ C f 0.u; \u0003/\n(because ﬂows are nonnegative)\n\u0002\nf .u; \u0003/ C cf .u; \u0003/\n(capacity constraint)\nD\nf .u; \u0003/ C c.u; \u0003/ \u0005 f .u; \u0003/\n(deﬁnition of cf )\nD\nc.u; \u0003/ :\nFor ﬂow conservation, because both f and f 0 obey ﬂow conservation, we have\nthat for all u 2 V \u0005 fs; tg,\nX\n\u00052V\n.f \" f 0/.u; \u0003/\nD\nX\n\u00052V\n.f .u; \u0003/ C f 0.u; \u0003/ \u0005 f 0.\u0003; u//\nD\nX\n\u00052V\nf .u; \u0003/ C\nX\n\u00052V\nf 0.u; \u0003/ \u0005\nX\n\u00052V\nf 0.\u0003; u/\nD\nX\n\u00052V\nf .\u0003; u/ C\nX\n\u00052V\nf 0.\u0003; u/ \u0005\nX\n\u00052V\nf 0.u; \u0003/\nD\nX\n\u00052V\n.f .\u0003; u/ C f 0.\u0003; u/ \u0005 f 0.u; \u0003//\nD\nX\n\u00052V\n.f \" f 0/.\u0003; u/ ;\nwhere the third line follows from the second by ﬂow conservation.\nFinally, we compute the value of f \" f 0. Recall that we disallow antiparallel\nedges in G (but not in Gf ), and hence for each vertex \u0003 2 V , we know that there\ncan be an edge .s; \u0003/ or .\u0003; s/, but never both. We deﬁne V1 D f\u0003 W .s; \u0003/ 2 Eg\nto be the set of vertices with edges from s, and V2 D f\u0003 W .\u0003; s/ 2 Eg to be the\nset of vertices with edges to s. We have V1 [ V2 \u0007 V and, because we disallow\nantiparallel edges, V1 \\ V2 D ;. We now compute\njf \" f 0j\nD\nX\n\u00052V\n.f \" f 0/ .s; \u0003/ \u0005\nX\n\u00052V\n.f \" f 0/ .\u0003; s/\nD\nX\n\u00052V1\n.f \" f 0/ .s; \u0003/ \u0005\nX\n\u00052V2\n.f \" f 0/ .\u0003; s/ ;\n(26.5)\n26.2\nThe Ford-Fulkerson method\n719\nwhere the second line follows because .f \" f 0/.w; x/ is 0 if .w; x/ 62 E. We now\napply the deﬁnition of f \" f 0 to equation (26.5), and then reorder and group terms\nto obtain\njf \" f 0j\nD\nX\n\u00052V1\n.f .s; \u0003/ C f 0.s; \u0003/ \u0005 f 0.\u0003; s// \u0005\nX\n\u00052V2\n.f .\u0003; s/ C f 0.\u0003; s/ \u0005 f 0.s; \u0003//\nD\nX\n\u00052V1\nf .s; \u0003/ C\nX\n\u00052V1\nf 0.s; \u0003/ \u0005\nX\n\u00052V1\nf 0.\u0003; s/\n\u0005\nX\n\u00052V2\nf .\u0003; s/ \u0005\nX\n\u00052V2\nf 0.\u0003; s/ C\nX\n\u00052V2\nf 0.s; \u0003/\nD\nX\n\u00052V1\nf .s; \u0003/ \u0005\nX\n\u00052V2\nf .\u0003; s/\nC\nX\n\u00052V1\nf 0.s; \u0003/ C\nX\n\u00052V2\nf 0.s; \u0003/ \u0005\nX\n\u00052V1\nf 0.\u0003; s/ \u0005\nX\n\u00052V2\nf 0.\u0003; s/\nD\nX\n\u00052V1",
    "parent_7b8bf4e7-351e-4526-86a1-e6b01f64f181": "X\n\u00052V2\n.f .\u0003; s/ C f 0.\u0003; s/ \u0005 f 0.s; \u0003//\nD\nX\n\u00052V1\nf .s; \u0003/ C\nX\n\u00052V1\nf 0.s; \u0003/ \u0005\nX\n\u00052V1\nf 0.\u0003; s/\n\u0005\nX\n\u00052V2\nf .\u0003; s/ \u0005\nX\n\u00052V2\nf 0.\u0003; s/ C\nX\n\u00052V2\nf 0.s; \u0003/\nD\nX\n\u00052V1\nf .s; \u0003/ \u0005\nX\n\u00052V2\nf .\u0003; s/\nC\nX\n\u00052V1\nf 0.s; \u0003/ C\nX\n\u00052V2\nf 0.s; \u0003/ \u0005\nX\n\u00052V1\nf 0.\u0003; s/ \u0005\nX\n\u00052V2\nf 0.\u0003; s/\nD\nX\n\u00052V1\nf .s; \u0003/ \u0005\nX\n\u00052V2\nf .\u0003; s/ C\nX\n\u00052V1[V2\nf 0.s; \u0003/ \u0005\nX\n\u00052V1[V2\nf 0.\u0003; s/ :\n(26.6)\nIn equation (26.6), we can extend all four summations to sum over V , since each\nadditional term has value 0. (Exercise 26.2-1 asks you to prove this formally.) We\nthus have\njf \" f 0j\nD\nX\n\u00052V\nf .s; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; s/ C\nX\n\u00052V\nf 0.s; \u0003/ \u0005\nX\n\u00052V\nf 0.\u0003; s/\n(26.7)\nD\njf j C jf 0j :\nAugmenting paths\nGiven a ﬂow network G D .V; E/ and a ﬂow f , an augmenting path p is a\nsimple path from s to t in the residual network Gf . By the deﬁnition of the resid-\nual network, we may increase the ﬂow on an edge .u; \u0003/ of an augmenting path\nby up to cf .u; \u0003/ without violating the capacity constraint on whichever of .u; \u0003/\nand .\u0003; u/ is in the original ﬂow network G.\nThe shaded path in Figure 26.4(b) is an augmenting path. Treating the residual\nnetwork Gf in the ﬁgure as a ﬂow network, we can increase the ﬂow through each\nedge of this path by up to 4 units without violating a capacity constraint, since the\nsmallest residual capacity on this path is cf .\u00032; \u00033/ D 4. We call the maximum\namount by which we can increase the ﬂow on each edge in an augmenting path p\nthe residual capacity of p, given by\ncf .p/ D min fcf .u; \u0003/ W .u; \u0003/ is on pg :\n720\nChapter 26\nMaximum Flow\nThe following lemma, whose proof we leave as Exercise 26.2-7, makes the above\nargument more precise.\nLemma 26.2\nLet G D .V; E/ be a ﬂow network, let f be a ﬂow in G, and let p be an augmenting\npath in Gf . Deﬁne a function fp W V \t V ! R by\nfp.u; \u0003/ D\n(\ncf .p/\nif .u; \u0003/ is on p ;\n0\notherwise :\n(26.8)\nThen, fp is a ﬂow in Gf with value jfpj D cf .p/ > 0.\nThe following corollary shows that if we augment f by fp, we get another ﬂow",
    "parent_3c9aa077-0fb7-4ff9-be82-ecf1711846dc": "path in Gf . Deﬁne a function fp W V \t V ! R by\nfp.u; \u0003/ D\n(\ncf .p/\nif .u; \u0003/ is on p ;\n0\notherwise :\n(26.8)\nThen, fp is a ﬂow in Gf with value jfpj D cf .p/ > 0.\nThe following corollary shows that if we augment f by fp, we get another ﬂow\nin G whose value is closer to the maximum. Figure 26.4(c) shows the result of\naugmenting the ﬂow f from Figure 26.4(a) by the ﬂow fp in Figure 26.4(b), and\nFigure 26.4(d) shows the ensuing residual network.\nCorollary 26.3\nLet G D .V; E/ be a ﬂow network, let f be a ﬂow in G, and let p be an\naugmenting path in Gf . Let fp be deﬁned as in equation (26.8), and suppose\nthat we augment f by fp. Then the function f \" fp is a ﬂow in G with value\njf \" fpj D jf j C jfpj > jf j.\nProof\nImmediate from Lemmas 26.1 and 26.2.\nCuts of ﬂow networks\nThe Ford-Fulkerson method repeatedly augments the ﬂow along augmenting paths\nuntil it has found a maximum ﬂow. How do we know that when the algorithm\nterminates, we have actually found a maximum ﬂow? The max-ﬂow min-cut theo-\nrem, which we shall prove shortly, tells us that a ﬂow is maximum if and only if its\nresidual network contains no augmenting path. To prove this theorem, though, we\nmust ﬁrst explore the notion of a cut of a ﬂow network.\nA cut .S; T / of ﬂow network G D .V; E/ is a partition of V into S and\nT D V \u0005 S such that s 2 S and t 2 T . (This deﬁnition is similar to the def-\ninition of “cut” that we used for minimum spanning trees in Chapter 23, except\nthat here we are cutting a directed graph rather than an undirected graph, and we\ninsist that s 2 S and t 2 T .) If f is a ﬂow, then the net ﬂow f .S; T / across the\ncut .S; T / is deﬁned to be\nf .S; T / D\nX\nu2S\nX\n\u00052T\nf .u; \u0003/ \u0005\nX\nu2S\nX\n\u00052T\nf .\u0003; u/ :\n(26.9)\n26.2\nThe Ford-Fulkerson method\n721\ns\nt\n11/16\n12/12\n15/20\n7/7\n4/9\n1/4\n8/13\n11/14\n4/4\nS\nT\nv4\nv3\nv1\nv2\nFigure 26.5\nA cut .S; T / in the ﬂow network of Figure 26.1(b), where S D fs; \u00031; \u00032g and\nT D f\u00033; \u00034; tg.\nThe vertices in S are black, and the vertices in T are white.\nThe net ﬂow",
    "parent_7e3ef780-34d0-40bf-b5ef-9ae7197f96d3": "f .\u0003; u/ :\n(26.9)\n26.2\nThe Ford-Fulkerson method\n721\ns\nt\n11/16\n12/12\n15/20\n7/7\n4/9\n1/4\n8/13\n11/14\n4/4\nS\nT\nv4\nv3\nv1\nv2\nFigure 26.5\nA cut .S; T / in the ﬂow network of Figure 26.1(b), where S D fs; \u00031; \u00032g and\nT D f\u00033; \u00034; tg.\nThe vertices in S are black, and the vertices in T are white.\nThe net ﬂow\nacross .S; T / is f .S; T / D 19, and the capacity is c.S; T / D 26.\nThe capacity of the cut .S; T / is\nc.S; T / D\nX\nu2S\nX\n\u00052T\nc.u; \u0003/ :\n(26.10)\nA minimum cut of a network is a cut whose capacity is minimum over all cuts of\nthe network.\nThe asymmetry between the deﬁnitions of ﬂow and capacity of a cut is inten-\ntional and important. For capacity, we count only the capacities of edges going\nfrom S to T , ignoring edges in the reverse direction. For ﬂow, we consider the\nﬂow going from S to T minus the ﬂow going in the reverse direction from T to S.\nThe reason for this difference will become clear later in this section.\nFigure 26.5 shows the cut .fs; \u00031; \u00032g ; f\u00033; \u00034; tg/ in the ﬂow network of Fig-\nure 26.1(b). The net ﬂow across this cut is\nf .\u00031; \u00033/ C f .\u00032; \u00034/ \u0005 f .\u00033; \u00032/\nD\n12 C 11 \u0005 4\nD\n19 ;\nand the capacity of this cut is\nc.\u00031; \u00033/ C c.\u00032; \u00034/\nD\n12 C 14\nD\n26 :\nThe following lemma shows that, for a given ﬂow f , the net ﬂow across any cut\nis the same, and it equals jf j, the value of the ﬂow.\nLemma 26.4\nLet f be a ﬂow in a ﬂow network G with source s and sink t, and let .S; T / be any\ncut of G. Then the net ﬂow across .S; T / is f .S; T / D jf j.\n722\nChapter 26\nMaximum Flow\nProof\nWe can rewrite the ﬂow-conservation condition for any node u 2 V \u0005fs; tg\nas\nX\n\u00052V\nf .u; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; u/ D 0 :\n(26.11)\nTaking the deﬁnition of jf j from equation (26.1) and adding the left-hand side of\nequation (26.11), which equals 0, summed over all vertices in S \u0005 fsg, gives\njf j D\nX\n\u00052V\nf .s; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; s/ C\nX\nu2S\u0003fsg\n X\n\u00052V\nf .u; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; u/\n!\n:\nExpanding the right-hand summation and regrouping terms yields\njf j\nD\nX\n\u00052V\nf .s; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; s/ C\nX\nu2S\u0003fsg\nX\n\u00052V",
    "parent_29fe95ea-9f75-4203-8901-1cdac51ba122": "equation (26.11), which equals 0, summed over all vertices in S \u0005 fsg, gives\njf j D\nX\n\u00052V\nf .s; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; s/ C\nX\nu2S\u0003fsg\n X\n\u00052V\nf .u; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; u/\n!\n:\nExpanding the right-hand summation and regrouping terms yields\njf j\nD\nX\n\u00052V\nf .s; \u0003/ \u0005\nX\n\u00052V\nf .\u0003; s/ C\nX\nu2S\u0003fsg\nX\n\u00052V\nf .u; \u0003/ \u0005\nX\nu2S\u0003fsg\nX\n\u00052V\nf .\u0003; u/\nD\nX\n\u00052V\n \nf .s; \u0003/ C\nX\nu2S\u0003fsg\nf .u; \u0003/\n!\n\u0005\nX\n\u00052V\n \nf .\u0003; s/ C\nX\nu2S\u0003fsg\nf .\u0003; u/\n!\nD\nX\n\u00052V\nX\nu2S\nf .u; \u0003/ \u0005\nX\n\u00052V\nX\nu2S\nf .\u0003; u/ :\nBecause V D S [ T and S \\ T D ;, we can split each summation over V into\nsummations over S and T to obtain\njf j\nD\nX\n\u00052S\nX\nu2S\nf .u; \u0003/ C\nX\n\u00052T\nX\nu2S\nf .u; \u0003/ \u0005\nX\n\u00052S\nX\nu2S\nf .\u0003; u/ \u0005\nX\n\u00052T\nX\nu2S\nf .\u0003; u/\nD\nX\n\u00052T\nX\nu2S\nf .u; \u0003/ \u0005\nX\n\u00052T\nX\nu2S\nf .\u0003; u/\nC\n X\n\u00052S\nX\nu2S\nf .u; \u0003/ \u0005\nX\n\u00052S\nX\nu2S\nf .\u0003; u/\n!\n:\nThe two summations within the parentheses are actually the same, since for all\nvertices x; y 2 V , the term f .x; y/ appears once in each summation. Hence, these\nsummations cancel, and we have\njf j\nD\nX\nu2S\nX\n\u00052T\nf .u; \u0003/ \u0005\nX\nu2S\nX\n\u00052T\nf .\u0003; u/\nD\nf .S; T / :\nA corollary to Lemma 26.4 shows how we can use cut capacities to bound the\nvalue of a ﬂow.\n26.2\nThe Ford-Fulkerson method\n723\nCorollary 26.5\nThe value of any ﬂow f in a ﬂow network G is bounded from above by the capacity\nof any cut of G.\nProof\nLet .S; T / be any cut of G and let f be any ﬂow. By Lemma 26.4 and the\ncapacity constraint,\njf j\nD\nf .S; T /\nD\nX\nu2S\nX\n\u00052T\nf .u; \u0003/ \u0005\nX\nu2S\nX\n\u00052T\nf .\u0003; u/\n\u0002\nX\nu2S\nX\n\u00052T\nf .u; \u0003/\n\u0002\nX\nu2S\nX\n\u00052T\nc.u; \u0003/\nD\nc.S; T / :\nCorollary 26.5 yields the immediate consequence that the value of a maximum\nﬂow in a network is bounded from above by the capacity of a minimum cut of\nthe network. The important max-ﬂow min-cut theorem, which we now state and\nprove, says that the value of a maximum ﬂow is in fact equal to the capacity of a\nminimum cut.\nTheorem 26.6 (Max-ﬂow min-cut theorem)\nIf f is a ﬂow in a ﬂow network G D .V; E/ with source s and sink t, then the\nfollowing conditions are equivalent:\n1. f is a maximum ﬂow in G.",
    "parent_07d16e60-1548-4fb4-a00c-b7c24a216672": "prove, says that the value of a maximum ﬂow is in fact equal to the capacity of a\nminimum cut.\nTheorem 26.6 (Max-ﬂow min-cut theorem)\nIf f is a ﬂow in a ﬂow network G D .V; E/ with source s and sink t, then the\nfollowing conditions are equivalent:\n1. f is a maximum ﬂow in G.\n2. The residual network Gf contains no augmenting paths.\n3. jf j D c.S; T / for some cut .S; T / of G.\nProof\n.1/ ) .2/: Suppose for the sake of contradiction that f is a maximum\nﬂow in G but that Gf has an augmenting path p. Then, by Corollary 26.3, the\nﬂow found by augmenting f by fp, where fp is given by equation (26.8), is a ﬂow\nin G with value strictly greater than jf j, contradicting the assumption that f is a\nmaximum ﬂow.\n.2/ ) .3/: Suppose that Gf has no augmenting path, that is, that Gf contains\nno path from s to t. Deﬁne\nS D f\u0003 2 V W there exists a path from s to \u0003 in Gf g\nand T D V \u0005 S. The partition .S; T / is a cut: we have s 2 S trivially and t 62 S\nbecause there is no path from s to t in Gf .\nNow consider a pair of vertices\n724\nChapter 26\nMaximum Flow\nu 2 S and \u0003 2 T . If .u; \u0003/ 2 E, we must have f .u; \u0003/ D c.u; \u0003/, since\notherwise .u; \u0003/ 2 Ef , which would place \u0003 in set S. If .\u0003; u/ 2 E, we must\nhave f .\u0003; u/ D 0, because otherwise cf .u; \u0003/ D f .\u0003; u/ would be positive and\nwe would have .u; \u0003/ 2 Ef , which would place \u0003 in S. Of course, if neither .u; \u0003/\nnor .\u0003; u/ is in E, then f .u; \u0003/ D f .\u0003; u/ D 0. We thus have\nf .S; T /\nD\nX\nu2S\nX\n\u00052T\nf .u; \u0003/ \u0005\nX\n\u00052T\nX\nu2S\nf .\u0003; u/\nD\nX\nu2S\nX\n\u00052T\nc.u; \u0003/ \u0005\nX\n\u00052T\nX\nu2S\n0\nD\nc.S; T / :\nBy Lemma 26.4, therefore, jf j D f .S; T / D c.S; T /.\n.3/ ) .1/: By Corollary 26.5, jf j \u0002 c.S; T / for all cuts .S; T /. The condition\njf j D c.S; T / thus implies that f is a maximum ﬂow.\nThe basic Ford-Fulkerson algorithm\nIn each iteration of the Ford-Fulkerson method, we ﬁnd some augmenting path p\nand use p to modify the ﬂow f . As Lemma 26.2 and Corollary 26.3 suggest, we\nreplace f by f \" fp, obtaining a new ﬂow whose value is jf j C jfpj. The follow-",
    "parent_e9e19ce1-cc22-4ca6-8258-aa8ce6734739": "The basic Ford-Fulkerson algorithm\nIn each iteration of the Ford-Fulkerson method, we ﬁnd some augmenting path p\nand use p to modify the ﬂow f . As Lemma 26.2 and Corollary 26.3 suggest, we\nreplace f by f \" fp, obtaining a new ﬂow whose value is jf j C jfpj. The follow-\ning implementation of the method computes the maximum ﬂow in a ﬂow network\nG D .V; E/ by updating the ﬂow attribute .u; \u0003/:f for each edge .u; \u0003/ 2 E.1\nIf .u; \u0003/ 62 E, we assume implicitly that .u; \u0003/:f D 0. We also assume that we\nare given the capacities c.u; \u0003/ along with the ﬂow network, and c.u; \u0003/ D 0\nif .u; \u0003/ 62 E. We compute the residual capacity cf .u; \u0003/ in accordance with the\nformula (26.2). The expression cf .p/ in the code is just a temporary variable that\nstores the residual capacity of the path p.\nFORD-FULKERSON.G; s; t/\n1\nfor each edge .u; \u0003/ 2 G:E\n2\n.u; \u0003/:f D 0\n3\nwhile there exists a path p from s to t in the residual network Gf\n4\ncf .p/ D min fcf .u; \u0003/ W .u; \u0003/ is in pg\n5\nfor each edge .u; \u0003/ in p\n6\nif .u; \u0003/ 2 E\n7\n.u; \u0003/:f D .u; \u0003/:f C cf .p/\n8\nelse .\u0003; u/:f D .\u0003; u/:f \u0005 cf .p/\n1Recall from Section 22.1 that we represent an attribute f for edge .u; \u0003/ with the same style of\nnotation—.u; \u0003/:f —that we use for an attribute of any other object.\n26.2\nThe Ford-Fulkerson method\n725\nThe FORD-FULKERSON algorithm simply expands on the FORD-FULKERSON-\nMETHOD pseudocode given earlier. Figure 26.6 shows the result of each iteration\nin a sample run. Lines 1–2 initialize the ﬂow f to 0. The while loop of lines 3–8\nrepeatedly ﬁnds an augmenting path p in Gf and augments ﬂow f along p by\nthe residual capacity cf .p/. Each residual edge in path p is either an edge in the\noriginal network or the reversal of an edge in the original network. Lines 6–8\nupdate the ﬂow in each case appropriately, adding ﬂow when the residual edge is\nan original edge and subtracting it otherwise. When no augmenting paths exist, the\nﬂow f is a maximum ﬂow.\nAnalysis of Ford-Fulkerson",
    "parent_2a4dba39-8cb0-4bbf-9f1c-03c1cbdaf4d0": "original network or the reversal of an edge in the original network. Lines 6–8\nupdate the ﬂow in each case appropriately, adding ﬂow when the residual edge is\nan original edge and subtracting it otherwise. When no augmenting paths exist, the\nﬂow f is a maximum ﬂow.\nAnalysis of Ford-Fulkerson\nThe running time of FORD-FULKERSON depends on how we ﬁnd the augmenting\npath p in line 3. If we choose it poorly, the algorithm might not even terminate: the\nvalue of the ﬂow will increase with successive augmentations, but it need not even\nconverge to the maximum ﬂow value.2 If we ﬁnd the augmenting path by using a\nbreadth-ﬁrst search (which we saw in Section 22.2), however, the algorithm runs in\npolynomial time. Before proving this result, we obtain a simple bound for the case\nin which we choose the augmenting path arbitrarily and all capacities are integers.\nIn practice, the maximum-ﬂow problem often arises with integral capacities. If\nthe capacities are rational numbers, we can apply an appropriate scaling transfor-\nmation to make them all integral. If f \u0004 denotes a maximum ﬂow in the transformed\nnetwork, then a straightforward implementation of FORD-FULKERSON executes\nthe while loop of lines 3–8 at most jf \u0004j times, since the ﬂow value increases by at\nleast one unit in each iteration.\nWe can perform the work done within the while loop efﬁciently if we implement\nthe ﬂow network G D .V; E/ with the right data structure and ﬁnd an augmenting\npath by a linear-time algorithm. Let us assume that we keep a data structure cor-\nresponding to a directed graph G0 D .V; E0/, where E0 D f.u; \u0003/ W .u; \u0003/ 2 E or\n.\u0003; u/ 2 Eg. Edges in the network G are also edges in G0, and therefore we can\neasily maintain capacities and ﬂows in this data structure. Given a ﬂow f on G,\nthe edges in the residual network Gf consist of all edges .u; \u0003/ of G0 such that\ncf .u; \u0003/ > 0, where cf conforms to equation (26.2). The time to ﬁnd a path in",
    "parent_ea57d1ff-e22f-4887-b971-b0044e89eb60": "easily maintain capacities and ﬂows in this data structure. Given a ﬂow f on G,\nthe edges in the residual network Gf consist of all edges .u; \u0003/ of G0 such that\ncf .u; \u0003/ > 0, where cf conforms to equation (26.2). The time to ﬁnd a path in\na residual network is therefore O.V C E0/ D O.E/ if we use either depth-ﬁrst\nsearch or breadth-ﬁrst search. Each iteration of the while loop thus takes O.E/\ntime, as does the initialization in lines 1–2, making the total running time of the\nFORD-FULKERSON algorithm O.E jf \u0004j/.\n2The Ford-Fulkerson method might fail to terminate only if edge capacities are irrational numbers.\n726\nChapter 26\nMaximum Flow\n12\n4\n4\n4/4\n4\nv1\n4\n16\n4\n10\ns\nt\n16\n12\n20\n7\n9\n4\n13\n14\n4\nv1\ns\nt\n4/16\n4/12\n20\n7\n4/9\n13\n4/14\n4/4\ns\nt\n7\n5\n4\n4\nv1\n8\n4\n13\n20\nv1\ns\nt\n4/16\n8/12\n4/20\n7\n4/9\n4/13\n4/14\n4/4\n4\n10\ns\nt\n7\n5\n8\n4\nv1\n4\n9\nv1\ns\nt\n8/16\n8/12\n8/20\n7\n9\n4/13\n4/14\n4/4\nv2\nv2\nv2\nv2\nv2\nv2\nv3\nv3\nv3\nv3\nv3\nv3\nv4\nv4\nv4\nv4\nv4\nv4\n(b)\n(a)\n(c)\n12\n4\n4\n4\n4\n4\nFigure 26.6\nThe execution of the basic Ford-Fulkerson algorithm. (a)–(e) Successive iterations of\nthe while loop. The left side of each part shows the residual network Gf from line 3 with a shaded\naugmenting path p. The right side of each part shows the new ﬂow f that results from augmenting f\nby fp. The residual network in (a) is the input network G.\nWhen the capacities are integral and the optimal ﬂow value jf \u0004j is small, the\nrunning time of the Ford-Fulkerson algorithm is good. Figure 26.7(a) shows an ex-\nample of what can happen on a simple ﬂow network for which jf \u0004j is large. A max-\nimum ﬂow in this network has value 2,000,000: 1,000,000 units of ﬂow traverse\nthe path s ! u ! t, and another 1,000,000 units traverse the path s ! \u0003 ! t. If\nthe ﬁrst augmenting path found by FORD-FULKERSON is s ! u ! \u0003 ! t, shown\nin Figure 26.7(a), the ﬂow has value 1 after the ﬁrst iteration. The resulting resid-\nual network appears in Figure 26.7(b). If the second iteration ﬁnds the augment-",
    "parent_b5f194d9-b9d4-43bd-82e8-bcbe0db7ce16": "the ﬁrst augmenting path found by FORD-FULKERSON is s ! u ! \u0003 ! t, shown\nin Figure 26.7(a), the ﬂow has value 1 after the ﬁrst iteration. The resulting resid-\nual network appears in Figure 26.7(b). If the second iteration ﬁnds the augment-\ning path s ! \u0003 ! u ! t, as shown in Figure 26.7(b), the ﬂow then has value 2.\nFigure 26.7(c) shows the resulting residual network. We can continue, choosing\nthe augmenting path s ! u ! \u0003 ! t in the odd-numbered iterations and the aug-\nmenting path s ! \u0003 ! u ! t in the even-numbered iterations. We would perform\na total of 2,000,000 augmentations, increasing the ﬂow value by only 1 unit in each.\n26.2\nThe Ford-Fulkerson method\n727\n4\n12\n11\n2\n11\n2\n8\n8\n9\n4\n4\n9\n8\n4\n4\n9\n8\ns\nt\n12\n7\n4\n4\nv1\ns\nt\n8/16\n8/12\n15/20\n7/7\n9\n11/13\n11/14\n4/4\nv1\n10\n19\ns\nt\n12\n1\n7\n11\n4\n3\nv2\nv3\nv3\nv3\nv4\nv4\nv4\n(d)\n(f)\n4\n9\n8\n4\n4\n15\ns\nt\n5\n7\n11\n4\nv1\ns\nt\n12/16\n12/12\n19/20\n7/7\n9\n11/13\n11/14\n4/4\nv1\n3\nv2\nv3\nv3\nv4\nv4\n(e)\n4\nv2\nv2\nv1\nv2\n8\n8\nFigure 26.6, continued\n(f) The residual network at the last while loop test. It has no augmenting\npaths, and the ﬂow f shown in (e) is therefore a maximum ﬂow. The value of the maximum ﬂow\nfound is 23.\nThe Edmonds-Karp algorithm\nWe can improve the bound on FORD-FULKERSON by ﬁnding the augmenting\npath p in line 3 with a breadth-ﬁrst search. That is, we choose the augmenting\npath as a shortest path from s to t in the residual network, where each edge has\nunit distance (weight). We call the Ford-Fulkerson method so implemented the\nEdmonds-Karp algorithm. We now prove that the Edmonds-Karp algorithm runs\nin O.VE2/ time.\nThe analysis depends on the distances to vertices in the residual network Gf .\nThe following lemma uses the notation ıf .u; \u0003/ for the shortest-path distance\nfrom u to \u0003 in Gf , where each edge has unit distance.\nLemma 26.7\nIf the Edmonds-Karp algorithm is run on a ﬂow network G D .V; E/ with source s\nand sink t, then for all vertices \u0003 2 V \u0005 fs; tg, the shortest-path distance ıf .s; \u0003/",
    "parent_ae3c9db1-c288-44ff-8048-107fd5bab233": "from u to \u0003 in Gf , where each edge has unit distance.\nLemma 26.7\nIf the Edmonds-Karp algorithm is run on a ﬂow network G D .V; E/ with source s\nand sink t, then for all vertices \u0003 2 V \u0005 fs; tg, the shortest-path distance ıf .s; \u0003/\nin the residual network Gf increases monotonically with each ﬂow augmentation.\n728\nChapter 26\nMaximum Flow\n1\n999,999\n999,999\n1\ns\nt\n1,000,000\n1,000,000\n1\n1,000,000\n1,000,000\n999,999\n1\n1\n999,999\nu\nv\ns\nt\n1,000,000\n1\n1,000,000\nu\nv\n999,999\n1\n999,999\n1\ns\nt\n1\nu\nv\n(a)\n(b)\n(c)\nFigure 26.7\n(a) A ﬂow network for which FORD-FULKERSON can take ‚.E jf \u0004j/ time,\nwhere f \u0004 is a maximum ﬂow, shown here with jf \u0004j D 2,000,000. The shaded path is an aug-\nmenting path with residual capacity 1. (b) The resulting residual network, with another augmenting\npath whose residual capacity is 1. (c) The resulting residual network.\nProof\nWe will suppose that for some vertex \u0003 2 V \u0005 fs; tg, there is a ﬂow aug-\nmentation that causes the shortest-path distance from s to \u0003 to decrease, and then\nwe will derive a contradiction. Let f be the ﬂow just before the ﬁrst augmentation\nthat decreases some shortest-path distance, and let f 0 be the ﬂow just afterward.\nLet \u0003 be the vertex with the minimum ıf 0.s; \u0003/ whose distance was decreased by\nthe augmentation, so that ıf 0.s; \u0003/ < ıf .s; \u0003/. Let p D s ; u ! \u0003 be a shortest\npath from s to \u0003 in Gf 0, so that .u; \u0003/ 2 Ef 0 and\nıf 0.s; u/ D ıf 0.s; \u0003/ \u0005 1 :\n(26.12)\nBecause of how we chose \u0003, we know that the distance of vertex u from the source s\ndid not decrease, i.e.,\nıf 0.s; u/ \u0006 ıf .s; u/ :\n(26.13)\nWe claim that .u; \u0003/ 62 Ef . Why? If we had .u; \u0003/ 2 Ef , then we would also have\nıf .s; \u0003/\n\u0002\nıf .s; u/ C 1\n(by Lemma 24.10, the triangle inequality)\n\u0002\nıf 0.s; u/ C 1\n(by inequality (26.13))\nD\nıf 0.s; \u0003/\n(by equation (26.12)) ,\nwhich contradicts our assumption that ıf 0.s; \u0003/ < ıf .s; \u0003/.\nHow can we have .u; \u0003/ 62 Ef and .u; \u0003/ 2 Ef 0? The augmentation must\nhave increased the ﬂow from \u0003 to u. The Edmonds-Karp algorithm always aug-",
    "parent_5d6b8a00-80c7-4ec8-a331-eeae2f9e8303": "\u0002\nıf 0.s; u/ C 1\n(by inequality (26.13))\nD\nıf 0.s; \u0003/\n(by equation (26.12)) ,\nwhich contradicts our assumption that ıf 0.s; \u0003/ < ıf .s; \u0003/.\nHow can we have .u; \u0003/ 62 Ef and .u; \u0003/ 2 Ef 0? The augmentation must\nhave increased the ﬂow from \u0003 to u. The Edmonds-Karp algorithm always aug-\nments ﬂow along shortest paths, and therefore the shortest path from s to u in Gf\nhas .\u0003; u/ as its last edge. Therefore,\nıf .s; \u0003/\nD\nıf .s; u/ \u0005 1\n\u0002\nıf 0.s; u/ \u0005 1\n(by inequality (26.13))\nD\nıf 0.s; \u0003/ \u0005 2\n(by equation (26.12)) ,\n26.2\nThe Ford-Fulkerson method\n729\nwhich contradicts our assumption that ıf 0.s; \u0003/ < ıf .s; \u0003/. We conclude that our\nassumption that such a vertex \u0003 exists is incorrect.\nThe next theorem bounds the number of iterations of the Edmonds-Karp algo-\nrithm.\nTheorem 26.8\nIf the Edmonds-Karp algorithm is run on a ﬂow network G D .V; E/ with source s\nand sink t, then the total number of ﬂow augmentations performed by the algorithm\nis O.VE/.\nProof\nWe say that an edge .u; \u0003/ in a residual network Gf is critical on an aug-\nmenting path p if the residual capacity of p is the residual capacity of .u; \u0003/, that\nis, if cf .p/ D cf .u; \u0003/. After we have augmented ﬂow along an augmenting path,\nany critical edge on the path disappears from the residual network. Moreover, at\nleast one edge on any augmenting path must be critical. We will show that each of\nthe jEj edges can become critical at most jV j =2 times.\nLet u and \u0003 be vertices in V that are connected by an edge in E. Since augment-\ning paths are shortest paths, when .u; \u0003/ is critical for the ﬁrst time, we have\nıf .s; \u0003/ D ıf .s; u/ C 1 :\nOnce the ﬂow is augmented, the edge .u; \u0003/ disappears from the residual network.\nIt cannot reappear later on another augmenting path until after the ﬂow from u to \u0003\nis decreased, which occurs only if .\u0003; u/ appears on an augmenting path. If f 0 is\nthe ﬂow in G when this event occurs, then we have\nıf 0.s; u/ D ıf 0.s; \u0003/ C 1 :\nSince ıf .s; \u0003/ \u0002 ıf 0.s; \u0003/ by Lemma 26.7, we have\nıf 0.s; u/",
    "parent_b07df2d8-af16-4e63-9c15-e1c9bac09f0e": "is decreased, which occurs only if .\u0003; u/ appears on an augmenting path. If f 0 is\nthe ﬂow in G when this event occurs, then we have\nıf 0.s; u/ D ıf 0.s; \u0003/ C 1 :\nSince ıf .s; \u0003/ \u0002 ıf 0.s; \u0003/ by Lemma 26.7, we have\nıf 0.s; u/\nD\nıf 0.s; \u0003/ C 1\n\u0006\nıf .s; \u0003/ C 1\nD\nıf .s; u/ C 2 :\nConsequently, from the time .u; \u0003/ becomes critical to the time when it next\nbecomes critical, the distance of u from the source increases by at least 2. The\ndistance of u from the source is initially at least 0. The intermediate vertices on a\nshortest path from s to u cannot contain s, u, or t (since .u; \u0003/ on an augmenting\npath implies that u ¤ t). Therefore, until u becomes unreachable from the source,\nif ever, its distance is at most jV j \u0005 2. Thus, after the ﬁrst time that .u; \u0003/ becomes\ncritical, it can become critical at most .jV j \u0005 2/=2 D jV j =2 \u0005 1 times more, for a\ntotal of at most jV j =2 times. Since there are O.E/ pairs of vertices that can have an\nedge between them in a residual network, the total number of critical edges during\n730\nChapter 26\nMaximum Flow\nthe entire execution of the Edmonds-Karp algorithm is O.VE/. Each augmenting\npath has at least one critical edge, and hence the theorem follows.\nBecause we can implement each iteration of FORD-FULKERSON in O.E/ time\nwhen we ﬁnd the augmenting path by breadth-ﬁrst search, the total running time of\nthe Edmonds-Karp algorithm is O.VE2/. We shall see that push-relabel algorithms\ncan yield even better bounds. The algorithm of Section 26.4 gives a method for\nachieving an O.V 2E/ running time, which forms the basis for the O.V 3/-time\nalgorithm of Section 26.5.\nExercises\n26.2-1\nProve that the summations in equation (26.6) equal the summations in equa-\ntion (26.7).\n26.2-2\nIn Figure 26.1(b), what is the ﬂow across the cut .fs; \u00032; \u00034g ; f\u00031; \u00033; tg/? What is\nthe capacity of this cut?\n26.2-3\nShow the execution of the Edmonds-Karp algorithm on the ﬂow network of Fig-\nure 26.1(a).\n26.2-4",
    "parent_d18a8114-0b78-440f-8619-60774b331242": "tion (26.7).\n26.2-2\nIn Figure 26.1(b), what is the ﬂow across the cut .fs; \u00032; \u00034g ; f\u00031; \u00033; tg/? What is\nthe capacity of this cut?\n26.2-3\nShow the execution of the Edmonds-Karp algorithm on the ﬂow network of Fig-\nure 26.1(a).\n26.2-4\nIn the example of Figure 26.6, what is the minimum cut corresponding to the max-\nimum ﬂow shown? Of the augmenting paths appearing in the example, which one\ncancels ﬂow?\n26.2-5\nRecall that the construction in Section 26.1 that converts a ﬂow network with mul-\ntiple sources and sinks into a single-source, single-sink network adds edges with\ninﬁnite capacity. Prove that any ﬂow in the resulting network has a ﬁnite value\nif the edges of the original network with multiple sources and sinks have ﬁnite\ncapacity.\n26.2-6\nSuppose that each source si in a ﬂow network with multiple sources and sinks\nproduces exactly pi units of ﬂow, so that P\n\u00052V f .si; \u0003/ D pi. Suppose also\nthat each sink tj consumes exactly qj units, so that P\n\u00052V f .\u0003; tj/ D qj, where\nP\ni pi D P\nj qj. Show how to convert the problem of ﬁnding a ﬂow f that obeys\n26.2\nThe Ford-Fulkerson method\n731\nthese additional constraints into the problem of ﬁnding a maximum ﬂow in a single-\nsource, single-sink ﬂow network.\n26.2-7\nProve Lemma 26.2.\n26.2-8\nSuppose that we redeﬁne the residual network to disallow edges into s. Argue that\nthe procedure FORD-FULKERSON still correctly computes a maximum ﬂow.\n26.2-9\nSuppose that both f and f 0 are ﬂows in a network G and we compute ﬂow f \" f 0.\nDoes the augmented ﬂow satisfy the ﬂow conservation property? Does it satisfy\nthe capacity constraint?\n26.2-10\nShow how to ﬁnd a maximum ﬂow in a network G D .V; E/ by a sequence of at\nmost jEj augmenting paths. (Hint: Determine the paths after ﬁnding the maximum\nﬂow.)\n26.2-11\nThe edge connectivity of an undirected graph is the minimum number k of edges\nthat must be removed to disconnect the graph. For example, the edge connectivity",
    "parent_d087ba93-edcb-40da-8ea6-3976b4a6489e": "most jEj augmenting paths. (Hint: Determine the paths after ﬁnding the maximum\nﬂow.)\n26.2-11\nThe edge connectivity of an undirected graph is the minimum number k of edges\nthat must be removed to disconnect the graph. For example, the edge connectivity\nof a tree is 1, and the edge connectivity of a cyclic chain of vertices is 2. Show\nhow to determine the edge connectivity of an undirected graph G D .V; E/ by\nrunning a maximum-ﬂow algorithm on at most jV j ﬂow networks, each having\nO.V / vertices and O.E/ edges.\n26.2-12\nSuppose that you are given a ﬂow network G, and G has edges entering the\nsource s. Let f be a ﬂow in G in which one of the edges .\u0003; s/ entering the source\nhas f .\u0003; s/ D 1. Prove that there must exist another ﬂow f 0 with f 0.\u0003; s/ D 0\nsuch that jf j D jf 0j. Give an O.E/-time algorithm to compute f 0, given f , and\nassuming that all edge capacities are integers.\n26.2-13\nSuppose that you wish to ﬁnd, among all minimum cuts in a ﬂow network G with\nintegral capacities, one that contains the smallest number of edges. Show how to\nmodify the capacities of G to create a new ﬂow network G0 in which any minimum\ncut in G0 is a minimum cut with the smallest number of edges in G.\n732\nChapter 26\nMaximum Flow\n26.3\nMaximum bipartite matching\nSome combinatorial problems can easily be cast as maximum-ﬂow problems. The\nmultiple-source, multiple-sink maximum-ﬂow problem from Section 26.1 gave us\none example. Some other combinatorial problems seem on the surface to have little\nto do with ﬂow networks, but can in fact be reduced to maximum-ﬂow problems.\nThis section presents one such problem: ﬁnding a maximum matching in a bipartite\ngraph. In order to solve this problem, we shall take advantage of an integrality\nproperty provided by the Ford-Fulkerson method. We shall also see how to use\nthe Ford-Fulkerson method to solve the maximum-bipartite-matching problem on\na graph G D .V; E/ in O.VE/ time.\nThe maximum-bipartite-matching problem",
    "parent_1323a7fa-a84c-4122-bedb-9b4c6f8c8eb6": "property provided by the Ford-Fulkerson method. We shall also see how to use\nthe Ford-Fulkerson method to solve the maximum-bipartite-matching problem on\na graph G D .V; E/ in O.VE/ time.\nThe maximum-bipartite-matching problem\nGiven an undirected graph G D .V; E/, a matching is a subset of edges M \u0007 E\nsuch that for all vertices \u0003 2 V , at most one edge of M is incident on \u0003. We\nsay that a vertex \u0003 2 V is matched by the matching M if some edge in M is\nincident on \u0003; otherwise, \u0003 is unmatched. A maximum matching is a matching\nof maximum cardinality, that is, a matching M such that for any matching M 0,\nwe have jMj \u0006 jM 0j. In this section, we shall restrict our attention to ﬁnding\nmaximum matchings in bipartite graphs: graphs in which the vertex set can be\npartitioned into V D L [ R, where L and R are disjoint and all edges in E\ngo between L and R. We further assume that every vertex in V has at least one\nincident edge. Figure 26.8 illustrates the notion of a matching in a bipartite graph.\nThe problem of ﬁnding a maximum matching in a bipartite graph has many\npractical applications. As an example, we might consider matching a set L of ma-\nchines with a set R of tasks to be performed simultaneously. We take the presence\nof edge .u; \u0003/ in E to mean that a particular machine u 2 L is capable of per-\nforming a particular task \u0003 2 R. A maximum matching provides work for as many\nmachines as possible.\nFinding a maximum bipartite matching\nWe can use the Ford-Fulkerson method to ﬁnd a maximum matching in an undi-\nrected bipartite graph G D .V; E/ in time polynomial in jV j and jEj. The trick is\nto construct a ﬂow network in which ﬂows correspond to matchings, as shown in\nFigure 26.8(c). We deﬁne the corresponding ﬂow network G0 D .V 0; E0/ for the\nbipartite graph G as follows. We let the source s and sink t be new vertices not\nin V , and we let V 0 D V [ fs; tg. If the vertex partition of G is V D L [ R, the\n26.3\nMaximum bipartite matching\n733\nL\nR\nL\nR\ns\nt\n(a)\n(c)\nL\nR\n(b)",
    "parent_dfcb3f2a-a8ea-42f0-9580-e72a2fcea2a6": "bipartite graph G as follows. We let the source s and sink t be new vertices not\nin V , and we let V 0 D V [ fs; tg. If the vertex partition of G is V D L [ R, the\n26.3\nMaximum bipartite matching\n733\nL\nR\nL\nR\ns\nt\n(a)\n(c)\nL\nR\n(b)\nFigure 26.8\nA bipartite graph G D .V; E/ with vertex partition V D L [ R. (a) A matching\nwith cardinality 2, indicated by shaded edges. (b) A maximum matching with cardinality 3. (c) The\ncorresponding ﬂow network G0 with a maximum ﬂow shown. Each edge has unit capacity. Shaded\nedges have a ﬂow of 1, and all other edges carry no ﬂow. The shaded edges from L to R correspond\nto those in the maximum matching from (b).\ndirected edges of G0 are the edges of E, directed from L to R, along with jV j new\ndirected edges:\nE0 D f.s; u/ W u 2 Lg [ f.u; \u0003/ W .u; \u0003/ 2 Eg [ f.\u0003; t/ W \u0003 2 Rg :\nTo complete the construction, we assign unit capacity to each edge in E0. Since\neach vertex in V has at least one incident edge, jEj \u0006 jV j =2. Thus, jEj \u0002 jE0j D\njEj C jV j \u0002 3 jEj, and so jE0j D ‚.E/.\nThe following lemma shows that a matching in G corresponds directly to a ﬂow\nin G’s corresponding ﬂow network G0. We say that a ﬂow f on a ﬂow network\nG D .V; E/ is integer-valued if f .u; \u0003/ is an integer for all .u; \u0003/ 2 V \t V .\nLemma 26.9\nLet G D .V; E/ be a bipartite graph with vertex partition V D L [ R, and let\nG0 D .V 0; E0/ be its corresponding ﬂow network. If M is a matching in G, then\nthere is an integer-valued ﬂow f in G0 with value jf j D jMj. Conversely, if f\nis an integer-valued ﬂow in G0, then there is a matching M in G with cardinality\njMj D jf j.\nProof\nWe ﬁrst show that a matching M in G corresponds to an integer-valued\nﬂow f in G0. Deﬁne f as follows. If .u; \u0003/ 2 M, then f .s; u/ D f .u; \u0003/ D\nf .\u0003; t/ D 1. For all other edges .u; \u0003/ 2 E0, we deﬁne f .u; \u0003/ D 0. It is simple\nto verify that f satisﬁes the capacity constraint and ﬂow conservation.\n734\nChapter 26\nMaximum Flow\nIntuitively, each edge .u; \u0003/ 2 M corresponds to one unit of ﬂow in G0 that",
    "parent_1b966c74-d402-4f17-8136-785fd11c615e": "f .\u0003; t/ D 1. For all other edges .u; \u0003/ 2 E0, we deﬁne f .u; \u0003/ D 0. It is simple\nto verify that f satisﬁes the capacity constraint and ﬂow conservation.\n734\nChapter 26\nMaximum Flow\nIntuitively, each edge .u; \u0003/ 2 M corresponds to one unit of ﬂow in G0 that\ntraverses the path s ! u ! \u0003 ! t. Moreover, the paths induced by edges in M\nare vertex-disjoint, except for s and t. The net ﬂow across cut .L [ fsg ; R [ ftg/\nis equal to jMj; thus, by Lemma 26.4, the value of the ﬂow is jf j D jMj.\nTo prove the converse, let f be an integer-valued ﬂow in G0, and let\nM D f.u; \u0003/ W u 2 L; \u0003 2 R; and f .u; \u0003/ > 0g :\nEach vertex u 2 L has only one entering edge, namely .s; u/, and its capacity\nis 1. Thus, each u 2 L has at most one unit of ﬂow entering it, and if one unit of\nﬂow does enter, by ﬂow conservation, one unit of ﬂow must leave. Furthermore,\nsince f is integer-valued, for each u 2 L, the one unit of ﬂow can enter on at most\none edge and can leave on at most one edge. Thus, one unit of ﬂow enters u if and\nonly if there is exactly one vertex \u0003 2 R such that f .u; \u0003/ D 1, and at most one\nedge leaving each u 2 L carries positive ﬂow. A symmetric argument applies to\neach \u0003 2 R. The set M is therefore a matching.\nTo see that jMj D jf j, observe that for every matched vertex u 2 L, we have\nf .s; u/ D 1, and for every edge .u; \u0003/ 2 E \u0005 M, we have f .u; \u0003/ D 0. Conse-\nquently, f .L [ fsg ; R [ ftg/, the net ﬂow across cut .L [ fsg ; R [ ftg/, is equal\nto jMj. Applying Lemma 26.4, we have that jf j D f .L[fsg ; R[ftg/ D jMj.\nBased on Lemma 26.9, we would like to conclude that a maximum matching\nin a bipartite graph G corresponds to a maximum ﬂow in its corresponding ﬂow\nnetwork G0, and we can therefore compute a maximum matching in G by running\na maximum-ﬂow algorithm on G0. The only hitch in this reasoning is that the\nmaximum-ﬂow algorithm might return a ﬂow in G0 for which some f .u; \u0003/ is\nnot an integer, even though the ﬂow value jf j must be an integer. The following",
    "parent_d045db32-d4c3-459b-9852-dad83ded1288": "a maximum-ﬂow algorithm on G0. The only hitch in this reasoning is that the\nmaximum-ﬂow algorithm might return a ﬂow in G0 for which some f .u; \u0003/ is\nnot an integer, even though the ﬂow value jf j must be an integer. The following\ntheorem shows that if we use the Ford-Fulkerson method, this difﬁculty cannot\narise.\nTheorem 26.10 (Integrality theorem)\nIf the capacity function c takes on only integral values, then the maximum ﬂow f\nproduced by the Ford-Fulkerson method has the property that jf j is an integer.\nMoreover, for all vertices u and \u0003, the value of f .u; \u0003/ is an integer.\nProof\nThe proof is by induction on the number of iterations. We leave it as\nExercise 26.3-2.\nWe can now prove the following corollary to Lemma 26.9.\n26.3\nMaximum bipartite matching\n735\nCorollary 26.11\nThe cardinality of a maximum matching M in a bipartite graph G equals the value\nof a maximum ﬂow f in its corresponding ﬂow network G0.\nProof\nWe use the nomenclature from Lemma 26.9. Suppose that M is a max-\nimum matching in G and that the corresponding ﬂow f in G0 is not maximum.\nThen there is a maximum ﬂow f 0 in G0 such that jf 0j > jf j. Since the ca-\npacities in G0 are integer-valued, by Theorem 26.10, we can assume that f 0 is\ninteger-valued.\nThus, f 0 corresponds to a matching M 0 in G with cardinality\njM 0j D jf 0j > jf j D jMj, contradicting our assumption that M is a maximum\nmatching. In a similar manner, we can show that if f is a maximum ﬂow in G0, its\ncorresponding matching is a maximum matching on G.\nThus, given a bipartite undirected graph G, we can ﬁnd a maximum matching by\ncreating the ﬂow network G0, running the Ford-Fulkerson method, and directly ob-\ntaining a maximum matching M from the integer-valued maximum ﬂow f found.\nSince any matching in a bipartite graph has cardinality at most min.L; R/ D O.V /,\nthe value of the maximum ﬂow in G0 is O.V /. We can therefore ﬁnd a maximum\nmatching in a bipartite graph in time O.VE0/ D O.VE/, since jE0j D ‚.E/.\nExercises\n26.3-1",
    "parent_07f55184-512b-49de-a943-d622ce06d98b": "Since any matching in a bipartite graph has cardinality at most min.L; R/ D O.V /,\nthe value of the maximum ﬂow in G0 is O.V /. We can therefore ﬁnd a maximum\nmatching in a bipartite graph in time O.VE0/ D O.VE/, since jE0j D ‚.E/.\nExercises\n26.3-1\nRun the Ford-Fulkerson algorithm on the ﬂow network in Figure 26.8(c) and show\nthe residual network after each ﬂow augmentation. Number the vertices in L top\nto bottom from 1 to 5 and in R top to bottom from 6 to 9. For each iteration, pick\nthe augmenting path that is lexicographically smallest.\n26.3-2\nProve Theorem 26.10.\n26.3-3\nLet G D .V; E/ be a bipartite graph with vertex partition V D L [ R, and let G0\nbe its corresponding ﬂow network. Give a good upper bound on the length of any\naugmenting path found in G0 during the execution of FORD-FULKERSON.\n26.3-4\n?\nA perfect matching is a matching in which every vertex is matched. Let G D\n.V; E/ be an undirected bipartite graph with vertex partition V D L [ R, where\njLj D jRj. For any X \u0007 V , deﬁne the neighborhood of X as\nN.X/ D fy 2 V W .x; y/ 2 E for some x 2 Xg ;\n736\nChapter 26\nMaximum Flow\nthat is, the set of vertices adjacent to some member of X. Prove Hall’s theorem:\nthere exists a perfect matching in G if and only if jAj \u0002 jN.A/j for every subset\nA \u0007 L.\n26.3-5\n?\nWe say that a bipartite graph G D .V; E/, where V D L[R, is d-regular if every\nvertex \u0003 2 V has degree exactly d. Every d-regular bipartite graph has jLj D jRj.\nProve that every d-regular bipartite graph has a matching of cardinality jLj by\narguing that a minimum cut of the corresponding ﬂow network has capacity jLj.\n?\n26.4\nPush-relabel algorithms\nIn this section, we present the “push-relabel” approach to computing maximum\nﬂows. To date, many of the asymptotically fastest maximum-ﬂow algorithms are\npush-relabel algorithms, and the fastest actual implementations of maximum-ﬂow\nalgorithms are based on the push-relabel method. Push-relabel methods also efﬁ-",
    "parent_7122006e-a5c2-460a-ba03-18c272b0249a": "ﬂows. To date, many of the asymptotically fastest maximum-ﬂow algorithms are\npush-relabel algorithms, and the fastest actual implementations of maximum-ﬂow\nalgorithms are based on the push-relabel method. Push-relabel methods also efﬁ-\nciently solve other ﬂow problems, such as the minimum-cost ﬂow problem. This\nsection introduces Goldberg’s “generic” maximum-ﬂow algorithm, which has a\nsimple implementation that runs in O.V 2E/ time, thereby improving upon the\nO.VE2/ bound of the Edmonds-Karp algorithm. Section 26.5 reﬁnes the generic\nalgorithm to obtain another push-relabel algorithm that runs in O.V 3/ time.\nPush-relabel algorithms work in a more localized manner than the Ford-\nFulkerson method. Rather than examine the entire residual network to ﬁnd an aug-\nmenting path, push-relabel algorithms work on one vertex at a time, looking only\nat the vertex’s neighbors in the residual network. Furthermore, unlike the Ford-\nFulkerson method, push-relabel algorithms do not maintain the ﬂow-conservation\nproperty throughout their execution. They do, however, maintain a preﬂow, which\nis a function f W V \tV ! R that satisﬁes the capacity constraint and the following\nrelaxation of ﬂow conservation:\nX\n\u00052V\nf .\u0003; u/ \u0005\nX\n\u00052V\nf .u; \u0003/ \u0006 0\nfor all vertices u 2 V \u0005 fsg. That is, the ﬂow into a vertex may exceed the ﬂow\nout. We call the quantity\ne.u/ D\nX\n\u00052V\nf .\u0003; u/ \u0005\nX\n\u00052V\nf .u; \u0003/\n(26.14)\nthe excess ﬂow into vertex u. The excess at a vertex is the amount by which the\nﬂow in exceeds the ﬂow out. We say that a vertex u 2 V \u0005 fs; tg is overﬂowing if\ne.u/ > 0.\n26.4\nPush-relabel algorithms\n737\nWe shall begin this section by describing the intuition behind the push-relabel\nmethod. We shall then investigate the two operations employed by the method:\n“pushing” preﬂow and “relabeling” a vertex. Finally, we shall present a generic\npush-relabel algorithm and analyze its correctness and running time.\nIntuition\nYou can understand the intuition behind the push-relabel method in terms of ﬂuid",
    "parent_4cc2b143-b699-49df-bd59-93e3dd1d22c1": "“pushing” preﬂow and “relabeling” a vertex. Finally, we shall present a generic\npush-relabel algorithm and analyze its correctness and running time.\nIntuition\nYou can understand the intuition behind the push-relabel method in terms of ﬂuid\nﬂows: we consider a ﬂow network G D .V; E/ to be a system of interconnected\npipes of given capacities. Applying this analogy to the Ford-Fulkerson method,\nwe might say that each augmenting path in the network gives rise to an additional\nstream of ﬂuid, with no branch points, ﬂowing from the source to the sink. The\nFord-Fulkerson method iteratively adds more streams of ﬂow until no more can be\nadded.\nThe generic push-relabel algorithm has a rather different intuition. As before,\ndirected edges correspond to pipes. Vertices, which are pipe junctions, have two\ninteresting properties. First, to accommodate excess ﬂow, each vertex has an out-\nﬂow pipe leading to an arbitrarily large reservoir that can accumulate ﬂuid. Second,\neach vertex, its reservoir, and all its pipe connections sit on a platform whose height\nincreases as the algorithm progresses.\nVertex heights determine how ﬂow is pushed: we push ﬂow only downhill, that\nis, from a higher vertex to a lower vertex. The ﬂow from a lower vertex to a higher\nvertex may be positive, but operations that push ﬂow push it only downhill. We\nﬁx the height of the source at jV j and the height of the sink at 0. All other vertex\nheights start at 0 and increase with time. The algorithm ﬁrst sends as much ﬂow as\npossible downhill from the source toward the sink. The amount it sends is exactly\nenough to ﬁll each outgoing pipe from the source to capacity; that is, it sends the\ncapacity of the cut .s; V \u0005 fsg/. When ﬂow ﬁrst enters an intermediate vertex, it\ncollects in the vertex’s reservoir. From there, we eventually push it downhill.\nWe may eventually ﬁnd that the only pipes that leave a vertex u and are not\nalready saturated with ﬂow connect to vertices that are on the same level as u or",
    "parent_d45f13b5-fed0-4607-b53d-b21b75ea64f7": "collects in the vertex’s reservoir. From there, we eventually push it downhill.\nWe may eventually ﬁnd that the only pipes that leave a vertex u and are not\nalready saturated with ﬂow connect to vertices that are on the same level as u or\nare uphill from u. In this case, to rid an overﬂowing vertex u of its excess ﬂow, we\nmust increase its height—an operation called “relabeling” vertex u. We increase\nits height to one unit more than the height of the lowest of its neighbors to which\nit has an unsaturated pipe. After a vertex is relabeled, therefore, it has at least one\noutgoing pipe through which we can push more ﬂow.\nEventually, all the ﬂow that can possibly get through to the sink has arrived there.\nNo more can arrive, because the pipes obey the capacity constraints; the amount of\nﬂow across any cut is still limited by the capacity of the cut. To make the preﬂow\na “legal” ﬂow, the algorithm then sends the excess collected in the reservoirs of\noverﬂowing vertices back to the source by continuing to relabel vertices to above\n738\nChapter 26\nMaximum Flow\nthe ﬁxed height jV j of the source. As we shall see, once we have emptied all the\nreservoirs, the preﬂow is not only a “legal” ﬂow, it is also a maximum ﬂow.\nThe basic operations\nFrom the preceding discussion, we see that a push-relabel algorithm performs two\nbasic operations: pushing ﬂow excess from a vertex to one of its neighbors and\nrelabeling a vertex. The situations in which these operations apply depend on the\nheights of vertices, which we now deﬁne precisely.\nLet G D .V; E/ be a ﬂow network with source s and sink t, and let f be a\npreﬂow in G. A function h W V ! N is a height function3 if h.s/ D jV j,\nh.t/ D 0, and\nh.u/ \u0002 h.\u0003/ C 1\nfor every residual edge .u; \u0003/ 2 Ef . We immediately obtain the following lemma.\nLemma 26.12\nLet G D .V; E/ be a ﬂow network, let f be a preﬂow in G, and let h be a height\nfunction on V . For any two vertices u; \u0003 2 V , if h.u/ > h.\u0003/ C 1, then .u; \u0003/ is",
    "parent_a442a435-e2d6-4f3c-85f8-570e23a13e7b": "h.t/ D 0, and\nh.u/ \u0002 h.\u0003/ C 1\nfor every residual edge .u; \u0003/ 2 Ef . We immediately obtain the following lemma.\nLemma 26.12\nLet G D .V; E/ be a ﬂow network, let f be a preﬂow in G, and let h be a height\nfunction on V . For any two vertices u; \u0003 2 V , if h.u/ > h.\u0003/ C 1, then .u; \u0003/ is\nnot an edge in the residual network.\nThe push operation\nThe basic operation PUSH.u; \u0003/ applies if u is an overﬂowing vertex, cf .u; \u0003/ > 0,\nand h.u/ D h.\u0003/C1. The pseudocode below updates the preﬂow f and the excess\nﬂows for u and \u0003. It assumes that we can compute residual capacity cf .u; \u0003/ in\nconstant time given c and f . We maintain the excess ﬂow stored at a vertex u as\nthe attribute u:e and the height of u as the attribute u:h. The expression \ff .u; \u0003/\nis a temporary variable that stores the amount of ﬂow that we can push from u to \u0003.\n3In the literature, a height function is typically called a “distance function,” and the height of a vertex\nis called a “distance label.” We use the term “height” because it is more suggestive of the intuition\nbehind the algorithm. We retain the use of the term “relabel” to refer to the operation that increases\nthe height of a vertex. The height of a vertex is related to its distance from the sink t, as would be\nfound in a breadth-ﬁrst search of the transpose GT.\n26.4\nPush-relabel algorithms\n739\nPUSH.u; \u0003/\n1\n// Applies when: u is overﬂowing, cf .u; \u0003/ > 0, and u:h D \u0003:h C 1.\n2\n// Action: Push \ff .u; \u0003/ D min.u:e; cf .u; \u0003// units of ﬂow from u to \u0003.\n3\n\ff .u; \u0003/ D min.u:e; cf .u; \u0003//\n4\nif .u; \u0003/ 2 E\n5\n.u; \u0003/:f D .u; \u0003/:f C \ff .u; \u0003/\n6\nelse .\u0003; u/:f D .\u0003; u/:f \u0005 \ff .u; \u0003/\n7\nu:e D u:e \u0005 \ff .u; \u0003/\n8\n\u0003:e D \u0003:e C \ff .u; \u0003/\nThe code for PUSH operates as follows. Because vertex u has a positive excess u:e\nand the residual capacity of .u; \u0003/ is positive, we can increase the ﬂow from u to \u0003\nby \ff .u; \u0003/ D min.u:e; cf .u; \u0003// without causing u:e to become negative or the\ncapacity c.u; \u0003/ to be exceeded. Line 3 computes the value \ff .u; \u0003/, and lines 4–6",
    "parent_6eeced82-ec13-48ae-9915-cb9c1c225206": "and the residual capacity of .u; \u0003/ is positive, we can increase the ﬂow from u to \u0003\nby \ff .u; \u0003/ D min.u:e; cf .u; \u0003// without causing u:e to become negative or the\ncapacity c.u; \u0003/ to be exceeded. Line 3 computes the value \ff .u; \u0003/, and lines 4–6\nupdate f . Line 5 increases the ﬂow on edge .u; \u0003/, because we are pushing ﬂow\nover a residual edge that is also an original edge. Line 6 decreases the ﬂow on\nedge .\u0003; u/, because the residual edge is actually the reverse of an edge in the\noriginal network. Finally, lines 7–8 update the excess ﬂows into vertices u and \u0003.\nThus, if f is a preﬂow before PUSH is called, it remains a preﬂow afterward.\nObserve that nothing in the code for PUSH depends on the heights of u and \u0003,\nyet we prohibit it from being invoked unless u:h D \u0003:h C 1. Thus, we push excess\nﬂow downhill only by a height differential of 1. By Lemma 26.12, no residual\nedges exist between two vertices whose heights differ by more than 1, and thus,\nas long as the attribute h is indeed a height function, we would gain nothing by\nallowing ﬂow to be pushed downhill by a height differential of more than 1.\nWe call the operation PUSH.u; \u0003/ a push from u to \u0003. If a push operation ap-\nplies to some edge .u; \u0003/ leaving a vertex u, we also say that the push operation\napplies to u. It is a saturating push if edge .u; \u0003/ in the residual network becomes\nsaturated (cf .u; \u0003/ D 0 afterward); otherwise, it is a nonsaturating push. If an\nedge becomes saturated, it disappears from the residual network. A simple lemma\ncharacterizes one result of a nonsaturating push.\nLemma 26.13\nAfter a nonsaturating push from u to \u0003, the vertex u is no longer overﬂowing.\nProof\nSince the push was nonsaturating, the amount of ﬂow \ff .u; \u0003/ actually\npushed must equal u:e prior to the push. Since u:e is reduced by this amount, it\nbecomes 0 after the push.\n740\nChapter 26\nMaximum Flow\nThe relabel operation\nThe basic operation RELABEL.u/ applies if u is overﬂowing and if u:h \u0002 \u0003:h for",
    "parent_f75327c9-b847-4f84-b9a2-8c1de5d2262b": "pushed must equal u:e prior to the push. Since u:e is reduced by this amount, it\nbecomes 0 after the push.\n740\nChapter 26\nMaximum Flow\nThe relabel operation\nThe basic operation RELABEL.u/ applies if u is overﬂowing and if u:h \u0002 \u0003:h for\nall edges .u; \u0003/ 2 Ef . In other words, we can relabel an overﬂowing vertex u if\nfor every vertex \u0003 for which there is residual capacity from u to \u0003, ﬂow cannot be\npushed from u to \u0003 because \u0003 is not downhill from u. (Recall that by deﬁnition,\nneither the source s nor the sink t can be overﬂowing, and so s and t are ineligible\nfor relabeling.)\nRELABEL.u/\n1\n// Applies when: u is overﬂowing and for all \u0003 2 V such that .u; \u0003/ 2 Ef ,\nwe have u:h \u0002 \u0003:h.\n2\n// Action: Increase the height of u.\n3\nu:h D 1 C min f\u0003:h W .u; \u0003/ 2 Ef g\nWhen we call the operation RELABEL.u/, we say that vertex u is relabeled. Note\nthat when u is relabeled, Ef must contain at least one edge that leaves u, so that\nthe minimization in the code is over a nonempty set. This property follows from\nthe assumption that u is overﬂowing, which in turn tells us that\nu:e D\nX\n\u00052V\nf .\u0003; u/ \u0005\nX\n\u00052V\nf .u; \u0003/ > 0 :\nSince all ﬂows are nonnegative, we must therefore have at least one vertex \u0003 such\nthat .\u0003; u/:f > 0. But then, cf .u; \u0003/ > 0, which implies that .u; \u0003/ 2 Ef . The\noperation RELABEL.u/ thus gives u the greatest height allowed by the constraints\non height functions.\nThe generic algorithm\nThe generic push-relabel algorithm uses the following subroutine to create an ini-\ntial preﬂow in the ﬂow network.\nINITIALIZE-PREFLOW.G; s/\n1\nfor each vertex \u0003 2 G:V\n2\n\u0003:h D 0\n3\n\u0003:e D 0\n4\nfor each edge .u; \u0003/ 2 G:E\n5\n.u; \u0003/:f D 0\n6\ns:h D jG:Vj\n7\nfor each vertex \u0003 2 s:Adj\n8\n.s; \u0003/:f D c.s; \u0003/\n9\n\u0003:e D c.s; \u0003/\n10\ns:e D s:e \u0005 c.s; \u0003/\n26.4\nPush-relabel algorithms\n741\nINITIALIZE-PREFLOW creates an initial preﬂow f deﬁned by\n.u; \u0003/:f D\n(\nc.u; \u0003/\nif u D s ;\n0\notherwise :\n(26.15)\nThat is, we ﬁll to capacity each edge leaving the source s, and all other edges carry",
    "parent_23888b57-996d-47ce-92b7-78dc2a5bf5eb": "8\n.s; \u0003/:f D c.s; \u0003/\n9\n\u0003:e D c.s; \u0003/\n10\ns:e D s:e \u0005 c.s; \u0003/\n26.4\nPush-relabel algorithms\n741\nINITIALIZE-PREFLOW creates an initial preﬂow f deﬁned by\n.u; \u0003/:f D\n(\nc.u; \u0003/\nif u D s ;\n0\notherwise :\n(26.15)\nThat is, we ﬁll to capacity each edge leaving the source s, and all other edges carry\nno ﬂow. For each vertex \u0003 adjacent to the source, we initially have \u0003:e D c.s; \u0003/,\nand we initialize s:e to the negative of the sum of these capacities. The generic\nalgorithm also begins with an initial height function h, given by\nu:h D\n(\njV j\nif u D s ;\n0\notherwise :\n(26.16)\nEquation (26.16) deﬁnes a height function because the only edges .u; \u0003/ for which\nu:h > \u0003:h C 1 are those for which u D s, and those edges are saturated, which\nmeans that they are not in the residual network.\nInitialization, followed by a sequence of push and relabel operations, executed\nin no particular order, yields the GENERIC-PUSH-RELABEL algorithm:\nGENERIC-PUSH-RELABEL.G/\n1\nINITIALIZE-PREFLOW.G; s/\n2\nwhile there exists an applicable push or relabel operation\n3\nselect an applicable push or relabel operation and perform it\nThe following lemma tells us that as long as an overﬂowing vertex exists, at least\none of the two basic operations applies.\nLemma 26.14 (An overﬂowing vertex can be either pushed or relabeled)\nLet G D .V; E/ be a ﬂow network with source s and sink t, let f be a preﬂow,\nand let h be any height function for f . If u is any overﬂowing vertex, then either a\npush or relabel operation applies to it.\nProof\nFor any residual edge .u; \u0003/, we have h.u/ \u0002 h.\u0003/ C 1 because h is a\nheight function. If a push operation does not apply to an overﬂowing vertex u,\nthen for all residual edges .u; \u0003/, we must have h.u/ < h.\u0003/ C 1, which implies\nh.u/ \u0002 h.\u0003/. Thus, a relabel operation applies to u.\nCorrectness of the push-relabel method\nTo show that the generic push-relabel algorithm solves the maximum-ﬂow prob-\nlem, we shall ﬁrst prove that if it terminates, the preﬂow f is a maximum ﬂow.",
    "parent_0191f395-9b97-4aa3-89fa-98d679a77fcc": "h.u/ \u0002 h.\u0003/. Thus, a relabel operation applies to u.\nCorrectness of the push-relabel method\nTo show that the generic push-relabel algorithm solves the maximum-ﬂow prob-\nlem, we shall ﬁrst prove that if it terminates, the preﬂow f is a maximum ﬂow.\nWe shall later prove that it terminates. We start with some observations about the\nheight function h.\n742\nChapter 26\nMaximum Flow\nLemma 26.15 (Vertex heights never decrease)\nDuring the execution of the GENERIC-PUSH-RELABEL procedure on a ﬂow net-\nwork G D .V; E/, for each vertex u 2 V , the height u:h never decreases. More-\nover, whenever a relabel operation is applied to a vertex u, its height u:h increases\nby at least 1.\nProof\nBecause vertex heights change only during relabel operations, it sufﬁces\nto prove the second statement of the lemma.\nIf vertex u is about to be rela-\nbeled, then for all vertices \u0003 such that .u; \u0003/ 2 Ef , we have u:h \u0002 \u0003:h. Thus,\nu:h < 1 C min f\u0003:h W .u; \u0003/ 2 Ef g, and so the operation must increase u:h.\nLemma 26.16\nLet G D .V; E/ be a ﬂow network with source s and sink t. Then the execution of\nGENERIC-PUSH-RELABEL on G maintains the attribute h as a height function.\nProof\nThe proof is by induction on the number of basic operations performed.\nInitially, h is a height function, as we have already observed.\nWe claim that if h is a height function, then an operation RELABEL.u/ leaves h\na height function. If we look at a residual edge .u; \u0003/ 2 Ef that leaves u, then\nthe operation RELABEL.u/ ensures that u:h \u0002 \u0003:h C 1 afterward. Now consider\na residual edge .w; u/ that enters u. By Lemma 26.15, w:h \u0002 u:h C 1 before the\noperation RELABEL.u/ implies w:h < u:h C 1 afterward. Thus, the operation\nRELABEL.u/ leaves h a height function.\nNow, consider an operation PUSH.u; \u0003/. This operation may add the edge .\u0003; u/\nto Ef , and it may remove .u; \u0003/ from Ef .\nIn the former case, we have\n\u0003:h D u:h \u0005 1 < u:h C 1, and so h remains a height function. In the latter case,",
    "parent_7664b5bd-8de6-46fd-bf0a-a91418e4521a": "RELABEL.u/ leaves h a height function.\nNow, consider an operation PUSH.u; \u0003/. This operation may add the edge .\u0003; u/\nto Ef , and it may remove .u; \u0003/ from Ef .\nIn the former case, we have\n\u0003:h D u:h \u0005 1 < u:h C 1, and so h remains a height function. In the latter case,\nremoving .u; \u0003/ from the residual network removes the corresponding constraint,\nand h again remains a height function.\nThe following lemma gives an important property of height functions.\nLemma 26.17\nLet G D .V; E/ be a ﬂow network with source s and sink t, let f be a preﬂow\nin G, and let h be a height function on V . Then there is no path from the source s\nto the sink t in the residual network Gf .\nProof\nAssume for the sake of contradiction that Gf contains a path p from s to t,\nwhere p D h\u00030; \u00031; : : : ; \u0003ki, \u00030 D s, and \u0003k D t. Without loss of generality, p\nis a simple path, and so k < jV j. For i D 0; 1; : : : ; k \u0005 1, edge .\u0003i; \u0003iC1/ 2 Ef .\nBecause h is a height function, h.\u0003i/ \u0002 h.\u0003iC1/ C 1 for i D 0; 1; : : : ; k \u0005 1. Com-\nbining these inequalities over path p yields h.s/ \u0002 h.t/Ck. But because h.t/ D 0,\n26.4\nPush-relabel algorithms\n743\nwe have h.s/ \u0002 k < jV j, which contradicts the requirement that h.s/ D jV j in a\nheight function.\nWe are now ready to show that if the generic push-relabel algorithm terminates,\nthe preﬂow it computes is a maximum ﬂow.\nTheorem 26.18 (Correctness of the generic push-relabel algorithm)\nIf the algorithm GENERIC-PUSH-RELABEL terminates when run on a ﬂow net-\nwork G D .V; E/ with source s and sink t, then the preﬂow f it computes is a\nmaximum ﬂow for G.\nProof\nWe use the following loop invariant:\nEach time the while loop test in line 2 in GENERIC-PUSH-RELABEL is\nexecuted, f is a preﬂow.\nInitialization: INITIALIZE-PREFLOW makes f a preﬂow.\nMaintenance: The only operations within the while loop of lines 2–3 are push and\nrelabel. Relabel operations affect only height attributes and not the ﬂow values;",
    "parent_01f19f99-5980-48ce-b421-844839b359d7": "executed, f is a preﬂow.\nInitialization: INITIALIZE-PREFLOW makes f a preﬂow.\nMaintenance: The only operations within the while loop of lines 2–3 are push and\nrelabel. Relabel operations affect only height attributes and not the ﬂow values;\nhence they do not affect whether f is a preﬂow. As argued on page 739, if f is\na preﬂow prior to a push operation, it remains a preﬂow afterward.\nTermination: At termination, each vertex in V \u0005 fs; tg must have an excess of 0,\nbecause by Lemma 26.14 and the invariant that f is always a preﬂow, there are\nno overﬂowing vertices. Therefore, f is a ﬂow. Lemma 26.16 shows that h is\na height function at termination, and thus Lemma 26.17 tells us that there is no\npath from s to t in the residual network Gf . By the max-ﬂow min-cut theorem\n(Theorem 26.6), therefore, f is a maximum ﬂow.\nAnalysis of the push-relabel method\nTo show that the generic push-relabel algorithm indeed terminates, we shall bound\nthe number of operations it performs. We bound separately each of the three types\nof operations: relabels, saturating pushes, and nonsaturating pushes. With knowl-\nedge of these bounds, it is a straightforward problem to construct an algorithm that\nruns in O.V 2E/ time. Before beginning the analysis, however, we prove an im-\nportant lemma. Recall that we allow edges into the source in the residual network.\nLemma 26.19\nLet G D .V; E/ be a ﬂow network with source s and sink t, and let f be a preﬂow\nin G. Then, for any overﬂowing vertex x, there is a simple path from x to s in the\nresidual network Gf .\n744\nChapter 26\nMaximum Flow\nProof\nFor an overﬂowing vertex x, let U D f\u0003 W there exists a simple path from x\nto \u0003 in Gf g, and suppose for the sake of contradiction that s 62 U . Let U D V \u0005U .\nWe take the deﬁnition of excess from equation (26.14), sum over all vertices\nin U , and note that V D U [ U , to obtain\nX\nu2U\ne.u/\nD\nX\nu2U\n X\n\u00052V\nf .\u0003; u/ \u0005\nX\n\u00052V\nf .u; \u0003/\n!\nD\nX\nu2U\n  X\n\u00052U\nf .\u0003; u/ C\nX\n\u00052U\nf .\u0003; u/\n!\n\u0005\n X\n\u00052U\nf .u; \u0003/ C\nX\n\u00052U\nf .u; \u0003/",
    "parent_f7ab5851-8676-4d2c-a1c5-1e7b5978b94f": "We take the deﬁnition of excess from equation (26.14), sum over all vertices\nin U , and note that V D U [ U , to obtain\nX\nu2U\ne.u/\nD\nX\nu2U\n X\n\u00052V\nf .\u0003; u/ \u0005\nX\n\u00052V\nf .u; \u0003/\n!\nD\nX\nu2U\n  X\n\u00052U\nf .\u0003; u/ C\nX\n\u00052U\nf .\u0003; u/\n!\n\u0005\n X\n\u00052U\nf .u; \u0003/ C\nX\n\u00052U\nf .u; \u0003/\n!!\nD\nX\nu2U\nX\n\u00052U\nf .\u0003; u/ C\nX\nu2U\nX\n\u00052U\nf .\u0003; u/ \u0005\nX\nu2U\nX\n\u00052U\nf .u; \u0003/ \u0005\nX\nu2U\nX\n\u00052U\nf .u; \u0003/\nD\nX\nu2U\nX\n\u00052U\nf .\u0003; u/ \u0005\nX\nu2U\nX\n\u00052U\nf .u; \u0003/ :\nWe know that the quantity P\nu2U e.u/ must be positive because e.x/ > 0, x 2 U ,\nall vertices other than s have nonnegative excess, and, by assumption, s 62 U . Thus,\nwe have\nX\nu2U\nX\n\u00052U\nf .\u0003; u/ \u0005\nX\nu2U\nX\n\u00052U\nf .u; \u0003/ > 0 :\n(26.17)\nAll edge ﬂows are nonnegative, and so for equation (26.17) to hold, we must have\nP\nu2U\nP\n\u00052U f .\u0003; u/ > 0. Hence, there must exist at least one pair of vertices\nu0 2 U and \u00030 2 U with f .\u00030; u0/ > 0. But, if f .\u00030; u0/ > 0, there must be a\nresidual edge .u0; \u00030/, which means that there is a simple path from x to \u00030 (the\npath x ; u0 ! \u00030), thus contradicting the deﬁnition of U .\nThe next lemma bounds the heights of vertices, and its corollary bounds the\nnumber of relabel operations that are performed in total.\nLemma 26.20\nLet G D .V; E/ be a ﬂow network with source s and sink t. At any time during\nthe execution of GENERIC-PUSH-RELABEL on G, we have u:h \u0002 2 jV j\u00051 for all\nvertices u 2 V .\nProof\nThe heights of the source s and the sink t never change because these\nvertices are by deﬁnition not overﬂowing. Thus, we always have s:h D jV j and\nt:h D 0, both of which are no greater than 2 jV j \u0005 1.\nNow consider any vertex u 2 V \u0005fs; tg. Initially, u:h D 0 \u0002 2 jV j\u00051. We shall\nshow that after each relabeling operation, we still have u:h \u0002 2 jV j \u0005 1. When u is\n26.4\nPush-relabel algorithms\n745\nrelabeled, it is overﬂowing, and Lemma 26.19 tells us that there is a simple path p\nfrom u to s in Gf . Let p D h\u00030;\u00031;: : : ;\u0003ki, where \u00030 D u, \u0003k D s, and k \u0002 jV j\u00051\nbecause p is simple. For i D 0; 1; : : : ; k \u0005 1, we have .\u0003i; \u0003iC1/ 2 Ef , and",
    "parent_66d6d415-2301-43e6-9f49-c36d0609a1ea": "26.4\nPush-relabel algorithms\n745\nrelabeled, it is overﬂowing, and Lemma 26.19 tells us that there is a simple path p\nfrom u to s in Gf . Let p D h\u00030;\u00031;: : : ;\u0003ki, where \u00030 D u, \u0003k D s, and k \u0002 jV j\u00051\nbecause p is simple. For i D 0; 1; : : : ; k \u0005 1, we have .\u0003i; \u0003iC1/ 2 Ef , and\ntherefore, by Lemma 26.16, \u0003i:h \u0002 \u0003iC1:h C 1. Expanding these inequalities over\npath p yields u:h D \u00030:h \u0002 \u0003k:h C k \u0002 s:h C .jV j \u0005 1/ D 2 jV j \u0005 1.\nCorollary 26.21 (Bound on relabel operations)\nLet G D .V; E/ be a ﬂow network with source s and sink t. Then, during the\nexecution of GENERIC-PUSH-RELABEL on G, the number of relabel operations is\nat most 2 jV j \u0005 1 per vertex and at most .2 jV j \u0005 1/.jV j \u0005 2/ < 2 jV j2 overall.\nProof\nOnly the jV j\u00052 vertices in V \u0005fs; tg may be relabeled. Let u 2 V \u0005fs; tg.\nThe operation RELABEL.u/ increases u:h. The value of u:h is initially 0 and by\nLemma 26.20, it grows to at most 2 jV j \u0005 1. Thus, each vertex u 2 V \u0005 fs; tg\nis relabeled at most 2 jV j \u0005 1 times, and the total number of relabel operations\nperformed is at most .2 jV j \u0005 1/.jV j \u0005 2/ < 2 jV j2.\nLemma 26.20 also helps us to bound the number of saturating pushes.\nLemma 26.22 (Bound on saturating pushes)\nDuring the execution of GENERIC-PUSH-RELABEL on any ﬂow network G D\n.V; E/, the number of saturating pushes is less than 2 jV j jEj.\nProof\nFor any pair of vertices u; \u0003 2 V , we will count the saturating pushes\nfrom u to \u0003 and from \u0003 to u together, calling them the saturating pushes between u\nand \u0003. If there are any such pushes, at least one of .u; \u0003/ and .\u0003; u/ is actually\nan edge in E. Now, suppose that a saturating push from u to \u0003 has occurred.\nAt that time, \u0003:h D u:h \u0005 1. In order for another push from u to \u0003 to occur\nlater, the algorithm must ﬁrst push ﬂow from \u0003 to u, which cannot happen until\n\u0003:h D u:h C 1. Since u:h never decreases, in order for \u0003:h D u:h C 1, the\nvalue of \u0003:h must increase by at least 2. Likewise, u:h must increase by at least 2",
    "parent_76716e5a-5d5c-411d-a2ce-d68848ddd56e": "later, the algorithm must ﬁrst push ﬂow from \u0003 to u, which cannot happen until\n\u0003:h D u:h C 1. Since u:h never decreases, in order for \u0003:h D u:h C 1, the\nvalue of \u0003:h must increase by at least 2. Likewise, u:h must increase by at least 2\nbetween saturating pushes from \u0003 to u. Heights start at 0 and, by Lemma 26.20,\nnever exceed 2 jV j\u00051, which implies that the number of times any vertex can have\nits height increase by 2 is less than jV j. Since at least one of u:h and \u0003:h must\nincrease by 2 between any two saturating pushes between u and \u0003, there are fewer\nthan 2 jV j saturating pushes between u and \u0003. Multiplying by the number of edges\ngives a bound of less than 2 jV j jEj on the total number of saturating pushes.\nThe following lemma bounds the number of nonsaturating pushes in the generic\npush-relabel algorithm.\n746\nChapter 26\nMaximum Flow\nLemma 26.23 (Bound on nonsaturating pushes)\nDuring the execution of GENERIC-PUSH-RELABEL on any ﬂow network G D\n.V; E/, the number of nonsaturating pushes is less than 4 jV j2 .jV j C jEj/.\nProof\nDeﬁne a potential function ˆ D P\n\u0005We.\u0005/>0 \u0003:h. Initially, ˆ D 0, and the\nvalue of ˆ may change after each relabeling, saturating push, and nonsaturating\npush. We will bound the amount that saturating pushes and relabelings can con-\ntribute to the increase of ˆ. Then we will show that each nonsaturating push must\ndecrease ˆ by at least 1, and will use these bounds to derive an upper bound on the\nnumber of nonsaturating pushes.\nLet us examine the two ways in which ˆ might increase. First, relabeling a\nvertex u increases ˆ by less than 2 jV j, since the set over which the sum is taken is\nthe same and the relabeling cannot increase u’s height by more than its maximum\npossible height, which, by Lemma 26.20, is at most 2 jV j \u0005 1. Second, a saturating\npush from a vertex u to a vertex \u0003 increases ˆ by less than 2 jV j, since no heights\nchange and only vertex \u0003, whose height is at most 2 jV j \u0005 1, can possibly become\noverﬂowing.",
    "parent_e7c3d196-c4e5-4471-bdf3-c32c4bf233c6": "possible height, which, by Lemma 26.20, is at most 2 jV j \u0005 1. Second, a saturating\npush from a vertex u to a vertex \u0003 increases ˆ by less than 2 jV j, since no heights\nchange and only vertex \u0003, whose height is at most 2 jV j \u0005 1, can possibly become\noverﬂowing.\nNow we show that a nonsaturating push from u to \u0003 decreases ˆ by at least 1.\nWhy? Before the nonsaturating push, u was overﬂowing, and \u0003 may or may not\nhave been overﬂowing. By Lemma 26.13, u is no longer overﬂowing after the\npush. In addition, unless \u0003 is the source, it may or may not be overﬂowing after\nthe push. Therefore, the potential function ˆ has decreased by exactly u:h, and it\nhas increased by either 0 or \u0003:h. Since u:h \u0005 \u0003:h D 1, the net effect is that the\npotential function has decreased by at least 1.\nThus, during the course of the algorithm, the total amount of increase in ˆ is\ndue to relabelings and saturated pushes, and Corollary 26.21 and Lemma 26.22\nconstrain the increase to be less than .2 jV j/.2 jV j2/ C .2 jV j/.2 jV j jEj/ D\n4 jV j2 .jV j C jEj/. Since ˆ \u0006 0, the total amount of decrease, and therefore the\ntotal number of nonsaturating pushes, is less than 4 jV j2 .jV j C jEj/.\nHaving bounded the number of relabelings, saturating pushes, and nonsatu-\nrating push, we have set the stage for the following analysis of the GENERIC-\nPUSH-RELABEL procedure, and hence of any algorithm based on the push-relabel\nmethod.\nTheorem 26.24\nDuring the execution of GENERIC-PUSH-RELABEL on any ﬂow network G D\n.V; E/, the number of basic operations is O.V 2E/.\nProof\nImmediate from Corollary 26.21 and Lemmas 26.22 and 26.23.\n26.4\nPush-relabel algorithms\n747\nThus, the algorithm terminates after O.V 2E/ operations. All that remains is\nto give an efﬁcient method for implementing each operation and for choosing an\nappropriate operation to execute.\nCorollary 26.25\nThere is an implementation of the generic push-relabel algorithm that runs in\nO.V 2E/ time on any ﬂow network G D .V; E/.\nProof",
    "parent_97f92052-83cb-4fb8-8807-945af3510ee0": "to give an efﬁcient method for implementing each operation and for choosing an\nappropriate operation to execute.\nCorollary 26.25\nThere is an implementation of the generic push-relabel algorithm that runs in\nO.V 2E/ time on any ﬂow network G D .V; E/.\nProof\nExercise 26.4-2 asks you to show how to implement the generic algorithm\nwith an overhead of O.V / per relabel operation and O.1/ per push. It also asks\nyou to design a data structure that allows you to pick an applicable operation in\nO.1/ time. The corollary then follows.\nExercises\n26.4-1\nProve that, after the procedure INITIALIZE-PREFLOW.G; s/ terminates, we have\ns:e \u0002 \u0005 jf \u0004j, where f \u0004 is a maximum ﬂow for G.\n26.4-2\nShow how to implement the generic push-relabel algorithm using O.V / time per\nrelabel operation, O.1/ time per push, and O.1/ time to select an applicable oper-\nation, for a total time of O.V 2E/.\n26.4-3\nProve that the generic push-relabel algorithm spends a total of only O.VE/ time\nin performing all the O.V 2/ relabel operations.\n26.4-4\nSuppose that we have found a maximum ﬂow in a ﬂow network G D .V; E/ using\na push-relabel algorithm. Give a fast algorithm to ﬁnd a minimum cut in G.\n26.4-5\nGive an efﬁcient push-relabel algorithm to ﬁnd a maximum matching in a bipartite\ngraph. Analyze your algorithm.\n26.4-6\nSuppose that all edge capacities in a ﬂow network G D .V; E/ are in the set\nf1; 2; : : : ; kg. Analyze the running time of the generic push-relabel algorithm in\nterms of jV j, jEj, and k. (Hint: How many times can each edge support a nonsat-\nurating push before it becomes saturated?)\n748\nChapter 26\nMaximum Flow\n26.4-7\nShow that we could change line 6 of INITIALIZE-PREFLOW to\n6\ns:h D jG:Vj \u0005 2\nwithout affecting the correctness or asymptotic performance of the generic push-\nrelabel algorithm.\n26.4-8\nLet ıf .u; \u0003/ be the distance (number of edges) from u to \u0003 in the residual net-\nwork Gf .\nShow that the GENERIC-PUSH-RELABEL procedure maintains the",
    "parent_e0204304-fc0c-4327-80f5-f7d713625679": "6\ns:h D jG:Vj \u0005 2\nwithout affecting the correctness or asymptotic performance of the generic push-\nrelabel algorithm.\n26.4-8\nLet ıf .u; \u0003/ be the distance (number of edges) from u to \u0003 in the residual net-\nwork Gf .\nShow that the GENERIC-PUSH-RELABEL procedure maintains the\nproperties that u:h < jV j implies u:h \u0002 ıf .u; t/ and that u:h \u0006 jV j implies\nu:h \u0005 jV j \u0002 ıf .u; s/.\n26.4-9\n?\nAs in the previous exercise, let ıf .u; \u0003/ be the distance from u to \u0003 in the residual\nnetwork Gf . Show how to modify the generic push-relabel algorithm to maintain\nthe property that u:h < jV j implies u:h D ıf .u; t/ and that u:h \u0006 jV j implies\nu:h \u0005 jV j D ıf .u; s/. The total time that your implementation dedicates to main-\ntaining this property should be O.VE/.\n26.4-10\nShow that the number of nonsaturating pushes executed by the GENERIC-PUSH-\nRELABEL procedure on a ﬂow network G D .V; E/ is at most 4 jV j2 jEj for\njV j \u0006 4.\n?\n26.5\nThe relabel-to-front algorithm\nThe push-relabel method allows us to apply the basic operations in any order at\nall. By choosing the order carefully and managing the network data structure efﬁ-\nciently, however, we can solve the maximum-ﬂow problem faster than the O.V 2E/\nbound given by Corollary 26.25. We shall now examine the relabel-to-front algo-\nrithm, a push-relabel algorithm whose running time is O.V 3/, which is asymptot-\nically at least as good as O.V 2E/, and even better for dense networks.\nThe relabel-to-front algorithm maintains a list of the vertices in the network.\nBeginning at the front, the algorithm scans the list, repeatedly selecting an over-\nﬂowing vertex u and then “discharging” it, that is, performing push and relabel\noperations until u no longer has a positive excess. Whenever we relabel a ver-\ntex, we move it to the front of the list (hence the name “relabel-to-front”) and the\nalgorithm begins its scan anew.\n26.5\nThe relabel-to-front algorithm\n749\nThe correctness and analysis of the relabel-to-front algorithm depend on the",
    "parent_1395b22c-bc58-4e14-87a7-0b10e4635929": "tex, we move it to the front of the list (hence the name “relabel-to-front”) and the\nalgorithm begins its scan anew.\n26.5\nThe relabel-to-front algorithm\n749\nThe correctness and analysis of the relabel-to-front algorithm depend on the\nnotion of “admissible” edges: those edges in the residual network through which\nﬂow can be pushed. After proving some properties about the network of admissible\nedges, we shall investigate the discharge operation and then present and analyze the\nrelabel-to-front algorithm itself.\nAdmissible edges and networks\nIf G D .V; E/ is a ﬂow network with source s and sink t, f is a preﬂow in G, and h\nis a height function, then we say that .u; \u0003/ is an admissible edge if cf .u; \u0003/ > 0\nand h.u/ D h.\u0003/ C 1. Otherwise, .u; \u0003/ is inadmissible. The admissible network\nis Gf;h D .V; Ef;h/, where Ef;h is the set of admissible edges.\nThe admissible network consists of those edges through which we can push ﬂow.\nThe following lemma shows that this network is a directed acyclic graph (dag).\nLemma 26.26 (The admissible network is acyclic)\nIf G D .V; E/ is a ﬂow network, f is a preﬂow in G, and h is a height function\non G, then the admissible network Gf;h D .V; Ef;h/ is acyclic.\nProof\nThe proof is by contradiction. Suppose that Gf;h contains a cycle p D\nh\u00030;\u00031;: : : ;\u0003ki, where \u00030 D \u0003k and k > 0. Since each edge in p is admissible, we\nhave h.\u0003i\u00031/ D h.\u0003i/ C 1 for i D 1; 2; : : : ; k. Summing around the cycle gives\nk\nX\niD1\nh.\u0003i\u00031/\nD\nk\nX\niD1\n.h.\u0003i/ C 1/\nD\nk\nX\niD1\nh.\u0003i/ C k :\nBecause each vertex in cycle p appears once in each of the summations, we derive\nthe contradiction that 0 D k.\nThe next two lemmas show how push and relabel operations change the admis-\nsible network.\nLemma 26.27\nLet G D .V; E/ be a ﬂow network, let f be a preﬂow in G, and suppose that the\nattribute h is a height function. If a vertex u is overﬂowing and .u; \u0003/ is an ad-\nmissible edge, then PUSH.u; \u0003/ applies. The operation does not create any new",
    "parent_0b41bcb8-0b35-4b8a-bfe2-c46e20db7851": "sible network.\nLemma 26.27\nLet G D .V; E/ be a ﬂow network, let f be a preﬂow in G, and suppose that the\nattribute h is a height function. If a vertex u is overﬂowing and .u; \u0003/ is an ad-\nmissible edge, then PUSH.u; \u0003/ applies. The operation does not create any new\nadmissible edges, but it may cause .u; \u0003/ to become inadmissible.\n750\nChapter 26\nMaximum Flow\nProof\nBy the deﬁnition of an admissible edge, we can push ﬂow from u to \u0003.\nSince u is overﬂowing, the operation PUSH.u; \u0003/ applies. The only new residual\nedge that pushing ﬂow from u to \u0003 can create is .\u0003; u/. Since \u0003:h D u:h \u0005 1,\nedge .\u0003; u/ cannot become admissible. If the operation is a saturating push, then\ncf .u; \u0003/ D 0 afterward and .u; \u0003/ becomes inadmissible.\nLemma 26.28\nLet G D .V; E/ be a ﬂow network, let f be a preﬂow in G, and suppose that\nthe attribute h is a height function. If a vertex u is overﬂowing and there are no\nadmissible edges leaving u, then RELABEL.u/ applies. After the relabel operation,\nthere is at least one admissible edge leaving u, but there are no admissible edges\nentering u.\nProof\nIf u is overﬂowing, then by Lemma 26.14, either a push or a relabel op-\neration applies to it. If there are no admissible edges leaving u, then no ﬂow\ncan be pushed from u and so RELABEL.u/ applies. After the relabel operation,\nu:h D 1 C min f\u0003:h W .u; \u0003/ 2 Ef g. Thus, if \u0003 is a vertex that realizes the mini-\nmum in this set, the edge .u; \u0003/ becomes admissible. Hence, after the relabel, there\nis at least one admissible edge leaving u.\nTo show that no admissible edges enter u after a relabel operation, suppose that\nthere is a vertex \u0003 such that .\u0003; u/ is admissible. Then, \u0003:h D u:h C 1 after the\nrelabel, and so \u0003:h > u:h C 1 just before the relabel. But by Lemma 26.12, no\nresidual edges exist between vertices whose heights differ by more than 1. More-\nover, relabeling a vertex does not change the residual network. Thus, .\u0003; u/ is not",
    "parent_c2f52c93-3901-45b2-8514-4fbef8e18e8f": "relabel, and so \u0003:h > u:h C 1 just before the relabel. But by Lemma 26.12, no\nresidual edges exist between vertices whose heights differ by more than 1. More-\nover, relabeling a vertex does not change the residual network. Thus, .\u0003; u/ is not\nin the residual network, and hence it cannot be in the admissible network.\nNeighbor lists\nEdges in the relabel-to-front algorithm are organized into “neighbor lists.” Given\na ﬂow network G D .V; E/, the neighbor list u:N for a vertex u 2 V is a singly\nlinked list of the neighbors of u in G. Thus, vertex \u0003 appears in the list u:N if\n.u; \u0003/ 2 E or .\u0003; u/ 2 E. The neighbor list u:N contains exactly those vertices \u0003\nfor which there may be a residual edge .u; \u0003/. The attribute u:N:head points to\nthe ﬁrst vertex in u:N, and \u0003:next-neighbor points to the vertex following \u0003 in a\nneighbor list; this pointer is NIL if \u0003 is the last vertex in the neighbor list.\nThe relabel-to-front algorithm cycles through each neighbor list in an arbitrary\norder that is ﬁxed throughout the execution of the algorithm. For each vertex u,\nthe attribute u:current points to the vertex currently under consideration in u:N.\nInitially, u:current is set to u:N:head.\n26.5\nThe relabel-to-front algorithm\n751\nDischarging an overﬂowing vertex\nAn overﬂowing vertex u is discharged by pushing all of its excess ﬂow through\nadmissible edges to neighboring vertices, relabeling u as necessary to cause edges\nleaving u to become admissible. The pseudocode goes as follows.\nDISCHARGE.u/\n1\nwhile u:e > 0\n2\n\u0003 D u:current\n3\nif \u0003 == NIL\n4\nRELABEL.u/\n5\nu:current D u:N:head\n6\nelseif cf .u; \u0003/ > 0 and u:h == \u0003:h C 1\n7\nPUSH.u; \u0003/\n8\nelse u:current D \u0003:next-neighbor\nFigure 26.9 steps through several iterations of the while loop of lines 1–8, which\nexecutes as long as vertex u has positive excess. Each iteration performs exactly\none of three actions, depending on the current vertex \u0003 in the neighbor list u:N.\n1. If \u0003 is NIL, then we have run off the end of u:N. Line 4 relabels vertex u,",
    "parent_62cd84c8-4d00-4710-a241-59c2d7d88d8c": "executes as long as vertex u has positive excess. Each iteration performs exactly\none of three actions, depending on the current vertex \u0003 in the neighbor list u:N.\n1. If \u0003 is NIL, then we have run off the end of u:N. Line 4 relabels vertex u,\nand then line 5 resets the current neighbor of u to be the ﬁrst one in u:N.\n(Lemma 26.29 below states that the relabel operation applies in this situation.)\n2. If \u0003 is non-NIL and .u; \u0003/ is an admissible edge (determined by the test in\nline 6), then line 7 pushes some (or possibly all) of u’s excess to vertex \u0003.\n3. If \u0003 is non-NIL but .u; \u0003/ is inadmissible, then line 8 advances u:current one\nposition further in the neighbor list u:N.\nObserve that if DISCHARGE is called on an overﬂowing vertex u, then the last\naction performed by DISCHARGE must be a push from u. Why? The procedure\nterminates only when u:e becomes zero, and neither the relabel operation nor ad-\nvancing the pointer u:current affects the value of u:e.\nWe must be sure that when PUSH or RELABEL is called by DISCHARGE, the\noperation applies. The next lemma proves this fact.\nLemma 26.29\nIf DISCHARGE calls PUSH.u; \u0003/ in line 7, then a push operation applies to .u; \u0003/.\nIf DISCHARGE calls RELABEL.u/ in line 4, then a relabel operation applies to u.\nProof\nThe tests in lines 1 and 6 ensure that a push operation occurs only if the\noperation applies, which proves the ﬁrst statement in the lemma.\n752\nChapter 26\nMaximum Flow\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n19\nz\n0\n5/5\n8\n14/14\ns\nx\nz\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n19\nz\n0\n8\n14/14\ns\nx\nz\n5/5\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n11\nz\n8\n8/8\n14/14\n5/5\ns\nx\nz\ns\nx\nz\n1\n2\n3\ns\nx\nz\n4\n5\ns\nx\nz\n6\ns\nx\nz\n7\ns\nx\nz\n8\ns\nx\nz\n9\n(a)\n(b)\n(c)\nFigure 26.9\nDischarging a vertex y. It takes 15 iterations of the while loop of DISCHARGE to push\nall the excess ﬂow from y. Only the neighbors of y and edges of the ﬂow network that enter or leave y\nare shown. In each part of the ﬁgure, the number inside each vertex is its excess at the beginning of",
    "parent_bca2f4cc-8afe-4a87-b989-c9bf829c06ca": "Discharging a vertex y. It takes 15 iterations of the while loop of DISCHARGE to push\nall the excess ﬂow from y. Only the neighbors of y and edges of the ﬂow network that enter or leave y\nare shown. In each part of the ﬁgure, the number inside each vertex is its excess at the beginning of\nthe ﬁrst iteration shown in the part, and each vertex is shown at its height throughout the part. The\nneighbor list y:N at the beginning of each iteration appears on the right, with the iteration number\non top. The shaded neighbor is y:current. (a) Initially, there are 19 units of excess to push from y,\nand y:current D s. Iterations 1, 2, and 3 just advance y:current, since there are no admissible edges\nleaving y. In iteration 4, y:current D NIL (shown by the shading being below the neighbor list),\nand so y is relabeled and y:current is reset to the head of the neighbor list. (b) After relabeling,\nvertex y has height 1. In iterations 5 and 6, edges .y; s/ and .y; x/ are found to be inadmissible, but\niteration 7 pushes 8 units of excess ﬂow from y to ´. Because of the push, y:current does not advance\nin this iteration. (c) Because the push in iteration 7 saturated edge .y; ´/, it is found inadmissible in\niteration 8. In iteration 9, y:current D NIL, and so vertex y is again relabeled and y:current is reset.\n26.5\nThe relabel-to-front algorithm\n753\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n5\ny\n6\nz\n8\n5\n8/8\n14/14\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n11\nz\n8\n8/8\n14/14\n5/5\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n5\ny\n6\nz\n8\n8/8\n14/14\n5\ns\n–20\n5\n4\n3\n2\n1\n0\n6\nx\n5\ny\n0\nz\n8\n5\n8/8\n8/14\ns\nx\nz\n10\ns\nx\nz\n11\ns\nx\nz\n12\ns\nx\nz\n13\ns\nx\nz\n14\ns\nx\nz\n15\n(f)\n(d)\n(e)\n(g)\nFigure 26.9, continued\n(d) In iteration 10, .y; s/ is inadmissible, but iteration 11 pushes 5 units\nof excess ﬂow from y to x. (e) Because y:current did not advance in iteration 11, iteration 12\nﬁnds .y; x/ to be inadmissible. Iteration 13 ﬁnds .y;´/ inadmissible, and iteration 14 relabels ver-\ntex y and resets y:current. (f) Iteration 15 pushes 6 units of excess ﬂow from y to s. (g) Vertex y",
    "parent_4f1faaa2-50dc-4599-aea0-8cd1dcaa9865": "of excess ﬂow from y to x. (e) Because y:current did not advance in iteration 11, iteration 12\nﬁnds .y; x/ to be inadmissible. Iteration 13 ﬁnds .y;´/ inadmissible, and iteration 14 relabels ver-\ntex y and resets y:current. (f) Iteration 15 pushes 6 units of excess ﬂow from y to s. (g) Vertex y\nnow has no excess ﬂow, and DISCHARGE terminates. In this example, DISCHARGE both starts and\nﬁnishes with the current pointer at the head of the neighbor list, but in general this need not be the\ncase.\n754\nChapter 26\nMaximum Flow\nTo prove the second statement, according to the test in line 1 and Lemma 26.28,\nwe need only show that all edges leaving u are inadmissible.\nIf a call to\nDISCHARGE.u/ starts with the pointer u:current at the head of u’s neighbor list\nand ﬁnishes with it off the end of the list, then all of u’s outgoing edges are in-\nadmissible and a relabel operation applies. It is possible, however, that during a\ncall to DISCHARGE.u/, the pointer u:current traverses only part of the list be-\nfore the procedure returns. Calls to DISCHARGE on other vertices may then oc-\ncur, but u:current will continue moving through the list during the next call to\nDISCHARGE.u/. We now consider what happens during a complete pass through\nthe list, which begins at the head of u:N and ﬁnishes with u:current D NIL. Once\nu:current reaches the end of the list, the procedure relabels u and begins a new\npass. For the u:current pointer to advance past a vertex \u0003 2 u:N during a pass, the\nedge .u; \u0003/ must be deemed inadmissible by the test in line 6. Thus, by the time\nthe pass completes, every edge leaving u has been determined to be inadmissible\nat some time during the pass. The key observation is that at the end of the pass,\nevery edge leaving u is still inadmissible. Why? By Lemma 26.27, pushes cannot\ncreate any admissible edges, regardless of which vertex the ﬂow is pushed from.\nThus, any admissible edge must be created by a relabel operation. But the vertex u",
    "parent_ede7a74b-c13a-43b1-87a9-556a320d609f": "every edge leaving u is still inadmissible. Why? By Lemma 26.27, pushes cannot\ncreate any admissible edges, regardless of which vertex the ﬂow is pushed from.\nThus, any admissible edge must be created by a relabel operation. But the vertex u\nis not relabeled during the pass, and by Lemma 26.28, any other vertex \u0003 that is\nrelabeled during the pass (resulting from a call of DISCHARGE.\u0003/) has no entering\nadmissible edges after relabeling. Thus, at the end of the pass, all edges leaving u\nremain inadmissible, which completes the proof.\nThe relabel-to-front algorithm\nIn the relabel-to-front algorithm, we maintain a linked list L consisting of all ver-\ntices in V \u0005 fs; tg. A key property is that the vertices in L are topologically sorted\naccording to the admissible network, as we shall see in the loop invariant that fol-\nlows. (Recall from Lemma 26.26 that the admissible network is a dag.)\nThe pseudocode for the relabel-to-front algorithm assumes that the neighbor\nlists u:N have already been created for each vertex u. It also assumes that u:next\npoints to the vertex that follows u in list L and that, as usual, u:next D NIL if u is\nthe last vertex in the list.\n26.5\nThe relabel-to-front algorithm\n755\nRELABEL-TO-FRONT.G; s; t/\n1\nINITIALIZE-PREFLOW.G; s/\n2\nL D G:V \u0005 fs; tg, in any order\n3\nfor each vertex u 2 G:V \u0005 fs; tg\n4\nu:current D u:N:head\n5\nu D L:head\n6\nwhile u ¤ NIL\n7\nold-height D u:h\n8\nDISCHARGE.u/\n9\nif u:h > old-height\n10\nmove u to the front of list L\n11\nu D u:next\nThe relabel-to-front algorithm works as follows. Line 1 initializes the preﬂow\nand heights to the same values as in the generic push-relabel algorithm. Line 2\ninitializes the list L to contain all potentially overﬂowing vertices, in any order.\nLines 3–4 initialize the current pointer of each vertex u to the ﬁrst vertex in u’s\nneighbor list.\nAs Figure 26.10 illustrates, the while loop of lines 6–11 runs through the list L,\ndischarging vertices. Line 5 makes it start with the ﬁrst vertex in the list. Each",
    "parent_840b1e8d-877a-4b35-9ecc-ca3cdc57e65f": "Lines 3–4 initialize the current pointer of each vertex u to the ﬁrst vertex in u’s\nneighbor list.\nAs Figure 26.10 illustrates, the while loop of lines 6–11 runs through the list L,\ndischarging vertices. Line 5 makes it start with the ﬁrst vertex in the list. Each\ntime through the loop, line 8 discharges a vertex u. If u was relabeled by the\nDISCHARGE procedure, line 10 moves it to the front of list L. We can determine\nwhether u was relabeled by comparing its height before the discharge operation,\nsaved into the variable old-height in line 7, with its height afterward, in line 9.\nLine 11 makes the next iteration of the while loop use the vertex following u in\nlist L. If line 10 moved u to the front of the list, the vertex used in the next iteration\nis the one following u in its new position in the list.\nTo show that RELABEL-TO-FRONT computes a maximum ﬂow, we shall show\nthat it is an implementation of the generic push-relabel algorithm.\nFirst, ob-\nserve that it performs push and relabel operations only when they apply, since\nLemma 26.29 guarantees that DISCHARGE performs them only when they apply.\nIt remains to show that when RELABEL-TO-FRONT terminates, no basic opera-\ntions apply. The remainder of the correctness argument relies on the following\nloop invariant:\nAt each test in line 6 of RELABEL-TO-FRONT, list L is a topological sort\nof the vertices in the admissible network Gf;h D .V; Ef;h/, and no vertex\nbefore u in the list has excess ﬂow.\nInitialization: Immediately after INITIALIZE-PREFLOW has been run, s:h D jV j\nand \u0003:h D 0 for all \u0003 2 V \u0005 fsg. Since jV j \u0006 2 (because V contains at\n756\nChapter 26\nMaximum Flow\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n12\ny\n14\nz\n0\nt\n0\n5\n8\n10\n7\n16\n14/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(a)\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n19\nz\n0\nt\n7\n5/5\n8\n10\n14/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(b)\n7\n7/16\ns\n–20\n5\n4\n3\n2\n1\n0\n6\nx\n5\ny\n0\nz\n8\nt\n7\n5\n8/8\n10\n8/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(c)\n7\n7/16\nFigure 26.10",
    "parent_0e4bae69-9630-4c27-a063-8a634d506192": "2\n1\n0\n6\nx\n12\ny\n14\nz\n0\nt\n0\n5\n8\n10\n7\n16\n14/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(a)\ns\n–26\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n19\nz\n0\nt\n7\n5/5\n8\n10\n14/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(b)\n7\n7/16\ns\n–20\n5\n4\n3\n2\n1\n0\n6\nx\n5\ny\n0\nz\n8\nt\n7\n5\n8/8\n10\n8/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(c)\n7\n7/16\nFigure 26.10\nThe action of RELABEL-TO-FRONT. (a) A ﬂow network just before the ﬁrst iteration\nof the while loop. Initially, 26 units of ﬂow leave source s. On the right is shown the initial list\nL D hx; y; ´i, where initially u D x. Under each vertex in list L is its neighbor list, with the current\nneighbor shaded. Vertex x is discharged. It is relabeled to height 1, 5 units of excess ﬂow are pushed\nto y, and the 7 remaining units of excess are pushed to the sink t. Because x is relabeled, it moves\nto the head of L, which in this case does not change the structure of L. (b) After x, the next vertex\nin L that is discharged is y. Figure 26.9 shows the detailed action of discharging y in this situation.\nBecause y is relabeled, it is moved to the head of L. (c) Vertex x now follows y in L, and so it is\nagain discharged, pushing all 5 units of excess ﬂow to t. Because vertex x is not relabeled in this\ndischarge operation, it remains in place in list L.\n26.5\nThe relabel-to-front algorithm\n757\ns\n–20\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n0\nz\n8\nt\n12\n5\n8/8\n10\n8/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(d)\n7\n12/16\ns\n–20\n5\n4\n3\n2\n1\n0\n6\nx\n0\ny\n0\nz\n0\nt\n20\n5\n8/8\n8/10\n8/14\n12/12\nL:\nx\ny\nz\nN:\ns\ny\nz\nt\ns\nx\nz\nx\ny\nt\n(e)\n12/16\n7\nFigure 26.10, continued\n(d) Since vertex ´ follows vertex x in L, it is discharged. It is relabeled\nto height 1 and all 8 units of excess ﬂow are pushed to t. Because ´ is relabeled, it moves to the\nfront of L. (e) Vertex y now follows vertex ´ in L and is therefore discharged. But because y has no\nexcess, DISCHARGE immediately returns, and y remains in place in L. Vertex x is then discharged.\nBecause it, too, has no excess, DISCHARGE again returns, and x remains in place in L. RELABEL-",
    "parent_07ba1398-47a9-4317-a709-1a051f50a41f": "front of L. (e) Vertex y now follows vertex ´ in L and is therefore discharged. But because y has no\nexcess, DISCHARGE immediately returns, and y remains in place in L. Vertex x is then discharged.\nBecause it, too, has no excess, DISCHARGE again returns, and x remains in place in L. RELABEL-\nTO-FRONT has reached the end of list L and terminates. There are no overﬂowing vertices, and the\npreﬂow is a maximum ﬂow.\nleast s and t), no edge can be admissible. Thus, Ef;h D ;, and any ordering of\nV \u0005 fs; tg is a topological sort of Gf;h.\nBecause u is initially the head of the list L, there are no vertices before it and\nso there are none before it with excess ﬂow.\nMaintenance: To see that each iteration of the while loop maintains the topolog-\nical sort, we start by observing that the admissible network is changed only by\npush and relabel operations. By Lemma 26.27, push operations do not cause\nedges to become admissible. Thus, only relabel operations can create admissi-\nble edges. After a vertex u is relabeled, however, Lemma 26.28 states that there\nare no admissible edges entering u but there may be admissible edges leaving u.\nThus, by moving u to the front of L, the algorithm ensures that any admissible\nedges leaving u satisfy the topological sort ordering.\n758\nChapter 26\nMaximum Flow\nTo see that no vertex preceding u in L has excess ﬂow, we denote the vertex\nthat will be u in the next iteration by u0. The vertices that will precede u0 in the\nnext iteration include the current u (due to line 11) and either no other vertices\n(if u is relabeled) or the same vertices as before (if u is not relabeled). When u\nis discharged, it has no excess ﬂow afterward. Thus, if u is relabeled during\nthe discharge, no vertices preceding u0 have excess ﬂow. If u is not relabeled\nduring the discharge, no vertices before it on the list acquired excess ﬂow during\nthis discharge, because L remained topologically sorted at all times during the",
    "parent_c4519a35-f615-4388-93b2-765eb5674d4e": "the discharge, no vertices preceding u0 have excess ﬂow. If u is not relabeled\nduring the discharge, no vertices before it on the list acquired excess ﬂow during\nthis discharge, because L remained topologically sorted at all times during the\ndischarge (as just pointed out, admissible edges are created only by relabeling,\nnot pushing), and so each push operation causes excess ﬂow to move only to\nvertices further down the list (or to s or t). Again, no vertices preceding u0 have\nexcess ﬂow.\nTermination: When the loop terminates, u is just past the end of L, and so the\nloop invariant ensures that the excess of every vertex is 0. Thus, no basic oper-\nations apply.\nAnalysis\nWe shall now show that RELABEL-TO-FRONT runs in O.V 3/ time on any ﬂow\nnetwork G D .V; E/. Since the algorithm is an implementation of the generic\npush-relabel algorithm, we shall take advantage of Corollary 26.21, which pro-\nvides an O.V / bound on the number of relabel operations executed per vertex and\nan O.V 2/ bound on the total number of relabel operations overall. In addition, Ex-\nercise 26.4-3 provides an O.VE/ bound on the total time spent performing relabel\noperations, and Lemma 26.22 provides an O.VE/ bound on the total number of\nsaturating push operations.\nTheorem 26.30\nThe running time of RELABEL-TO-FRONT on any ﬂow network G D .V; E/\nis O.V 3/.\nProof\nLet us consider a “phase” of the relabel-to-front algorithm to be the time\nbetween two consecutive relabel operations. There are O.V 2/ phases, since there\nare O.V 2/ relabel operations. Each phase consists of at most jV j calls to DIS-\nCHARGE, which we can see as follows. If DISCHARGE does not perform a re-\nlabel operation, then the next call to DISCHARGE is further down the list L, and\nthe length of L is less than jV j. If DISCHARGE does perform a relabel, the next\ncall to DISCHARGE belongs to a different phase. Since each phase contains at\nmost jV j calls to DISCHARGE and there are O.V 2/ phases, the number of times",
    "parent_c1d11caf-22f7-49cc-a1d0-f12dcffe2242": "the length of L is less than jV j. If DISCHARGE does perform a relabel, the next\ncall to DISCHARGE belongs to a different phase. Since each phase contains at\nmost jV j calls to DISCHARGE and there are O.V 2/ phases, the number of times\nDISCHARGE is called in line 8 of RELABEL-TO-FRONT is O.V 3/. Thus, the total\n26.5\nThe relabel-to-front algorithm\n759\nwork performed by the while loop in RELABEL-TO-FRONT, excluding the work\nperformed within DISCHARGE, is at most O.V 3/.\nWe must now bound the work performed within DISCHARGE during the ex-\necution of the algorithm. Each iteration of the while loop within DISCHARGE\nperforms one of three actions. We shall analyze the total amount of work involved\nin performing each of these actions.\nWe start with relabel operations (lines 4–5). Exercise 26.4-3 provides an O.VE/\ntime bound on all the O.V 2/ relabels that are performed.\nNow, suppose that the action updates the u:current pointer in line 8. This action\noccurs O.degree.u// times each time a vertex u is relabeled, and O.V \u0003degree.u//\ntimes overall for the vertex. For all vertices, therefore, the total amount of work\ndone in advancing pointers in neighbor lists is O.VE/ by the handshaking lemma\n(Exercise B.4-1).\nThe third type of action performed by DISCHARGE is a push operation (line 7).\nWe already know that the total number of saturating push operations is O.VE/.\nObserve that if a nonsaturating push is executed, DISCHARGE immediately returns,\nsince the push reduces the excess to 0. Thus, there can be at most one nonsaturating\npush per call to DISCHARGE. As we have observed, DISCHARGE is called O.V 3/\ntimes, and thus the total time spent performing nonsaturating pushes is O.V 3/.\nThe running time of RELABEL-TO-FRONT is therefore O.V 3 C VE/, which\nis O.V 3/.\nExercises\n26.5-1\nIllustrate the execution of RELABEL-TO-FRONT in the manner of Figure 26.10 for\nthe ﬂow network in Figure 26.1(a). Assume that the initial ordering of vertices in L",
    "parent_9e5f4526-f3ef-49da-9bcb-4db5a1061ef6": "The running time of RELABEL-TO-FRONT is therefore O.V 3 C VE/, which\nis O.V 3/.\nExercises\n26.5-1\nIllustrate the execution of RELABEL-TO-FRONT in the manner of Figure 26.10 for\nthe ﬂow network in Figure 26.1(a). Assume that the initial ordering of vertices in L\nis h\u00031; \u00032; \u00033; \u00034i and that the neighbor lists are\n\u00031:N\nD\nhs; \u00032; \u00033i ;\n\u00032:N\nD\nhs; \u00031; \u00033; \u00034i ;\n\u00033:N\nD\nh\u00031; \u00032; \u00034; ti ;\n\u00034:N\nD\nh\u00032; \u00033; ti :\n26.5-2\n?\nWe would like to implement a push-relabel algorithm in which we maintain a ﬁrst-\nin, ﬁrst-out queue of overﬂowing vertices. The algorithm repeatedly discharges the\nvertex at the head of the queue, and any vertices that were not overﬂowing before\nthe discharge but are overﬂowing afterward are placed at the end of the queue.\nAfter the vertex at the head of the queue is discharged, it is removed. When the\n760\nChapter 26\nMaximum Flow\nqueue is empty, the algorithm terminates. Show how to implement this algorithm\nto compute a maximum ﬂow in O.V 3/ time.\n26.5-3\nShow that the generic algorithm still works if RELABEL updates u:h by sim-\nply computing u:h D u:h C 1. How would this change affect the analysis of\nRELABEL-TO-FRONT?\n26.5-4\n?\nShow that if we always discharge a highest overﬂowing vertex, we can make the\npush-relabel method run in O.V 3/ time.\n26.5-5\nSuppose that at some point in the execution of a push-relabel algorithm, there exists\nan integer 0 < k \u0002 jV j \u0005 1 for which no vertex has \u0003:h D k. Show that all\nvertices with \u0003:h > k are on the source side of a minimum cut. If such a k exists,\nthe gap heuristic updates every vertex \u0003 2 V \u0005 fsg for which \u0003:h > k, to set\n\u0003:h D max.\u0003:h; jV j C 1/. Show that the resulting attribute h is a height function.\n(The gap heuristic is crucial in making implementations of the push-relabel method\nperform well in practice.)\nProblems\n26-1\nEscape problem\nAn n\tn grid is an undirected graph consisting of n rows and n columns of vertices,\nas shown in Figure 26.11. We denote the vertex in the ith row and the j th column",
    "parent_64dd3b77-8772-4aab-a3a1-5724acaf6d28": "perform well in practice.)\nProblems\n26-1\nEscape problem\nAn n\tn grid is an undirected graph consisting of n rows and n columns of vertices,\nas shown in Figure 26.11. We denote the vertex in the ith row and the j th column\nby .i; j /. All vertices in a grid have exactly four neighbors, except for the boundary\nvertices, which are the points .i; j / for which i D 1, i D n, j D 1, or j D n.\nGiven m \u0002 n2 starting points .x1; y1/; .x2; y2/; : : : ; .xm; ym/ in the grid, the\nescape problem is to determine whether or not there are m vertex-disjoint paths\nfrom the starting points to any m different points on the boundary. For example,\nthe grid in Figure 26.11(a) has an escape, but the grid in Figure 26.11(b) does not.\na. Consider a ﬂow network in which vertices, as well as edges, have capacities.\nThat is, the total positive ﬂow entering any given vertex is subject to a capacity\nconstraint. Show that determining the maximum ﬂow in a network with edge\nand vertex capacities can be reduced to an ordinary maximum-ﬂow problem on\na ﬂow network of comparable size.\nProblems for Chapter 26\n761\n(a)\n(b)\nFigure 26.11\nGrids for the escape problem. Starting points are black, and other grid vertices are\nwhite. (a) A grid with an escape, shown by shaded paths. (b) A grid with no escape.\nb. Describe an efﬁcient algorithm to solve the escape problem, and analyze its\nrunning time.\n26-2\nMinimum path cover\nA path cover of a directed graph G D .V; E/ is a set P of vertex-disjoint paths\nsuch that every vertex in V is included in exactly one path in P . Paths may start\nand end anywhere, and they may be of any length, including 0. A minimum path\ncover of G is a path cover containing the fewest possible paths.\na. Give an efﬁcient algorithm to ﬁnd a minimum path cover of a directed acyclic\ngraph G D .V; E/. (Hint: Assuming that V D f1; 2; : : : ; ng, construct the\ngraph G0 D .V 0; E0/, where\nV 0\nD\nfx0; x1; : : : ; xng [ fy0; y1; : : : ; yng ;\nE0\nD",
    "parent_094ada6a-3070-441c-911b-49600438fda0": "a. Give an efﬁcient algorithm to ﬁnd a minimum path cover of a directed acyclic\ngraph G D .V; E/. (Hint: Assuming that V D f1; 2; : : : ; ng, construct the\ngraph G0 D .V 0; E0/, where\nV 0\nD\nfx0; x1; : : : ; xng [ fy0; y1; : : : ; yng ;\nE0\nD\nf.x0; xi/ W i 2 V g [ f.yi; y0/ W i 2 V g [ f.xi; yj/ W .i; j / 2 Eg ;\nand run a maximum-ﬂow algorithm.)\nb. Does your algorithm work for directed graphs that contain cycles? Explain.\n26-3\nAlgorithmic consulting\nProfessor Gore wants to open up an algorithmic consulting company. He has iden-\ntiﬁed n important subareas of algorithms (roughly corresponding to different por-\ntions of this textbook), which he represents by the set A D fA1; A2; : : : ; Ang. In\neach subarea Ak, he can hire an expert in that area for ck dollars. The consulting\ncompany has lined up a set J D fJ1; J2; : : : ; Jmg of potential jobs. In order to\nperform job Ji, the company needs to have hired experts in a subset Ri \u0007 A of\n762\nChapter 26\nMaximum Flow\nsubareas. Each expert can work on multiple jobs simultaneously. If the company\nchooses to accept job Ji, it must have hired experts in all subareas in Ri, and it will\ntake in revenue of pi dollars.\nProfessor Gore’s job is to determine which subareas to hire experts in and which\njobs to accept in order to maximize the net revenue, which is the total income from\njobs accepted minus the total cost of employing the experts.\nConsider the following ﬂow network G. It contains a source vertex s, vertices\nA1; A2; : : : ; An, vertices J1; J2; : : : ; Jm, and a sink vertex t. For k D 1; 2 : : : ; n,\nthe ﬂow network contains an edge .s; Ak/ with capacity c.s; Ak/ D ck, and\nfor i D 1; 2; : : : ; m, the ﬂow network contains an edge .Ji; t/ with capacity\nc.Ji; t/ D pi. For k D 1; 2; : : : ; n and i D 1; 2; : : : ; m, if Ak 2 Ri, then G\ncontains an edge .Ak; Ji/ with capacity c.Ak; Ji/ D 1.\na. Show that if Ji 2 T for a ﬁnite-capacity cut .S; T / of G, then Ak 2 T for each\nAk 2 Ri.",
    "parent_9f843627-6d51-4529-a143-389aa5d4bd40": "c.Ji; t/ D pi. For k D 1; 2; : : : ; n and i D 1; 2; : : : ; m, if Ak 2 Ri, then G\ncontains an edge .Ak; Ji/ with capacity c.Ak; Ji/ D 1.\na. Show that if Ji 2 T for a ﬁnite-capacity cut .S; T / of G, then Ak 2 T for each\nAk 2 Ri.\nb. Show how to determine the maximum net revenue from the capacity of a mini-\nmum cut of G and the given pi values.\nc. Give an efﬁcient algorithm to determine which jobs to accept and which experts\nto hire. Analyze the running time of your algorithm in terms of m, n, and\nr D Pm\niD1 jRij.\n26-4\nUpdating maximum ﬂow\nLet G D .V; E/ be a ﬂow network with source s, sink t, and integer capacities.\nSuppose that we are given a maximum ﬂow in G.\na. Suppose that we increase the capacity of a single edge .u; \u0003/ 2 E by 1. Give\nan O.V C E/-time algorithm to update the maximum ﬂow.\nb. Suppose that we decrease the capacity of a single edge .u; \u0003/ 2 E by 1. Give\nan O.V C E/-time algorithm to update the maximum ﬂow.\n26-5\nMaximum ﬂow by scaling\nLet G D .V; E/ be a ﬂow network with source s, sink t, and an integer capac-\nity c.u; \u0003/ on each edge .u; \u0003/ 2 E. Let C D max.u;\u0005/2E c.u; \u0003/.\na. Argue that a minimum cut of G has capacity at most C jEj.\nb. For a given number K, show how to ﬁnd an augmenting path of capacity at\nleast K in O.E/ time, if such a path exists.\nProblems for Chapter 26\n763\nWe can use the following modiﬁcation of FORD-FULKERSON-METHOD to com-\npute a maximum ﬂow in G:\nMAX-FLOW-BY-SCALING.G; s; t/\n1\nC D max.u;\u0005/2E c.u; \u0003/\n2\ninitialize ﬂow f to 0\n3\nK D 2blg Cc\n4\nwhile K \u0006 1\n5\nwhile there exists an augmenting path p of capacity at least K\n6\naugment ﬂow f along p\n7\nK D K=2\n8\nreturn f\nc. Argue that MAX-FLOW-BY-SCALING returns a maximum ﬂow.\nd. Show that the capacity of a minimum cut of the residual network Gf is at most\n2K jEj each time line 4 is executed.\ne. Argue that the inner while loop of lines 5–6 executes O.E/ times for each value\nof K.\nf. Conclude that MAX-FLOW-BY-SCALING can be implemented so that it runs\nin O.E2 lg C/ time.\n26-6",
    "parent_0d7efc3c-76d6-43c4-a5c8-d01acd4e32cc": "2K jEj each time line 4 is executed.\ne. Argue that the inner while loop of lines 5–6 executes O.E/ times for each value\nof K.\nf. Conclude that MAX-FLOW-BY-SCALING can be implemented so that it runs\nin O.E2 lg C/ time.\n26-6\nThe Hopcroft-Karp bipartite matching algorithm\nIn this problem, we describe a faster algorithm, due to Hopcroft and Karp, for\nﬁnding a maximum matching in a bipartite graph. The algorithm runs in O.\np\nV E/\ntime. Given an undirected, bipartite graph G D .V; E/, where V D L [ R and\nall edges have exactly one endpoint in L, let M be a matching in G. We say that\na simple path P in G is an augmenting path with respect to M if it starts at an\nunmatched vertex in L, ends at an unmatched vertex in R, and its edges belong\nalternately to M and E \u0005 M. (This deﬁnition of an augmenting path is related\nto, but different from, an augmenting path in a ﬂow network.) In this problem,\nwe treat a path as a sequence of edges, rather than as a sequence of vertices. A\nshortest augmenting path with respect to a matching M is an augmenting path\nwith a minimum number of edges.\nGiven two sets A and B, the symmetric difference A˚B is deﬁned as .A\u0005B/[\n.B \u0005 A/, that is, the elements that are in exactly one of the two sets.\n764\nChapter 26\nMaximum Flow\na. Show that if M is a matching and P is an augmenting path with respect to M,\nthen the symmetric difference M ˚ P is a matching and jM ˚ P j D jMj C 1.\nShow that if P1; P2; : : : ; Pk are vertex-disjoint augmenting paths with respect\nto M, then the symmetric difference M ˚ .P1 [ P2 [ \u0003 \u0003 \u0003 [ Pk/ is a matching\nwith cardinality jMj C k.\nThe general structure of our algorithm is the following:\nHOPCROFT-KARP.G/\n1\nM D ;\n2\nrepeat\n3\nlet P D fP1; P2; : : : ; Pkg be a maximal set of vertex-disjoint\nshortest augmenting paths with respect to M\n4\nM D M ˚ .P1 [ P2 [ \u0003 \u0003 \u0003 [ Pk/\n5\nuntil P == ;\n6\nreturn M\nThe remainder of this problem asks you to analyze the number of iterations in",
    "parent_144e858b-4900-41ad-9eb6-4aef0f1c8cb4": "HOPCROFT-KARP.G/\n1\nM D ;\n2\nrepeat\n3\nlet P D fP1; P2; : : : ; Pkg be a maximal set of vertex-disjoint\nshortest augmenting paths with respect to M\n4\nM D M ˚ .P1 [ P2 [ \u0003 \u0003 \u0003 [ Pk/\n5\nuntil P == ;\n6\nreturn M\nThe remainder of this problem asks you to analyze the number of iterations in\nthe algorithm (that is, the number of iterations in the repeat loop) and to describe\nan implementation of line 3.\nb. Given two matchings M and M \u0004 in G, show that every vertex in the graph\nG0 D .V; M ˚ M \u0004/ has degree at most 2. Conclude that G0 is a disjoint\nunion of simple paths or cycles. Argue that edges in each such simple path\nor cycle belong alternately to M or M \u0004. Prove that if jMj \u0002 jM \u0004j, then\nM ˚ M \u0004 contains at least jM \u0004j \u0005 jMj vertex-disjoint augmenting paths with\nrespect to M.\nLet l be the length of a shortest augmenting path with respect to a matching M, and\nlet P1; P2; : : : ; Pk be a maximal set of vertex-disjoint augmenting paths of length l\nwith respect to M. Let M 0 D M ˚.P1[\u0003 \u0003 \u0003[Pk/, and suppose that P is a shortest\naugmenting path with respect to M 0.\nc. Show that if P is vertex-disjoint from P1; P2; : : : ; Pk, then P has more than l\nedges.\nd. Now suppose that P is not vertex-disjoint from P1; P2; : : : ; Pk. Let A be the\nset of edges .M ˚ M 0/ ˚ P . Show that A D .P1 [ P2 [ \u0003 \u0003 \u0003 [ Pk/ ˚ P and\nthat jAj \u0006 .k C 1/l. Conclude that P has more than l edges.\ne. Prove that if a shortest augmenting path with respect to M has l edges, the size\nof the maximum matching is at most jMj C jV j =.l C 1/.\nNotes for Chapter 26\n765\nf. Show that the number of repeat loop iterations in the algorithm is at\nmost 2\np\njV j. (Hint: By how much can M grow after iteration number\np\njV j?)\ng. Give an algorithm that runs in O.E/ time to ﬁnd a maximal set of vertex-\ndisjoint shortest augmenting paths P1; P2; : : : ; Pk for a given matching M.\nConclude that the total running time of HOPCROFT-KARP is O.\np\nV E/.\nChapter notes",
    "parent_19b251ce-ab9c-41e3-a54c-fe1aeda0d7d0": "p\njV j?)\ng. Give an algorithm that runs in O.E/ time to ﬁnd a maximal set of vertex-\ndisjoint shortest augmenting paths P1; P2; : : : ; Pk for a given matching M.\nConclude that the total running time of HOPCROFT-KARP is O.\np\nV E/.\nChapter notes\nAhuja, Magnanti, and Orlin [7], Even [103], Lawler [224], Papadimitriou and Stei-\nglitz [271], and Tarjan [330] are good references for network ﬂow and related algo-\nrithms. Goldberg, Tardos, and Tarjan [139] also provide a nice survey of algorithms\nfor network-ﬂow problems, and Schrijver [304] has written an interesting review\nof historical developments in the ﬁeld of network ﬂows.\nThe Ford-Fulkerson method is due to Ford and Fulkerson [109], who originated\nthe formal study of many of the problems in the area of network ﬂow, including\nthe maximum-ﬂow and bipartite-matching problems. Many early implementations\nof the Ford-Fulkerson method found augmenting paths using breadth-ﬁrst search;\nEdmonds and Karp [102], and independently Dinic [89], proved that this strategy\nyields a polynomial-time algorithm. A related idea, that of using “blocking ﬂows,”\nwas also ﬁrst developed by Dinic [89]. Karzanov [202] ﬁrst developed the idea of\npreﬂows. The push-relabel method is due to Goldberg [136] and Goldberg and Tar-\njan [140]. Goldberg and Tarjan gave an O.V 3/-time algorithm that uses a queue to\nmaintain the set of overﬂowing vertices, as well as an algorithm that uses dynamic\ntrees to achieve a running time of O.VE lg.V 2=E C2//. Several other researchers\nhave developed push-relabel maximum-ﬂow algorithms. Ahuja and Orlin [9] and\nAhuja, Orlin, and Tarjan [10] gave algorithms that used scaling. Cheriyan and\nMaheshwari [62] proposed pushing ﬂow from the overﬂowing vertex of maximum\nheight. Cheriyan and Hagerup [61] suggested randomly permuting the neighbor\nlists, and several researchers [14, 204, 276] developed clever derandomizations of\nthis idea, leading to a sequence of faster algorithms. The algorithm of King, Rao,",
    "parent_a78fb5f3-5949-4a8e-9e3c-42e4b6e36b69": "height. Cheriyan and Hagerup [61] suggested randomly permuting the neighbor\nlists, and several researchers [14, 204, 276] developed clever derandomizations of\nthis idea, leading to a sequence of faster algorithms. The algorithm of King, Rao,\nand Tarjan [204] is the fastest such algorithm and runs in O.VE logE=.V lg V / V /\ntime.\nThe asymptotically fastest algorithm to date for the maximum-ﬂow problem, by\nGoldberg and Rao [138], runs in time O.min.V 2=3; E1=2/E lg.V 2=E C 2/ lg C/,\nwhere C D max.u;\u0005/2E c.u; \u0003/.\nThis algorithm does not use the push-relabel\nmethod but instead is based on ﬁnding blocking ﬂows. All previous maximum-\nﬂow algorithms, including the ones in this chapter, use some notion of distance\n(the push-relabel algorithms use the analogous notion of height), with a length of 1\n766\nChapter 26\nMaximum Flow\nassigned implicitly to each edge. This new algorithm takes a different approach and\nassigns a length of 0 to high-capacity edges and a length of 1 to low-capacity edges.\nInformally, with respect to these lengths, shortest paths from the source to the sink\ntend have high capacity, which means that fewer iterations need be performed.\nIn practice, push-relabel algorithms currently dominate augmenting-path or\nlinear-programming based algorithms for the maximum-ﬂow problem. A study\nby Cherkassky and Goldberg [63] underscores the importance of using two heuris-\ntics when implementing a push-relabel algorithm. The ﬁrst heuristic is to peri-\nodically perform a breadth-ﬁrst search of the residual network in order to obtain\nmore accurate height values. The second heuristic is the gap heuristic, described in\nExercise 26.5-5. Cherkassky and Goldberg conclude that the best choice of push-\nrelabel variants is the one that chooses to discharge the overﬂowing vertex with the\nmaximum height.\nThe best algorithm to date for maximum bipartite matching, discovered by\nHopcroft and Karp [176], runs in O.\np\nV E/ time and is described in Problem 26-6.",
    "parent_0ff1aabe-1589-4419-88c7-fab13c90eeb6": "relabel variants is the one that chooses to discharge the overﬂowing vertex with the\nmaximum height.\nThe best algorithm to date for maximum bipartite matching, discovered by\nHopcroft and Karp [176], runs in O.\np\nV E/ time and is described in Problem 26-6.\nThe book by Lov´asz and Plummer [239] is an excellent reference on matching\nproblems.\nVII\nSelected Topics\nIntroduction\nThis part contains a selection of algorithmic topics that extend and complement\nearlier material in this book. Some chapters introduce new models of computation\nsuch as circuits or parallel computers. Others cover specialized domains such as\ncomputational geometry or number theory. The last two chapters discuss some of\nthe known limitations to the design of efﬁcient algorithms and introduce techniques\nfor coping with those limitations.\nChapter 27 presents an algorithmic model for parallel computing based on dy-\nnamic multithreading. The chapter introduces the basics of the model, showing\nhow to quantify parallelism in terms of the measures of work and span. It then\ninvestigates several interesting multithreaded algorithms, including algorithms for\nmatrix multiplication and merge sorting.\nChapter 28 studies efﬁcient algorithms for operating on matrices. It presents\ntwo general methods—LU decomposition and LUP decomposition—for solving\nlinear equations by Gaussian elimination in O.n3/ time. It also shows that matrix\ninversion and matrix multiplication can be performed equally fast. The chapter\nconcludes by showing how to compute a least-squares approximate solution when\na set of linear equations has no exact solution.\nChapter 29 studies linear programming, in which we wish to maximize or mini-\nmize an objective, given limited resources and competing constraints. Linear pro-\ngramming arises in a variety of practical application areas. This chapter covers how\nto formulate and solve linear programs. The solution method covered is the sim-",
    "parent_2851c3ea-93fc-461d-8d5f-e5e55f86087f": "mize an objective, given limited resources and competing constraints. Linear pro-\ngramming arises in a variety of practical application areas. This chapter covers how\nto formulate and solve linear programs. The solution method covered is the sim-\nplex algorithm, which is the oldest algorithm for linear programming. In contrast\nto many algorithms in this book, the simplex algorithm does not run in polynomial\ntime in the worst case, but it is fairly efﬁcient and widely used in practice.\n770\nPart VII\nSelected Topics\nChapter 30 studies operations on polynomials and shows how to use a well-\nknown signal-processing technique—the fast Fourier transform (FFT)—to multi-\nply two degree-n polynomials in O.n lg n/ time. It also investigates efﬁcient im-\nplementations of the FFT, including a parallel circuit.\nChapter 31 presents number-theoretic algorithms. After reviewing elementary\nnumber theory, it presents Euclid’s algorithm for computing greatest common di-\nvisors. Next, it studies algorithms for solving modular linear equations and for\nraising one number to a power modulo another number. Then, it explores an impor-\ntant application of number-theoretic algorithms: the RSA public-key cryptosystem.\nThis cryptosystem can be used not only to encrypt messages so that an adversary\ncannot read them, but also to provide digital signatures. The chapter then presents\nthe Miller-Rabin randomized primality test, with which we can ﬁnd large primes\nefﬁciently—an essential requirement for the RSA system. Finally, the chapter cov-\ners Pollard’s “rho” heuristic for factoring integers and discusses the state of the art\nof integer factorization.\nChapter 32 studies the problem of ﬁnding all occurrences of a given pattern\nstring in a given text string, a problem that arises frequently in text-editing pro-\ngrams. After examining the naive approach, the chapter presents an elegant ap-\nproach due to Rabin and Karp. Then, after showing an efﬁcient solution based",
    "parent_0303e6c3-30e8-4dc4-9cb8-e7b5d29249ba": "string in a given text string, a problem that arises frequently in text-editing pro-\ngrams. After examining the naive approach, the chapter presents an elegant ap-\nproach due to Rabin and Karp. Then, after showing an efﬁcient solution based\non ﬁnite automata, the chapter presents the Knuth-Morris-Pratt algorithm, which\nmodiﬁes the automaton-based algorithm to save space by cleverly preprocessing\nthe pattern.\nChapter 33 considers a few problems in computational geometry. After dis-\ncussing basic primitives of computational geometry, the chapter shows how to use\na “sweeping” method to efﬁciently determine whether a set of line segments con-\ntains any intersections. Two clever algorithms for ﬁnding the convex hull of a set of\npoints—Graham’s scan and Jarvis’s march—also illustrate the power of sweeping\nmethods. The chapter closes with an efﬁcient algorithm for ﬁnding the closest pair\nfrom among a given set of points in the plane.\nChapter 34 concerns NP-complete problems. Many interesting computational\nproblems are NP-complete, but no polynomial-time algorithm is known for solving\nany of them. This chapter presents techniques for determining when a problem is\nNP-complete. Several classic problems are proved to be NP-complete: determining\nwhether a graph has a hamiltonian cycle, determining whether a boolean formula\nis satisﬁable, and determining whether a given set of numbers has a subset that\nadds up to a given target value. The chapter also proves that the famous traveling-\nsalesman problem is NP-complete.\nChapter 35 shows how to ﬁnd approximate solutions to NP-complete problems\nefﬁciently by using approximation algorithms. For some NP-complete problems,\napproximate solutions that are near optimal are quite easy to produce, but for others\neven the best approximation algorithms known work progressively more poorly as\nPart VII\nSelected Topics\n771\nthe problem size increases. Then, there are some problems for which we can invest",
    "parent_a12037e2-0cb4-41de-944c-440045c2756d": "approximate solutions that are near optimal are quite easy to produce, but for others\neven the best approximation algorithms known work progressively more poorly as\nPart VII\nSelected Topics\n771\nthe problem size increases. Then, there are some problems for which we can invest\nincreasing amounts of computation time in return for increasingly better approx-\nimate solutions. This chapter illustrates these possibilities with the vertex-cover\nproblem (unweighted and weighted versions), an optimization version of 3-CNF\nsatisﬁability, the traveling-salesman problem, the set-covering problem, and the\nsubset-sum problem.\n27\nMultithreaded Algorithms\nThe vast majority of algorithms in this book are serial algorithms suitable for\nrunning on a uniprocessor computer in which only one instruction executes at a\ntime. In this chapter, we shall extend our algorithmic model to encompass parallel\nalgorithms, which can run on a multiprocessor computer that permits multiple\ninstructions to execute concurrently. In particular, we shall explore the elegant\nmodel of dynamic multithreaded algorithms, which are amenable to algorithmic\ndesign and analysis, as well as to efﬁcient implementation in practice.\nParallel computers—computers with multiple processing units—have become\nincreasingly common, and they span a wide range of prices and performance. Rela-\ntively inexpensive desktop and laptop chip multiprocessors contain a single multi-\ncore integrated-circuit chip that houses multiple processing “cores,” each of which\nis a full-ﬂedged processor that can access a common memory. At an intermedi-\nate price/performance point are clusters built from individual computers—often\nsimple PC-class machines—with a dedicated network interconnecting them. The\nhighest-priced machines are supercomputers, which often use a combination of\ncustom architectures and custom networks to deliver the highest performance in\nterms of instructions executed per second.",
    "parent_c47c9bd9-d10d-4446-a767-2ffc3a6f3e08": "simple PC-class machines—with a dedicated network interconnecting them. The\nhighest-priced machines are supercomputers, which often use a combination of\ncustom architectures and custom networks to deliver the highest performance in\nterms of instructions executed per second.\nMultiprocessor computers have been around, in one form or another, for\ndecades. Although the computing community settled on the random-access ma-\nchine model for serial computing early on in the history of computer science, no\nsingle model for parallel computing has gained as wide acceptance. A major rea-\nson is that vendors have not agreed on a single architectural model for parallel\ncomputers. For example, some parallel computers feature shared memory, where\neach processor can directly access any location of memory. Other parallel com-\nputers employ distributed memory, where each processor’s memory is private, and\nan explicit message must be sent between processors in order for one processor to\naccess the memory of another. With the advent of multicore technology, however,\nevery new laptop and desktop machine is now a shared-memory parallel computer,\nChapter 27\nMultithreaded Algorithms\n773\nand the trend appears to be toward shared-memory multiprocessing. Although time\nwill tell, that is the approach we shall take in this chapter.\nOne common means of programming chip multiprocessors and other shared-\nmemory parallel computers is by using static threading, which provides a software\nabstraction of “virtual processors,” or threads, sharing a common memory. Each\nthread maintains an associated program counter and can execute code indepen-\ndently of the other threads. The operating system loads a thread onto a processor\nfor execution and switches it out when another thread needs to run. Although the\noperating system allows programmers to create and destroy threads, these opera-\ntions are comparatively slow. Thus, for most applications, threads persist for the",
    "parent_b3876bc7-44fe-430e-80e0-9ef05858a5b4": "for execution and switches it out when another thread needs to run. Although the\noperating system allows programmers to create and destroy threads, these opera-\ntions are comparatively slow. Thus, for most applications, threads persist for the\nduration of a computation, which is why we call them “static.”\nUnfortunately, programming a shared-memory parallel computer directly using\nstatic threads is difﬁcult and error-prone. One reason is that dynamically parti-\ntioning the work among the threads so that each thread receives approximately\nthe same load turns out to be a complicated undertaking. For any but the sim-\nplest of applications, the programmer must use complex communication protocols\nto implement a scheduler to load-balance the work. This state of affairs has led\ntoward the creation of concurrency platforms, which provide a layer of software\nthat coordinates, schedules, and manages the parallel-computing resources. Some\nconcurrency platforms are built as runtime libraries, but others provide full-ﬂedged\nparallel languages with compiler and runtime support.\nDynamic multithreaded programming\nOne important class of concurrency platform is dynamic multithreading, which is\nthe model we shall adopt in this chapter. Dynamic multithreading allows program-\nmers to specify parallelism in applications without worrying about communication\nprotocols, load balancing, and other vagaries of static-thread programming. The\nconcurrency platform contains a scheduler, which load-balances the computation\nautomatically, thereby greatly simplifying the programmer’s chore. Although the\nfunctionality of dynamic-multithreading environments is still evolving, almost all\nsupport two features: nested parallelism and parallel loops. Nested parallelism\nallows a subroutine to be “spawned,” allowing the caller to proceed while the\nspawned subroutine is computing its result. A parallel loop is like an ordinary\nfor loop, except that the iterations of the loop can execute concurrently.",
    "parent_619f37d1-24a4-4c6f-900e-917366edbc62": "allows a subroutine to be “spawned,” allowing the caller to proceed while the\nspawned subroutine is computing its result. A parallel loop is like an ordinary\nfor loop, except that the iterations of the loop can execute concurrently.\nThese two features form the basis of the model for dynamic multithreading that\nwe shall study in this chapter. A key aspect of this model is that the programmer\nneeds to specify only the logical parallelism within a computation, and the threads\nwithin the underlying concurrency platform schedule and load-balance the compu-\ntation among themselves. We shall investigate multithreaded algorithms written for\n774\nChapter 27\nMultithreaded Algorithms\nthis model, as well how the underlying concurrency platform can schedule compu-\ntations efﬁciently.\nOur model for dynamic multithreading offers several important advantages:\n\u0002\nIt is a simple extension of our serial programming model. We can describe a\nmultithreaded algorithm by adding to our pseudocode just three “concurrency”\nkeywords: parallel, spawn, and sync. Moreover, if we delete these concur-\nrency keywords from the multithreaded pseudocode, the resulting text is serial\npseudocode for the same problem, which we call the “serialization” of the mul-\ntithreaded algorithm.\n\u0002\nIt provides a theoretically clean way to quantify parallelism based on the no-\ntions of “work” and “span.”\n\u0002\nMany multithreaded algorithms involving nested parallelism follow naturally\nfrom the divide-and-conquer paradigm. Moreover, just as serial divide-and-\nconquer algorithms lend themselves to analysis by solving recurrences, so do\nmultithreaded algorithms.\n\u0002\nThe model is faithful to how parallel-computing practice is evolving. A grow-\ning number of concurrency platforms support one variant or another of dynamic\nmultithreading, including Cilk [51, 118], Cilk++ [71], OpenMP [59], Task Par-\nallel Library [230], and Threading Building Blocks [292].",
    "parent_e7ecfb61-4d48-47d3-8af0-38c747f2e4a7": "\u0002\nThe model is faithful to how parallel-computing practice is evolving. A grow-\ning number of concurrency platforms support one variant or another of dynamic\nmultithreading, including Cilk [51, 118], Cilk++ [71], OpenMP [59], Task Par-\nallel Library [230], and Threading Building Blocks [292].\nSection 27.1 introduces the dynamic multithreading model and presents the met-\nrics of work, span, and parallelism, which we shall use to analyze multithreaded\nalgorithms. Section 27.2 investigates how to multiply matrices with multithread-\ning, and Section 27.3 tackles the tougher problem of multithreading merge sort.\n27.1\nThe basics of dynamic multithreading\nWe shall begin our exploration of dynamic multithreading using the example of\ncomputing Fibonacci numbers recursively. Recall that the Fibonacci numbers are\ndeﬁned by recurrence (3.22):\nF0\nD\n0 ;\nF1\nD\n1 ;\nFi\nD\nFi\u00031 C Fi\u00032\nfor i \u0006 2 :\nHere is a simple, recursive, serial algorithm to compute the nth Fibonacci number:\n27.1\nThe basics of dynamic multithreading\n775\nFIB.0/\nFIB.0/\nFIB.0/\nFIB.0/\nFIB.0/\nFIB.1/\nFIB.1/\nFIB.1/\nFIB.1/\nFIB.1/\nFIB.1/\nFIB.1/\nFIB.1/\nFIB.2/\nFIB.2/\nFIB.2/\nFIB.2/\nFIB.2/\nFIB.3/\nFIB.3/\nFIB.3/\nFIB.4/\nFIB.4/\nFIB.5/\nFIB.6/\nFigure 27.1\nThe tree of recursive procedure instances when computing FIB.6/. Each instance of\nFIB with the same argument does the same work to produce the same result, providing an inefﬁcient\nbut interesting way to compute Fibonacci numbers.\nFIB.n/\n1\nif n \u0002 1\n2\nreturn n\n3\nelse x D FIB.n \u0005 1/\n4\ny D FIB.n \u0005 2/\n5\nreturn x C y\nYou would not really want to compute large Fibonacci numbers this way, be-\ncause this computation does much repeated work. Figure 27.1 shows the tree of\nrecursive procedure instances that are created when computing F6. For example,\na call to FIB.6/ recursively calls FIB.5/ and then FIB.4/. But, the call to FIB.5/\nalso results in a call to FIB.4/. Both instances of FIB.4/ return the same result\n(F4 D 3). Since the FIB procedure does not memoize, the second call to FIB.4/",
    "parent_ddfe7725-714d-4ddf-a063-c7c416dfa5cb": "a call to FIB.6/ recursively calls FIB.5/ and then FIB.4/. But, the call to FIB.5/\nalso results in a call to FIB.4/. Both instances of FIB.4/ return the same result\n(F4 D 3). Since the FIB procedure does not memoize, the second call to FIB.4/\nreplicates the work that the ﬁrst call performs.\nLet T .n/ denote the running time of FIB.n/. Since FIB.n/ contains two recur-\nsive calls plus a constant amount of extra work, we obtain the recurrence\nT .n/ D T .n \u0005 1/ C T .n \u0005 2/ C ‚.1/ :\nThis recurrence has solution T .n/ D ‚.Fn/, which we can show using the substi-\ntution method. For an inductive hypothesis, assume that T .n/ \u0002 aFn \u0005 b, where\na > 1 and b > 0 are constants. Substituting, we obtain\n776\nChapter 27\nMultithreaded Algorithms\nT .n/\n\u0002\n.aFn\u00031 \u0005 b/ C .aFn\u00032 \u0005 b/ C ‚.1/\nD\na.Fn\u00031 C Fn\u00032/ \u0005 2b C ‚.1/\nD\naFn \u0005 b \u0005 .b \u0005 ‚.1//\n\u0002\naFn \u0005 b\nif we choose b large enough to dominate the constant in the ‚.1/. We can then\nchoose a large enough to satisfy the initial condition. The analytical bound\nT .n/ D ‚.\u0007n/ ;\n(27.1)\nwhere \u0007 D .1 C\np\n5/=2 is the golden ratio, now follows from equation (3.25).\nSince Fn grows exponentially in n, this procedure is a particularly slow way to\ncompute Fibonacci numbers. (See Problem 31-3 for much faster ways.)\nAlthough the FIB procedure is a poor way to compute Fibonacci numbers, it\nmakes a good example for illustrating key concepts in the analysis of multithreaded\nalgorithms. Observe that within FIB.n/, the two recursive calls in lines 3 and 4 to\nFIB.n \u0005 1/ and FIB.n \u0005 2/, respectively, are independent of each other: they could\nbe called in either order, and the computation performed by one in no way affects\nthe other. Therefore, the two recursive calls can run in parallel.\nWe augment our pseudocode to indicate parallelism by adding the concurrency\nkeywords spawn and sync. Here is how we can rewrite the FIB procedure to use\ndynamic multithreading:\nP-FIB.n/\n1\nif n \u0002 1\n2\nreturn n\n3\nelse x D spawn P-FIB.n \u0005 1/\n4\ny D P-FIB.n \u0005 2/\n5\nsync\n6\nreturn x C y",
    "parent_3b997a6f-101a-4eac-91f2-90f28e50afb2": "We augment our pseudocode to indicate parallelism by adding the concurrency\nkeywords spawn and sync. Here is how we can rewrite the FIB procedure to use\ndynamic multithreading:\nP-FIB.n/\n1\nif n \u0002 1\n2\nreturn n\n3\nelse x D spawn P-FIB.n \u0005 1/\n4\ny D P-FIB.n \u0005 2/\n5\nsync\n6\nreturn x C y\nNotice that if we delete the concurrency keywords spawn and sync from P-FIB,\nthe resulting pseudocode text is identical to FIB (other than renaming the procedure\nin the header and in the two recursive calls). We deﬁne the serialization of a mul-\ntithreaded algorithm to be the serial algorithm that results from deleting the multi-\nthreaded keywords: spawn, sync, and when we examine parallel loops, parallel.\nIndeed, our multithreaded pseudocode has the nice property that a serialization is\nalways ordinary serial pseudocode to solve the same problem.\nNested parallelism occurs when the keyword spawn precedes a procedure call,\nas in line 3. The semantics of a spawn differs from an ordinary procedure call in\nthat the procedure instance that executes the spawn—the parent—may continue\nto execute in parallel with the spawned subroutine—its child—instead of waiting\n27.1\nThe basics of dynamic multithreading\n777\nfor the child to complete, as would normally happen in a serial execution. In this\ncase, while the spawned child is computing P-FIB.n \u0005 1/, the parent may go on\nto compute P-FIB.n \u0005 2/ in line 4 in parallel with the spawned child. Since the\nP-FIB procedure is recursive, these two subroutine calls themselves create nested\nparallelism, as do their children, thereby creating a potentially vast tree of subcom-\nputations, all executing in parallel.\nThe keyword spawn does not say, however, that a procedure must execute con-\ncurrently with its spawned children, only that it may. The concurrency keywords\nexpress the logical parallelism of the computation, indicating which parts of the\ncomputation may proceed in parallel. At runtime, it is up to a scheduler to deter-",
    "parent_3e20f855-5bdd-4e5c-ab28-5ab2d22af537": "currently with its spawned children, only that it may. The concurrency keywords\nexpress the logical parallelism of the computation, indicating which parts of the\ncomputation may proceed in parallel. At runtime, it is up to a scheduler to deter-\nmine which subcomputations actually run concurrently by assigning them to avail-\nable processors as the computation unfolds. We shall discuss the theory behind\nschedulers shortly.\nA procedure cannot safely use the values returned by its spawned children until\nafter it executes a sync statement, as in line 5. The keyword sync indicates that\nthe procedure must wait as necessary for all its spawned children to complete be-\nfore proceeding to the statement after the sync. In the P-FIB procedure, a sync\nis required before the return statement in line 6 to avoid the anomaly that would\noccur if x and y were summed before x was computed. In addition to explicit\nsynchronization provided by the sync statement, every procedure executes a sync\nimplicitly before it returns, thus ensuring that all its children terminate before it\ndoes.\nA model for multithreaded execution\nIt helps to think of a multithreaded computation—the set of runtime instruc-\ntions executed by a processor on behalf of a multithreaded program—as a directed\nacyclic graph G D .V; E/, called a computation dag. As an example, Figure 27.2\nshows the computation dag that results from computing P-FIB.4/. Conceptually,\nthe vertices in V are instructions, and the edges in E represent dependencies be-\ntween instructions, where .u; \u0003/ 2 E means that instruction u must execute before\ninstruction \u0003. For convenience, however, if a chain of instructions contains no\nparallel control (no spawn, sync, or return from a spawn—via either an explicit\nreturn statement or the return that happens implicitly upon reaching the end of\na procedure), we may group them into a single strand, each of which represents\none or more instructions. Instructions involving parallel control are not included",
    "parent_82a432ac-a390-4257-aa7e-ae34a02969fc": "return statement or the return that happens implicitly upon reaching the end of\na procedure), we may group them into a single strand, each of which represents\none or more instructions. Instructions involving parallel control are not included\nin strands, but are represented in the structure of the dag. For example, if a strand\nhas two successors, one of them must have been spawned, and a strand with mul-\ntiple predecessors indicates the predecessors joined because of a sync statement.\nThus, in the general case, the set V forms the set of strands, and the set E of di-\nrected edges represents dependencies between strands induced by parallel control.\n778\nChapter 27\nMultithreaded Algorithms\nP-FIB(1)\nP-FIB(0)\nP-FIB(3)\nP-FIB(4)\nP-FIB(1)\nP-FIB(1)\nP-FIB(0)\nP-FIB(2)\nP-FIB(2)\nFigure 27.2\nA directed acyclic graph representing the computation of P-FIB.4/. Each circle rep-\nresents one strand, with black circles representing either base cases or the part of the procedure\n(instance) up to the spawn of P-FIB.n \u0005 1/ in line 3, shaded circles representing the part of the pro-\ncedure that calls P-FIB.n \u0005 2/ in line 4 up to the sync in line 5, where it suspends until the spawn of\nP-FIB.n \u0005 1/ returns, and white circles representing the part of the procedure after the sync where\nit sums x and y up to the point where it returns the result. Each group of strands belonging to the\nsame procedure is surrounded by a rounded rectangle, lightly shaded for spawned procedures and\nheavily shaded for called procedures. Spawn edges and call edges point downward, continuation\nedges point horizontally to the right, and return edges point upward. Assuming that each strand takes\nunit time, the work equals 17 time units, since there are 17 strands, and the span is 8 time units, since\nthe critical path—shown with shaded edges—contains 8 strands.\nIf G has a directed path from strand u to strand \u0003, we say that the two strands are\n(logically) in series. Otherwise, strands u and \u0003 are (logically) in parallel.",
    "parent_cba98f3a-bcdc-4338-8911-3e2663137bfa": "the critical path—shown with shaded edges—contains 8 strands.\nIf G has a directed path from strand u to strand \u0003, we say that the two strands are\n(logically) in series. Otherwise, strands u and \u0003 are (logically) in parallel.\nWe can picture a multithreaded computation as a dag of strands embedded in a\ntree of procedure instances. For example, Figure 27.1 shows the tree of procedure\ninstances for P-FIB.6/ without the detailed structure showing strands. Figure 27.2\nzooms in on a section of that tree, showing the strands that constitute each proce-\ndure. All directed edges connecting strands run either within a procedure or along\nundirected edges in the procedure tree.\nWe can classify the edges of a computation dag to indicate the kind of dependen-\ncies between the various strands. A continuation edge .u; u0/, drawn horizontally\nin Figure 27.2, connects a strand u to its successor u0 within the same procedure\ninstance. When a strand u spawns a strand \u0003, the dag contains a spawn edge .u; \u0003/,\nwhich points downward in the ﬁgure. Call edges, representing normal procedure\ncalls, also point downward. Strand u spawning strand \u0003 differs from u calling \u0003\nin that a spawn induces a horizontal continuation edge from u to the strand u0 fol-\n27.1\nThe basics of dynamic multithreading\n779\nlowing u in its procedure, indicating that u0 is free to execute at the same time\nas \u0003, whereas a call induces no such edge. When a strand u returns to its calling\nprocedure and x is the strand immediately following the next sync in the calling\nprocedure, the computation dag contains return edge .u; x/, which points upward.\nA computation starts with a single initial strand—the black vertex in the procedure\nlabeled P-FIB.4/ in Figure 27.2—and ends with a single ﬁnal strand—the white\nvertex in the procedure labeled P-FIB.4/.\nWe shall study the execution of multithreaded algorithms on an ideal paral-\nlel computer, which consists of a set of processors and a sequentially consistent",
    "parent_67d82958-2420-4665-ace5-8503b355c5c1": "labeled P-FIB.4/ in Figure 27.2—and ends with a single ﬁnal strand—the white\nvertex in the procedure labeled P-FIB.4/.\nWe shall study the execution of multithreaded algorithms on an ideal paral-\nlel computer, which consists of a set of processors and a sequentially consistent\nshared memory. Sequential consistency means that the shared memory, which may\nin reality be performing many loads and stores from the processors at the same\ntime, produces the same results as if at each step, exactly one instruction from one\nof the processors is executed. That is, the memory behaves as if the instructions\nwere executed sequentially according to some global linear order that preserves the\nindividual orders in which each processor issues its own instructions. For dynamic\nmultithreaded computations, which are scheduled onto processors automatically\nby the concurrency platform, the shared memory behaves as if the multithreaded\ncomputation’s instructions were interleaved to produce a linear order that preserves\nthe partial order of the computation dag. Depending on scheduling, the ordering\ncould differ from one run of the program to another, but the behavior of any exe-\ncution can be understood by assuming that the instructions are executed in some\nlinear order consistent with the computation dag.\nIn addition to making assumptions about semantics, the ideal-parallel-computer\nmodel makes some performance assumptions. Speciﬁcally, it assumes that each\nprocessor in the machine has equal computing power, and it ignores the cost of\nscheduling. Although this last assumption may sound optimistic, it turns out that\nfor algorithms with sufﬁcient “parallelism” (a term we shall deﬁne precisely in a\nmoment), the overhead of scheduling is generally minimal in practice.\nPerformance measures\nWe can gauge the theoretical efﬁciency of a multithreaded algorithm by using two\nmetrics: “work” and “span.” The work of a multithreaded computation is the total",
    "parent_522fe74d-8996-4c67-addf-c73403f4fd31": "moment), the overhead of scheduling is generally minimal in practice.\nPerformance measures\nWe can gauge the theoretical efﬁciency of a multithreaded algorithm by using two\nmetrics: “work” and “span.” The work of a multithreaded computation is the total\ntime to execute the entire computation on one processor. In other words, the work\nis the sum of the times taken by each of the strands. For a computation dag in\nwhich each strand takes unit time, the work is just the number of vertices in the\ndag. The span is the longest time to execute the strands along any path in the dag.\nAgain, for a dag in which each strand takes unit time, the span equals the number of\nvertices on a longest or critical path in the dag. (Recall from Section 24.2 that we\ncan ﬁnd a critical path in a dag G D .V; E/ in ‚.V C E/ time.) For example, the\ncomputation dag of Figure 27.2 has 17 vertices in all and 8 vertices on its critical\n780\nChapter 27\nMultithreaded Algorithms\npath, so that if each strand takes unit time, its work is 17 time units and its span\nis 8 time units.\nThe actual running time of a multithreaded computation depends not only on\nits work and its span, but also on how many processors are available and how\nthe scheduler allocates strands to processors. To denote the running time of a\nmultithreaded computation on P processors, we shall subscript by P . For example,\nwe might denote the running time of an algorithm on P processors by TP. The\nwork is the running time on a single processor, or T1. The span is the running time\nif we could run each strand on its own processor—in other words, if we had an\nunlimited number of processors—and so we denote the span by T1.\nThe work and span provide lower bounds on the running time TP of a multi-\nthreaded computation on P processors:\n\u0002\nIn one step, an ideal parallel computer with P processors can do at most P\nunits of work, and thus in TP time, it can perform at most P TP work. Since the",
    "parent_56e88aca-3435-4c1d-a7ef-5175331f056f": "The work and span provide lower bounds on the running time TP of a multi-\nthreaded computation on P processors:\n\u0002\nIn one step, an ideal parallel computer with P processors can do at most P\nunits of work, and thus in TP time, it can perform at most P TP work. Since the\ntotal work to do is T1, we have P TP \u0006 T1. Dividing by P yields the work law:\nTP \u0006 T1=P :\n(27.2)\n\u0002\nA P -processor ideal parallel computer cannot run any faster than a machine\nwith an unlimited number of processors. Looked at another way, a machine\nwith an unlimited number of processors can emulate a P -processor machine by\nusing just P of its processors. Thus, the span law follows:\nTP \u0006 T1 :\n(27.3)\nWe deﬁne the speedup of a computation on P processors by the ratio T1=TP,\nwhich says how many times faster the computation is on P processors than\non 1 processor.\nBy the work law, we have TP \u0006 T1=P , which implies that\nT1=TP \u0002 P . Thus, the speedup on P processors can be at most P . When the\nspeedup is linear in the number of processors, that is, when T1=TP D ‚.P /, the\ncomputation exhibits linear speedup, and when T1=TP D P , we have perfect\nlinear speedup.\nThe ratio T1=T1 of the work to the span gives the parallelism of the multi-\nthreaded computation. We can view the parallelism from three perspectives. As a\nratio, the parallelism denotes the average amount of work that can be performed in\nparallel for each step along the critical path. As an upper bound, the parallelism\ngives the maximum possible speedup that can be achieved on any number of pro-\ncessors. Finally, and perhaps most important, the parallelism provides a limit on\nthe possibility of attaining perfect linear speedup. Speciﬁcally, once the number of\nprocessors exceeds the parallelism, the computation cannot possibly achieve per-\nfect linear speedup. To see this last point, suppose that P > T1=T1, in which case\n27.1\nThe basics of dynamic multithreading\n781\nthe span law implies that the speedup satisﬁes T1=TP \u0002 T1=T1 < P . Moreover,",
    "parent_afff994a-afc8-45ad-9e36-c22ee24aeb63": "processors exceeds the parallelism, the computation cannot possibly achieve per-\nfect linear speedup. To see this last point, suppose that P > T1=T1, in which case\n27.1\nThe basics of dynamic multithreading\n781\nthe span law implies that the speedup satisﬁes T1=TP \u0002 T1=T1 < P . Moreover,\nif the number P of processors in the ideal parallel computer greatly exceeds the\nparallelism—that is, if P \u000b T1=T1—then T1=TP \f P , so that the speedup is\nmuch less than the number of processors. In other words, the more processors we\nuse beyond the parallelism, the less perfect the speedup.\nAs an example, consider the computation P-FIB.4/ in Figure 27.2, and assume\nthat each strand takes unit time. Since the work is T1 D 17 and the span is T1 D 8,\nthe parallelism is T1=T1 D 17=8 D 2:125. Consequently, achieving much more\nthan double the speedup is impossible, no matter how many processors we em-\nploy to execute the computation. For larger input sizes, however, we shall see that\nP-FIB.n/ exhibits substantial parallelism.\nWe deﬁne the (parallel) slackness of a multithreaded computation executed\non an ideal parallel computer with P processors to be the ratio .T1=T1/=P D\nT1=.P T1/, which is the factor by which the parallelism of the computation ex-\nceeds the number of processors in the machine. Thus, if the slackness is less than 1,\nwe cannot hope to achieve perfect linear speedup, because T1=.P T1/ < 1 and the\nspan law imply that the speedup on P processors satisﬁes T1=TP \u0002 T1=T1 < P .\nIndeed, as the slackness decreases from 1 toward 0, the speedup of the computation\ndiverges further and further from perfect linear speedup. If the slackness is greater\nthan 1, however, the work per processor is the limiting constraint. As we shall see,\nas the slackness increases from 1, a good scheduler can achieve closer and closer\nto perfect linear speedup.\nScheduling\nGood performance depends on more than just minimizing the work and span. The",
    "parent_cbda4d81-eb45-4e29-9bde-ba48c254fcb9": "than 1, however, the work per processor is the limiting constraint. As we shall see,\nas the slackness increases from 1, a good scheduler can achieve closer and closer\nto perfect linear speedup.\nScheduling\nGood performance depends on more than just minimizing the work and span. The\nstrands must also be scheduled efﬁciently onto the processors of the parallel ma-\nchine. Our multithreaded programming model provides no way to specify which\nstrands to execute on which processors. Instead, we rely on the concurrency plat-\nform’s scheduler to map the dynamically unfolding computation to individual pro-\ncessors. In practice, the scheduler maps the strands to static threads, and the op-\nerating system schedules the threads on the processors themselves, but this extra\nlevel of indirection is unnecessary for our understanding of scheduling. We can\njust imagine that the concurrency platform’s scheduler maps strands to processors\ndirectly.\nA multithreaded scheduler must schedule the computation with no advance\nknowledge of when strands will be spawned or when they will complete—it must\noperate on-line. Moreover, a good scheduler operates in a distributed fashion,\nwhere the threads implementing the scheduler cooperate to load-balance the com-\nputation. Provably good on-line, distributed schedulers exist, but analyzing them\nis complicated.\n782\nChapter 27\nMultithreaded Algorithms\nInstead, to keep our analysis simple, we shall investigate an on-line centralized\nscheduler, which knows the global state of the computation at any given time. In\nparticular, we shall analyze greedy schedulers, which assign as many strands to\nprocessors as possible in each time step. If at least P strands are ready to execute\nduring a time step, we say that the step is a complete step, and a greedy scheduler\nassigns any P of the ready strands to processors. Otherwise, fewer than P strands\nare ready to execute, in which case we say that the step is an incomplete step, and",
    "parent_c82c563d-d054-4803-a286-3a995fdae0ef": "during a time step, we say that the step is a complete step, and a greedy scheduler\nassigns any P of the ready strands to processors. Otherwise, fewer than P strands\nare ready to execute, in which case we say that the step is an incomplete step, and\nthe scheduler assigns each ready strand to its own processor.\nFrom the work law, the best running time we can hope for on P processors\nis TP D T1=P , and from the span law the best we can hope for is TP D T1.\nThe following theorem shows that greedy scheduling is provably good in that it\nachieves the sum of these two lower bounds as an upper bound.\nTheorem 27.1\nOn an ideal parallel computer with P processors, a greedy scheduler executes a\nmultithreaded computation with work T1 and span T1 in time\nTP \u0002 T1=P C T1 :\n(27.4)\nProof\nWe start by considering the complete steps. In each complete step, the\nP processors together perform a total of P work. Suppose for the purpose of\ncontradiction that the number of complete steps is strictly greater than bT1=P c.\nThen, the total work of the complete steps is at least\nP \u0003 .bT1=P c C 1/\nD\nP bT1=P c C P\nD\nT1 \u0005 .T1 mod P / C P\n(by equation (3.8))\n>\nT1\n(by inequality (3.9)) .\nThus, we obtain the contradiction that the P processors would perform more work\nthan the computation requires, which allows us to conclude that the number of\ncomplete steps is at most bT1=P c.\nNow, consider an incomplete step. Let G be the dag representing the entire\ncomputation, and without loss of generality, assume that each strand takes unit\ntime. (We can replace each longer strand by a chain of unit-time strands.) Let G0\nbe the subgraph of G that has yet to be executed at the start of the incomplete step,\nand let G00 be the subgraph remaining to be executed after the incomplete step. A\nlongest path in a dag must necessarily start at a vertex with in-degree 0. Since an\nincomplete step of a greedy scheduler executes all strands with in-degree 0 in G0,",
    "parent_cb4446d4-c5dd-49ba-8e70-b90f2a9f250a": "and let G00 be the subgraph remaining to be executed after the incomplete step. A\nlongest path in a dag must necessarily start at a vertex with in-degree 0. Since an\nincomplete step of a greedy scheduler executes all strands with in-degree 0 in G0,\nthe length of a longest path in G00 must be 1 less than the length of a longest path\nin G0. In other words, an incomplete step decreases the span of the unexecuted dag\nby 1. Hence, the number of incomplete steps is at most T1.\nSince each step is either complete or incomplete, the theorem follows.\n27.1\nThe basics of dynamic multithreading\n783\nThe following corollary to Theorem 27.1 shows that a greedy scheduler always\nperforms well.\nCorollary 27.2\nThe running time TP of any multithreaded computation scheduled by a greedy\nscheduler on an ideal parallel computer with P processors is within a factor of 2\nof optimal.\nProof\nLet T \u0004\nP be the running time produced by an optimal scheduler on a machine\nwith P processors, and let T1 and T1 be the work and span of the computation,\nrespectively. Since the work and span laws—inequalities (27.2) and (27.3)—give\nus T \u0004\nP \u0006 max.T1=P; T1/, Theorem 27.1 implies that\nTP\n\u0002\nT1=P C T1\n\u0002\n2 \u0003 max.T1=P; T1/\n\u0002\n2T \u0004\nP :\nThe next corollary shows that, in fact, a greedy scheduler achieves near-perfect\nlinear speedup on any multithreaded computation as the slackness grows.\nCorollary 27.3\nLet TP be the running time of a multithreaded computation produced by a greedy\nscheduler on an ideal parallel computer with P processors, and let T1 and T1 be\nthe work and span of the computation, respectively. Then, if P \f T1=T1, we\nhave TP \u0004 T1=P , or equivalently, a speedup of approximately P .\nProof\nIf we suppose that P \f T1=T1, then we also have T1 \f T1=P , and\nhence Theorem 27.1 gives us TP \u0002 T1=P C T1 \u0004 T1=P .\nSince the work\nlaw (27.2) dictates that TP \u0006 T1=P , we conclude that TP \u0004 T1=P , or equiva-\nlently, that the speedup is T1=TP \u0004 P .\nThe \f symbol denotes “much less,” but how much is “much less”? As a rule",
    "parent_5921831b-5db2-4bf2-9929-ce1565d218fd": "hence Theorem 27.1 gives us TP \u0002 T1=P C T1 \u0004 T1=P .\nSince the work\nlaw (27.2) dictates that TP \u0006 T1=P , we conclude that TP \u0004 T1=P , or equiva-\nlently, that the speedup is T1=TP \u0004 P .\nThe \f symbol denotes “much less,” but how much is “much less”? As a rule\nof thumb, a slackness of at least 10—that is, 10 times more parallelism than pro-\ncessors—generally sufﬁces to achieve good speedup. Then, the span term in the\ngreedy bound, inequality (27.4), is less than 10% of the work-per-processor term,\nwhich is good enough for most engineering situations. For example, if a computa-\ntion runs on only 10 or 100 processors, it doesn’t make sense to value parallelism\nof, say 1,000,000 over parallelism of 10,000, even with the factor of 100 differ-\nence. As Problem 27-2 shows, sometimes by reducing extreme parallelism, we\ncan obtain algorithms that are better with respect to other concerns and which still\nscale up well on reasonable numbers of processors.\n784\nChapter 27\nMultithreaded Algorithms\nA\n(a)\n(b)\nB\nA\nB\nWork: T1.A [ B/ D T1.A/ C T1.B/\nSpan: T1.A [ B/ D T1.A/ C T1.B/\nWork: T1.A [ B/ D T1.A/ C T1.B/\nSpan: T1.A [ B/ D max.T1.A/; T1.B/)\nFigure 27.3\nThe work and span of composed subcomputations. (a) When two subcomputations\nare joined in series, the work of the composition is the sum of their work, and the span of the\ncomposition is the sum of their spans. (b) When two subcomputations are joined in parallel, the\nwork of the composition remains the sum of their work, but the span of the composition is only the\nmaximum of their spans.\nAnalyzing multithreaded algorithms\nWe now have all the tools we need to analyze multithreaded algorithms and provide\ngood bounds on their running times on various numbers of processors. Analyzing\nthe work is relatively straightforward, since it amounts to nothing more than ana-\nlyzing the running time of an ordinary serial algorithm—namely, the serialization\nof the multithreaded algorithm—which you should already be familiar with, since",
    "parent_8f8eb987-7bfd-4ef8-88ed-6c9805f18808": "the work is relatively straightforward, since it amounts to nothing more than ana-\nlyzing the running time of an ordinary serial algorithm—namely, the serialization\nof the multithreaded algorithm—which you should already be familiar with, since\nthat is what most of this textbook is about! Analyzing the span is more interesting,\nbut generally no harder once you get the hang of it. We shall investigate the basic\nideas using the P-FIB program.\nAnalyzing the work T1.n/ of P-FIB.n/ poses no hurdles, because we’ve already\ndone it. The original FIB procedure is essentially the serialization of P-FIB, and\nhence T1.n/ D T .n/ D ‚.\u0007n/ from equation (27.1).\nFigure 27.3 illustrates how to analyze the span. If two subcomputations are\njoined in series, their spans add to form the span of their composition, whereas\nif they are joined in parallel, the span of their composition is the maximum of the\nspans of the two subcomputations. For P-FIB.n/, the spawned call to P-FIB.n\u00051/\nin line 3 runs in parallel with the call to P-FIB.n \u0005 2/ in line 4. Hence, we can\nexpress the span of P-FIB.n/ as the recurrence\nT1.n/\nD\nmax.T1.n \u0005 1/; T1.n \u0005 2// C ‚.1/\nD\nT1.n \u0005 1/ C ‚.1/ ;\nwhich has solution T1.n/ D ‚.n/.\nThe parallelism of P-FIB.n/ is T1.n/=T1.n/ D ‚.\u0007n=n/, which grows dra-\nmatically as n gets large. Thus, on even the largest parallel computers, a modest\n27.1\nThe basics of dynamic multithreading\n785\nvalue for n sufﬁces to achieve near perfect linear speedup for P-FIB.n/, because\nthis procedure exhibits considerable parallel slackness.\nParallel loops\nMany algorithms contain loops all of whose iterations can operate in parallel. As\nwe shall see, we can parallelize such loops using the spawn and sync keywords,\nbut it is much more convenient to specify directly that the iterations of such loops\ncan run concurrently. Our pseudocode provides this functionality via the parallel\nconcurrency keyword, which precedes the for keyword in a for loop statement.",
    "parent_8b176653-31cf-4e8b-ae67-743fd656225c": "but it is much more convenient to specify directly that the iterations of such loops\ncan run concurrently. Our pseudocode provides this functionality via the parallel\nconcurrency keyword, which precedes the for keyword in a for loop statement.\nAs an example, consider the problem of multiplying an n \t n matrix A D .aij/\nby an n-vector x D .xj/. The resulting n-vector y D .yi/ is given by the equation\nyi D\nn\nX\njD1\naijxj ;\nfor i D 1; 2; : : : ; n. We can perform matrix-vector multiplication by computing all\nthe entries of y in parallel as follows:\nMAT-VEC.A; x/\n1\nn D A:rows\n2\nlet y be a new vector of length n\n3\nparallel for i D 1 to n\n4\nyi D 0\n5\nparallel for i D 1 to n\n6\nfor j D 1 to n\n7\nyi D yi C aijxj\n8\nreturn y\nIn this code, the parallel for keywords in lines 3 and 5 indicate that the itera-\ntions of the respective loops may be run concurrently. A compiler can implement\neach parallel for loop as a divide-and-conquer subroutine using nested parallelism.\nFor example, the parallel for loop in lines 5–7 can be implemented with the call\nMAT-VEC-MAIN-LOOP.A; x; y; n; 1; n/, where the compiler produces the auxil-\niary subroutine MAT-VEC-MAIN-LOOP as follows:\n786\nChapter 27\nMultithreaded Algorithms\n1,1\n2,2\n3,3\n4,4\n5,5\n6,6\n7,7\n8,8\n1,2\n3,4\n5,6\n7,8\n1,4\n5,8\n1,8\nFigure 27.4\nA dag representing the computation of MAT-VEC-MAIN-LOOP.A; x; y; 8; 1; 8/. The\ntwo numbers within each rounded rectangle give the values of the last two parameters (i and i0 in\nthe procedure header) in the invocation (spawn or call) of the procedure. The black circles repre-\nsent strands corresponding to either the base case or the part of the procedure up to the spawn of\nMAT-VEC-MAIN-LOOP in line 5; the shaded circles represent strands corresponding to the part of\nthe procedure that calls MAT-VEC-MAIN-LOOP in line 6 up to the sync in line 7, where it suspends\nuntil the spawned subroutine in line 5 returns; and the white circles represent strands corresponding",
    "parent_165e6e79-3f85-4892-90c5-d3042fb1a1f2": "MAT-VEC-MAIN-LOOP in line 5; the shaded circles represent strands corresponding to the part of\nthe procedure that calls MAT-VEC-MAIN-LOOP in line 6 up to the sync in line 7, where it suspends\nuntil the spawned subroutine in line 5 returns; and the white circles represent strands corresponding\nto the (negligible) part of the procedure after the sync up to the point where it returns.\nMAT-VEC-MAIN-LOOP.A; x; y; n; i; i 0/\n1\nif i == i 0\n2\nfor j D 1 to n\n3\nyi D yi C aijxj\n4\nelse mid D b.i C i 0/=2c\n5\nspawn MAT-VEC-MAIN-LOOP.A; x; y; n; i; mid/\n6\nMAT-VEC-MAIN-LOOP.A; x; y; n; mid C 1; i 0/\n7\nsync\nThis code recursively spawns the ﬁrst half of the iterations of the loop to execute\nin parallel with the second half of the iterations and then executes a sync, thereby\ncreating a binary tree of execution where the leaves are individual loop iterations,\nas shown in Figure 27.4.\nTo calculate the work T1.n/ of MAT-VEC on an n\tn matrix, we simply compute\nthe running time of its serialization, which we obtain by replacing the parallel for\nloops with ordinary for loops. Thus, we have T1.n/ D ‚.n2/, because the qua-\ndratic running time of the doubly nested loops in lines 5–7 dominates. This analysis\n27.1\nThe basics of dynamic multithreading\n787\nseems to ignore the overhead for recursive spawning in implementing the parallel\nloops, however. In fact, the overhead of recursive spawning does increase the work\nof a parallel loop compared with that of its serialization, but not asymptotically.\nTo see why, observe that since the tree of recursive procedure instances is a full\nbinary tree, the number of internal nodes is 1 fewer than the number of leaves (see\nExercise B.5-3). Each internal node performs constant work to divide the iteration\nrange, and each leaf corresponds to an iteration of the loop, which takes at least\nconstant time (‚.n/ time in this case). Thus, we can amortize the overhead of re-\ncursive spawning against the work of the iterations, contributing at most a constant",
    "parent_3ad10bf0-3ff6-41ff-ba62-33f46dcab320": "range, and each leaf corresponds to an iteration of the loop, which takes at least\nconstant time (‚.n/ time in this case). Thus, we can amortize the overhead of re-\ncursive spawning against the work of the iterations, contributing at most a constant\nfactor to the overall work.\nAs a practical matter, dynamic-multithreading concurrency platforms sometimes\ncoarsen the leaves of the recursion by executing several iterations in a single leaf,\neither automatically or under programmer control, thereby reducing the overhead\nof recursive spawning. This reduced overhead comes at the expense of also reduc-\ning the parallelism, however, but if the computation has sufﬁcient parallel slack-\nness, near-perfect linear speedup need not be sacriﬁced.\nWe must also account for the overhead of recursive spawning when analyzing the\nspan of a parallel-loop construct. Since the depth of recursive calling is logarithmic\nin the number of iterations, for a parallel loop with n iterations in which the ith\niteration has span iter1.i/, the span is\nT1.n/ D ‚.lg n/ C max\n1\u0005i\u0005n iter1.i/ :\nFor example, for MAT-VEC on an n \t n matrix, the parallel initialization loop in\nlines 3–4 has span ‚.lg n/, because the recursive spawning dominates the constant-\ntime work of each iteration. The span of the doubly nested loops in lines 5–7\nis ‚.n/, because each iteration of the outer parallel for loop contains n iterations\nof the inner (serial) for loop. The span of the remaining code in the procedure\nis constant, and thus the span is dominated by the doubly nested loops, yielding\nan overall span of ‚.n/ for the whole procedure. Since the work is ‚.n2/, the\nparallelism is ‚.n2/=‚.n/ D ‚.n/. (Exercise 27.1-6 asks you to provide an\nimplementation with even more parallelism.)\nRace conditions\nA multithreaded algorithm is deterministic if it always does the same thing on the\nsame input, no matter how the instructions are scheduled on the multicore com-",
    "parent_487e4ad8-e2e4-428c-9960-c974ac8e16a0": "parallelism is ‚.n2/=‚.n/ D ‚.n/. (Exercise 27.1-6 asks you to provide an\nimplementation with even more parallelism.)\nRace conditions\nA multithreaded algorithm is deterministic if it always does the same thing on the\nsame input, no matter how the instructions are scheduled on the multicore com-\nputer. It is nondeterministic if its behavior might vary from run to run. Often, a\nmultithreaded algorithm that is intended to be deterministic fails to be, because it\ncontains a “determinacy race.”\nRace conditions are the bane of concurrency. Famous race bugs include the\nTherac-25 radiation therapy machine, which killed three people and injured sev-\n788\nChapter 27\nMultithreaded Algorithms\neral others, and the North American Blackout of 2003, which left over 50 million\npeople without power. These pernicious bugs are notoriously hard to ﬁnd. You can\nrun tests in the lab for days without a failure only to discover that your software\nsporadically crashes in the ﬁeld.\nA determinacy race occurs when two logically parallel instructions access the\nsame memory location and at least one of the instructions performs a write. The\nfollowing procedure illustrates a race condition:\nRACE-EXAMPLE. /\n1\nx D 0\n2\nparallel for i D 1 to 2\n3\nx D x C 1\n4\nprint x\nAfter initializing x to 0 in line 1, RACE-EXAMPLE creates two parallel strands,\neach of which increments x in line 3.\nAlthough it might seem that RACE-\nEXAMPLE should always print the value 2 (its serialization certainly does), it could\ninstead print the value 1. Let’s see how this anomaly might occur.\nWhen a processor increments x, the operation is not indivisible, but is composed\nof a sequence of instructions:\n1. Read x from memory into one of the processor’s registers.\n2. Increment the value in the register.\n3. Write the value in the register back into x in memory.\nFigure 27.5(a) illustrates a computation dag representing the execution of RACE-\nEXAMPLE, with the strands broken down to individual instructions. Recall that",
    "parent_76cf8d1d-f7da-4fdb-a87d-11a5a8ab4dc2": "2. Increment the value in the register.\n3. Write the value in the register back into x in memory.\nFigure 27.5(a) illustrates a computation dag representing the execution of RACE-\nEXAMPLE, with the strands broken down to individual instructions. Recall that\nsince an ideal parallel computer supports sequential consistency, we can view the\nparallel execution of a multithreaded algorithm as an interleaving of instructions\nthat respects the dependencies in the dag. Part (b) of the ﬁgure shows the values\nin an execution of the computation that elicits the anomaly. The value x is stored\nin memory, and r1 and r2 are processor registers. In step 1, one of the processors\nsets x to 0. In steps 2 and 3, processor 1 reads x from memory into its register r1\nand increments it, producing the value 1 in r1. At that point, processor 2 comes\ninto the picture, executing instructions 4–6. Processor 2 reads x from memory into\nregister r2; increments it, producing the value 1 in r2; and then stores this value\ninto x, setting x to 1. Now, processor 1 resumes with step 7, storing the value 1\nin r1 into x, which leaves the value of x unchanged. Therefore, step 8 prints the\nvalue 1, rather than 2, as the serialization would print.\nWe can see what has happened. If the effect of the parallel execution were that\nprocessor 1 executed all its instructions before processor 2, the value 2 would be\n27.1\nThe basics of dynamic multithreading\n789\nincr r1\n3\nr1 = x\n2\nx = r1\n7\nincr r2\n5\nr2 =  x\n4\nx = r2\n6\nx = 0\n1\nprint x\n8\n(a)\nstep\nx\nr1\nr2\n1\n2\n3\n4\n5\n6\n7\n0\n0\n0\n0\n0\n1\n1\n–\n0\n1\n1\n1\n1\n1\n–\n–\n–\n0\n1\n1\n1\n(b)\nFigure 27.5\nIllustration of the determinacy race in RACE-EXAMPLE. (a) A computation dag show-\ning the dependencies among individual instructions. The processor registers are r1 and r2. Instruc-\ntions unrelated to the race, such as the implementation of loop control, are omitted. (b) An execution\nsequence that elicits the bug, showing the values of x in memory and registers r1 and r2 for each",
    "parent_d7d7f901-40d3-4d91-99a0-ac77536187de": "tions unrelated to the race, such as the implementation of loop control, are omitted. (b) An execution\nsequence that elicits the bug, showing the values of x in memory and registers r1 and r2 for each\nstep in the execution sequence.\nprinted. Conversely, if the effect were that processor 2 executed all its instructions\nbefore processor 1, the value 2 would still be printed. When the instructions of the\ntwo processors execute at the same time, however, it is possible, as in this example\nexecution, that one of the updates to x is lost.\nOf course, many executions do not elicit the bug. For example, if the execution\norder were h1; 2; 3; 7; 4; 5; 6; 8i or h1; 4; 5; 6; 2; 3; 7; 8i, we would get the cor-\nrect result. That’s the problem with determinacy races. Generally, most orderings\nproduce correct results—such as any in which the instructions on the left execute\nbefore the instructions on the right, or vice versa. But some orderings generate\nimproper results when the instructions interleave. Consequently, races can be ex-\ntremely hard to test for. You can run tests for days and never see the bug, only to\nexperience a catastrophic system crash in the ﬁeld when the outcome is critical.\nAlthough we can cope with races in a variety of ways, including using mutual-\nexclusion locks and other methods of synchronization, for our purposes, we shall\nsimply ensure that strands that operate in parallel are independent: they have no\ndeterminacy races among them. Thus, in a parallel for construct, all the iterations\nshould be independent. Between a spawn and the corresponding sync, the code\nof the spawned child should be independent of the code of the parent, including\ncode executed by additional spawned or called children. Note that arguments to a\nspawned child are evaluated in the parent before the actual spawn occurs, and thus\nthe evaluation of arguments to a spawned subroutine is in series with any accesses\nto those arguments after the spawn.\n790\nChapter 27",
    "parent_06e8b8ce-24b3-47ba-b4be-25a5438ac2cc": "code executed by additional spawned or called children. Note that arguments to a\nspawned child are evaluated in the parent before the actual spawn occurs, and thus\nthe evaluation of arguments to a spawned subroutine is in series with any accesses\nto those arguments after the spawn.\n790\nChapter 27\nMultithreaded Algorithms\nAs an example of how easy it is to generate code with races, here is a faulty\nimplementation of multithreaded matrix-vector multiplication that achieves a span\nof ‚.lg n/ by parallelizing the inner for loop:\nMAT-VEC-WRONG.A; x/\n1\nn D A:rows\n2\nlet y be a new vector of length n\n3\nparallel for i D 1 to n\n4\nyi D 0\n5\nparallel for i D 1 to n\n6\nparallel for j D 1 to n\n7\nyi D yi C aijxj\n8\nreturn y\nThis procedure is, unfortunately, incorrect due to races on updating yi in line 7,\nwhich executes concurrently for all n values of j . Exercise 27.1-6 asks you to give\na correct implementation with ‚.lg n/ span.\nA multithreaded algorithm with races can sometimes be correct. As an exam-\nple, two parallel threads might store the same value into a shared variable, and it\nwouldn’t matter which stored the value ﬁrst. Generally, however, we shall consider\ncode with races to be illegal.\nA chess lesson\nWe close this section with a true story that occurred during the development of\nthe world-class multithreaded chess-playing program ?Socrates [80], although the\ntimings below have been simpliﬁed for exposition. The program was prototyped\non a 32-processor computer but was ultimately to run on a supercomputer with 512\nprocessors. At one point, the developers incorporated an optimization into the pro-\ngram that reduced its running time on an important benchmark on the 32-processor\nmachine from T32 D 65 seconds to T 0\n32 D 40 seconds. Yet, the developers used\nthe work and span performance measures to conclude that the optimized version,\nwhich was faster on 32 processors, would actually be slower than the original ver-",
    "parent_c72a083c-21f4-43bf-b985-8257e9f0c4f0": "machine from T32 D 65 seconds to T 0\n32 D 40 seconds. Yet, the developers used\nthe work and span performance measures to conclude that the optimized version,\nwhich was faster on 32 processors, would actually be slower than the original ver-\nsion on 512 processsors. As a result, they abandoned the “optimization.”\nHere is their analysis. The original version of the program had work T1 D 2048\nseconds and span T1 D 1 second. If we treat inequality (27.4) as an equation,\nTP D T1=P C T1, and use it as an approximation to the running time on P pro-\ncessors, we see that indeed T32 D 2048=32 C 1 D 65. With the optimization, the\nwork became T 0\n1 D 1024 seconds and the span became T 0\n1 D 8 seconds. Again\nusing our approximation, we get T 0\n32 D 1024=32 C 8 D 40.\nThe relative speeds of the two versions switch when we calculate the running\ntimes on 512 processors, however. In particular, we have T512 D 2048=512C1 D 5\n27.1\nThe basics of dynamic multithreading\n791\nseconds, and T 0\n512 D 1024=512 C 8 D 10 seconds. The optimization that sped up\nthe program on 32 processors would have made the program twice as slow on 512\nprocessors! The optimized version’s span of 8, which was not the dominant term in\nthe running time on 32 processors, became the dominant term on 512 processors,\nnullifying the advantage from using more processors.\nThe moral of the story is that work and span can provide a better means of\nextrapolating performance than can measured running times.\nExercises\n27.1-1\nSuppose that we spawn P-FIB.n \u0005 2/ in line 4 of P-FIB, rather than calling it\nas is done in the code. What is the impact on the asymptotic work, span, and\nparallelism?\n27.1-2\nDraw the computation dag that results from executing P-FIB.5/. Assuming that\neach strand in the computation takes unit time, what are the work, span, and par-\nallelism of the computation? Show how to schedule the dag on 3 processors using\ngreedy scheduling by labeling each strand with the time step in which it is executed.\n27.1-3",
    "parent_29199d91-6976-43a8-abae-078076008fba": "each strand in the computation takes unit time, what are the work, span, and par-\nallelism of the computation? Show how to schedule the dag on 3 processors using\ngreedy scheduling by labeling each strand with the time step in which it is executed.\n27.1-3\nProve that a greedy scheduler achieves the following time bound, which is slightly\nstronger than the bound proven in Theorem 27.1:\nTP \u0002 T1 \u0005 T1\nP\nC T1 :\n(27.5)\n27.1-4\nConstruct a computation dag for which one execution of a greedy scheduler can\ntake nearly twice the time of another execution of a greedy scheduler on the same\nnumber of processors. Describe how the two executions would proceed.\n27.1-5\nProfessor Karan measures her deterministic multithreaded algorithm on 4, 10,\nand 64 processors of an ideal parallel computer using a greedy scheduler. She\nclaims that the three runs yielded T4 D 80 seconds, T10 D 42 seconds, and\nT64 D 10 seconds. Argue that the professor is either lying or incompetent. (Hint:\nUse the work law (27.2), the span law (27.3), and inequality (27.5) from Exer-\ncise 27.1-3.)\n792\nChapter 27\nMultithreaded Algorithms\n27.1-6\nGive a multithreaded algorithm to multiply an n \t n matrix by an n-vector that\nachieves ‚.n2= lg n/ parallelism while maintaining ‚.n2/ work.\n27.1-7\nConsider the following multithreaded pseudocode for transposing an n\tn matrix A\nin place:\nP-TRANSPOSE.A/\n1\nn D A:rows\n2\nparallel for j D 2 to n\n3\nparallel for i D 1 to j \u0005 1\n4\nexchange aij with aji\nAnalyze the work, span, and parallelism of this algorithm.\n27.1-8\nSuppose that we replace the parallel for loop in line 3 of P-TRANSPOSE (see Ex-\nercise 27.1-7) with an ordinary for loop. Analyze the work, span, and parallelism\nof the resulting algorithm.\n27.1-9\nFor how many processors do the two versions of the chess programs run equally\nfast, assuming that TP D T1=P C T1?\n27.2\nMultithreaded matrix multiplication\nIn this section, we examine how to multithread matrix multiplication, a problem",
    "parent_8c0b63a8-419b-42e0-a1c1-40922435fdab": "of the resulting algorithm.\n27.1-9\nFor how many processors do the two versions of the chess programs run equally\nfast, assuming that TP D T1=P C T1?\n27.2\nMultithreaded matrix multiplication\nIn this section, we examine how to multithread matrix multiplication, a problem\nwhose serial running time we studied in Section 4.2. We’ll look at multithreaded\nalgorithms based on the standard triply nested loop, as well as divide-and-conquer\nalgorithms.\nMultithreaded matrix multiplication\nThe ﬁrst algorithm we study is the straighforward algorithm based on parallelizing\nthe loops in the procedure SQUARE-MATRIX-MULTIPLY on page 75:\n27.2\nMultithreaded matrix multiplication\n793\nP-SQUARE-MATRIX-MULTIPLY.A; B/\n1\nn D A:rows\n2\nlet C be a new n \u0003 n matrix\n3\nparallel for i D 1 to n\n4\nparallel for j D 1 to n\n5\ncij D 0\n6\nfor k D 1 to n\n7\ncij D cij C aik \u0004 bkj\n8\nreturn C\nTo analyze this algorithm, observe that since the serialization of the algorithm is\njust SQUARE-MATRIX-MULTIPLY, the work is therefore simply T1.n/ D ‚.n3/,\nthe same as the running time of SQUARE-MATRIX-MULTIPLY.\nThe span is\nT1.n/ D ‚.n/, because it follows a path down the tree of recursion for the\nparallel for loop starting in line 3, then down the tree of recursion for the parallel\nfor loop starting in line 4, and then executes all n iterations of the ordinary for loop\nstarting in line 6, resulting in a total span of ‚.lg n/ C ‚.lg n/ C ‚.n/ D ‚.n/.\nThus, the parallelism is ‚.n3/=‚.n/ D ‚.n2/. Exercise 27.2-3 asks you to par-\nallelize the inner loop to obtain a parallelism of ‚.n3= lg n/, which you cannot do\nstraightforwardly using parallel for, because you would create races.\nA divide-and-conquer multithreaded algorithm for matrix multiplication\nAs we learned in Section 4.2, we can multiply n \u0003 n matrices serially in time\n‚.nlg 7/ D O.n2:81/ using Strassen’s divide-and-conquer strategy, which motivates\nus to look at multithreading such an algorithm. We begin, as we did in Section 4.2,",
    "parent_0b47d06e-86ad-46ba-acde-261585a168f6": "As we learned in Section 4.2, we can multiply n \u0003 n matrices serially in time\n‚.nlg 7/ D O.n2:81/ using Strassen’s divide-and-conquer strategy, which motivates\nus to look at multithreading such an algorithm. We begin, as we did in Section 4.2,\nwith multithreading a simpler divide-and-conquer algorithm.\nRecall from page 77 that the SQUARE-MATRIX-MULTIPLY-RECURSIVE proce-\ndure, which multiplies two n \u0003 n matrices A and B to produce the n \u0003 n matrix C,\nrelies on partitioning each of the three matrices into four n=2 \u0003 n=2 submatrices:\nA D\n\u0002 A11\nA12\nA21\nA22\n\u0003\n;\nB D\n\u0002 B11\nB12\nB21\nB22\n\u0003\n;\nC D\n\u0002 C11\nC12\nC21\nC22\n\u0003\n:\nThen, we can write the matrix product as\n\u0002 C11\nC12\nC21\nC22\n\u0003\nD\n\u0002 A11\nA12\nA21\nA22\n\u0003\u0002 B11\nB12\nB21\nB22\n\u0003\nD\n\u0002 A11B11\nA11B12\nA21B11\nA21B12\n\u0003\nC\n\u0002 A12B21\nA12B22\nA22B21\nA22B22\n\u0003\n:\n(27.6)\nThus, to multiply two n\u0003n matrices, we perform eight multiplications of n=2\u0003n=2\nmatrices and one addition of n\u0003n matrices. The following pseudocode implements\n794\nChapter 27\nMultithreaded Algorithms\nthis divide-and-conquer strategy using nested parallelism. Unlike the SQUARE-\nMATRIX-MULTIPLY-RECURSIVE procedure on which it is based, P-MATRIX-\nMULTIPLY-RECURSIVE takes the output matrix as a parameter to avoid allocating\nmatrices unnecessarily.\nP-MATRIX-MULTIPLY-RECURSIVE.C; A; B/\n1\nn D A:rows\n2\nif n == 1\n3\nc11 D a11b11\n4\nelse let T be a new n \t n matrix\n5\npartition A, B, C, and T into n=2 \t n=2 submatrices\nA11; A12; A21; A22; B11; B12; B21; B22; C11; C12; C21; C22;\nand T11; T12; T21; T22; respectively\n6\nspawn P-MATRIX-MULTIPLY-RECURSIVE.C11; A11; B11/\n7\nspawn P-MATRIX-MULTIPLY-RECURSIVE.C12; A11; B12/\n8\nspawn P-MATRIX-MULTIPLY-RECURSIVE.C21; A21; B11/\n9\nspawn P-MATRIX-MULTIPLY-RECURSIVE.C22; A21; B12/\n10\nspawn P-MATRIX-MULTIPLY-RECURSIVE.T11; A12; B21/\n11\nspawn P-MATRIX-MULTIPLY-RECURSIVE.T12; A12; B22/\n12\nspawn P-MATRIX-MULTIPLY-RECURSIVE.T21; A22; B21/\n13\nP-MATRIX-MULTIPLY-RECURSIVE.T22; A22; B22/\n14\nsync\n15\nparallel for i D 1 to n\n16\nparallel for j D 1 to n\n17\ncij D cij C tij",
    "parent_368ee255-b7a6-4116-a1c9-4e45d1550c60": "10\nspawn P-MATRIX-MULTIPLY-RECURSIVE.T11; A12; B21/\n11\nspawn P-MATRIX-MULTIPLY-RECURSIVE.T12; A12; B22/\n12\nspawn P-MATRIX-MULTIPLY-RECURSIVE.T21; A22; B21/\n13\nP-MATRIX-MULTIPLY-RECURSIVE.T22; A22; B22/\n14\nsync\n15\nparallel for i D 1 to n\n16\nparallel for j D 1 to n\n17\ncij D cij C tij\nLine 3 handles the base case, where we are multiplying 1 \t 1 matrices. We handle\nthe recursive case in lines 4–17. We allocate a temporary matrix T in line 4, and\nline 5 partitions each of the matrices A, B, C, and T into n=2 \t n=2 submatrices.\n(As with SQUARE-MATRIX-MULTIPLY-RECURSIVE on page 77, we gloss over\nthe minor issue of how to use index calculations to represent submatrix sections\nof a matrix.) The recursive call in line 6 sets the submatrix C11 to the submatrix\nproduct A11B11, so that C11 equals the ﬁrst of the two terms that form its sum in\nequation (27.6). Similarly, lines 7–9 set C12, C21, and C22 to the ﬁrst of the two\nterms that equal their sums in equation (27.6). Line 10 sets the submatrix T11 to\nthe submatrix product A12B21, so that T11 equals the second of the two terms that\nform C11’s sum. Lines 11–13 set T12, T21, and T22 to the second of the two terms\nthat form the sums of C12, C21, and C22, respectively. The ﬁrst seven recursive\ncalls are spawned, and the last one runs in the main strand. The sync statement in\nline 14 ensures that all the submatrix products in lines 6–13 have been computed,\n27.2\nMultithreaded matrix multiplication\n795\nafter which we add the products from T into C in using the doubly nested parallel\nfor loops in lines 15–17.\nWe ﬁrst analyze the work M1.n/ of the P-MATRIX-MULTIPLY-RECURSIVE\nprocedure, echoing the serial running-time analysis of its progenitor SQUARE-\nMATRIX-MULTIPLY-RECURSIVE. In the recursive case, we partition in ‚.1/ time,\nperform eight recursive multiplications of n=2 \t n=2 matrices, and ﬁnish up with\nthe ‚.n2/ work from adding two n \t n matrices. Thus, the recurrence for the\nwork M1.n/ is\nM1.n/\nD\n8M1.n=2/ C ‚.n2/\nD\n‚.n3/",
    "parent_93cac559-a20f-43c9-ba97-bdf86e1d3ca2": "MATRIX-MULTIPLY-RECURSIVE. In the recursive case, we partition in ‚.1/ time,\nperform eight recursive multiplications of n=2 \t n=2 matrices, and ﬁnish up with\nthe ‚.n2/ work from adding two n \t n matrices. Thus, the recurrence for the\nwork M1.n/ is\nM1.n/\nD\n8M1.n=2/ C ‚.n2/\nD\n‚.n3/\nby case 1 of the master theorem. In other words, the work of our multithreaded al-\ngorithm is asymptotically the same as the running time of the procedure SQUARE-\nMATRIX-MULTIPLY in Section 4.2, with its triply nested loops.\nTo determine the span M1.n/ of P-MATRIX-MULTIPLY-RECURSIVE, we ﬁrst\nobserve that the span for partitioning is ‚.1/, which is dominated by the ‚.lg n/\nspan of the doubly nested parallel for loops in lines 15–17. Because the eight\nparallel recursive calls all execute on matrices of the same size, the maximum span\nfor any recursive call is just the span of any one. Hence, the recurrence for the\nspan M1.n/ of P-MATRIX-MULTIPLY-RECURSIVE is\nM1.n/ D M1.n=2/ C ‚.lg n/ :\n(27.7)\nThis recurrence does not fall under any of the cases of the master theorem, but\nit does meet the condition of Exercise 4.6-2. By Exercise 4.6-2, therefore, the\nsolution to recurrence (27.7) is M1.n/ D ‚.lg2 n/.\nNow that we know the work and span of P-MATRIX-MULTIPLY-RECURSIVE,\nwe can compute its parallelism as M1.n/=M1.n/ D ‚.n3= lg2 n/, which is very\nhigh.\nMultithreading Strassen’s method\nTo multithread Strassen’s algorithm, we follow the same general outline as on\npage 79, only using nested parallelism:\n1. Divide the input matrices A and B and output matrix C into n=2 \t n=2 sub-\nmatrices, as in equation (27.6). This step takes ‚.1/ work and span by index\ncalculation.\n2. Create 10 matrices S1; S2; : : : ; S10, each of which is n=2 \t n=2 and is the sum\nor difference of two matrices created in step 1. We can create all 10 matrices\nwith ‚.n2/ work and ‚.lg n/ span by using doubly nested parallel for loops.\n796\nChapter 27\nMultithreaded Algorithms",
    "parent_7c12d181-8df2-4691-ae06-9e3fd61674f9": "calculation.\n2. Create 10 matrices S1; S2; : : : ; S10, each of which is n=2 \t n=2 and is the sum\nor difference of two matrices created in step 1. We can create all 10 matrices\nwith ‚.n2/ work and ‚.lg n/ span by using doubly nested parallel for loops.\n796\nChapter 27\nMultithreaded Algorithms\n3. Using the submatrices created in step 1 and the 10 matrices created in\nstep 2, recursively spawn the computation of seven n=2 \t n=2 matrix products\nP1; P2; : : : ; P7.\n4. Compute the desired submatrices C11; C12; C21; C22 of the result matrix C by\nadding and subtracting various combinations of the Pi matrices, once again\nusing doubly nested parallel for loops. We can compute all four submatrices\nwith ‚.n2/ work and ‚.lg n/ span.\nTo analyze this algorithm, we ﬁrst observe that since the serialization is the\nsame as the original serial algorithm, the work is just the running time of the\nserialization, namely, ‚.nlg 7/. As for P-MATRIX-MULTIPLY-RECURSIVE, we\ncan devise a recurrence for the span.\nIn this case, seven recursive calls exe-\ncute in parallel, but since they all operate on matrices of the same size, we ob-\ntain the same recurrence (27.7) as we did for P-MATRIX-MULTIPLY-RECURSIVE,\nwhich has solution ‚.lg2 n/. Thus, the parallelism of multithreaded Strassen’s\nmethod is ‚.nlg 7= lg2 n/, which is high, though slightly less than the parallelism\nof P-MATRIX-MULTIPLY-RECURSIVE.\nExercises\n27.2-1\nDraw the computation dag for computing P-SQUARE-MATRIX-MULTIPLY on 2\t2\nmatrices, labeling how the vertices in your diagram correspond to strands in the\nexecution of the algorithm. Use the convention that spawn and call edges point\ndownward, continuation edges point horizontally to the right, and return edges\npoint upward. Assuming that each strand takes unit time, analyze the work, span,\nand parallelism of this computation.\n27.2-2\nRepeat Exercise 27.2-1 for P-MATRIX-MULTIPLY-RECURSIVE.\n27.2-3\nGive pseudocode for a multithreaded algorithm that multiplies two n \t n matrices",
    "parent_17253ad5-f74e-405f-b21c-1dab48219606": "point upward. Assuming that each strand takes unit time, analyze the work, span,\nand parallelism of this computation.\n27.2-2\nRepeat Exercise 27.2-1 for P-MATRIX-MULTIPLY-RECURSIVE.\n27.2-3\nGive pseudocode for a multithreaded algorithm that multiplies two n \t n matrices\nwith work ‚.n3/ but span only ‚.lg n/. Analyze your algorithm.\n27.2-4\nGive pseudocode for an efﬁcient multithreaded algorithm that multiplies a p \t q\nmatrix by a q \t r matrix. Your algorithm should be highly parallel even if any of\np, q, and r are 1. Analyze your algorithm.\n27.3\nMultithreaded merge sort\n797\n27.2-5\nGive pseudocode for an efﬁcient multithreaded algorithm that transposes an n \t n\nmatrix in place by using divide-and-conquer to divide the matrix recursively into\nfour n=2 \t n=2 submatrices. Analyze your algorithm.\n27.2-6\nGive pseudocode for an efﬁcient multithreaded implementation of the Floyd-\nWarshall algorithm (see Section 25.2), which computes shortest paths between all\npairs of vertices in an edge-weighted graph. Analyze your algorithm.\n27.3\nMultithreaded merge sort\nWe ﬁrst saw serial merge sort in Section 2.3.1, and in Section 2.3.2 we analyzed its\nrunning time and showed it to be ‚.n lg n/. Because merge sort already uses the\ndivide-and-conquer paradigm, it seems like a terriﬁc candidate for multithreading\nusing nested parallelism. We can easily modify the pseudocode so that the ﬁrst\nrecursive call is spawned:\nMERGE-SORT0.A; p; r/\n1\nif p < r\n2\nq D b.p C r/=2c\n3\nspawn MERGE-SORT0.A; p; q/\n4\nMERGE-SORT0.A; q C 1; r/\n5\nsync\n6\nMERGE.A; p; q; r/\nLike its serial counterpart, MERGE-SORT0 sorts the subarray AŒp : : r\u0002. After the\ntwo recursive subroutines in lines 3 and 4 have completed, which is ensured by the\nsync statement in line 5, MERGE-SORT0 calls the same MERGE procedure as on\npage 31.\nLet us analyze MERGE-SORT0. To do so, we ﬁrst need to analyze MERGE. Re-\ncall that its serial running time to merge n elements is ‚.n/. Because MERGE is",
    "parent_973179a0-0b78-4b47-ad08-808af15f4c66": "sync statement in line 5, MERGE-SORT0 calls the same MERGE procedure as on\npage 31.\nLet us analyze MERGE-SORT0. To do so, we ﬁrst need to analyze MERGE. Re-\ncall that its serial running time to merge n elements is ‚.n/. Because MERGE is\nserial, both its work and its span are ‚.n/. Thus, the following recurrence charac-\nterizes the work MS0\n1.n/ of MERGE-SORT0 on n elements:\nMS0\n1.n/\nD\n2 MS0\n1.n=2/ C ‚.n/\nD\n‚.n lg n/ ;\n798\nChapter 27\nMultithreaded Algorithms\n…\n…\n…\n…\n…\nmerge\nmerge\ncopy\np1\nq1\nr1\np2\nq2\nr2\np3\nq3\nr3\nA\nT\nx\nx\n\u0002 x\n\u0002 x\n< x\n\u0006 x\n\u0006 x\n\u0006 x\nFigure 27.6\nThe idea behind the multithreaded merging of two sorted subarrays T Œp1 : : r1\u0002\nand T Œp2 : : r2\u0002 into the subarray AŒp3 : : r3\u0002. Letting x D T Œq1\u0002 be the median of T Œp1 : : r1\u0002 and q2\nbe the place in T Œp2 : : r2\u0002 such that x would fall between T Œq2 \u0005 1\u0002 and T Œq2\u0002, every element in\nsubarrays T Œp1 : : q1 \u0005 1\u0002 and T Œp2 : : q2 \u0005 1\u0002 (lightly shaded) is less than or equal to x, and every\nelement in the subarrays T Œq1 C 1 : : r1\u0002 and T Œq2 C 1 : : r2\u0002 (heavily shaded) is at least x. To merge,\nwe compute the index q3 where x belongs in AŒp3 : : r3\u0002, copy x into AŒq3\u0002, and then recursively\nmerge T Œp1 : : q1 \u0005 1\u0002 with T Œp2 : : q2 \u0005 1\u0002 into AŒp3 : : q3 \u0005 1\u0002 and T Œq1 C 1 : : r1\u0002 with T Œq2 : : r2\u0002\ninto AŒq3 C 1 : : r3\u0002.\nwhich is the same as the serial running time of merge sort. Since the two recursive\ncalls of MERGE-SORT0 can run in parallel, the span MS0\n1 is given by the recurrence\nMS0\n1.n/\nD\nMS0\n1.n=2/ C ‚.n/\nD\n‚.n/ :\nThus, the parallelism of MERGE-SORT0 comes to MS0\n1.n/=MS0\n1.n/ D ‚.lg n/,\nwhich is an unimpressive amount of parallelism. To sort 10 million elements, for\nexample, it might achieve linear speedup on a few processors, but it would not\nscale up effectively to hundreds of processors.\nYou probably have already ﬁgured out where the parallelism bottleneck is in\nthis multithreaded merge sort: the serial MERGE procedure. Although merging",
    "parent_5bf1d0a6-345e-4810-b93b-306a5626c539": "example, it might achieve linear speedup on a few processors, but it would not\nscale up effectively to hundreds of processors.\nYou probably have already ﬁgured out where the parallelism bottleneck is in\nthis multithreaded merge sort: the serial MERGE procedure. Although merging\nmight initially seem to be inherently serial, we can, in fact, fashion a multithreaded\nversion of it by using nested parallelism.\nOur divide-and-conquer strategy for multithreaded merging, which is illus-\ntrated in Figure 27.6, operates on subarrays of an array T .\nSuppose that we\nare merging the two sorted subarrays T Œp1 : : r1\u0002 of length n1 D r1 \u0005 p1 C 1\nand T Œp2 : : r2\u0002 of length n2 D r2 \u0005 p2 C 1 into another subarray AŒp3 : : r3\u0002, of\nlength n3 D r3 \u0005 p3 C 1 D n1 C n2. Without loss of generality, we make the sim-\nplifying assumption that n1 \u0006 n2.\nWe ﬁrst ﬁnd the middle element x\nD T Œq1\u0002 of the subarray T Œp1 : : r1\u0002,\nwhere q1 D b.p1 C r1/=2c.\nBecause the subarray is sorted, x is a median\nof T Œp1 : : r1\u0002: every element in T Œp1 : : q1 \u0005 1\u0002 is no more than x, and every el-\nement in T Œq1 C 1 : : r1\u0002 is no less than x. We then use binary search to ﬁnd the\n27.3\nMultithreaded merge sort\n799\nindex q2 in the subarray T Œp2 : : r2\u0002 so that the subarray would still be sorted if we\ninserted x between T Œq2 \u0005 1\u0002 and T Œq2\u0002.\nWe next merge the original subarrays T Œp1 : : r1\u0002 and T Œp2 : : r2\u0002 into AŒp3 : : r3\u0002\nas follows:\n1. Set q3 D p3 C .q1 \u0005 p1/ C .q2 \u0005 p2/.\n2. Copy x into AŒq3\u0002.\n3. Recursively merge T Œp1 : : q1 \u00051\u0002 with T Œp2 : : q2 \u00051\u0002, and place the result into\nthe subarray AŒp3 : : q3 \u0005 1\u0002.\n4. Recursively merge T Œq1 C 1 : : r1\u0002 with T Œq2 : : r2\u0002, and place the result into the\nsubarray AŒq3 C 1 : : r3\u0002.\nWhen we compute q3, the quantity q1\u0005p1 is the number of elements in the subarray\nT Œp1 : : q1 \u0005 1\u0002, and the quantity q2 \u0005 p2 is the number of elements in the subarray\nT Œp2 : : q2 \u0005 1\u0002. Thus, their sum is the number of elements that end up before x in\nthe subarray AŒp3 : : r3\u0002.",
    "parent_3719248b-639b-41a9-868b-8f7b6554604b": "When we compute q3, the quantity q1\u0005p1 is the number of elements in the subarray\nT Œp1 : : q1 \u0005 1\u0002, and the quantity q2 \u0005 p2 is the number of elements in the subarray\nT Œp2 : : q2 \u0005 1\u0002. Thus, their sum is the number of elements that end up before x in\nthe subarray AŒp3 : : r3\u0002.\nThe base case occurs when n1 D n2 D 0, in which case we have no work\nto do to merge the two empty subarrays. Since we have assumed that the sub-\narray T Œp1 : : r1\u0002 is at least as long as T Œp2 : : r2\u0002, that is, n1 \u0006 n2, we can check\nfor the base case by just checking whether n1 D 0. We must also ensure that the\nrecursion properly handles the case when only one of the two subarrays is empty,\nwhich, by our assumption that n1 \u0006 n2, must be the subarray T Œp2 : : r2\u0002.\nNow, let’s put these ideas into pseudocode. We start with the binary search,\nwhich we express serially. The procedure BINARY-SEARCH.x; T; p; r/ takes a\nkey x and a subarray T Œp : : r\u0002, and it returns one of the following:\n\u0002\nIf T Œp : : r\u0002 is empty (r < p), then it returns the index p.\n\u0002\nIf x \u0002 T Œp\u0002, and hence less than or equal to all the elements of T Œp : : r\u0002, then\nit returns the index p.\n\u0002\nIf x > T Œp\u0002, then it returns the largest index q in the range p < q \u0002 r C1 such\nthat T Œq \u0005 1\u0002 < x.\nHere is the pseudocode:\nBINARY-SEARCH.x; T; p; r/\n1\nlow D p\n2\nhigh D max.p; r C 1/\n3\nwhile low < high\n4\nmid D b.low C high/=2c\n5\nif x \u0002 T Œmid\u0002\n6\nhigh D mid\n7\nelse low D mid C 1\n8\nreturn high\n800\nChapter 27\nMultithreaded Algorithms\nThe call BINARY-SEARCH.x; T; p; r/ takes ‚.lg n/ serial time in the worst case,\nwhere n D r \u0005 p C 1 is the size of the subarray on which it runs. (See Exer-\ncise 2.3-5.) Since BINARY-SEARCH is a serial procedure, its worst-case work and\nspan are both ‚.lg n/.\nWe are now prepared to write pseudocode for the multithreaded merging pro-\ncedure itself. Like the MERGE procedure on page 31, the P-MERGE procedure\nassumes that the two subarrays to be merged lie within the same array.\nUn-",
    "parent_3b540a03-ff74-4d6c-bd29-f10fcb06aa99": "span are both ‚.lg n/.\nWe are now prepared to write pseudocode for the multithreaded merging pro-\ncedure itself. Like the MERGE procedure on page 31, the P-MERGE procedure\nassumes that the two subarrays to be merged lie within the same array.\nUn-\nlike MERGE, however, P-MERGE does not assume that the two subarrays to\nbe merged are adjacent within the array. (That is, P-MERGE does not require\nthat p2 D r1 C 1.) Another difference between MERGE and P-MERGE is that\nP-MERGE takes as an argument an output subarray A into which the merged val-\nues should be stored. The call P-MERGE.T; p1; r1; p2; r2; A; p3/ merges the sorted\nsubarrays T Œp1 : : r1\u0002 and T Œp2 : : r2\u0002 into the subarray AŒp3 : : r3\u0002, where r3 D\np3 C .r1 \u0005 p1 C 1/ C .r2 \u0005 p2 C 1/ \u0005 1 D p3 C .r1 \u0005 p1/ C .r2 \u0005 p2/ C 1 and\nis not provided as an input.\nP-MERGE.T; p1; r1; p2; r2; A; p3/\n1\nn1 D r1 \u0005 p1 C 1\n2\nn2 D r2 \u0005 p2 C 1\n3\nif n1 < n2\n// ensure that n1 \u0006 n2\n4\nexchange p1 with p2\n5\nexchange r1 with r2\n6\nexchange n1 with n2\n7\nif n1 == 0\n// both empty?\n8\nreturn\n9\nelse q1 D b.p1 C r1/=2c\n10\nq2 D BINARY-SEARCH.T Œq1\u0002; T; p2; r2/\n11\nq3 D p3 C .q1 \u0005 p1/ C .q2 \u0005 p2/\n12\nAŒq3\u0002 D T Œq1\u0002\n13\nspawn P-MERGE.T; p1; q1 \u0005 1; p2; q2 \u0005 1; A; p3/\n14\nP-MERGE.T; q1 C 1; r1; q2; r2; A; q3 C 1/\n15\nsync\nThe P-MERGE procedure works as follows. Lines 1–2 compute the lengths n1\nand n2 of the subarrays T Œp1 : : r1\u0002 and T Œp2 : : r2\u0002, respectively. Lines 3–6 en-\nforce the assumption that n1 \u0006 n2. Line 7 tests for the base case, where the\nsubarray T Œp1 : : r1\u0002 is empty (and hence so is T Œp2 : : r2\u0002), in which case we sim-\nply return. Lines 9–15 implement the divide-and-conquer strategy. Line 9 com-\nputes the midpoint of T Œp1 : : r1\u0002, and line 10 ﬁnds the point q2 in T Œp2 : : r2\u0002 such\nthat all elements in T Œp2 : : q2 \u0005 1\u0002 are less than T Œq1\u0002 (which corresponds to x)\nand all the elements in T Œq2 : : p2\u0002 are at least as large as T Œq1\u0002. Line 11 com-\n27.3\nMultithreaded merge sort\n801",
    "parent_164be6a9-b79c-4226-b2a0-ee2bfede9147": "putes the midpoint of T Œp1 : : r1\u0002, and line 10 ﬁnds the point q2 in T Œp2 : : r2\u0002 such\nthat all elements in T Œp2 : : q2 \u0005 1\u0002 are less than T Œq1\u0002 (which corresponds to x)\nand all the elements in T Œq2 : : p2\u0002 are at least as large as T Œq1\u0002. Line 11 com-\n27.3\nMultithreaded merge sort\n801\nputes the index q3 of the element that divides the output subarray AŒp3 : : r3\u0002 into\nAŒp3 : : q3 \u0005 1\u0002 and AŒq3C1 : : r3\u0002, and then line 12 copies T Œq1\u0002 directly into AŒq3\u0002.\nThen, we recurse using nested parallelism. Line 13 spawns the ﬁrst subproblem,\nwhile line 14 calls the second subproblem in parallel. The sync statement in line 15\nensures that the subproblems have completed before the procedure returns. (Since\nevery procedure implicitly executes a sync before returning, we could have omitted\nthe sync statement in line 15, but including it is good coding practice.) There\nis some cleverness in the coding to ensure that when the subarray T Œp2 : : r2\u0002 is\nempty, the code operates correctly. The way it works is that on each recursive call,\na median element of T Œp1 : : r1\u0002 is placed into the output subarray, until T Œp1 : : r1\u0002\nitself ﬁnally becomes empty, triggering the base case.\nAnalysis of multithreaded merging\nWe ﬁrst derive a recurrence for the span PM1.n/ of P-MERGE, where the two\nsubarrays contain a total of n D n1Cn2 elements. Because the spawn in line 13 and\nthe call in line 14 operate logically in parallel, we need examine only the costlier of\nthe two calls. The key is to understand that in the worst case, the maximum number\nof elements in either of the recursive calls can be at most 3n=4, which we see as\nfollows. Because lines 3–6 ensure that n2 \u0002 n1, it follows that n2 D 2n2=2 \u0002\n.n1 C n2/=2 D n=2. In the worst case, one of the two recursive calls merges\nbn1=2c elements of T Œp1 : : r1\u0002 with all n2 elements of T Œp2 : : r2\u0002, and hence the\nnumber of elements involved in the call is\nbn1=2c C n2\n\u0002\nn1=2 C n2=2 C n2=2\nD\n.n1 C n2/=2 C n2=2\n\u0002\nn=2 C n=4\nD\n3n=4 :",
    "parent_85ca6ac1-8805-457f-bd6e-48fb86dbddad": ".n1 C n2/=2 D n=2. In the worst case, one of the two recursive calls merges\nbn1=2c elements of T Œp1 : : r1\u0002 with all n2 elements of T Œp2 : : r2\u0002, and hence the\nnumber of elements involved in the call is\nbn1=2c C n2\n\u0002\nn1=2 C n2=2 C n2=2\nD\n.n1 C n2/=2 C n2=2\n\u0002\nn=2 C n=4\nD\n3n=4 :\nAdding in the ‚.lg n/ cost of the call to BINARY-SEARCH in line 10, we obtain\nthe following recurrence for the worst-case span:\nPM1.n/ D PM1.3n=4/ C ‚.lg n/ :\n(27.8)\n(For the base case, the span is ‚.1/, since lines 1–8 execute in constant time.)\nThis recurrence does not fall under any of the cases of the master theorem, but it\nmeets the condition of Exercise 4.6-2. Therefore, the solution to recurrence (27.8)\nis PM1.n/ D ‚.lg2 n/.\nWe now analyze the work PM1.n/ of P-MERGE on n elements, which turns out\nto be ‚.n/. Since each of the n elements must be copied from array T to array A,\nwe have PM1.n/ D \u0004.n/. Thus, it remains only to show that PM1.n/ D O.n/.\nWe shall ﬁrst derive a recurrence for the worst-case work. The binary search in\nline 10 costs ‚.lg n/ in the worst case, which dominates the other work outside\n802\nChapter 27\nMultithreaded Algorithms\nof the recursive calls. For the recursive calls, observe that although the recursive\ncalls in lines 13 and 14 might merge different numbers of elements, together the\ntwo recursive calls merge at most n elements (actually n \u0005 1 elements, since T Œq1\u0002\ndoes not participate in either recursive call). Moreover, as we saw in analyzing the\nspan, a recursive call operates on at most 3n=4 elements. We therefore obtain the\nrecurrence\nPM1.n/ D PM1.˛n/ C PM1..1 \u0005 ˛/n/ C O.lg n/ ;\n(27.9)\nwhere ˛ lies in the range 1=4 \u0002 ˛ \u0002 3=4, and where we understand that the actual\nvalue of ˛ may vary for each level of recursion.\nWe prove that recurrence (27.9) has solution PM1 D O.n/ via the substitution\nmethod. Assume that PM1.n/ \u0002 c1n\u0005c2 lg n for some positive constants c1 and c2.\nSubstituting gives us\nPM1.n/\n\u0002",
    "parent_9584046d-38c5-407c-a7a8-e63571c497dd": "value of ˛ may vary for each level of recursion.\nWe prove that recurrence (27.9) has solution PM1 D O.n/ via the substitution\nmethod. Assume that PM1.n/ \u0002 c1n\u0005c2 lg n for some positive constants c1 and c2.\nSubstituting gives us\nPM1.n/\n\u0002\n.c1˛n \u0005 c2 lg.˛n// C .c1.1 \u0005 ˛/n \u0005 c2 lg..1 \u0005 ˛/n// C ‚.lg n/\nD\nc1.˛ C .1 \u0005 ˛//n \u0005 c2.lg.˛n/ C lg..1 \u0005 ˛/n// C ‚.lg n/\nD\nc1n \u0005 c2.lg ˛ C lg n C lg.1 \u0005 ˛/ C lg n/ C ‚.lg n/\nD\nc1n \u0005 c2 lg n \u0005 .c2.lg n C lg.˛.1 \u0005 ˛/// \u0005 ‚.lg n//\n\u0002\nc1n \u0005 c2 lg n ;\nsince we can choose c2 large enough that c2.lg n C lg.˛.1 \u0005 ˛/// dominates the\n‚.lg n/ term. Furthermore, we can choose c1 large enough to satisfy the base\nconditions of the recurrence. Since the work PM1.n/ of P-MERGE is both \u0004.n/\nand O.n/, we have PM1.n/ D ‚.n/.\nThe parallelism of P-MERGE is PM1.n/=PM1.n/ D ‚.n= lg2 n/.\nMultithreaded merge sort\nNow that we have a nicely parallelized multithreaded merging procedure, we can\nincorporate it into a multithreaded merge sort. This version of merge sort is similar\nto the MERGE-SORT0 procedure we saw earlier, but unlike MERGE-SORT0, it takes\nas an argument an output subarray B, which will hold the sorted result. In par-\nticular, the call P-MERGE-SORT.A; p; r; B; s/ sorts the elements in AŒp : : r\u0002 and\nstores them in BŒs : : s C r \u0005 p\u0002.\n27.3\nMultithreaded merge sort\n803\nP-MERGE-SORT.A; p; r; B; s/\n1\nn D r \u0005 p C 1\n2\nif n == 1\n3\nBŒs\u0002 D AŒp\u0002\n4\nelse let T Œ1 : : n\u0002 be a new array\n5\nq D b.p C r/=2c\n6\nq0 D q \u0005 p C 1\n7\nspawn P-MERGE-SORT.A; p; q; T; 1/\n8\nP-MERGE-SORT.A; q C 1; r; T; q0 C 1/\n9\nsync\n10\nP-MERGE.T; 1; q0; q0 C 1; n; B; s/\nAfter line 1 computes the number n of elements in the input subarray AŒp : : r\u0002,\nlines 2–3 handle the base case when the array has only 1 element. Lines 4–6 set\nup for the recursive spawn in line 7 and call in line 8, which operate in parallel. In\nparticular, line 4 allocates a temporary array T with n elements to store the results\nof the recursive merge sorting. Line 5 calculates the index q of AŒp : : r\u0002 to divide",
    "parent_cea78eb3-ba53-4f2f-9905-0aca4e0e7e4d": "up for the recursive spawn in line 7 and call in line 8, which operate in parallel. In\nparticular, line 4 allocates a temporary array T with n elements to store the results\nof the recursive merge sorting. Line 5 calculates the index q of AŒp : : r\u0002 to divide\nthe elements into the two subarrays AŒp : : q\u0002 and AŒq C 1 : : r\u0002 that will be sorted\nrecursively, and line 6 goes on to compute the number q0 of elements in the ﬁrst\nsubarray AŒp : : q\u0002, which line 8 uses to determine the starting index in T of where\nto store the sorted result of AŒq C 1 : : r\u0002. At that point, the spawn and recursive\ncall are made, followed by the sync in line 9, which forces the procedure to wait\nuntil the spawned procedure is done. Finally, line 10 calls P-MERGE to merge\nthe sorted subarrays, now in T Œ1 : : q0\u0002 and T Œq0 C 1 : : n\u0002, into the output subarray\nBŒs : : s C r \u0005 p\u0002.\nAnalysis of multithreaded merge sort\nWe start by analyzing the work PMS1.n/ of P-MERGE-SORT, which is consider-\nably easier than analyzing the work of P-MERGE. Indeed, the work is given by the\nrecurrence\nPMS1.n/\nD\n2 PMS1.n=2/ C PM1.n/\nD\n2 PMS1.n=2/ C ‚.n/ :\nThis recurrence is the same as the recurrence (4.4) for ordinary MERGE-SORT\nfrom Section 2.3.1 and has solution PMS1.n/ D ‚.n lg n/ by case 2 of the master\ntheorem.\nWe now derive and analyze a recurrence for the worst-case span PMS1.n/. Be-\ncause the two recursive calls to P-MERGE-SORT on lines 7 and 8 operate logically\nin parallel, we can ignore one of them, obtaining the recurrence\n804\nChapter 27\nMultithreaded Algorithms\nPMS1.n/\nD\nPMS1.n=2/ C PM1.n/\nD\nPMS1.n=2/ C ‚.lg2 n/ :\n(27.10)\nAs for recurrence (27.8), the master theorem does not apply to recurrence (27.10),\nbut Exercise 4.6-2 does. The solution is PMS1.n/ D ‚.lg3 n/, and so the span of\nP-MERGE-SORT is ‚.lg3 n/.\nParallel merging gives P-MERGE-SORT a signiﬁcant parallelism advantage over\nMERGE-SORT0. Recall that the parallelism of MERGE-SORT0, which calls the se-",
    "parent_4816d5fa-904a-4a81-a748-f71e260e0e22": "but Exercise 4.6-2 does. The solution is PMS1.n/ D ‚.lg3 n/, and so the span of\nP-MERGE-SORT is ‚.lg3 n/.\nParallel merging gives P-MERGE-SORT a signiﬁcant parallelism advantage over\nMERGE-SORT0. Recall that the parallelism of MERGE-SORT0, which calls the se-\nrial MERGE procedure, is only ‚.lg n/. For P-MERGE-SORT, the parallelism is\nPMS1.n/=PMS1.n/\nD\n‚.n lg n/=‚.lg3 n/\nD\n‚.n= lg2 n/ ;\nwhich is much better both in theory and in practice. A good implementation in\npractice would sacriﬁce some parallelism by coarsening the base case in order to\nreduce the constants hidden by the asymptotic notation. The straightforward way\nto coarsen the base case is to switch to an ordinary serial sort, perhaps quicksort,\nwhen the size of the array is sufﬁciently small.\nExercises\n27.3-1\nExplain how to coarsen the base case of P-MERGE.\n27.3-2\nInstead of ﬁnding a median element in the larger subarray, as P-MERGE does, con-\nsider a variant that ﬁnds a median element of all the elements in the two sorted\nsubarrays using the result of Exercise 9.3-8. Give pseudocode for an efﬁcient\nmultithreaded merging procedure that uses this median-ﬁnding procedure. Ana-\nlyze your algorithm.\n27.3-3\nGive an efﬁcient multithreaded algorithm for partitioning an array around a pivot,\nas is done by the PARTITION procedure on page 171. You need not partition the ar-\nray in place. Make your algorithm as parallel as possible. Analyze your algorithm.\n(Hint: You may need an auxiliary array and may need to make more than one pass\nover the input elements.)\n27.3-4\nGive a multithreaded version of RECURSIVE-FFT on page 911. Make your imple-\nmentation as parallel as possible. Analyze your algorithm.\nProblems for Chapter 27\n805\n27.3-5\n?\nGive a multithreaded version of RANDOMIZED-SELECT on page 216. Make your\nimplementation as parallel as possible. Analyze your algorithm. (Hint: Use the\npartitioning algorithm from Exercise 27.3-3.)\n27.3-6\n?\nShow how to multithread SELECT from Section 9.3. Make your implementation as",
    "parent_75b19b15-d8f9-4fd2-b87f-722d221e943a": "805\n27.3-5\n?\nGive a multithreaded version of RANDOMIZED-SELECT on page 216. Make your\nimplementation as parallel as possible. Analyze your algorithm. (Hint: Use the\npartitioning algorithm from Exercise 27.3-3.)\n27.3-6\n?\nShow how to multithread SELECT from Section 9.3. Make your implementation as\nparallel as possible. Analyze your algorithm.\nProblems\n27-1\nImplementing parallel loops using nested parallelism\nConsider the following multithreaded algorithm for performing pairwise addition\non n-element arrays AŒ1 : : n\u0002 and BŒ1 : : n\u0002, storing the sums in CŒ1 : : n\u0002:\nSUM-ARRAYS.A; B; C/\n1\nparallel for i D 1 to A:length\n2\nCŒi\u0002 D AŒi\u0002 C BŒi\u0002\na. Rewrite the parallel loop in SUM-ARRAYS using nested parallelism (spawn\nand sync) in the manner of MAT-VEC-MAIN-LOOP. Analyze the parallelism\nof your implementation.\nConsider the following alternative implementation of the parallel loop, which\ncontains a value grain-size to be speciﬁed:\nSUM-ARRAYS0.A; B; C/\n1\nn D A:length\n2\ngrain-size D ‹\n// to be determined\n3\nr D dn=grain-sizee\n4\nfor k D 0 to r \u0005 1\n5\nspawn ADD-SUBARRAY.A; B; C; k \u0003 grain-size C 1;\nmin..k C 1/ \u0003 grain-size; n//\n6\nsync\nADD-SUBARRAY.A; B; C; i; j /\n1\nfor k D i to j\n2\nCŒk\u0002 D AŒk\u0002 C BŒk\u0002\n806\nChapter 27\nMultithreaded Algorithms\nb. Suppose that we set grain-size D 1. What is the parallelism of this implemen-\ntation?\nc. Give a formula for the span of SUM-ARRAYS0 in terms of n and grain-size.\nDerive the best value for grain-size to maximize parallelism.\n27-2\nSaving temporary space in matrix multiplication\nThe P-MATRIX-MULTIPLY-RECURSIVE procedure has the disadvantage that it\nmust allocate a temporary matrix T of size n \t n, which can adversely affect the\nconstants hidden by the ‚-notation. The P-MATRIX-MULTIPLY-RECURSIVE pro-\ncedure does have high parallelism, however. For example, ignoring the constants\nin the ‚-notation, the parallelism for multiplying 1000 \t 1000 matrices comes to\napproximately 10003=102 D 107, since lg 1000 \u0004 10. Most parallel computers",
    "parent_25caaf16-056b-4ff9-bbaf-b81733168ad5": "cedure does have high parallelism, however. For example, ignoring the constants\nin the ‚-notation, the parallelism for multiplying 1000 \t 1000 matrices comes to\napproximately 10003=102 D 107, since lg 1000 \u0004 10. Most parallel computers\nhave far fewer than 10 million processors.\na. Describe a recursive multithreaded algorithm that eliminates the need for the\ntemporary matrix T at the cost of increasing the span to ‚.n/. (Hint: Com-\npute C D C C AB following the general strategy of P-MATRIX-MULTIPLY-\nRECURSIVE, but initialize C in parallel and insert a sync in a judiciously cho-\nsen location.)\nb. Give and solve recurrences for the work and span of your implementation.\nc. Analyze the parallelism of your implementation. Ignoring the constants in the\n‚-notation, estimate the parallelism on 1000 \t 1000 matrices. Compare with\nthe parallelism of P-MATRIX-MULTIPLY-RECURSIVE.\n27-3\nMultithreaded matrix algorithms\na. Parallelize the LU-DECOMPOSITION procedure on page 821 by giving pseu-\ndocode for a multithreaded version of this algorithm. Make your implementa-\ntion as parallel as possible, and analyze its work, span, and parallelism.\nb. Do the same for LUP-DECOMPOSITION on page 824.\nc. Do the same for LUP-SOLVE on page 817.\nd. Do the same for a multithreaded algorithm based on equation (28.13) for in-\nverting a symmetric positive-deﬁnite matrix.\nProblems for Chapter 27\n807\n27-4\nMultithreading reductions and preﬁx computations\nA ˝-reduction of an array xŒ1 : : n\u0002, where ˝ is an associative operator, is the value\ny D xŒ1\u0002 ˝ xŒ2\u0002 ˝ \u0003 \u0003 \u0003 ˝ xŒn\u0002 :\nThe following procedure computes the ˝-reduction of a subarray xŒi : : j \u0002 serially.\nREDUCE.x; i; j /\n1\ny D xŒi\u0002\n2\nfor k D i C 1 to j\n3\ny D y ˝ xŒk\u0002\n4\nreturn y\na. Use nested parallelism to implement a multithreaded algorithm P-REDUCE,\nwhich performs the same function with ‚.n/ work and ‚.lg n/ span. Analyze\nyour algorithm.\nA related problem is that of computing a ˝-preﬁx computation, sometimes",
    "parent_abaa5ada-4c7b-4628-898b-7679123ac9b5": "1\ny D xŒi\u0002\n2\nfor k D i C 1 to j\n3\ny D y ˝ xŒk\u0002\n4\nreturn y\na. Use nested parallelism to implement a multithreaded algorithm P-REDUCE,\nwhich performs the same function with ‚.n/ work and ‚.lg n/ span. Analyze\nyour algorithm.\nA related problem is that of computing a ˝-preﬁx computation, sometimes\ncalled a ˝-scan, on an array xŒ1 : : n\u0002, where ˝ is once again an associative op-\nerator. The ˝-scan produces the array yŒ1 : : n\u0002 given by\nyŒ1\u0002\nD\nxŒ1\u0002 ;\nyŒ2\u0002\nD\nxŒ1\u0002 ˝ xŒ2\u0002 ;\nyŒ3\u0002\nD\nxŒ1\u0002 ˝ xŒ2\u0002 ˝ xŒ3\u0002 ;\n:::\nyŒn\u0002\nD\nxŒ1\u0002 ˝ xŒ2\u0002 ˝ xŒ3\u0002 ˝ \u0003 \u0003 \u0003 ˝ xŒn\u0002 ;\nthat is, all preﬁxes of the array x “summed” using the ˝ operator. The following\nserial procedure SCAN performs a ˝-preﬁx computation:\nSCAN.x/\n1\nn D x:length\n2\nlet yŒ1 : : n\u0002 be a new array\n3\nyŒ1\u0002 D xŒ1\u0002\n4\nfor i D 2 to n\n5\nyŒi\u0002 D yŒi \u0005 1\u0002 ˝ xŒi\u0002\n6\nreturn y\nUnfortunately, multithreading SCAN is not straightforward. For example, changing\nthe for loop to a parallel for loop would create races, since each iteration of the\nloop body depends on the previous iteration. The following procedure P-SCAN-1\nperforms the ˝-preﬁx computation in parallel, albeit inefﬁciently:\n808\nChapter 27\nMultithreaded Algorithms\nP-SCAN-1.x/\n1\nn D x:length\n2\nlet yŒ1 : : n\u0002 be a new array\n3\nP-SCAN-1-AUX.x; y; 1; n/\n4\nreturn y\nP-SCAN-1-AUX.x; y; i; j /\n1\nparallel for l D i to j\n2\nyŒl\u0002 D P-REDUCE.x; 1; l/\nb. Analyze the work, span, and parallelism of P-SCAN-1.\nBy using nested parallelism, we can obtain a more efﬁcient ˝-preﬁx computa-\ntion:\nP-SCAN-2.x/\n1\nn D x:length\n2\nlet yŒ1 : : n\u0002 be a new array\n3\nP-SCAN-2-AUX.x; y; 1; n/\n4\nreturn y\nP-SCAN-2-AUX.x; y; i; j /\n1\nif i == j\n2\nyŒi\u0002 D xŒi\u0002\n3\nelse k D b.i C j /=2c\n4\nspawn P-SCAN-2-AUX.x; y; i; k/\n5\nP-SCAN-2-AUX.x; y; k C 1; j /\n6\nsync\n7\nparallel for l D k C 1 to j\n8\nyŒl\u0002 D yŒk\u0002 ˝ yŒl\u0002\nc. Argue that P-SCAN-2 is correct, and analyze its work, span, and parallelism.\nWe can improve on both P-SCAN-1 and P-SCAN-2 by performing the ˝-preﬁx\ncomputation in two distinct passes over the data. On the ﬁrst pass, we gather the",
    "parent_4e13c795-3f87-4827-b66b-53866d9f791a": "6\nsync\n7\nparallel for l D k C 1 to j\n8\nyŒl\u0002 D yŒk\u0002 ˝ yŒl\u0002\nc. Argue that P-SCAN-2 is correct, and analyze its work, span, and parallelism.\nWe can improve on both P-SCAN-1 and P-SCAN-2 by performing the ˝-preﬁx\ncomputation in two distinct passes over the data. On the ﬁrst pass, we gather the\nterms for various contiguous subarrays of x into a temporary array t, and on the\nsecond pass we use the terms in t to compute the ﬁnal result y. The following\npseudocode implements this strategy, but certain expressions have been omitted:\nProblems for Chapter 27\n809\nP-SCAN-3.x/\n1\nn D x:length\n2\nlet yŒ1 : : n\u0002 and tŒ1 : : n\u0002 be new arrays\n3\nyŒ1\u0002 D xŒ1\u0002\n4\nif n > 1\n5\nP-SCAN-UP.x; t; 2; n/\n6\nP-SCAN-DOWN.xŒ1\u0002; x; t; y; 2; n/\n7\nreturn y\nP-SCAN-UP.x; t; i; j /\n1\nif i == j\n2\nreturn xŒi\u0002\n3\nelse\n4\nk D b.i C j /=2c\n5\ntŒk\u0002 D spawn P-SCAN-UP.x; t; i; k/\n6\nright D P-SCAN-UP.x; t; k C 1; j /\n7\nsync\n8\nreturn\n// ﬁll in the blank\nP-SCAN-DOWN.\u0003; x; t; y; i; j /\n1\nif i == j\n2\nyŒi\u0002 D \u0003 ˝ xŒi\u0002\n3\nelse\n4\nk D b.i C j /=2c\n5\nspawn P-SCAN-DOWN.\n; x; t; y; i; k/\n// ﬁll in the blank\n6\nP-SCAN-DOWN.\n; x; t; y; k C 1; j /\n// ﬁll in the blank\n7\nsync\nd. Fill in the three missing expressions in line 8 of P-SCAN-UP and lines 5 and 6\nof P-SCAN-DOWN. Argue that with expressions you supplied, P-SCAN-3 is\ncorrect. (Hint: Prove that the value \u0003 passed to P-SCAN-DOWN.\u0003; x; t; y; i; j /\nsatisﬁes \u0003 D xŒ1\u0002 ˝ xŒ2\u0002 ˝ \u0003 \u0003 \u0003 ˝ xŒi \u0005 1\u0002.)\ne. Analyze the work, span, and parallelism of P-SCAN-3.\n27-5\nMultithreading a simple stencil calculation\nComputational science is replete with algorithms that require the entries of an array\nto be ﬁlled in with values that depend on the values of certain already computed\nneighboring entries, along with other information that does not change over the\ncourse of the computation. The pattern of neighboring entries does not change\nduring the computation and is called a stencil. For example, Section 15.4 presents\n810\nChapter 27\nMultithreaded Algorithms",
    "parent_851e4402-4c38-4829-a23d-b283ed5bf002": "neighboring entries, along with other information that does not change over the\ncourse of the computation. The pattern of neighboring entries does not change\nduring the computation and is called a stencil. For example, Section 15.4 presents\n810\nChapter 27\nMultithreaded Algorithms\na stencil algorithm to compute a longest common subsequence, where the value in\nentry cŒi; j \u0002 depends only on the values in cŒi \u00051; j \u0002, cŒi; j \u00051\u0002, and cŒi \u00051; j \u00051\u0002,\nas well as the elements xi and yj within the two sequences given as inputs. The\ninput sequences are ﬁxed, but the algorithm ﬁlls in the two-dimensional array c so\nthat it computes entry cŒi; j \u0002 after computing all three entries cŒi \u00051; j \u0002, cŒi; j \u00051\u0002,\nand cŒi \u0005 1; j \u0005 1\u0002.\nIn this problem, we examine how to use nested parallelism to multithread a\nsimple stencil calculation on an n \t n array A in which, of the values in A, the\nvalue placed into entry AŒi; j \u0002 depends only on values in AŒi 0; j 0\u0002, where i 0 \u0002 i\nand j 0 \u0002 j (and of course, i 0 ¤ i or j 0 ¤ j ). In other words, the value in an\nentry depends only on values in entries that are above it and/or to its left, along\nwith static information outside of the array. Furthermore, we assume throughout\nthis problem that once we have ﬁlled in the entries upon which AŒi; j \u0002 depends, we\ncan ﬁll in AŒi; j \u0002 in ‚.1/ time (as in the LCS-LENGTH procedure of Section 15.4).\nWe can partition the n \t n array A into four n=2 \t n=2 subarrays as follows:\nA D\n\u0002 A11\nA12\nA21\nA22\n\u0003\n:\n(27.11)\nObserve now that we can ﬁll in subarray A11 recursively, since it does not depend\non the entries of the other three subarrays. Once A11 is complete, we can continue\nto ﬁll in A12 and A21 recursively in parallel, because although they both depend\non A11, they do not depend on each other. Finally, we can ﬁll in A22 recursively.\na. Give multithreaded pseudocode that performs this simple stencil calculation\nusing a divide-and-conquer algorithm SIMPLE-STENCIL based on the decom-",
    "parent_73286f79-8512-4c0a-88d8-cedab96bcde0": "on A11, they do not depend on each other. Finally, we can ﬁll in A22 recursively.\na. Give multithreaded pseudocode that performs this simple stencil calculation\nusing a divide-and-conquer algorithm SIMPLE-STENCIL based on the decom-\nposition (27.11) and the discussion above. (Don’t worry about the details of the\nbase case, which depends on the speciﬁc stencil.) Give and solve recurrences\nfor the work and span of this algorithm in terms of n. What is the parallelism?\nb. Modify your solution to part (a) to divide an n \t n array into nine n=3 \t n=3\nsubarrays, again recursing with as much parallelism as possible. Analyze this\nalgorithm. How much more or less parallelism does this algorithm have com-\npared with the algorithm from part (a)?\nc. Generalize your solutions to parts (a) and (b) as follows. Choose an integer\nb \u0006 2. Divide an n\tn array into b2 subarrays, each of size n=b\tn=b, recursing\nwith as much parallelism as possible. In terms of n and b, what are the work,\nspan, and parallelism of your algorithm? Argue that, using this approach, the\nparallelism must be o.n/ for any choice of b \u0006 2. (Hint: For this last argument,\nshow that the exponent of n in the parallelism is strictly less than 1 for any\nchoice of b \u0006 2.)\nNotes for Chapter 27\n811\nd. Give pseudocode for a multithreaded algorithm for this simple stencil calcu-\nlation that achieves ‚.n= lg n/ parallelism. Argue using notions of work and\nspan that the problem, in fact, has ‚.n/ inherent parallelism. As it turns out,\nthe divide-and-conquer nature of our multithreaded pseudocode does not let us\nachieve this maximal parallelism.\n27-6\nRandomized multithreaded algorithms\nJust as with ordinary serial algorithms, we sometimes want to implement random-\nized multithreaded algorithms. This problem explores how to adapt the various\nperformance measures in order to handle the expected behavior of such algorithms.\nIt also asks you to design and analyze a multithreaded algorithm for randomized\nquicksort.",
    "parent_eee30efa-2730-4943-b20b-c2f986e13a5f": "ized multithreaded algorithms. This problem explores how to adapt the various\nperformance measures in order to handle the expected behavior of such algorithms.\nIt also asks you to design and analyze a multithreaded algorithm for randomized\nquicksort.\na. Explain how to modify the work law (27.2), span law (27.3), and greedy sched-\nuler bound (27.4) to work with expectations when TP, T1, and T1 are all ran-\ndom variables.\nb. Consider a randomized multithreaded algorithm for which 1% of the time we\nhave T1 D 104 and T10;000 D 1, but for 99% of the time we have T1 D\nT10;000 D 109. Argue that the speedup of a randomized multithreaded algo-\nrithm should be deﬁned as E ŒT1\u0002 =E ŒTP\u0002, rather than E ŒT1=TP \u0002.\nc. Argue that the parallelism of a randomized multithreaded algorithm should be\ndeﬁned as the ratio E ŒT1\u0002 =E ŒT1\u0002.\nd. Multithread the RANDOMIZED-QUICKSORT algorithm on page 179 by using\nnested parallelism. (Do not parallelize RANDOMIZED-PARTITION.) Give the\npseudocode for your P-RANDOMIZED-QUICKSORT algorithm.\ne. Analyze your multithreaded algorithm for randomized quicksort. (Hint: Re-\nview the analysis of RANDOMIZED-SELECT on page 216.)\nChapter notes\nParallel computers, models for parallel computers, and algorithmic models for par-\nallel programming have been around in various forms for years. Prior editions of\nthis book included material on sorting networks and the PRAM (Parallel Random-\nAccess Machine) model. The data-parallel model [48, 168] is another popular al-\ngorithmic programming model, which features operations on vectors and matrices\nas primitives.\n812\nChapter 27\nMultithreaded Algorithms\nGraham [149] and Brent [55] showed that there exist schedulers achieving the\nbound of Theorem 27.1. Eager, Zahorjan, and Lazowska [98] showed that any\ngreedy scheduler achieves this bound and proposed the methodology of using work\nand span (although not by those names) to analyze parallel algorithms. Blelloch",
    "parent_d7244cd6-237e-469d-b053-1cd8dd196c98": "bound of Theorem 27.1. Eager, Zahorjan, and Lazowska [98] showed that any\ngreedy scheduler achieves this bound and proposed the methodology of using work\nand span (although not by those names) to analyze parallel algorithms. Blelloch\n[47] developed an algorithmic programming model based on work and span (which\nhe called the “depth” of the computation) for data-parallel programming. Blumofe\nand Leiserson [52] gave a distributed scheduling algorithm for dynamic multi-\nthreading based on randomized “work-stealing” and showed that it achieves the\nbound E ŒTP \u0002 \u0002 T1=P C O.T1/. Arora, Blumofe, and Plaxton [19] and Blelloch,\nGibbons, and Matias [49] also provided provably good algorithms for scheduling\ndynamic multithreaded computations.\nThe multithreaded pseudocode and programming model were heavily inﬂuenced\nby the Cilk [51, 118] project at MIT and the Cilk++ [71] extensions to C++ dis-\ntributed by Cilk Arts, Inc. Many of the multithreaded algorithms in this chapter\nappeared in unpublished lecture notes by C. E. Leiserson and H. Prokop and have\nbeen implemented in Cilk or Cilk++. The multithreaded merge-sorting algorithm\nwas inspired by an algorithm of Akl [12].\nThe notion of sequential consistency is due to Lamport [223].\n28\nMatrix Operations\nBecause operations on matrices lie at the heart of scientiﬁc computing, efﬁcient al-\ngorithms for working with matrices have many practical applications. This chapter\nfocuses on how to multiply matrices and solve sets of simultaneous linear equa-\ntions. Appendix D reviews the basics of matrices.\nSection 28.1 shows how to solve a set of linear equations using LUP decomposi-\ntions. Then, Section 28.2 explores the close relationship between multiplying and\ninverting matrices. Finally, Section 28.3 discusses the important class of symmetric\npositive-deﬁnite matrices and shows how we can use them to ﬁnd a least-squares\nsolution to an overdetermined set of linear equations.",
    "parent_3a8f4a4d-9aa2-40e8-997d-b498d7ccf48f": "inverting matrices. Finally, Section 28.3 discusses the important class of symmetric\npositive-deﬁnite matrices and shows how we can use them to ﬁnd a least-squares\nsolution to an overdetermined set of linear equations.\nOne important issue that arises in practice is numerical stability. Due to the\nlimited precision of ﬂoating-point representations in actual computers, round-off\nerrors in numerical computations may become ampliﬁed over the course of a com-\nputation, leading to incorrect results; we call such computations numerically un-\nstable. Although we shall brieﬂy consider numerical stability on occasion, we do\nnot focus on it in this chapter. We refer you to the excellent book by Golub and\nVan Loan [144] for a thorough discussion of stability issues.\n28.1\nSolving systems of linear equations\nNumerous applications need to solve sets of simultaneous linear equations. We\ncan formulate a linear system as a matrix equation in which each matrix or vector\nelement belongs to a ﬁeld, typically the real numbers R. This section discusses how\nto solve a system of linear equations using a method called LUP decomposition.\nWe start with a set of linear equations in n unknowns x1; x2; : : : ; xn:\n814\nChapter 28\nMatrix Operations\na11x1 C a12x2 C \u0003 \u0003 \u0003 C a1nxn\nD\nb1 ;\na21x1 C a22x2 C \u0003 \u0003 \u0003 C a2nxn\nD\nb2 ;\n:::\nan1x1 C an2x2 C \u0003 \u0003 \u0003 C annxn\nD\nbn :\n(28.1)\nA solution to the equations (28.1) is a set of values for x1; x2; : : : ; xn that satisfy\nall of the equations simultaneously. In this section, we treat only the case in which\nthere are exactly n equations in n unknowns.\nWe can conveniently rewrite equations (28.1) as the matrix-vector equation\n˙\na11\na12\n\u0003 \u0003 \u0003\na1n\na21\na22\n\u0003 \u0003 \u0003\na2n\n:::\n:::\n:::\n:::\nan1\nan2\n\u0003 \u0003 \u0003\nann\n\u0007˙\nx1\nx2\n:::\nxn\n\u0007\nD\n˙\nb1\nb2\n:::\nbn\n\u0007\nor, equivalently, letting A D .aij/, x D .xi/, and b D .bi/, as\nAx D b :\n(28.2)\nIf A is nonsingular, it possesses an inverse A\u00031, and\nx D A\u00031b\n(28.3)\nis the solution vector. We can prove that x is the unique solution to equation (28.2)",
    "parent_12e70702-ddae-4ff2-a5c2-6017b7a029a3": ":::\n:::\nan1\nan2\n\u0003 \u0003 \u0003\nann\n\u0007˙\nx1\nx2\n:::\nxn\n\u0007\nD\n˙\nb1\nb2\n:::\nbn\n\u0007\nor, equivalently, letting A D .aij/, x D .xi/, and b D .bi/, as\nAx D b :\n(28.2)\nIf A is nonsingular, it possesses an inverse A\u00031, and\nx D A\u00031b\n(28.3)\nis the solution vector. We can prove that x is the unique solution to equation (28.2)\nas follows. If there are two solutions, x and x0, then Ax D Ax0 D b and, letting I\ndenote an identity matrix,\nx\nD\nIx\nD\n.A\u00031A/x\nD\nA\u00031.Ax/\nD\nA\u00031.Ax0/\nD\n.A\u00031A/x0\nD\nx0 :\nIn this section, we shall be concerned predominantly with the case in which A\nis nonsingular or, equivalently (by Theorem D.1), the rank of A is equal to the\nnumber n of unknowns. There are other possibilities, however, which merit a brief\ndiscussion. If the number of equations is less than the number n of unknowns—or,\nmore generally, if the rank of A is less than n—then the system is underdeter-\nmined. An underdetermined system typically has inﬁnitely many solutions, al-\nthough it may have no solutions at all if the equations are inconsistent. If the\nnumber of equations exceeds the number n of unknowns, the system is overdeter-\nmined, and there may not exist any solutions. Section 28.3 addresses the important\n28.1\nSolving systems of linear equations\n815\nproblem of ﬁnding good approximate solutions to overdetermined systems of linear\nequations.\nLet us return to our problem of solving the system Ax D b of n equations in n\nunknowns. We could compute A\u00031 and then, using equation (28.3), multiply b\nby A\u00031, yielding x D A\u00031b. This approach suffers in practice from numerical\ninstability. Fortunately, another approach—LUP decomposition—is numerically\nstable and has the further advantage of being faster in practice.\nOverview of LUP decomposition\nThe idea behind LUP decomposition is to ﬁnd three n \t n matrices L, U , and P\nsuch that\nPA D LU ;\n(28.4)\nwhere\n\u0002\nL is a unit lower-triangular matrix,\n\u0002\nU is an upper-triangular matrix, and\n\u0002\nP is a permutation matrix.",
    "parent_f9a086e2-727d-4b8b-8481-2b9d44ce794e": "Overview of LUP decomposition\nThe idea behind LUP decomposition is to ﬁnd three n \t n matrices L, U , and P\nsuch that\nPA D LU ;\n(28.4)\nwhere\n\u0002\nL is a unit lower-triangular matrix,\n\u0002\nU is an upper-triangular matrix, and\n\u0002\nP is a permutation matrix.\nWe call matrices L, U , and P satisfying equation (28.4) an LUP decomposition\nof the matrix A. We shall show that every nonsingular matrix A possesses such a\ndecomposition.\nComputing an LUP decomposition for the matrix A has the advantage that we\ncan more easily solve linear systems when they are triangular, as is the case for\nboth matrices L and U . Once we have found an LUP decomposition for A, we\ncan solve equation (28.2), Ax D b, by solving only triangular linear systems, as\nfollows. Multiplying both sides of Ax D b by P yields the equivalent equation\nPAx D Pb, which, by Exercise D.1-4, amounts to permuting the equations (28.1).\nUsing our decomposition (28.4), we obtain\nLUx D Pb :\nWe can now solve this equation by solving two triangular linear systems. Let us\ndeﬁne y D Ux, where x is the desired solution vector. First, we solve the lower-\ntriangular system\nLy D Pb\n(28.5)\nfor the unknown vector y by a method called “forward substitution.” Having solved\nfor y, we then solve the upper-triangular system\nUx D y\n(28.6)\n816\nChapter 28\nMatrix Operations\nfor the unknown x by a method called “back substitution.” Because the permu-\ntation matrix P is invertible (Exercise D.2-3), multiplying both sides of equa-\ntion (28.4) by P \u00031 gives P \u00031PA D P \u00031LU , so that\nA D P \u00031LU :\n(28.7)\nHence, the vector x is our solution to Ax D b:\nAx\nD\nP \u00031LUx\n(by equation (28.7))\nD\nP \u00031Ly\n(by equation (28.6))\nD\nP \u00031Pb\n(by equation (28.5))\nD\nb :\nOur next step is to show how forward and back substitution work and then attack\nthe problem of computing the LUP decomposition itself.\nForward and back substitution\nForward substitution can solve the lower-triangular system (28.5) in ‚.n2/ time,",
    "parent_0cf01c0b-5a81-40ae-8d73-fe25744e9b9e": "D\nP \u00031Pb\n(by equation (28.5))\nD\nb :\nOur next step is to show how forward and back substitution work and then attack\nthe problem of computing the LUP decomposition itself.\nForward and back substitution\nForward substitution can solve the lower-triangular system (28.5) in ‚.n2/ time,\ngiven L, P , and b. For convenience, we represent the permutation P compactly\nby an array \u0006Œ1 : : n\u0002. For i D 1; 2; : : : ; n, the entry \u0006Œi\u0002 indicates that Pi;\u0003Œi\u0004 D 1\nand Pij D 0 for j ¤ \u0006Œi\u0002. Thus, PA has a\u0003Œi\u0004;j in row i and column j , and Pb\nhas b\u0003Œi\u0004 as its ith element. Since L is unit lower-triangular, we can rewrite equa-\ntion (28.5) as\ny1\nD\nb\u0003Œ1\u0004 ;\nl21y1 C\ny2\nD\nb\u0003Œ2\u0004 ;\nl31y1 C l32y2 C\ny3\nD\nb\u0003Œ3\u0004 ;\n:::\nln1y1 C ln2y2 C ln3y3 C \u0003 \u0003 \u0003 C yn\nD\nb\u0003Œn\u0004 :\nThe ﬁrst equation tells us that y1 D b\u0003Œ1\u0004. Knowing the value of y1, we can\nsubstitute it into the second equation, yielding\ny2 D b\u0003Œ2\u0004 \u0005 l21y1 :\nNow, we can substitute both y1 and y2 into the third equation, obtaining\ny3 D b\u0003Œ3\u0004 \u0005 .l31y1 C l32y2/ :\nIn general, we substitute y1; y2; : : : ; yi\u00031 “forward” into the ith equation to solve\nfor yi:\n28.1\nSolving systems of linear equations\n817\nyi D b\u0003Œi\u0004 \u0005\ni\u00031\nX\njD1\nlij yj :\nHaving solved for y, we solve for x in equation (28.6) using back substitution,\nwhich is similar to forward substitution. Here, we solve the nth equation ﬁrst and\nwork backward to the ﬁrst equation. Like forward substitution, this process runs\nin ‚.n2/ time. Since U is upper-triangular, we can rewrite the system (28.6) as\nu11x1 C u12x2 C \u0003 \u0003 \u0003 C\nu1;n\u00032xn\u00032 C\nu1;n\u00031xn\u00031 C\nu1nxn D y1 ;\nu22x2 C \u0003 \u0003 \u0003 C\nu2;n\u00032xn\u00032 C\nu2;n\u00031xn\u00031 C\nu2nxn D y2 ;\n:::\nun\u00032;n\u00032xn\u00032 C un\u00032;n\u00031xn\u00031 C un\u00032;nxn D yn\u00032 ;\nun\u00031;n\u00031xn\u00031 C un\u00031;nxn D yn\u00031 ;\nun;nxn D yn :\nThus, we can solve for xn; xn\u00031; : : : ; x1 successively as follows:\nxn\nD\nyn=un;n ;\nxn\u00031\nD\n.yn\u00031 \u0005 un\u00031;nxn/=un\u00031;n\u00031 ;\nxn\u00032\nD\n.yn\u00032 \u0005 .un\u00032;n\u00031xn\u00031 C un\u00032;nxn//=un\u00032;n\u00032 ;\n:::\nor, in general,\nxi D\n \nyi \u0005\nn\nX\njDiC1\nuijxj\n!\n=uii :",
    "parent_9940f735-cfca-410e-833b-b14b3d351c29": "un\u00031;n\u00031xn\u00031 C un\u00031;nxn D yn\u00031 ;\nun;nxn D yn :\nThus, we can solve for xn; xn\u00031; : : : ; x1 successively as follows:\nxn\nD\nyn=un;n ;\nxn\u00031\nD\n.yn\u00031 \u0005 un\u00031;nxn/=un\u00031;n\u00031 ;\nxn\u00032\nD\n.yn\u00032 \u0005 .un\u00032;n\u00031xn\u00031 C un\u00032;nxn//=un\u00032;n\u00032 ;\n:::\nor, in general,\nxi D\n \nyi \u0005\nn\nX\njDiC1\nuijxj\n!\n=uii :\nGiven P , L, U , and b, the procedure LUP-SOLVE solves for x by combining\nforward and back substitution. The pseudocode assumes that the dimension n ap-\npears in the attribute L:rows and that the permutation matrix P is represented by\nthe array \u0006.\nLUP-SOLVE.L; U; \u0006; b/\n1\nn D L:rows\n2\nlet x be a new vector of length n\n3\nfor i D 1 to n\n4\nyi D b\u0003Œi\u0004 \u0005 Pi\u00031\njD1 lijyj\n5\nfor i D n downto 1\n6\nxi D\n\u000b\nyi \u0005 Pn\njDiC1 uij xj\n\f\n=uii\n7\nreturn x\n818\nChapter 28\nMatrix Operations\nProcedure LUP-SOLVE solves for y using forward substitution in lines 3–4, and\nthen it solves for x using backward substitution in lines 5–6. Since the summation\nwithin each of the for loops includes an implicit loop, the running time is ‚.n2/.\nAs an example of these methods, consider the system of linear equations deﬁned\nby\u0005\n1\n2\n0\n3\n4\n4\n5\n6\n3\n\u0006\nx D\n\u0005\n3\n7\n8\n\u0006\n;\nwhere\nA\nD\n\u0005\n1\n2\n0\n3\n4\n4\n5\n6\n3\n\u0006\n;\nb\nD\n\u0005\n3\n7\n8\n\u0006\n;\nand we wish to solve for the unknown x. The LUP decomposition is\nL\nD\n\u0005\n1\n0\n0\n0:2\n1\n0\n0:6\n0:5\n1\n\u0006\n;\nU\nD\n\u0005\n5\n6\n3\n0\n0:8\n\u00050:6\n0\n0\n2:5\n\u0006\n;\nP\nD\n\u0005\n0\n0\n1\n1\n0\n0\n0\n1\n0\n\u0006\n:\n(You might want to verify that PA D LU .) Using forward substitution, we solve\nLy D Pb for y:\n\u0005\n1\n0\n0\n0:2\n1\n0\n0:6\n0:5\n1\n\u0006\u0005\ny1\ny2\ny3\n\u0006\nD\n\u0005\n8\n3\n7\n\u0006\n;\nobtaining\ny D\n\u0005\n8\n1:4\n1:5\n\u0006\nby computing ﬁrst y1, then y2, and ﬁnally y3. Using back substitution, we solve\nUx D y for x:\n28.1\nSolving systems of linear equations\n819\n\u0005\n5\n6\n3\n0\n0:8\n\u00050:6\n0\n0\n2:5\n\u0006\u0005\nx1\nx2\nx3\n\u0006\nD\n\u0005\n8\n1:4\n1:5\n\u0006\n;\nthereby obtaining the desired answer\nx D\n\u0005\n\u00051:4\n2:2\n0:6\n\u0006\nby computing ﬁrst x3, then x2, and ﬁnally x1.\nComputing an LU decomposition\nWe have now shown that if we can create an LUP decomposition for a nonsingular\nmatrix A, then forward and back substitution can solve the system Ax D b of",
    "parent_4b444a09-7e51-4269-a6a5-26cd64609834": "1:5\n\u0006\n;\nthereby obtaining the desired answer\nx D\n\u0005\n\u00051:4\n2:2\n0:6\n\u0006\nby computing ﬁrst x3, then x2, and ﬁnally x1.\nComputing an LU decomposition\nWe have now shown that if we can create an LUP decomposition for a nonsingular\nmatrix A, then forward and back substitution can solve the system Ax D b of\nlinear equations. Now we show how to efﬁciently compute an LUP decomposition\nfor A. We start with the case in which A is an n \t n nonsingular matrix and P is\nabsent (or, equivalently, P D In). In this case, we factor A D LU . We call the\ntwo matrices L and U an LU decomposition of A.\nWe use a process known as Gaussian elimination to create an LU decomposi-\ntion. We start by subtracting multiples of the ﬁrst equation from the other equations\nin order to remove the ﬁrst variable from those equations. Then, we subtract mul-\ntiples of the second equation from the third and subsequent equations so that now\nthe ﬁrst and second variables are removed from them. We continue this process\nuntil the system that remains has an upper-triangular form—in fact, it is the ma-\ntrix U . The matrix L is made up of the row multipliers that cause variables to be\neliminated.\nOur algorithm to implement this strategy is recursive. We wish to construct an\nLU decomposition for an n \t n nonsingular matrix A. If n D 1, then we are done,\nsince we can choose L D I1 and U D A. For n > 1, we break A into four parts:\nA\nD\n˙\na11\na12\n\u0003 \u0003 \u0003\na1n\na21\na22\n\u0003 \u0003 \u0003\na2n\n:::\n:::\n:::\n:::\nan1\nan2\n\u0003 \u0003 \u0003\nann\n\u0007\nD\n\u0002 a11\nwT\n\u0003\nA0\n\u0003\n;\nwhere \u0003 is a column .n \u0005 1/-vector, wT is a row .n \u0005 1/-vector, and A0 is an\n.n \u0005 1/ \t .n \u0005 1/ matrix. Then, using matrix algebra (verify the equations by\n820\nChapter 28\nMatrix Operations\nsimply multiplying through), we can factor A as\nA\nD\n\u0002 a11\nwT\n\u0003\nA0\n\u0003\nD\n\u0002\n1\n0\n\u0003=a11\nIn\u00031\n\u0003\u0002 a11\nwT\n0\nA0 \u0005 \u0003wT=a11\n\u0003\n:\n(28.8)\nThe 0s in the ﬁrst and second matrices of equation (28.8) are row and col-\numn .n \u0005 1/-vectors, respectively.\nThe term \u0003wT=a11, formed by taking the",
    "parent_80ae45ef-3fc1-4834-a334-e79618ee7282": "Matrix Operations\nsimply multiplying through), we can factor A as\nA\nD\n\u0002 a11\nwT\n\u0003\nA0\n\u0003\nD\n\u0002\n1\n0\n\u0003=a11\nIn\u00031\n\u0003\u0002 a11\nwT\n0\nA0 \u0005 \u0003wT=a11\n\u0003\n:\n(28.8)\nThe 0s in the ﬁrst and second matrices of equation (28.8) are row and col-\numn .n \u0005 1/-vectors, respectively.\nThe term \u0003wT=a11, formed by taking the\nouter product of \u0003 and w and dividing each element of the result by a11, is an\n.n \u0005 1/ \t .n \u0005 1/ matrix, which conforms in size to the matrix A0 from which it is\nsubtracted. The resulting .n \u0005 1/ \t .n \u0005 1/ matrix\nA0 \u0005 \u0003wT=a11\n(28.9)\nis called the Schur complement of A with respect to a11.\nWe claim that if A is nonsingular, then the Schur complement is nonsingular,\ntoo. Why? Suppose that the Schur complement, which is .n \u0005 1/ \t .n \u0005 1/, is\nsingular. Then by Theorem D.1, it has row rank strictly less than n \u0005 1. Because\nthe bottom n \u0005 1 entries in the ﬁrst column of the matrix\n\u0002 a11\nwT\n0\nA0 \u0005 \u0003wT=a11\n\u0003\nare all 0, the bottom n \u0005 1 rows of this matrix must have row rank strictly less\nthan n \u0005 1. The row rank of the entire matrix, therefore, is strictly less than n.\nApplying Exercise D.2-8 to equation (28.8), A has rank strictly less than n, and\nfrom Theorem D.1 we derive the contradiction that A is singular.\nBecause the Schur complement is nonsingular, we can now recursively ﬁnd an\nLU decomposition for it. Let us say that\nA0 \u0005 \u0003wT=a11 D L0U 0 ;\nwhere L0 is unit lower-triangular and U 0 is upper-triangular. Then, using matrix\nalgebra, we have\nA\nD\n\u0002\n1\n0\n\u0003=a11\nIn\u00031\n\u0003\u0002 a11\nwT\n0\nA0 \u0005 \u0003wT=a11\n\u0003\nD\n\u0002\n1\n0\n\u0003=a11\nIn\u00031\n\u0003\u0002 a11\nwT\n0\nL0U 0\n\u0003\nD\n\u0002\n1\n0\n\u0003=a11\nL0\n\u0003\u0002 a11\nwT\n0\nU 0\n\u0003\nD\nLU ;\nthereby providing our LU decomposition. (Note that because L0 is unit lower-\ntriangular, so is L, and because U 0 is upper-triangular, so is U .)\n28.1\nSolving systems of linear equations\n821\nOf course, if a11 D 0, this method doesn’t work, because it divides by 0. It also\ndoesn’t work if the upper leftmost entry of the Schur complement A0 \u0005 \u0003wT=a11",
    "parent_a892714b-3d8b-4e1c-ad87-00dafcb624ab": "triangular, so is L, and because U 0 is upper-triangular, so is U .)\n28.1\nSolving systems of linear equations\n821\nOf course, if a11 D 0, this method doesn’t work, because it divides by 0. It also\ndoesn’t work if the upper leftmost entry of the Schur complement A0 \u0005 \u0003wT=a11\nis 0, since we divide by it in the next step of the recursion. The elements by\nwhich we divide during LU decomposition are called pivots, and they occupy the\ndiagonal elements of the matrix U . The reason we include a permutation matrix P\nduring LUP decomposition is that it allows us to avoid dividing by 0. When we use\npermutations to avoid division by 0 (or by small numbers, which would contribute\nto numerical instability), we are pivoting.\nAn important class of matrices for which LU decomposition always works cor-\nrectly is the class of symmetric positive-deﬁnite matrices. Such matrices require\nno pivoting, and thus we can employ the recursive strategy outlined above with-\nout fear of dividing by 0. We shall prove this result, as well as several others, in\nSection 28.3.\nOur code for LU decomposition of a matrix A follows the recursive strategy, ex-\ncept that an iteration loop replaces the recursion. (This transformation is a standard\noptimization for a “tail-recursive” procedure—one whose last operation is a recur-\nsive call to itself. See Problem 7-4.) It assumes that the attribute A:rows gives\nthe dimension of A. We initialize the matrix U with 0s below the diagonal and\nmatrix L with 1s on its diagonal and 0s above the diagonal.\nLU-DECOMPOSITION.A/\n1\nn D A:rows\n2\nlet L and U be new n \t n matrices\n3\ninitialize U with 0s below the diagonal\n4\ninitialize L with 1s on the diagonal and 0s above the diagonal\n5\nfor k D 1 to n\n6\nukk D akk\n7\nfor i D k C 1 to n\n8\nlik D aik=ukk\n// lik holds \u0003i\n9\nuki D aki\n// uki holds wT\ni\n10\nfor i D k C 1 to n\n11\nfor j D k C 1 to n\n12\naij D aij \u0005 likukj\n13\nreturn L and U\nThe outer for loop beginning in line 5 iterates once for each recursive step. Within",
    "parent_95ed845c-60eb-41ea-a9b4-991a06ac678d": "5\nfor k D 1 to n\n6\nukk D akk\n7\nfor i D k C 1 to n\n8\nlik D aik=ukk\n// lik holds \u0003i\n9\nuki D aki\n// uki holds wT\ni\n10\nfor i D k C 1 to n\n11\nfor j D k C 1 to n\n12\naij D aij \u0005 likukj\n13\nreturn L and U\nThe outer for loop beginning in line 5 iterates once for each recursive step. Within\nthis loop, line 6 determines the pivot to be ukk D akk. The for loop in lines 7–9\n(which does not execute when k D n), uses the \u0003 and wT vectors to update L\nand U . Line 8 determines the elements of the \u0003 vector, storing \u0003i in lik, and line 9\ncomputes the elements of the wT vector, storing wT\ni in uki. Finally, lines 10–12\ncompute the elements of the Schur complement and store them back into the ma-\n822\nChapter 28\nMatrix Operations\n2\n3\n1\n5\n6 13 5 19\n2 19 10 23\n4 10 11 31\n(a)\n3\n1\n5\n3\n4\n2\n4\n1 16 9 18\n2\n4\n9 21\n(b)\n2\n3\n1\n5\n3\n2\n4\n1\n4\n1\n2\n2\n1\n7 17\n(c)\n2\n3\n1\n5\n3\n4\n2\n4\n1\n4\n2\n2\n1\n7\n3\n(d)\n(e)\n2\n4\n1\n\u0004\n2\n3\n1\n5\n6\n13\n5\n19\n2\n19\n10\n23\n4\n10\n11\n31\n˘\nD\n\u0004\n1\n0\n0\n0\n3\n1\n0\n0\n1\n4\n1\n0\n2\n1\n7\n1\n˘ \u0004\n2\n3\n1\n5\n0\n4\n2\n4\n0\n0\n1\n2\n0\n0\n0\n3\n˘\nA\nL\nU\nFigure 28.1\nThe operation of LU-DECOMPOSITION. (a) The matrix A. (b) The element a11 D 2\nin the black circle is the pivot, the shaded column is \u0003=a11, and the shaded row is wT. The elements\nof U computed thus far are above the horizontal line, and the elements of L are to the left of the\nvertical line. The Schur complement matrix A0 \u0005 \u0003wT=a11 occupies the lower right. (c) We now\noperate on the Schur complement matrix produced from part (b). The element a22 D 4 in the black\ncircle is the pivot, and the shaded column and row are \u0003=a22 and wT (in the partitioning of the Schur\ncomplement), respectively. Lines divide the matrix into the elements of U computed so far (above),\nthe elements of L computed so far (left), and the new Schur complement (lower right). (d) After the\nnext step, the matrix A is factored. (The element 3 in the new Schur complement becomes part of U\nwhen the recursion terminates.) (e) The factorization A D LU .",
    "parent_5727e81e-f2e2-4f86-8d9d-a6b18942d1ea": "the elements of L computed so far (left), and the new Schur complement (lower right). (d) After the\nnext step, the matrix A is factored. (The element 3 in the new Schur complement becomes part of U\nwhen the recursion terminates.) (e) The factorization A D LU .\ntrix A. (We don’t need to divide by akk in line 12 because we already did so when\nwe computed lik in line 8.) Because line 12 is triply nested, LU-DECOMPOSITION\nruns in time ‚.n3/.\nFigure 28.1 illustrates the operation of LU-DECOMPOSITION. It shows a stan-\ndard optimization of the procedure in which we store the signiﬁcant elements of L\nand U in place in the matrix A. That is, we can set up a correspondence between\neach element aij and either lij (if i > j ) or uij (if i \u0002 j ) and update the ma-\ntrix A so that it holds both L and U when the procedure terminates. To obtain\nthe pseudocode for this optimization from the above pseudocode, just replace each\nreference to l or u by a; you can easily verify that this transformation preserves\ncorrectness.\nComputing an LUP decomposition\nGenerally, in solving a system of linear equations Ax D b, we must pivot on off-\ndiagonal elements of A to avoid dividing by 0. Dividing by 0 would, of course,\nbe disastrous. But we also want to avoid dividing by a small value—even if A is\n28.1\nSolving systems of linear equations\n823\nnonsingular—because numerical instabilities can result. We therefore try to pivot\non a large value.\nThe mathematics behind LUP decomposition is similar to that of LU decom-\nposition. Recall that we are given an n \t n nonsingular matrix A, and we wish\nto ﬁnd a permutation matrix P , a unit lower-triangular matrix L, and an upper-\ntriangular matrix U such that PA D LU . Before we partition the matrix A, as we\ndid for LU decomposition, we move a nonzero element, say ak1, from somewhere\nin the ﬁrst column to the .1; 1/ position of the matrix. For numerical stability, we\nchoose ak1 as the element in the ﬁrst column with the greatest absolute value. (The",
    "parent_8dd37a1a-3bc0-4e12-aa6a-4228731e8a7f": "did for LU decomposition, we move a nonzero element, say ak1, from somewhere\nin the ﬁrst column to the .1; 1/ position of the matrix. For numerical stability, we\nchoose ak1 as the element in the ﬁrst column with the greatest absolute value. (The\nﬁrst column cannot contain only 0s, for then A would be singular, because its de-\nterminant would be 0, by Theorems D.4 and D.5.) In order to preserve the set of\nequations, we exchange row 1 with row k, which is equivalent to multiplying A by\na permutation matrix Q on the left (Exercise D.1-4). Thus, we can write QA as\nQA D\n\u0002 ak1\nwT\n\u0003\nA0\n\u0003\n;\nwhere \u0003 D .a21; a31; : : : ; an1/T, except that a11 replaces ak1; wT D .ak2; ak3;\n: : : ; akn/; and A0 is an .n\u00051/\t.n\u00051/ matrix. Since ak1 ¤ 0, we can now perform\nmuch the same linear algebra as for LU decomposition, but now guaranteeing that\nwe do not divide by 0:\nQA\nD\n\u0002 ak1\nwT\n\u0003\nA0\n\u0003\nD\n\u0002\n1\n0\n\u0003=ak1\nIn\u00031\n\u0003\u0002 ak1\nwT\n0\nA0 \u0005 \u0003wT=ak1\n\u0003\n:\nAs we saw for LU decomposition, if A is nonsingular, then the Schur comple-\nment A0 \u0005 \u0003wT=ak1 is nonsingular, too. Therefore, we can recursively ﬁnd an\nLUP decomposition for it, with unit lower-triangular matrix L0, upper-triangular\nmatrix U 0, and permutation matrix P 0, such that\nP 0.A0 \u0005 \u0003wT=ak1/ D L0U 0 :\nDeﬁne\nP D\n\u0002 1\n0\n0\nP 0\n\u0003\nQ ;\nwhich is a permutation matrix, since it is the product of two permutation matrices\n(Exercise D.1-4). We now have\n824\nChapter 28\nMatrix Operations\nPA\nD\n\u0002 1\n0\n0\nP 0\n\u0003\nQA\nD\n\u0002 1\n0\n0\nP 0\n\u0003\u0002\n1\n0\n\u0003=ak1\nIn\u00031\n\u0003\u0002 ak1\nwT\n0\nA0 \u0005 \u0003wT=ak1\n\u0003\nD\n\u0002\n1\n0\nP 0\u0003=ak1\nP 0\n\u0003\u0002 ak1\nwT\n0\nA0 \u0005 \u0003wT=ak1\n\u0003\nD\n\u0002\n1\n0\nP 0\u0003=ak1\nIn\u00031\n\u0003\u0002 ak1\nwT\n0\nP 0.A0 \u0005 \u0003wT=ak1/\n\u0003\nD\n\u0002\n1\n0\nP 0\u0003=ak1\nIn\u00031\n\u0003\u0002 ak1\nwT\n0\nL0U 0\n\u0003\nD\n\u0002\n1\n0\nP 0\u0003=ak1\nL0\n\u0003\u0002 ak1\nwT\n0\nU 0\n\u0003\nD\nLU ;\nyielding the LUP decomposition. Because L0 is unit lower-triangular, so is L, and\nbecause U 0 is upper-triangular, so is U .\nNotice that in this derivation, unlike the one for LU decomposition, we must\nmultiply both the column vector \u0003=ak1 and the Schur complement A0 \u0005 \u0003wT=ak1",
    "parent_d29b1def-ba5d-43bd-b30a-91db7fdbceec": "wT\n0\nU 0\n\u0003\nD\nLU ;\nyielding the LUP decomposition. Because L0 is unit lower-triangular, so is L, and\nbecause U 0 is upper-triangular, so is U .\nNotice that in this derivation, unlike the one for LU decomposition, we must\nmultiply both the column vector \u0003=ak1 and the Schur complement A0 \u0005 \u0003wT=ak1\nby the permutation matrix P 0. Here is the pseudocode for LUP decomposition:\nLUP-DECOMPOSITION.A/\n1\nn D A:rows\n2\nlet \u0006Œ1 : : n\u0002 be a new array\n3\nfor i D 1 to n\n4\n\u0006Œi\u0002 D i\n5\nfor k D 1 to n\n6\np D 0\n7\nfor i D k to n\n8\nif jaikj > p\n9\np D jaikj\n10\nk0 D i\n11\nif p == 0\n12\nerror “singular matrix”\n13\nexchange \u0006Œk\u0002 with \u0006Œk0\u0002\n14\nfor i D 1 to n\n15\nexchange aki with ak0i\n16\nfor i D k C 1 to n\n17\naik D aik=akk\n18\nfor j D k C 1 to n\n19\naij D aij \u0005 aikakj\n28.1\nSolving systems of linear equations\n825\nLike LU-DECOMPOSITION, our LUP-DECOMPOSITION procedure replaces\nthe recursion with an iteration loop. As an improvement over a direct implemen-\ntation of the recursion, we dynamically maintain the permutation matrix P as an\narray \u0006, where \u0006Œi\u0002 D j means that the ith row of P contains a 1 in column j .\nWe also implement the code to compute L and U “in place” in the matrix A. Thus,\nwhen the procedure terminates,\naij D\n(\nlij\nif i > j ;\nuij\nif i \u0002 j :\nFigure 28.2 illustrates how LUP-DECOMPOSITION factors a matrix. Lines 3–4\ninitialize the array \u0006 to represent the identity permutation. The outer for loop\nbeginning in line 5 implements the recursion. Each time through the outer loop,\nlines 6–10 determine the element ak0k with largest absolute value of those in the\ncurrent ﬁrst column (column k) of the .n \u0005 k C 1/ \t .n \u0005 k C 1/ matrix whose\nLUP decomposition we are ﬁnding. If all elements in the current ﬁrst column are\nzero, lines 11–12 report that the matrix is singular. To pivot, we exchange \u0006Œk0\u0002\nwith \u0006Œk\u0002 in line 13 and exchange the kth and k0th rows of A in lines 14–15,\nthereby making the pivot element akk. (The entire rows are swapped because in",
    "parent_7e7a1c3e-2bcc-4ac4-b844-4d4cb90ec5ad": "zero, lines 11–12 report that the matrix is singular. To pivot, we exchange \u0006Œk0\u0002\nwith \u0006Œk\u0002 in line 13 and exchange the kth and k0th rows of A in lines 14–15,\nthereby making the pivot element akk. (The entire rows are swapped because in\nthe derivation of the method above, not only is A0 \u0005 \u0003wT=ak1 multiplied by P 0, but\nso is \u0003=ak1.) Finally, the Schur complement is computed by lines 16–19 in much\nthe same way as it is computed by lines 7–12 of LU-DECOMPOSITION, except that\nhere the operation is written to work in place.\nBecause of its triply nested loop structure, LUP-DECOMPOSITION has a run-\nning time of ‚.n3/, which is the same as that of LU-DECOMPOSITION. Thus,\npivoting costs us at most a constant factor in time.\nExercises\n28.1-1\nSolve the equation\n\u0005\n1\n0\n0\n4\n1\n0\n\u00056\n5\n1\n\u0006\u0005\nx1\nx2\nx3\n\u0006\nD\n\u0005\n3\n14\n\u00057\n\u0006\nby using forward substitution.\n28.1-2\nFind an LU decomposition of the matrix\n\u0005\n4\n\u00055\n6\n8\n\u00056\n7\n12\n\u00057\n12\n\u0006\n:\n826\nChapter 28\nMatrix Operations\n2\n0\n2\n0.6\n3\n3\n4\n–2\n5\n5\n4\n2\n–1\n–2\n3.4\n–1\n(a)\n1\n2\n3\n4\n2\n0\n2\n0.6\n3\n3\n4\n–2\n5\n5\n4\n2\n–1\n–2\n3.4\n–1\n(b)\n3\n2\n1\n4\n0.4\n–2\n0.4\n–.2\n0.6\n0\n1.6 –3.2\n5\n5\n4\n2\n–0.2\n–1\n4.2 –0.6\n(c)\n3\n2\n1\n4\n0.4\n–2\n0.4 –0.2\n0.6\n0\n1.6 –3.2\n5\n5\n4\n2\n–0.2\n–1\n4.2 –0.6\n(d)\n3\n2\n1\n4\n0.4\n–2\n0.4 –0.2\n0.6\n0\n1.6 –3.2\n5\n5\n4\n2\n–0.2\n–1\n4.2 –0.6\n(e)\n3\n2\n1\n4\n0.4\n–2\n0.4 –0.2\n0.6\n0\n1.6 –3.2\n5\n5\n4\n2\n–0.2 0.5\n4\n–0.5\n(f)\n3\n2\n1\n4\n0.4\n–2\n0.4 –0.2\n0.6\n0\n1.6 –3.2\n5\n5\n4\n2\n–0.2 0.5\n4\n–0.5\n(g)\n3\n2\n1\n4\n0.4\n–2\n0.4 –0.2\n0.6\n0\n1.6 –3.2\n5\n5\n4\n2\n–0.2 0.5\n4\n–0.5\n(h)\n3\n2\n1\n4\n0.4\n–2\n0.4 –0.2\n0.6\n0\n0.4\n–3\n5\n5\n4\n2\n–0.2 0.5\n4\n–0.5\n(i)\n3\n2\n1\n4\n(j)\n\u0004\n0\n0\n1\n0\n1\n0\n0\n0\n0\n0\n0\n1\n0\n1\n0\n0\n˘ \u0004\n2\n0\n2\n0:6\n3\n3\n4\n\u00052\n5\n5\n4\n2\n\u00051\n\u00052\n3:4\n\u00051\n˘\nD\n\u0004\n1\n0\n0\n0\n0:4\n1\n0\n0\n\u00050:2\n0:5\n1\n0\n0:6\n0\n0:4\n1\n˘ \u0004\n5\n5\n4\n2\n0\n\u00052\n0:4\n\u00050:2\n0\n0\n4\n\u00050:5\n0\n0\n0\n\u00053\n˘\nP\nA\nL\nU\nFigure 28.2\nThe operation of LUP-DECOMPOSITION. (a) The input matrix A with the identity\npermutation of the rows on the left. The ﬁrst step of the algorithm determines that the element 5\nin the black circle in the third row is the pivot for the ﬁrst column. (b) Rows 1 and 3 are swapped",
    "parent_092027d0-cd8a-4909-bb6a-6cb19c7847c2": "\u00053\n˘\nP\nA\nL\nU\nFigure 28.2\nThe operation of LUP-DECOMPOSITION. (a) The input matrix A with the identity\npermutation of the rows on the left. The ﬁrst step of the algorithm determines that the element 5\nin the black circle in the third row is the pivot for the ﬁrst column. (b) Rows 1 and 3 are swapped\nand the permutation is updated. The shaded column and row represent \u0003 and wT. (c) The vector \u0003\nis replaced by \u0003=5, and the lower right of the matrix is updated with the Schur complement. Lines\ndivide the matrix into three regions: elements of U (above), elements of L (left), and elements of the\nSchur complement (lower right). (d)–(f) The second step. (g)–(i) The third step. No further changes\noccur on the fourth (ﬁnal) step. (j) The LUP decomposition PA D LU .\n28.2\nInverting matrices\n827\n28.1-3\nSolve the equation\n\u0005\n1\n5\n4\n2\n0\n3\n5\n8\n2\n\u0006\u0005\nx1\nx2\nx3\n\u0006\nD\n\u0005\n12\n9\n5\n\u0006\nby using an LUP decomposition.\n28.1-4\nDescribe the LUP decomposition of a diagonal matrix.\n28.1-5\nDescribe the LUP decomposition of a permutation matrix A, and prove that it is\nunique.\n28.1-6\nShow that for all n \u0006 1, there exists a singular n \t n matrix that has an LU decom-\nposition.\n28.1-7\nIn LU-DECOMPOSITION, is it necessary to perform the outermost for loop itera-\ntion when k D n? How about in LUP-DECOMPOSITION?\n28.2\nInverting matrices\nAlthough in practice we do not generally use matrix inverses to solve systems of\nlinear equations, preferring instead to use more numerically stable techniques such\nas LUP decomposition, sometimes we need to compute a matrix inverse. In this\nsection, we show how to use LUP decomposition to compute a matrix inverse.\nWe also prove that matrix multiplication and computing the inverse of a matrix\nare equivalently hard problems, in that (subject to technical conditions) we can\nuse an algorithm for one to solve the other in the same asymptotic running time.\nThus, we can use Strassen’s algorithm (see Section 4.2) for matrix multiplication",
    "parent_14a705c9-da32-4855-8284-2414c420fc31": "are equivalently hard problems, in that (subject to technical conditions) we can\nuse an algorithm for one to solve the other in the same asymptotic running time.\nThus, we can use Strassen’s algorithm (see Section 4.2) for matrix multiplication\nto invert a matrix. Indeed, Strassen’s original paper was motivated by the problem\nof showing that a set of a linear equations could be solved more quickly than by\nthe usual method.\n828\nChapter 28\nMatrix Operations\nComputing a matrix inverse from an LUP decomposition\nSuppose that we have an LUP decomposition of a matrix A in the form of three\nmatrices L, U , and P such that PA D LU . Using LUP-SOLVE, we can solve\nan equation of the form Ax D b in time ‚.n2/. Since the LUP decomposition\ndepends on A but not b, we can run LUP-SOLVE on a second set of equations of\nthe form Ax D b0 in additional time ‚.n2/. In general, once we have the LUP\ndecomposition of A, we can solve, in time ‚.kn2/, k versions of the equation\nAx D b that differ only in b.\nWe can think of the equation\nAX D In ;\n(28.10)\nwhich deﬁnes the matrix X, the inverse of A, as a set of n distinct equations of the\nform Ax D b. To be precise, let Xi denote the ith column of X, and recall that the\nunit vector ei is the ith column of In. We can then solve equation (28.10) for X by\nusing the LUP decomposition for A to solve each equation\nAXi D ei\nseparately for Xi. Once we have the LUP decomposition, we can compute each of\nthe n columns Xi in time ‚.n2/, and so we can compute X from the LUP decom-\nposition of A in time ‚.n3/. Since we can determine the LUP decomposition of A\nin time ‚.n3/, we can compute the inverse A\u00031 of a matrix A in time ‚.n3/.\nMatrix multiplication and matrix inversion\nWe now show that the theoretical speedups obtained for matrix multiplication\ntranslate to speedups for matrix inversion. In fact, we prove something stronger:\nmatrix inversion is equivalent to matrix multiplication, in the following sense.",
    "parent_92d2cd40-c9e0-4ca5-9027-9711d737dcf3": "Matrix multiplication and matrix inversion\nWe now show that the theoretical speedups obtained for matrix multiplication\ntranslate to speedups for matrix inversion. In fact, we prove something stronger:\nmatrix inversion is equivalent to matrix multiplication, in the following sense.\nIf M.n/ denotes the time to multiply two n \t n matrices, then we can invert a\nnonsingular n \t n matrix in time O.M.n//. Moreover, if I.n/ denotes the time\nto invert a nonsingular n \t n matrix, then we can multiply two n \t n matrices in\ntime O.I.n//. We prove these results as two separate theorems.\nTheorem 28.1 (Multiplication is no harder than inversion)\nIf we can invert an n \t n matrix in time I.n/, where I.n/ D \u0004.n2/ and I.n/\nsatisﬁes the regularity condition I.3n/ D O.I.n//, then we can multiply two n\tn\nmatrices in time O.I.n//.\nProof\nLet A and B be n \t n matrices whose matrix product C we wish to com-\npute. We deﬁne the 3n \t 3n matrix D by\n28.2\nInverting matrices\n829\nD D\n\u0005\nIn\nA\n0\n0\nIn\nB\n0\n0\nIn\n\u0006\n:\nThe inverse of D is\nD\u00031 D\n\u0005\nIn\n\u0005A\nAB\n0\nIn\n\u0005B\n0\n0\nIn\n\u0006\n;\nand thus we can compute the product AB by taking the upper right n\tn submatrix\nof D\u00031.\nWe can construct matrix D in ‚.n2/ time, which is O.I.n// because we assume\nthat I.n/ D \u0004.n2/, and we can invert D in O.I.3n// D O.I.n// time, by the\nregularity condition on I.n/. We thus have M.n/ D O.I.n//.\nNote that I.n/ satisﬁes the regularity condition whenever I.n/ D ‚.nc lgd n/\nfor any constants c > 0 and d \u0006 0.\nThe proof that matrix inversion is no harder than matrix multiplication relies\non some properties of symmetric positive-deﬁnite matrices that we will prove in\nSection 28.3.\nTheorem 28.2 (Inversion is no harder than multiplication)\nSuppose we can multiply two n \t n real matrices in time M.n/, where M.n/ D\n\u0004.n2/ and M.n/ satisﬁes the two regularity conditions M.n C k/ D O.M.n// for\nany k in the range 0 \u0002 k \u0002 n and M.n=2/ \u0002 cM.n/ for some constant c < 1=2.\nThen we can compute the inverse of any real nonsingular n \t n matrix in time",
    "parent_77ada7e5-8e49-4ab3-ae50-648f9605e5db": "\u0004.n2/ and M.n/ satisﬁes the two regularity conditions M.n C k/ D O.M.n// for\nany k in the range 0 \u0002 k \u0002 n and M.n=2/ \u0002 cM.n/ for some constant c < 1=2.\nThen we can compute the inverse of any real nonsingular n \t n matrix in time\nO.M.n//.\nProof\nWe prove the theorem here for real matrices. Exercise 28.2-6 asks you to\ngeneralize the proof for matrices whose entries are complex numbers.\nWe can assume that n is an exact power of 2, since we have\n\u0002 A\n0\n0\nIk\n\u0003\u00031\nD\n\u0002 A\u00031\n0\n0\nIk\n\u0003\nfor any k > 0. Thus, by choosing k such that n C k is a power of 2, we enlarge\nthe matrix to a size that is the next power of 2 and obtain the desired answer A\u00031\nfrom the answer to the enlarged problem. The ﬁrst regularity condition on M.n/\nensures that this enlargement does not cause the running time to increase by more\nthan a constant factor.\nFor the moment, let us assume that the n\tn matrix A is symmetric and positive-\ndeﬁnite. We partition each of A and its inverse A\u00031 into four n=2 \t n=2 submatri-\nces:\n830\nChapter 28\nMatrix Operations\nA D\n\u0002 B\nC T\nC\nD\n\u0003\nand A\u00031 D\n\u0002 R\nT\nU\nV\n\u0003\n:\n(28.11)\nThen, if we let\nS D D \u0005 CB\u00031C T\n(28.12)\nbe the Schur complement of A with respect to B (we shall see more about this form\nof Schur complement in Section 28.3), we have\nA\u00031 D\n\u0002 R\nT\nU\nV\n\u0003\nD\n\u0002 B\u00031 C B\u00031C TS \u00031CB\u00031\n\u0005B\u00031C TS \u00031\n\u0005S \u00031CB\u00031\nS \u00031\n\u0003\n;\n(28.13)\nsince AA\u00031 D In, as you can verify by performing the matrix multiplication. Be-\ncause A is symmetric and positive-deﬁnite, Lemmas 28.4 and 28.5 in Section 28.3\nimply that B and S are both symmetric and positive-deﬁnite. By Lemma 28.3 in\nSection 28.3, therefore, the inverses B\u00031 and S \u00031 exist, and by Exercise D.2-6,\nB\u00031 and S \u00031 are symmetric, so that .B\u00031/T D B\u00031 and .S \u00031/T D S \u00031. There-\nfore, we can compute the submatrices R, T , U , and V of A\u00031 as follows, where\nall matrices mentioned are n=2 \t n=2:\n1. Form the submatrices B, C, C T, and D of A.\n2. Recursively compute the inverse B\u00031 of B.",
    "parent_a9270ea5-b033-41a3-afb5-42173f0dcc04": "B\u00031 and S \u00031 are symmetric, so that .B\u00031/T D B\u00031 and .S \u00031/T D S \u00031. There-\nfore, we can compute the submatrices R, T , U , and V of A\u00031 as follows, where\nall matrices mentioned are n=2 \t n=2:\n1. Form the submatrices B, C, C T, and D of A.\n2. Recursively compute the inverse B\u00031 of B.\n3. Compute the matrix product W D CB\u00031, and then compute its transpose W T,\nwhich equals B\u00031C T (by Exercise D.1-2 and .B\u00031/T D B\u00031).\n4. Compute the matrix product X D W C T, which equals CB\u00031C T, and then\ncompute the matrix S D D \u0005 X D D \u0005 CB\u00031C T.\n5. Recursively compute the inverse S \u00031 of S, and set V to S \u00031.\n6. Compute the matrix product Y\nD S \u00031W , which equals S \u00031CB\u00031, and\nthen compute its transpose Y T, which equals B\u00031C TS \u00031 (by Exercise D.1-2,\n.B\u00031/T D B\u00031, and .S \u00031/T D S \u00031). Set T to \u0005Y T and U to \u0005Y .\n7. Compute the matrix product Z D W TY , which equals B\u00031C TS \u00031CB\u00031, and\nset R to B\u00031 C Z.\nThus, we can invert an n\tn symmetric positive-deﬁnite matrix by inverting two\nn=2 \t n=2 matrices in steps 2 and 5; performing four multiplications of n=2 \t n=2\nmatrices in steps 3, 4, 6, and 7; plus an additional cost of O.n2/ for extracting\nsubmatrices from A, inserting submatrices into A\u00031, and performing a constant\nnumber of additions, subtractions, and transposes on n=2 \t n=2 matrices. We get\nthe recurrence\nI.n/\n\u0002\n2I.n=2/ C 4M.n=2/ C O.n2/\nD\n2I.n=2/ C ‚.M.n//\nD\nO.M.n// :\n28.2\nInverting matrices\n831\nThe second line holds because the second regularity condition in the statement\nof the theorem implies that 4M.n=2/ < 2M.n/ and because we assume that\nM.n/ D \u0004.n2/. The third line follows because the second regularity condition\nallows us to apply case 3 of the master theorem (Theorem 4.1).\nIt remains to prove that we can obtain the same asymptotic running time for ma-\ntrix multiplication as for matrix inversion when A is invertible but not symmetric\nand positive-deﬁnite. The basic idea is that for any nonsingular matrix A, the ma-",
    "parent_f7e00ac7-1463-46f3-a934-d4a764aa09b1": "It remains to prove that we can obtain the same asymptotic running time for ma-\ntrix multiplication as for matrix inversion when A is invertible but not symmetric\nand positive-deﬁnite. The basic idea is that for any nonsingular matrix A, the ma-\ntrix ATA is symmetric (by Exercise D.1-2) and positive-deﬁnite (by Theorem D.6).\nThe trick, then, is to reduce the problem of inverting A to the problem of invert-\ning ATA.\nThe reduction is based on the observation that when A is an n \t n nonsingular\nmatrix, we have\nA\u00031 D .ATA/\u00031AT ;\nsince ..ATA/\u00031AT/A D .ATA/\u00031.ATA/ D In and a matrix inverse is unique.\nTherefore, we can compute A\u00031 by ﬁrst multiplying AT by A to obtain ATA, then\ninverting the symmetric positive-deﬁnite matrix ATA using the above divide-and-\nconquer algorithm, and ﬁnally multiplying the result by AT. Each of these three\nsteps takes O.M.n// time, and thus we can invert any nonsingular matrix with real\nentries in O.M.n// time.\nThe proof of Theorem 28.2 suggests a means of solving the equation Ax D b\nby using LU decomposition without pivoting, so long as A is nonsingular. We\nmultiply both sides of the equation by AT, yielding .ATA/x D ATb. This trans-\nformation doesn’t affect the solution x, since AT is invertible, and so we can fac-\ntor the symmetric positive-deﬁnite matrix ATA by computing an LU decomposi-\ntion. We then use forward and back substitution to solve for x with the right-hand\nside ATb. Although this method is theoretically correct, in practice the procedure\nLUP-DECOMPOSITION works much better. LUP decomposition requires fewer\narithmetic operations by a constant factor, and it has somewhat better numerical\nproperties.\nExercises\n28.2-1\nLet M.n/ be the time to multiply two n \t n matrices, and let S.n/ denote the time\nrequired to square an n \t n matrix. Show that multiplying and squaring matri-\nces have essentially the same difﬁculty: an M.n/-time matrix-multiplication al-\ngorithm implies an O.M.n//-time squaring algorithm, and an S.n/-time squaring",
    "parent_4c72faf0-c447-49a4-8e60-f72b52713035": "required to square an n \t n matrix. Show that multiplying and squaring matri-\nces have essentially the same difﬁculty: an M.n/-time matrix-multiplication al-\ngorithm implies an O.M.n//-time squaring algorithm, and an S.n/-time squaring\nalgorithm implies an O.S.n//-time matrix-multiplication algorithm.\n832\nChapter 28\nMatrix Operations\n28.2-2\nLet M.n/ be the time to multiply two n \t n matrices, and let L.n/ be the time to\ncompute the LUP decomposition of an n \t n matrix. Show that multiplying matri-\nces and computing LUP decompositions of matrices have essentially the same dif-\nﬁculty: an M.n/-time matrix-multiplication algorithm implies an O.M.n//-time\nLUP-decomposition algorithm, and an L.n/-time LUP-decomposition algorithm\nimplies an O.L.n//-time matrix-multiplication algorithm.\n28.2-3\nLet M.n/ be the time to multiply two n \t n matrices, and let D.n/ denote the\ntime required to ﬁnd the determinant of an n \t n matrix. Show that multiply-\ning matrices and computing the determinant have essentially the same difﬁculty:\nan M.n/-time matrix-multiplication algorithm implies an O.M.n//-time determi-\nnant algorithm, and a D.n/-time determinant algorithm implies an O.D.n//-time\nmatrix-multiplication algorithm.\n28.2-4\nLet M.n/ be the time to multiply two n \t n boolean matrices, and let T .n/ be the\ntime to ﬁnd the transitive closure of an n \t n boolean matrix. (See Section 25.2.)\nShow that an M.n/-time boolean matrix-multiplication algorithm implies an\nO.M.n/ lg n/-time transitive-closure algorithm, and a T .n/-time transitive-closure\nalgorithm implies an O.T .n//-time boolean matrix-multiplication algorithm.\n28.2-5\nDoes the matrix-inversion algorithm based on Theorem 28.2 work when matrix\nelements are drawn from the ﬁeld of integers modulo 2? Explain.\n28.2-6\n?\nGeneralize the matrix-inversion algorithm of Theorem 28.2 to handle matrices of\ncomplex numbers, and prove that your generalization works correctly. (Hint: In-",
    "parent_d7f7a3a9-ce8a-4626-adb9-6bd4cb369da6": "elements are drawn from the ﬁeld of integers modulo 2? Explain.\n28.2-6\n?\nGeneralize the matrix-inversion algorithm of Theorem 28.2 to handle matrices of\ncomplex numbers, and prove that your generalization works correctly. (Hint: In-\nstead of the transpose of A, use the conjugate transpose A\u0004, which you obtain from\nthe transpose of A by replacing every entry with its complex conjugate. Instead of\nsymmetric matrices, consider Hermitian matrices, which are matrices A such that\nA D A\u0004.)\n28.3\nSymmetric positive-deﬁnite matrices and least-squares approximation\nSymmetric positive-deﬁnite matrices have many interesting and desirable proper-\nties. For example, they are nonsingular, and we can perform LU decomposition\non them without having to worry about dividing by 0. In this section, we shall\n28.3\nSymmetric positive-deﬁnite matrices and least-squares approximation\n833\nprove several other important properties of symmetric positive-deﬁnite matrices\nand show an interesting application to curve ﬁtting by a least-squares approxima-\ntion.\nThe ﬁrst property we prove is perhaps the most basic.\nLemma 28.3\nAny positive-deﬁnite matrix is nonsingular.\nProof\nSuppose that a matrix A is singular. Then by Corollary D.3, there exists a\nnonzero vector x such that Ax D 0. Hence, xTAx D 0, and A cannot be positive-\ndeﬁnite.\nThe proof that we can perform LU decomposition on a symmetric positive-\ndeﬁnite matrix A without dividing by 0 is more involved. We begin by proving\nproperties about certain submatrices of A. Deﬁne the kth leading submatrix of A\nto be the matrix Ak consisting of the intersection of the ﬁrst k rows and ﬁrst k\ncolumns of A.\nLemma 28.4\nIf A is a symmetric positive-deﬁnite matrix, then every leading submatrix of A is\nsymmetric and positive-deﬁnite.\nProof\nThat each leading submatrix Ak is symmetric is obvious. To prove that Ak\nis positive-deﬁnite, we assume that it is not and derive a contradiction. If Ak is not",
    "parent_df9cd5a7-ee8f-4cff-b05e-3ab85a8b7132": "Lemma 28.4\nIf A is a symmetric positive-deﬁnite matrix, then every leading submatrix of A is\nsymmetric and positive-deﬁnite.\nProof\nThat each leading submatrix Ak is symmetric is obvious. To prove that Ak\nis positive-deﬁnite, we assume that it is not and derive a contradiction. If Ak is not\npositive-deﬁnite, then there exists a k-vector xk ¤ 0 such that xT\nkAkxk \u0002 0. Let A\nbe n \t n, and\nA D\n\u0002 Ak\nBT\nB\nC\n\u0003\n(28.14)\nfor submatrices B (which is .n\u0005k/\tk) and C (which is .n\u0005k/\t.n\u0005k/). Deﬁne\nthe n-vector x D . xT\nk\n0 /T, where n \u0005 k 0s follow xk. Then we have\nxTAx\nD\n. xT\nk\n0 /\n\u0002 Ak\nBT\nB\nC\n\u0003\u0002 xk\n0\n\u0003\nD\n. xT\nk\n0 /\n\u0002 Akxk\nBxk\n\u0003\nD\nxT\nkAkxk\n\u0002\n0 ;\nwhich contradicts A being positive-deﬁnite.\n834\nChapter 28\nMatrix Operations\nWe now turn to some essential properties of the Schur complement. Let A be\na symmetric positive-deﬁnite matrix, and let Ak be a leading k \t k submatrix\nof A. Partition A once again according to equation (28.14). We generalize equa-\ntion (28.9) to deﬁne the Schur complement S of A with respect to Ak as\nS D C \u0005 BA\u00031\nk BT :\n(28.15)\n(By Lemma 28.4, Ak is symmetric and positive-deﬁnite; therefore, A\u00031\nk\nexists by\nLemma 28.3, and S is well deﬁned.) Note that our earlier deﬁnition (28.9) of the\nSchur complement is consistent with equation (28.15), by letting k D 1.\nThe next lemma shows that the Schur-complement matrices of symmetric posi-\ntive-deﬁnite matrices are themselves symmetric and positive-deﬁnite. We used this\nresult in Theorem 28.2, and we need its corollary to prove the correctness of LU\ndecomposition for symmetric positive-deﬁnite matrices.\nLemma 28.5 (Schur complement lemma)\nIf A is a symmetric positive-deﬁnite matrix and Ak is a leading k \t k submatrix\nof A, then the Schur complement S of A with respect to Ak is symmetric and\npositive-deﬁnite.\nProof\nBecause A is symmetric, so is the submatrix C. By Exercise D.2-6, the\nproduct BA\u00031\nk BT is symmetric, and by Exercise D.1-1, S is symmetric.",
    "parent_872dea48-8b02-44f4-8cf7-d1946eba6a84": "of A, then the Schur complement S of A with respect to Ak is symmetric and\npositive-deﬁnite.\nProof\nBecause A is symmetric, so is the submatrix C. By Exercise D.2-6, the\nproduct BA\u00031\nk BT is symmetric, and by Exercise D.1-1, S is symmetric.\nIt remains to show that S is positive-deﬁnite. Consider the partition of A given in\nequation (28.14). For any nonzero vector x, we have xTAx > 0 by the assumption\nthat A is positive-deﬁnite. Let us break x into two subvectors y and ´ compatible\nwith Ak and C, respectively. Because A\u00031\nk exists, we have\nxTAx\nD\n. yT\n´T /\n\u0002 Ak\nBT\nB\nC\n\u0003\u0002 y\n´\n\u0003\nD\n. yT\n´T /\n\u0002 Aky C BT´\nBy C C´\n\u0003\nD\nyTAky C yTBT´ C ´TBy C ´TC´\nD\n.y C A\u00031\nk BT´/TAk.y C A\u00031\nk BT´/ C ´T.C \u0005 BA\u00031\nk BT/´ ;\n(28.16)\nby matrix magic. (Verify by multiplying through.) This last equation amounts to\n“completing the square” of the quadratic form. (See Exercise 28.3-2.)\nSince xTAx > 0 holds for any nonzero x, let us pick any nonzero ´ and then\nchoose y D \u0005A\u00031\nk BT´, which causes the ﬁrst term in equation (28.16) to vanish,\nleaving\n´T.C \u0005 BA\u00031\nk BT/´ D ´TS´\nas the value of the expression.\nFor any ´ ¤ 0, we therefore have ´TS´ D\nxTAx > 0, and thus S is positive-deﬁnite.\n28.3\nSymmetric positive-deﬁnite matrices and least-squares approximation\n835\nCorollary 28.6\nLU decomposition of a symmetric positive-deﬁnite matrix never causes a division\nby 0.\nProof\nLet A be a symmetric positive-deﬁnite matrix. We shall prove something\nstronger than the statement of the corollary: every pivot is strictly positive. The ﬁrst\npivot is a11. Let e1 be the ﬁrst unit vector, from which we obtain a11 D eT\n1Ae1 > 0.\nSince the ﬁrst step of LU decomposition produces the Schur complement of A\nwith respect to A1 D .a11/, Lemma 28.5 implies by induction that all pivots are\npositive.\nLeast-squares approximation\nOne important application of symmetric positive-deﬁnite matrices arises in ﬁtting\ncurves to given sets of data points. Suppose that we are given a set of m data points\n.x1; y1/; .x2; y2/; : : : ; .xm; ym/ ;",
    "parent_019bf72c-d2f8-403e-ba6b-b76028e9c702": "positive.\nLeast-squares approximation\nOne important application of symmetric positive-deﬁnite matrices arises in ﬁtting\ncurves to given sets of data points. Suppose that we are given a set of m data points\n.x1; y1/; .x2; y2/; : : : ; .xm; ym/ ;\nwhere we know that the yi are subject to measurement errors. We would like to\ndetermine a function F.x/ such that the approximation errors\n\u000ei D F.xi/ \u0005 yi\n(28.17)\nare small for i D 1; 2; : : : ; m. The form of the function F depends on the problem\nat hand. Here, we assume that it has the form of a linearly weighted sum,\nF.x/ D\nn\nX\njD1\ncjfj.x/ ;\nwhere the number of summands n and the speciﬁc basis functions fj are chosen\nbased on knowledge of the problem at hand. A common choice is fj.x/ D xj\u00031,\nwhich means that\nF.x/ D c1 C c2x C c3x2 C \u0003 \u0003 \u0003 C cnxn\u00031\nis a polynomial of degree n \u0005 1 in x. Thus, given m data points .x1; y1/; .x2; y2/;\n: : : ; .xm; ym/, we wish to calculate n coefﬁcients c1; c2; : : : ; cn that minimize the\napproximation errors \u000e1; \u000e2; : : : ; \u000em.\nBy choosing n D m, we can calculate each yi exactly in equation (28.17). Such\na high-degree F “ﬁts the noise” as well as the data, however, and generally gives\npoor results when used to predict y for previously unseen values of x. It is usu-\nally better to choose n signiﬁcantly smaller than m and hope that by choosing the\ncoefﬁcients cj well, we can obtain a function F that ﬁnds the signiﬁcant patterns\nin the data points without paying undue attention to the noise. Some theoretical\n836\nChapter 28\nMatrix Operations\nprinciples exist for choosing n, but they are beyond the scope of this text. In any\ncase, once we choose a value of n that is less than m, we end up with an overde-\ntermined set of equations whose solution we wish to approximate. We now show\nhow to do so.\nLet\nA D\n˙\nf1.x1/\nf2.x1/\n: : :\nfn.x1/\nf1.x2/\nf2.x2/\n: : :\nfn.x2/\n:::\n:::\n:::\n:::\nf1.xm/\nf2.xm/\n: : :\nfn.xm/\n\u0007\ndenote the matrix of values of the basis functions at the given points; that is,",
    "parent_f16e36f1-ad4c-4e5b-9f55-f1f2d43b18d0": "termined set of equations whose solution we wish to approximate. We now show\nhow to do so.\nLet\nA D\n˙\nf1.x1/\nf2.x1/\n: : :\nfn.x1/\nf1.x2/\nf2.x2/\n: : :\nfn.x2/\n:::\n:::\n:::\n:::\nf1.xm/\nf2.xm/\n: : :\nfn.xm/\n\u0007\ndenote the matrix of values of the basis functions at the given points; that is,\naij D fj.xi/. Let c D .ck/ denote the desired n-vector of coefﬁcients. Then,\nAc\nD\n˙\nf1.x1/\nf2.x1/\n: : :\nfn.x1/\nf1.x2/\nf2.x2/\n: : :\nfn.x2/\n:::\n:::\n:::\n:::\nf1.xm/\nf2.xm/\n: : :\nfn.xm/\n\u0007˙\nc1\nc2\n:::\ncn\n\u0007\nD\n˙\nF.x1/\nF.x2/\n:::\nF.xm/\n\u0007\nis the m-vector of “predicted values” for y. Thus,\n\u000e D Ac \u0005 y\nis the m-vector of approximation errors.\nTo minimize approximation errors, we choose to minimize the norm of the error\nvector \u000e, which gives us a least-squares solution, since\nk\u000ek D\n m\nX\niD1\n\u000e2\ni\n!1=2\n:\nBecause\nk\u000ek2 D kAc \u0005 yk2 D\nm\nX\niD1\n n\nX\njD1\naijcj \u0005 yi\n!2\n;\nwe can minimize k\u000ek by differentiating k\u000ek2 with respect to each ck and then\nsetting the result to 0:\n28.3\nSymmetric positive-deﬁnite matrices and least-squares approximation\n837\nd k\u000ek2\ndck\nD\nm\nX\niD1\n2\n \nn\nX\njD1\naijcj \u0005 yi\n!\naik D 0 :\n(28.18)\nThe n equations (28.18) for k D 1; 2; : : : ; n are equivalent to the single matrix\nequation\n.Ac \u0005 y/TA D 0\nor, equivalently (using Exercise D.1-2), to\nAT.Ac \u0005 y/ D 0 ;\nwhich implies\nATAc D ATy :\n(28.19)\nIn statistics, this is called the normal equation. The matrix ATA is symmetric\nby Exercise D.1-2, and if A has full column rank, then by Theorem D.6, ATA\nis positive-deﬁnite as well.\nHence, .ATA/\u00031 exists, and the solution to equa-\ntion (28.19) is\nc\nD\n\u000b\n.ATA/\u00031AT\f\ny\nD\nACy ;\n(28.20)\nwhere the matrix AC D ..ATA/\u00031AT/ is the pseudoinverse of the matrix A. The\npseudoinverse naturally generalizes the notion of a matrix inverse to the case in\nwhich A is not square. (Compare equation (28.20) as the approximate solution to\nAc D y with the solution A\u00031b as the exact solution to Ax D b.)\nAs an example of producing a least-squares ﬁt, suppose that we have ﬁve data\npoints\n.x1; y1/\nD\n.\u00051; 2/ ;\n.x2; y2/\nD\n.1; 1/ ;\n.x3; y3/",
    "parent_9eee97e9-efeb-49c7-8aeb-eddb186ea3cb": "which A is not square. (Compare equation (28.20) as the approximate solution to\nAc D y with the solution A\u00031b as the exact solution to Ax D b.)\nAs an example of producing a least-squares ﬁt, suppose that we have ﬁve data\npoints\n.x1; y1/\nD\n.\u00051; 2/ ;\n.x2; y2/\nD\n.1; 1/ ;\n.x3; y3/\nD\n.2; 1/ ;\n.x4; y4/\nD\n.3; 0/ ;\n.x5; y5/\nD\n.5; 3/ ;\nshown as black dots in Figure 28.3. We wish to ﬁt these points with a quadratic\npolynomial\nF.x/ D c1 C c2x C c3x2 :\nWe start with the matrix of basis-function values\n838\nChapter 28\nMatrix Operations\n0.5\n1.0\n1.5\n2.0\n2.5\n3.0\n0.0\n1\n2\n3\n4\n5\n0\n–1\n–2\nx\ny\nF(x) = 1.2 – 0.757x + 0.214x2\nFigure 28.3\nThe least-squares ﬁt of a quadratic polynomial to the set of ﬁve data points\nf.\u00051; 2/; .1; 1/; .2; 1/; .3; 0/; .5; 3/g. The black dots are the data points, and the white dots are their\nestimated values predicted by the polynomial F.x/ D 1:2 \u0005 0:757x C 0:214x2, the quadratic poly-\nnomial that minimizes the sum of the squared errors. Each shaded line shows the error for one data\npoint.\nA D\n\u0003\n1\nx1\nx2\n1\n1\nx2\nx2\n2\n1\nx3\nx2\n3\n1\nx4\nx2\n4\n1\nx5\nx2\n5\n\u0004\nD\n\u0003\n1\n\u00051\n1\n1\n1\n1\n1\n2\n4\n1\n3\n9\n1\n5\n25\n\u0004\n;\nwhose pseudoinverse is\nAC D\n\u0005\n0:500\n0:300\n0:200\n0:100\n\u00050:100\n\u00050:388\n0:093\n0:190\n0:193\n\u00050:088\n0:060\n\u00050:036\n\u00050:048\n\u00050:036\n0:060\n\u0006\n:\nMultiplying y by AC, we obtain the coefﬁcient vector\nc D\n\u0005\n1:200\n\u00050:757\n0:214\n\u0006\n;\nwhich corresponds to the quadratic polynomial\n28.3\nSymmetric positive-deﬁnite matrices and least-squares approximation\n839\nF.x/ D 1:200 \u0005 0:757x C 0:214x2\nas the closest-ﬁtting quadratic to the given data, in a least-squares sense.\nAs a practical matter, we solve the normal equation (28.19) by multiplying y\nby AT and then ﬁnding an LU decomposition of ATA. If A has full rank, the\nmatrix ATA is guaranteed to be nonsingular, because it is symmetric and positive-\ndeﬁnite. (See Exercise D.1-2 and Theorem D.6.)\nExercises\n28.3-1\nProve that every diagonal element of a symmetric positive-deﬁnite matrix is posi-\ntive.\n28.3-2\nLet A D\n\u0002 a\nb\nb\nc\n\u0003",
    "parent_a9a97718-ea5b-4cbe-b69f-300be1171a3e": "matrix ATA is guaranteed to be nonsingular, because it is symmetric and positive-\ndeﬁnite. (See Exercise D.1-2 and Theorem D.6.)\nExercises\n28.3-1\nProve that every diagonal element of a symmetric positive-deﬁnite matrix is posi-\ntive.\n28.3-2\nLet A D\n\u0002 a\nb\nb\nc\n\u0003\nbe a 2 \t 2 symmetric positive-deﬁnite matrix. Prove that its\ndeterminant ac \u0005 b2 is positive by “completing the square” in a manner similar to\nthat used in the proof of Lemma 28.5.\n28.3-3\nProve that the maximum element in a symmetric positive-deﬁnite matrix lies on\nthe diagonal.\n28.3-4\nProve that the determinant of each leading submatrix of a symmetric positive-\ndeﬁnite matrix is positive.\n28.3-5\nLet Ak denote the kth leading submatrix of a symmetric positive-deﬁnite matrix A.\nProve that det.Ak/= det.Ak\u00031/ is the kth pivot during LU decomposition, where,\nby convention, det.A0/ D 1.\n28.3-6\nFind the function of the form\nF.x/ D c1 C c2x lg x C c3ex\nthat is the best least-squares ﬁt to the data points\n.1; 1/; .2; 1/; .3; 3/; .4; 8/ :\n840\nChapter 28\nMatrix Operations\n28.3-7\nShow that the pseudoinverse AC satisﬁes the following four equations:\nAACA\nD\nA ;\nACAAC\nD\nAC ;\n.AAC/T\nD\nAAC ;\n.ACA/T\nD\nACA :\nProblems\n28-1\nTridiagonal systems of linear equations\nConsider the tridiagonal matrix\nA D\nˇ\n1\n\u00051\n0\n0\n0\n\u00051\n2\n\u00051\n0\n0\n0\n\u00051\n2\n\u00051\n0\n0\n0\n\u00051\n2\n\u00051\n0\n0\n0\n\u00051\n2\n\u0003\n:\na. Find an LU decomposition of A.\nb. Solve the equation Ax D\n\u000b 1\n1\n1\n1\n1 \fT by using forward and back sub-\nstitution.\nc. Find the inverse of A.\nd. Show how, for any n \t n symmetric positive-deﬁnite, tridiagonal matrix A and\nany n-vector b, to solve the equation Ax D b in O.n/ time by performing an\nLU decomposition. Argue that any method based on forming A\u00031 is asymptot-\nically more expensive in the worst case.\ne. Show how, for any n\tn nonsingular, tridiagonal matrix A and any n-vector b, to\nsolve the equation Ax D b in O.n/ time by performing an LUP decomposition.\n28-2\nSplines\nA practical method for interpolating a set of points with a curve is to use cu-",
    "parent_c0cc9fa2-f494-4321-99d4-a3de7f07834d": "ically more expensive in the worst case.\ne. Show how, for any n\tn nonsingular, tridiagonal matrix A and any n-vector b, to\nsolve the equation Ax D b in O.n/ time by performing an LUP decomposition.\n28-2\nSplines\nA practical method for interpolating a set of points with a curve is to use cu-\nbic splines. We are given a set f.xi; yi/ W i D 0; 1; : : : ; ng of n C 1 point-value\npairs, where x0 < x1 < \u0003 \u0003 \u0003 < xn.\nWe wish to ﬁt a piecewise-cubic curve\n(spline) f .x/ to the points. That is, the curve f .x/ is made up of n cubic polyno-\nmials fi.x/ D ai C bix C cix2 C dix3 for i D 0; 1; : : : ; n \u0005 1, where if x falls in\nProblems for Chapter 28\n841\nthe range xi \u0002 x \u0002 xiC1, then the value of the curve is given by f .x/ D fi.x\u0005xi/.\nThe points xi at which the cubic polynomials are “pasted” together are called knots.\nFor simplicity, we shall assume that xi D i for i D 0; 1; : : : ; n.\nTo ensure continuity of f .x/, we require that\nf .xi/\nD\nfi.0/\nD\nyi ;\nf .xiC1/\nD\nfi.1/\nD\nyiC1\nfor i D 0; 1; : : : ; n \u0005 1. To ensure that f .x/ is sufﬁciently smooth, we also insist\nthat the ﬁrst derivative be continuous at each knot:\nf 0.xiC1/ D f 0\ni .1/ D f 0\niC1.0/\nfor i D 0; 1; : : : ; n \u0005 2.\na. Suppose that for i D 0; 1; : : : ; n, we are given not only the point-value pairs\nf.xi; yi/g but also the ﬁrst derivatives Di D f 0.xi/ at each knot. Express each\ncoefﬁcient ai, bi, ci, and di in terms of the values yi, yiC1, Di, and DiC1.\n(Remember that xi D i.) How quickly can we compute the 4n coefﬁcients\nfrom the point-value pairs and ﬁrst derivatives?\nThe question remains of how to choose the ﬁrst derivatives of f .x/ at the knots.\nOne method is to require the second derivatives to be continuous at the knots:\nf 00.xiC1/ D f 00\ni .1/ D f 00\niC1.0/\nfor i D 0; 1; : : : ; n \u0005 2. At the ﬁrst and last knots, we assume that f 00.x0/ D\nf 00\n0 .0/ D 0 and f 00.xn/ D f 00\nn\u00031.1/ D 0; these assumptions make f .x/ a natural\ncubic spline.",
    "parent_f2534393-18ff-4d8d-b6f0-70e5bb872e72": "One method is to require the second derivatives to be continuous at the knots:\nf 00.xiC1/ D f 00\ni .1/ D f 00\niC1.0/\nfor i D 0; 1; : : : ; n \u0005 2. At the ﬁrst and last knots, we assume that f 00.x0/ D\nf 00\n0 .0/ D 0 and f 00.xn/ D f 00\nn\u00031.1/ D 0; these assumptions make f .x/ a natural\ncubic spline.\nb. Use the continuity constraints on the second derivative to show that for i D\n1; 2; : : : ; n \u0005 1,\nDi\u00031 C 4Di C DiC1 D 3.yiC1 \u0005 yi\u00031/ :\n(28.21)\nc. Show that\n2D0 C D1\nD\n3.y1 \u0005 y0/ ;\n(28.22)\nDn\u00031 C 2Dn\nD\n3.yn \u0005 yn\u00031/ :\n(28.23)\nd. Rewrite equations (28.21)–(28.23) as a matrix equation involving the vector\nD D hD0; D1; : : : ; Dni of unknowns. What attributes does the matrix in your\nequation have?\ne. Argue that a natural cubic spline can interpolate a set of n C 1 point-value pairs\nin O.n/ time (see Problem 28-1).\n842\nChapter 28\nMatrix Operations\nf.\nShow how to determine a natural cubic spline that interpolates a set of n C 1\npoints .xi; yi/ satisfying x0 < x1 < \u0003 \u0003 \u0003 < xn, even when xi is not necessarily\nequal to i. What matrix equation must your method solve, and how quickly\ndoes your algorithm run?\nChapter notes\nMany excellent texts describe numerical and scientiﬁc computation in much greater\ndetail than we have room for here. The following are especially readable: George\nand Liu [132], Golub and Van Loan [144], Press, Teukolsky, Vetterling, and Flan-\nnery [283, 284], and Strang [323, 324].\nGolub and Van Loan [144] discuss numerical stability. They show why det.A/\nis not necessarily a good indicator of the stability of a matrix A, proposing instead\nto use kAk1 kA\u00031k1, where kAk1 D max1\u0005i\u0005n\nPn\njD1 jaijj. They also address\nthe question of how to compute this value without actually computing A\u00031.\nGaussian elimination, upon which the LU and LUP decompositions are based,\nwas the ﬁrst systematic method for solving linear systems of equations. It was also\none of the earliest numerical algorithms. Although it was known earlier, its dis-",
    "parent_9edfe133-7f59-4fe4-a52d-578c4ccca6f3": "Gaussian elimination, upon which the LU and LUP decompositions are based,\nwas the ﬁrst systematic method for solving linear systems of equations. It was also\none of the earliest numerical algorithms. Although it was known earlier, its dis-\ncovery is commonly attributed to C. F. Gauss (1777–1855). In his famous paper\n[325], Strassen showed that an n\tn matrix can be inverted in O.nlg 7/ time. Wino-\ngrad [358] originally proved that matrix multiplication is no harder than matrix\ninversion, and the converse is due to Aho, Hopcroft, and Ullman [5].\nAnother important matrix decomposition is the singular value decomposition,\nor SVD. The SVD factors an m \t n matrix A into A D Q1†QT\n2, where † is an\nm\tn matrix with nonzero values only on the diagonal, Q1 is m\tm with mutually\northonormal columns, and Q2 is n \t n, also with mutually orthonormal columns.\nTwo vectors are orthonormal if their inner product is 0 and each vector has a norm\nof 1. The books by Strang [323, 324] and Golub and Van Loan [144] contain good\ntreatments of the SVD.\nStrang [324] has an excellent presentation of symmetric positive-deﬁnite matri-\nces and of linear algebra in general.\n29\nLinear Programming\nMany problems take the form of maximizing or minimizing an objective, given\nlimited resources and competing constraints. If we can specify the objective as\na linear function of certain variables, and if we can specify the constraints on\nresources as equalities or inequalities on those variables, then we have a linear-\nprogramming problem. Linear programs arise in a variety of practical applica-\ntions. We begin by studying an application in electoral politics.\nA political problem\nSuppose that you are a politician trying to win an election. Your district has three\ndifferent types of areas—urban, suburban, and rural. These areas have, respec-\ntively, 100,000, 200,000, and 50,000 registered voters. Although not all the reg-\nistered voters actually go to the polls, you decide that to govern effectively, you",
    "parent_74ead4e5-bc3b-4cfb-8533-3119a6961076": "different types of areas—urban, suburban, and rural. These areas have, respec-\ntively, 100,000, 200,000, and 50,000 registered voters. Although not all the reg-\nistered voters actually go to the polls, you decide that to govern effectively, you\nwould like at least half the registered voters in each of the three regions to vote for\nyou. You are honorable and would never consider supporting policies in which you\ndo not believe. You realize, however, that certain issues may be more effective in\nwinning votes in certain places. Your primary issues are building more roads, gun\ncontrol, farm subsidies, and a gasoline tax dedicated to improved public transit.\nAccording to your campaign staff’s research, you can estimate how many votes\nyou win or lose from each population segment by spending $1,000 on advertising\non each issue. This information appears in the table of Figure 29.1. In this table,\neach entry indicates the number of thousands of either urban, suburban, or rural\nvoters who would be won over by spending $1,000 on advertising in support of a\nparticular issue. Negative entries denote votes that would be lost. Your task is to\nﬁgure out the minimum amount of money that you need to spend in order to win\n50,000 urban votes, 100,000 suburban votes, and 25,000 rural votes.\nYou could, by trial and error, devise a strategy that wins the required number\nof votes, but the strategy you come up with might not be the least expensive one.\nFor example, you could devote $20,000 of advertising to building roads, $0 to gun\ncontrol, $4,000 to farm subsidies, and $9,000 to a gasoline tax. In this case, you\n844\nChapter 29\nLinear Programming\npolicy\nurban\nsuburban\nrural\nbuild roads\n\u00052\n5\n3\ngun control\n8\n2\n\u00055\nfarm subsidies\n0\n0\n10\ngasoline tax\n10\n0\n\u00052\nFigure 29.1\nThe effects of policies on voters. Each entry describes the number of thousands of\nurban, suburban, or rural voters who could be won over by spending $1,000 on advertising support",
    "parent_a527bd0a-93ed-4bb9-96d1-7da829b3fd46": "urban\nsuburban\nrural\nbuild roads\n\u00052\n5\n3\ngun control\n8\n2\n\u00055\nfarm subsidies\n0\n0\n10\ngasoline tax\n10\n0\n\u00052\nFigure 29.1\nThe effects of policies on voters. Each entry describes the number of thousands of\nurban, suburban, or rural voters who could be won over by spending $1,000 on advertising support\nof a policy on a particular issue. Negative entries denote votes that would be lost.\nwould win 20.\u00052/C0.8/C4.0/C9.10/ D 50 thousand urban votes, 20.5/C0.2/C\n4.0/C9.0/ D 100 thousand suburban votes, and 20.3/C0.\u00055/C4.10/C9.\u00052/ D\n82 thousand rural votes. You would win the exact number of votes desired in the\nurban and suburban areas and more than enough votes in the rural area. (In fact,\nin the rural area, you would receive more votes than there are voters.) In order to\ngarner these votes, you would have paid for 20 C 0 C 4 C 9 D 33 thousand dollars\nof advertising.\nNaturally, you may wonder whether this strategy is the best possible. That is,\ncould you achieve your goals while spending less on advertising? Additional trial\nand error might help you to answer this question, but wouldn’t you rather have a\nsystematic method for answering such questions? In order to develop one, we shall\nformulate this question mathematically. We introduce 4 variables:\n\u0002\nx1 is the number of thousands of dollars spent on advertising on building roads,\n\u0002\nx2 is the number of thousands of dollars spent on advertising on gun control,\n\u0002\nx3 is the number of thousands of dollars spent on advertising on farm subsidies,\nand\n\u0002\nx4 is the number of thousands of dollars spent on advertising on a gasoline tax.\nWe can write the requirement that we win at least 50,000 urban votes as\n\u00052x1 C 8x2 C 0x3 C 10x4 \u0006 50 :\n(29.1)\nSimilarly, we can write the requirements that we win at least 100,000 suburban\nvotes and 25,000 rural votes as\n5x1 C 2x2 C 0x3 C 0x4 \u0006 100\n(29.2)\nand\n3x1 \u0005 5x2 C 10x3 \u0005 2x4 \u0006 25 :\n(29.3)\nAny setting of the variables x1; x2; x3; x4 that satisﬁes inequalities (29.1)–(29.3)",
    "parent_1dfcfd48-79af-4bb5-ba9e-3d989f9ae779": "(29.1)\nSimilarly, we can write the requirements that we win at least 100,000 suburban\nvotes and 25,000 rural votes as\n5x1 C 2x2 C 0x3 C 0x4 \u0006 100\n(29.2)\nand\n3x1 \u0005 5x2 C 10x3 \u0005 2x4 \u0006 25 :\n(29.3)\nAny setting of the variables x1; x2; x3; x4 that satisﬁes inequalities (29.1)–(29.3)\nyields a strategy that wins a sufﬁcient number of each type of vote. In order to\nChapter 29\nLinear Programming\n845\nkeep costs as small as possible, you would like to minimize the amount spent on\nadvertising. That is, you want to minimize the expression\nx1 C x2 C x3 C x4 :\n(29.4)\nAlthough negative advertising often occurs in political campaigns, there is no such\nthing as negative-cost advertising. Consequently, we require that\nx1 \u0006 0; x2 \u0006 0; x3 \u0006 0; and x4 \u0006 0 :\n(29.5)\nCombining inequalities (29.1)–(29.3) and (29.5) with the objective of minimiz-\ning (29.4), we obtain what is known as a “linear program.” We format this problem\nas\nminimize\nx1\nC\nx2\nC\nx3\nC\nx4\n(29.6)\nsubject to\n\u00052x1\nC\n8x2\nC\n0x3\nC\n10x4\n\u0006\n50\n(29.7)\n5x1\nC\n2x2\nC\n0x3\nC\n0x4\n\u0006\n100\n(29.8)\n3x1\n\u0005\n5x2\nC\n10x3\n\u0005\n2x4\n\u0006\n25\n(29.9)\nx1; x2; x3; x4\n\u0006\n0 :\n(29.10)\nThe solution of this linear program yields your optimal strategy.\nGeneral linear programs\nIn the general linear-programming problem, we wish to optimize a linear function\nsubject to a set of linear inequalities. Given a set of real numbers a1; a2; : : : ; an and\na set of variables x1; x2; : : : ; xn, we deﬁne a linear function f on those variables\nby\nf .x1; x2; : : : ; xn/ D a1x1 C a2x2 C \u0003 \u0003 \u0003 C anxn D\nn\nX\njD1\najxj :\nIf b is a real number and f is a linear function, then the equation\nf .x1; x2; : : : ; xn/ D b\nis a linear equality and the inequalities\nf .x1; x2; : : : ; xn/ \u0002 b\nand\nf .x1; x2; : : : ; xn/ \u0006 b\n846\nChapter 29\nLinear Programming\nare linear inequalities. We use the general term linear constraints to denote either\nlinear equalities or linear inequalities. In linear programming, we do not allow\nstrict inequalities. Formally, a linear-programming problem is the problem of",
    "parent_e0dff083-9719-4c50-b4fb-427927844f08": "846\nChapter 29\nLinear Programming\nare linear inequalities. We use the general term linear constraints to denote either\nlinear equalities or linear inequalities. In linear programming, we do not allow\nstrict inequalities. Formally, a linear-programming problem is the problem of\neither minimizing or maximizing a linear function subject to a ﬁnite set of linear\nconstraints. If we are to minimize, then we call the linear program a minimization\nlinear program, and if we are to maximize, then we call the linear program a\nmaximization linear program.\nThe remainder of this chapter covers how to formulate and solve linear pro-\ngrams. Although several polynomial-time algorithms for linear programming have\nbeen developed, we will not study them in this chapter. Instead, we shall study the\nsimplex algorithm, which is the oldest linear-programming algorithm. The simplex\nalgorithm does not run in polynomial time in the worst case, but it is fairly efﬁcient\nand widely used in practice.\nAn overview of linear programming\nIn order to describe properties of and algorithms for linear programs, we ﬁnd it\nconvenient to express them in canonical forms. We shall use two forms, standard\nand slack, in this chapter. We will deﬁne them precisely in Section 29.1. Infor-\nmally, a linear program in standard form is the maximization of a linear function\nsubject to linear inequalities, whereas a linear program in slack form is the max-\nimization of a linear function subject to linear equalities. We shall typically use\nstandard form for expressing linear programs, but we ﬁnd it more convenient to\nuse slack form when we describe the details of the simplex algorithm. For now, we\nrestrict our attention to maximizing a linear function on n variables subject to a set\nof m linear inequalities.\nLet us ﬁrst consider the following linear program with two variables:\nmaximize\nx1\nC\nx2\n(29.11)\nsubject to\n4x1\n\u0005\nx2\n\u0002\n8\n(29.12)\n2x1\nC\nx2\n\u0002\n10\n(29.13)\n5x1\n\u0005\n2x2\n\u0006\n\u00052\n(29.14)\nx1; x2\n\u0006\n0 :\n(29.15)",
    "parent_a3e098d0-cbca-4b2c-a77a-4ec5c834e4a6": "of m linear inequalities.\nLet us ﬁrst consider the following linear program with two variables:\nmaximize\nx1\nC\nx2\n(29.11)\nsubject to\n4x1\n\u0005\nx2\n\u0002\n8\n(29.12)\n2x1\nC\nx2\n\u0002\n10\n(29.13)\n5x1\n\u0005\n2x2\n\u0006\n\u00052\n(29.14)\nx1; x2\n\u0006\n0 :\n(29.15)\nWe call any setting of the variables x1 and x2 that satisﬁes all the constraints\n(29.12)–(29.15) a feasible solution to the linear program. If we graph the con-\nstraints in the .x1; x2/-Cartesian coordinate system, as in Figure 29.2(a), we see\nChapter 29\nLinear Programming\n847\n4x1 – x2 ≤ 8\n2x1 + x2 ≤ 10\nx2\nx1\nx2 ≥ 0\nx1 ≥ 0\n5x1 – 2x2 ≥ –2\n(a)\nx2\nx1\n(b)\nx1 + x2 = 0\nx1 + x2 = 4\nx1 + x2 = 8\nFigure 29.2\n(a) The linear program given in (29.12)–(29.15). Each constraint is represented by\na line and a direction. The intersection of the constraints, which is the feasible region, is shaded.\n(b) The dotted lines show, respectively, the points for which the objective value is 0, 4, and 8. The\noptimal solution to the linear program is x1 D 2 and x2 D 6 with objective value 8.\nthat the set of feasible solutions (shaded in the ﬁgure) forms a convex region1 in\nthe two-dimensional space. We call this convex region the feasible region and the\nfunction we wish to maximize the objective function. Conceptually, we could eval-\nuate the objective function x1 C x2 at each point in the feasible region; we call the\nvalue of the objective function at a particular point the objective value. We could\nthen identify a point that has the maximum objective value as an optimal solution.\nFor this example (and for most linear programs), the feasible region contains an\ninﬁnite number of points, and so we need to determine an efﬁcient way to ﬁnd a\npoint that achieves the maximum objective value without explicitly evaluating the\nobjective function at every point in the feasible region.\nIn two dimensions, we can optimize via a graphical procedure. The set of points\nfor which x1Cx2 D ´, for any ´, is a line with a slope of \u00051. If we plot x1Cx2 D 0,",
    "parent_871976ff-f519-4f8f-b36e-95bf9de2523a": "objective function at every point in the feasible region.\nIn two dimensions, we can optimize via a graphical procedure. The set of points\nfor which x1Cx2 D ´, for any ´, is a line with a slope of \u00051. If we plot x1Cx2 D 0,\nwe obtain the line with slope \u00051 through the origin, as in Figure 29.2(b). The\nintersection of this line and the feasible region is the set of feasible solutions that\nhave an objective value of 0. In this case, that intersection of the line with the\nfeasible region is the single point .0; 0/. More generally, for any ´, the intersection\n1An intuitive deﬁnition of a convex region is that it fulﬁlls the requirement that for any two points in\nthe region, all points on a line segment between them are also in the region.\n848\nChapter 29\nLinear Programming\nof the line x1 C x2 D ´ and the feasible region is the set of feasible solutions that\nhave objective value ´. Figure 29.2(b) shows the lines x1 C x2 D 0, x1 C x2 D 4,\nand x1 C x2 D 8. Because the feasible region in Figure 29.2 is bounded, there\nmust be some maximum value ´ for which the intersection of the line x1 C x2 D ´\nand the feasible region is nonempty. Any point at which this occurs is an optimal\nsolution to the linear program, which in this case is the point x1 D 2 and x2 D 6\nwith objective value 8.\nIt is no accident that an optimal solution to the linear program occurs at a vertex\nof the feasible region. The maximum value of ´ for which the line x1 C x2 D ´\nintersects the feasible region must be on the boundary of the feasible region, and\nthus the intersection of this line with the boundary of the feasible region is either a\nsingle vertex or a line segment. If the intersection is a single vertex, then there is\njust one optimal solution, and it is that vertex. If the intersection is a line segment,\nevery point on that line segment must have the same objective value; in particular,\nboth endpoints of the line segment are optimal solutions. Since each endpoint of a",
    "parent_8819e570-6472-49fd-be0f-98e280bfe641": "just one optimal solution, and it is that vertex. If the intersection is a line segment,\nevery point on that line segment must have the same objective value; in particular,\nboth endpoints of the line segment are optimal solutions. Since each endpoint of a\nline segment is a vertex, there is an optimal solution at a vertex in this case as well.\nAlthough we cannot easily graph linear programs with more than two variables,\nthe same intuition holds. If we have three variables, then each constraint corre-\nsponds to a half-space in three-dimensional space. The intersection of these half-\nspaces forms the feasible region. The set of points for which the objective function\nobtains a given value ´ is now a plane (assuming no degenerate conditions). If all\ncoefﬁcients of the objective function are nonnegative, and if the origin is a feasible\nsolution to the linear program, then as we move this plane away from the origin, in\na direction normal to the objective function, we ﬁnd points of increasing objective\nvalue. (If the origin is not feasible or if some coefﬁcients in the objective function\nare negative, the intuitive picture becomes slightly more complicated.) As in two\ndimensions, because the feasible region is convex, the set of points that achieve\nthe optimal objective value must include a vertex of the feasible region. Simi-\nlarly, if we have n variables, each constraint deﬁnes a half-space in n-dimensional\nspace. We call the feasible region formed by the intersection of these half-spaces a\nsimplex. The objective function is now a hyperplane and, because of convexity, an\noptimal solution still occurs at a vertex of the simplex.\nThe simplex algorithm takes as input a linear program and returns an optimal\nsolution. It starts at some vertex of the simplex and performs a sequence of itera-\ntions. In each iteration, it moves along an edge of the simplex from a current vertex\nto a neighboring vertex whose objective value is no smaller than that of the current",
    "parent_5c2b0d50-8330-475a-a3ea-283b4f592666": "solution. It starts at some vertex of the simplex and performs a sequence of itera-\ntions. In each iteration, it moves along an edge of the simplex from a current vertex\nto a neighboring vertex whose objective value is no smaller than that of the current\nvertex (and usually is larger.) The simplex algorithm terminates when it reaches\na local maximum, which is a vertex from which all neighboring vertices have a\nsmaller objective value. Because the feasible region is convex and the objective\nfunction is linear, this local optimum is actually a global optimum. In Section 29.4,\nChapter 29\nLinear Programming\n849\nwe shall use a concept called “duality” to show that the solution returned by the\nsimplex algorithm is indeed optimal.\nAlthough the geometric view gives a good intuitive view of the operations of the\nsimplex algorithm, we shall not refer to it explicitly when developing the details\nof the simplex algorithm in Section 29.3. Instead, we take an algebraic view. We\nﬁrst write the given linear program in slack form, which is a set of linear equalities.\nThese linear equalities express some of the variables, called “basic variables,” in\nterms of other variables, called “nonbasic variables.” We move from one vertex\nto another by making a basic variable become nonbasic and making a nonbasic\nvariable become basic. We call this operation a “pivot” and, viewed algebraically,\nit is nothing more than rewriting the linear program in an equivalent slack form.\nThe two-variable example described above was particularly simple. We shall\nneed to address several more details in this chapter. These issues include iden-\ntifying linear programs that have no solutions, linear programs that have no ﬁnite\noptimal solution, and linear programs for which the origin is not a feasible solution.\nApplications of linear programming\nLinear programming has a large number of applications. Any textbook on opera-\ntions research is ﬁlled with examples of linear programming, and linear program-",
    "parent_0e962145-5c9c-464c-80cf-2481a49ed98b": "optimal solution, and linear programs for which the origin is not a feasible solution.\nApplications of linear programming\nLinear programming has a large number of applications. Any textbook on opera-\ntions research is ﬁlled with examples of linear programming, and linear program-\nming has become a standard tool taught to students in most business schools. The\nelection scenario is one typical example. Two more examples of linear program-\nming are the following:\n\u0002\nAn airline wishes to schedule its ﬂight crews. The Federal Aviation Adminis-\ntration imposes many constraints, such as limiting the number of consecutive\nhours that each crew member can work and insisting that a particular crew work\nonly on one model of aircraft during each month. The airline wants to schedule\ncrews on all of its ﬂights using as few crew members as possible.\n\u0002\nAn oil company wants to decide where to drill for oil. Siting a drill at a particu-\nlar location has an associated cost and, based on geological surveys, an expected\npayoff of some number of barrels of oil. The company has a limited budget for\nlocating new drills and wants to maximize the amount of oil it expects to ﬁnd,\ngiven this budget.\nWith linear programs, we also model and solve graph and combinatorial prob-\nlems, such as those appearing in this textbook. We have already seen a special\ncase of linear programming used to solve systems of difference constraints in Sec-\ntion 24.4. In Section 29.2, we shall study how to formulate several graph and\nnetwork-ﬂow problems as linear programs. In Section 35.4, we shall use linear\nprogramming as a tool to ﬁnd an approximate solution to another graph problem.\n850\nChapter 29\nLinear Programming\nAlgorithms for linear programming\nThis chapter studies the simplex algorithm. This algorithm, when implemented\ncarefully, often solves general linear programs quickly in practice. With some\ncarefully contrived inputs, however, the simplex algorithm can require exponential",
    "parent_b854de1b-9450-4e69-ae43-cbe92b1dd5e4": "Linear Programming\nAlgorithms for linear programming\nThis chapter studies the simplex algorithm. This algorithm, when implemented\ncarefully, often solves general linear programs quickly in practice. With some\ncarefully contrived inputs, however, the simplex algorithm can require exponential\ntime. The ﬁrst polynomial-time algorithm for linear programming was the ellipsoid\nalgorithm, which runs slowly in practice. A second class of polynomial-time algo-\nrithms are known as interior-point methods. In contrast to the simplex algorithm,\nwhich moves along the exterior of the feasible region and maintains a feasible solu-\ntion that is a vertex of the simplex at each iteration, these algorithms move through\nthe interior of the feasible region. The intermediate solutions, while feasible, are\nnot necessarily vertices of the simplex, but the ﬁnal solution is a vertex. For large\ninputs, interior-point algorithms can run as fast as, and sometimes faster than, the\nsimplex algorithm. The chapter notes point you to more information about these\nalgorithms.\nIf we add to a linear program the additional requirement that all variables take\non integer values, we have an integer linear program. Exercise 34.5-3 asks you\nto show that just ﬁnding a feasible solution to this problem is NP-hard; since\nno polynomial-time algorithms are known for any NP-hard problems, there is no\nknown polynomial-time algorithm for integer linear programming. In contrast, we\ncan solve a general linear-programming problem in polynomial time.\nIn this chapter, if we have a linear program with variables x D .x1; x2; : : : ; xn/\nand wish to refer to a particular setting of the variables, we shall use the notation\nNx D . Nx1; Nx2; : : : ; Nxn/.\n29.1\nStandard and slack forms\nThis section describes two formats, standard form and slack form, that are use-\nful when we specify and work with linear programs. In standard form, all the\nconstraints are inequalities, whereas in slack form, all constraints are equalities",
    "parent_94cc3e91-9857-4fd5-bea4-68ec130694b3": "29.1\nStandard and slack forms\nThis section describes two formats, standard form and slack form, that are use-\nful when we specify and work with linear programs. In standard form, all the\nconstraints are inequalities, whereas in slack form, all constraints are equalities\n(except for those that require the variables to be nonnegative).\nStandard form\nIn standard form, we are given n real numbers c1; c2; : : : ; cn; m real numbers\nb1; b2; : : : ; bm; and mn real numbers aij for i D 1; 2; : : : ; m and j D 1; 2; : : : ; n.\nWe wish to ﬁnd n real numbers x1; x2; : : : ; xn that\n29.1\nStandard and slack forms\n851\nmaximize\nn\nX\njD1\ncjxj\n(29.16)\nsubject to\nn\nX\njD1\naijxj\n\u0002\nbi\nfor i D 1; 2; : : : ; m\n(29.17)\nxj\n\u0006\n0\nfor j D 1; 2; : : : ; n :\n(29.18)\nGeneralizing the terminology we introduced for the two-variable linear program,\nwe call expression (29.16) the objective function and the n C m inequalities in\nlines (29.17) and (29.18) the constraints. The n constraints in line (29.18) are the\nnonnegativity constraints. An arbitrary linear program need not have nonnegativ-\nity constraints, but standard form requires them. Sometimes we ﬁnd it convenient\nto express a linear program in a more compact form. If we create an m \t n matrix\nA D .aij/, an m-vector b D .bi/, an n-vector c D .cj/, and an n-vector x D .xj/,\nthen we can rewrite the linear program deﬁned in (29.16)–(29.18) as\nmaximize\ncTx\n(29.19)\nsubject to\nAx\n\u0002\nb\n(29.20)\nx\n\u0006\n0 :\n(29.21)\nIn line (29.19), cTx is the inner product of two vectors. In inequality (29.20), Ax\nis a matrix-vector product, and in inequality (29.21), x \u0006 0 means that each entry\nof the vector x must be nonnegative. We see that we can specify a linear program\nin standard form by a tuple .A; b; c/, and we shall adopt the convention that A, b,\nand c always have the dimensions given above.\nWe now introduce terminology to describe solutions to linear programs. We used\nsome of this terminology in the earlier example of a two-variable linear program.",
    "parent_b67febb6-2ac4-4d11-9a42-b42e3fca7b0a": "in standard form by a tuple .A; b; c/, and we shall adopt the convention that A, b,\nand c always have the dimensions given above.\nWe now introduce terminology to describe solutions to linear programs. We used\nsome of this terminology in the earlier example of a two-variable linear program.\nWe call a setting of the variables Nx that satisﬁes all the constraints a feasible solu-\ntion, whereas a setting of the variables Nx that fails to satisfy at least one constraint\nis an infeasible solution. We say that a solution Nx has objective value cT Nx. A fea-\nsible solution Nx whose objective value is maximum over all feasible solutions is an\noptimal solution, and we call its objective value cT Nx the optimal objective value.\nIf a linear program has no feasible solutions, we say that the linear program is in-\nfeasible; otherwise it is feasible. If a linear program has some feasible solutions\nbut does not have a ﬁnite optimal objective value, we say that the linear program\nis unbounded. Exercise 29.1-9 asks you to show that a linear program can have a\nﬁnite optimal objective value even if the feasible region is not bounded.\n852\nChapter 29\nLinear Programming\nConverting linear programs into standard form\nIt is always possible to convert a linear program, given as minimizing or maxi-\nmizing a linear function subject to linear constraints, into standard form. A linear\nprogram might not be in standard form for any of four possible reasons:\n1. The objective function might be a minimization rather than a maximization.\n2. There might be variables without nonnegativity constraints.\n3. There might be equality constraints, which have an equal sign rather than a\nless-than-or-equal-to sign.\n4. There might be inequality constraints, but instead of having a less-than-or-\nequal-to sign, they have a greater-than-or-equal-to sign.\nWhen converting one linear program L into another linear program L0, we would\nlike the property that an optimal solution to L0 yields an optimal solution to L. To",
    "parent_89beac1f-4bfb-4393-afa2-4fa04601d619": "equal-to sign, they have a greater-than-or-equal-to sign.\nWhen converting one linear program L into another linear program L0, we would\nlike the property that an optimal solution to L0 yields an optimal solution to L. To\ncapture this idea, we say that two maximization linear programs L and L0 are\nequivalent if for each feasible solution Nx to L with objective value ´, there is\na corresponding feasible solution Nx0 to L0 with objective value ´, and for each\nfeasible solution Nx0 to L0 with objective value ´, there is a corresponding feasible\nsolution Nx to L with objective value ´. (This deﬁnition does not imply a one-to-\none correspondence between feasible solutions.) A minimization linear program L\nand a maximization linear program L0 are equivalent if for each feasible solution Nx\nto L with objective value ´, there is a corresponding feasible solution Nx0 to L0 with\nobjective value \u0005´, and for each feasible solution Nx0 to L0 with objective value ´,\nthere is a corresponding feasible solution Nx to L with objective value \u0005´.\nWe now show how to remove, one by one, each of the possible problems in the\nlist above. After removing each one, we shall argue that the new linear program is\nequivalent to the old one.\nTo convert a minimization linear program L into an equivalent maximization lin-\near program L0, we simply negate the coefﬁcients in the objective function. Since\nL and L0 have identical sets of feasible solutions and, for any feasible solution, the\nobjective value in L is the negative of the objective value in L0, these two linear\nprograms are equivalent. For example, if we have the linear program\nminimize\n\u00052x1\nC\n3x2\nsubject to\nx1\nC\nx2\nD\n7\nx1\n\u0005\n2x2\n\u0002\n4\nx1\n\u0006\n0 ;\nand we negate the coefﬁcients of the objective function, we obtain\n29.1\nStandard and slack forms\n853\nmaximize\n2x1\n\u0005\n3x2\nsubject to\nx1\nC\nx2\nD\n7\nx1\n\u0005\n2x2\n\u0002\n4\nx1\n\u0006\n0 :\nNext, we show how to convert a linear program in which some of the variables",
    "parent_a127fa47-031f-4494-a8aa-e4517b656808": "\u00052x1\nC\n3x2\nsubject to\nx1\nC\nx2\nD\n7\nx1\n\u0005\n2x2\n\u0002\n4\nx1\n\u0006\n0 ;\nand we negate the coefﬁcients of the objective function, we obtain\n29.1\nStandard and slack forms\n853\nmaximize\n2x1\n\u0005\n3x2\nsubject to\nx1\nC\nx2\nD\n7\nx1\n\u0005\n2x2\n\u0002\n4\nx1\n\u0006\n0 :\nNext, we show how to convert a linear program in which some of the variables\ndo not have nonnegativity constraints into one in which each variable has a non-\nnegativity constraint. Suppose that some variable xj does not have a nonnegativity\nconstraint. Then, we replace each occurrence of xj by x0\nj \u0005 x00\nj , and add the non-\nnegativity constraints x0\nj \u0006 0 and x00\nj \u0006 0. Thus, if the objective function has a\nterm cjxj, we replace it by cjx0\nj \u0005 cjx00\nj , and if constraint i has a term aijxj, we\nreplace it by aijx0\nj \u0005 aijx00\nj . Any feasible solution yx to the new linear program cor-\nresponds to a feasible solution Nx to the original linear program with Nxj D yx0\nj \u0005 yx00\nj\nand with the same objective value. Also, any feasible solution Nx to the original\nlinear program corresponds to a feasible solution yx to the new linear program with\nyx0\nj D Nxj and yx00\nj D 0 if Nxj \u0006 0, or with yx00\nj D Nxj and yx0\nj D 0 if Nxj < 0. The two\nlinear programs have the same objective value regardless of the sign of Nxj. Thus,\nthe two linear programs are equivalent. We apply this conversion scheme to each\nvariable that does not have a nonnegativity constraint to yield an equivalent linear\nprogram in which all variables have nonnegativity constraints.\nContinuing the example, we want to ensure that each variable has a correspond-\ning nonnegativity constraint. Variable x1 has such a constraint, but variable x2 does\nnot. Therefore, we replace x2 by two variables x0\n2 and x00\n2, and we modify the linear\nprogram to obtain\nmaximize\n2x1\n\u0005\n3x0\n2\nC\n3x00\n2\nsubject to\nx1\nC\nx0\n2\n\u0005\nx00\n2\nD\n7\n(29.22)\nx1\n\u0005\n2x0\n2\nC\n2x00\n2\n\u0002\n4\nx1; x0\n2; x00\n2\n\u0006\n0 :\nNext, we convert equality constraints into inequality constraints. Suppose that a",
    "parent_3769d1be-5fcb-4b0c-b8c7-6301fd725971": "2 and x00\n2, and we modify the linear\nprogram to obtain\nmaximize\n2x1\n\u0005\n3x0\n2\nC\n3x00\n2\nsubject to\nx1\nC\nx0\n2\n\u0005\nx00\n2\nD\n7\n(29.22)\nx1\n\u0005\n2x0\n2\nC\n2x00\n2\n\u0002\n4\nx1; x0\n2; x00\n2\n\u0006\n0 :\nNext, we convert equality constraints into inequality constraints. Suppose that a\nlinear program has an equality constraint f .x1; x2; : : : ; xn/ D b. Since x D y if\nand only if both x \u0006 y and x \u0002 y, we can replace this equality constraint by the\npair of inequality constraints f .x1; x2; : : : ; xn/ \u0002 b and f .x1; x2; : : : ; xn/ \u0006 b.\nRepeating this conversion for each equality constraint yields a linear program in\nwhich all constraints are inequalities.\nFinally, we can convert the greater-than-or-equal-to constraints to less-than-or-\nequal-to constraints by multiplying these constraints through by \u00051. That is, any\ninequality of the form\n854\nChapter 29\nLinear Programming\nn\nX\njD1\naijxj \u0006 bi\nis equivalent to\nn\nX\njD1\n\u0005aijxj \u0002 \u0005bi :\nThus, by replacing each coefﬁcient aij by \u0005aij and each value bi by \u0005bi, we obtain\nan equivalent less-than-or-equal-to constraint.\nFinishing our example, we replace the equality in constraint (29.22) by two in-\nequalities, obtaining\nmaximize\n2x1\n\u0005\n3x0\n2\nC\n3x00\n2\nsubject to\nx1\nC\nx0\n2\n\u0005\nx00\n2\n\u0002\n7\nx1\nC\nx0\n2\n\u0005\nx00\n2\n\u0006\n7\n(29.23)\nx1\n\u0005\n2x0\n2\nC\n2x00\n2\n\u0002\n4\nx1; x0\n2; x00\n2\n\u0006\n0 :\nFinally, we negate constraint (29.23). For consistency in variable names, we re-\nname x0\n2 to x2 and x00\n2 to x3, obtaining the standard form\nmaximize\n2x1\n\u0005\n3x2\nC\n3x3\n(29.24)\nsubject to\nx1\nC\nx2\n\u0005\nx3\n\u0002\n7\n(29.25)\n\u0005x1\n\u0005\nx2\nC\nx3\n\u0002\n\u00057\n(29.26)\nx1\n\u0005\n2x2\nC\n2x3\n\u0002\n4\n(29.27)\nx1; x2; x3\n\u0006\n0 :\n(29.28)\nConverting linear programs into slack form\nTo efﬁciently solve a linear program with the simplex algorithm, we prefer to ex-\npress it in a form in which some of the constraints are equality constraints. More\nprecisely, we shall convert it into a form in which the nonnegativity constraints are\nthe only inequality constraints, and the remaining constraints are equalities. Let\nn\nX\njD1\naijxj \u0002 bi\n(29.29)\n29.1",
    "parent_63effbed-465e-4fc4-ae41-730f81c7f598": "press it in a form in which some of the constraints are equality constraints. More\nprecisely, we shall convert it into a form in which the nonnegativity constraints are\nthe only inequality constraints, and the remaining constraints are equalities. Let\nn\nX\njD1\naijxj \u0002 bi\n(29.29)\n29.1\nStandard and slack forms\n855\nbe an inequality constraint. We introduce a new variable s and rewrite inequal-\nity (29.29) as the two constraints\ns\nD\nbi \u0005\nn\nX\njD1\naijxj ;\n(29.30)\ns\n\u0006\n0 :\n(29.31)\nWe call s a slack variable because it measures the slack, or difference, between\nthe left-hand and right-hand sides of equation (29.29). (We shall soon see why we\nﬁnd it convenient to write the constraint with only the slack variable on the left-\nhand side.) Because inequality (29.29) is true if and only if both equation (29.30)\nand inequality (29.31) are true, we can convert each inequality constraint of a lin-\near program in this way to obtain an equivalent linear program in which the only\ninequality constraints are the nonnegativity constraints. When converting from\nstandard to slack form, we shall use xnCi (instead of s) to denote the slack variable\nassociated with the ith inequality. The ith constraint is therefore\nxnCi D bi \u0005\nn\nX\njD1\naijxj ;\n(29.32)\nalong with the nonnegativity constraint xnCi \u0006 0.\nBy converting each constraint of a linear program in standard form, we obtain a\nlinear program in a different form. For example, for the linear program described\nin (29.24)–(29.28), we introduce slack variables x4, x5, and x6, obtaining\nmaximize\n2x1\n\u0005\n3x2\nC\n3x3\n(29.33)\nsubject to\nx4\nD\n7\n\u0005\nx1\n\u0005\nx2\nC\nx3\n(29.34)\nx5\nD\n\u00057\nC\nx1\nC\nx2\n\u0005\nx3\n(29.35)\nx6\nD\n4\n\u0005\nx1\nC\n2x2\n\u0005\n2x3\n(29.36)\nx1; x2; x3; x4; x5; x6\n\u0006\n0\n:\n(29.37)\nIn this linear program, all the constraints except for the nonnegativity constraints\nare equalities, and each variable is subject to a nonnegativity constraint. We write\neach equality constraint with one of the variables on the left-hand side of the equal-",
    "parent_77d5e02c-ae0e-4e0f-a8a2-92052992d186": "x1; x2; x3; x4; x5; x6\n\u0006\n0\n:\n(29.37)\nIn this linear program, all the constraints except for the nonnegativity constraints\nare equalities, and each variable is subject to a nonnegativity constraint. We write\neach equality constraint with one of the variables on the left-hand side of the equal-\nity and all others on the right-hand side. Furthermore, each equation has the same\nset of variables on the right-hand side, and these variables are also the only ones\nthat appear in the objective function. We call the variables on the left-hand side of\nthe equalities basic variables and those on the right-hand side nonbasic variables.\nFor linear programs that satisfy these conditions, we shall sometimes omit the\nwords “maximize” and “subject to,” as well as the explicit nonnegativity con-\nstraints. We shall also use the variable ´ to denote the value of the objective func-\n856\nChapter 29\nLinear Programming\ntion. We call the resulting format slack form. If we write the linear program given\nin (29.33)–(29.37) in slack form, we obtain\n´\nD\n2x1\n\u0005\n3x2\nC\n3x3\n(29.38)\nx4\nD\n7\n\u0005\nx1\n\u0005\nx2\nC\nx3\n(29.39)\nx5\nD\n\u00057\nC\nx1\nC\nx2\n\u0005\nx3\n(29.40)\nx6\nD\n4\n\u0005\nx1\nC\n2x2\n\u0005\n2x3 :\n(29.41)\nAs with standard form, we ﬁnd it convenient to have a more concise notation\nfor describing a slack form. As we shall see in Section 29.3, the sets of basic and\nnonbasic variables will change as the simplex algorithm runs. We use N to denote\nthe set of indices of the nonbasic variables and B to denote the set of indices of\nthe basic variables. We always have that jN j D n, jBj D m, and N [ B D\nf1; 2; : : : ; n C mg. The equations are indexed by the entries of B, and the variables\non the right-hand sides are indexed by the entries of N . As in standard form, we use\nbi, cj, and aij to denote constant terms and coefﬁcients. We also use \u0003 to denote\nan optional constant term in the objective function. (We shall see a little later that\nincluding the constant term in the objective function makes it easy to determine the",
    "parent_cae197d2-f7b7-4ae5-9fd0-118b30b2cb1b": "bi, cj, and aij to denote constant terms and coefﬁcients. We also use \u0003 to denote\nan optional constant term in the objective function. (We shall see a little later that\nincluding the constant term in the objective function makes it easy to determine the\nvalue of the objective function.) Thus we can concisely deﬁne a slack form by a\ntuple .N; B; A; b; c; \u0003/, denoting the slack form\n´\nD\n\u0003\nC\nX\nj2N\ncjxj\n(29.42)\nxi\nD\nbi\n\u0005\nX\nj2N\naijxj\nfor i 2 B ;\n(29.43)\nin which all variables x are constrained to be nonnegative. Because we subtract\nthe sum P\nj2N aijxj in (29.43), the values aij are actually the negatives of the\ncoefﬁcients as they “appear” in the slack form.\nFor example, in the slack form\n´\nD\n28\n\u0005\nx3\n6\n\u0005\nx5\n6\n\u0005\n2x6\n3\nx1\nD\n8\nC\nx3\n6\nC\nx5\n6\n\u0005\nx6\n3\nx2\nD\n4\n\u0005\n8x3\n3\n\u0005\n2x5\n3\nC\nx6\n3\nx4\nD\n18\n\u0005\nx3\n2\nC\nx5\n2\n;\nwe have B D f1; 2; 4g, N D f3; 5; 6g,\n29.1\nStandard and slack forms\n857\nA D\n\u0005\na13\na15\na16\na23\na25\na26\na43\na45\na46\n\u0006\nD\n\u0005\n\u00051=6\n\u00051=6\n1=3\n8=3\n2=3\n\u00051=3\n1=2\n\u00051=2\n0\n\u0006\n;\nb D\n\u0005\nb1\nb2\nb4\n\u0006\nD\n\u0005\n8\n4\n18\n\u0006\n;\nc D\n\u000b c3\nc5\nc6\n\fT D\n\u000b \u00051=6\n\u00051=6\n\u00052=3 \fT, and \u0003 D 28. Note that the\nindices into A, b, and c are not necessarily sets of contiguous integers; they depend\non the index sets B and N . As an example of the entries of A being the negatives\nof the coefﬁcients as they appear in the slack form, observe that the equation for x1\nincludes the term x3=6, yet the coefﬁcient a13 is actually \u00051=6 rather than C1=6.\nExercises\n29.1-1\nIf we express the linear program in (29.24)–(29.28) in the compact notation of\n(29.19)–(29.21), what are n, m, A, b, and c?\n29.1-2\nGive three feasible solutions to the linear program in (29.24)–(29.28). What is the\nobjective value of each one?\n29.1-3\nFor the slack form in (29.38)–(29.41), what are N , B, A, b, c, and \u0003?\n29.1-4\nConvert the following linear program into standard form:\nminimize\n2x1\nC\n7x2\nC\nx3\nsubject to\nx1\n\u0005\nx3\nD\n7\n3x1\nC\nx2\n\u0006\n24\nx2\n\u0006\n0\nx3\n\u0002\n0 :\n858\nChapter 29\nLinear Programming\n29.1-5\nConvert the following linear program into slack form:\nmaximize\n2x1\n\u0005\n6x3",
    "parent_4e8da805-924e-40ad-8a6d-a688a2bd17ee": "29.1-4\nConvert the following linear program into standard form:\nminimize\n2x1\nC\n7x2\nC\nx3\nsubject to\nx1\n\u0005\nx3\nD\n7\n3x1\nC\nx2\n\u0006\n24\nx2\n\u0006\n0\nx3\n\u0002\n0 :\n858\nChapter 29\nLinear Programming\n29.1-5\nConvert the following linear program into slack form:\nmaximize\n2x1\n\u0005\n6x3\nsubject to\nx1\nC\nx2\n\u0005\nx3\n\u0002\n7\n3x1\n\u0005\nx2\n\u0006\n8\n\u0005x1\nC\n2x2\nC\n2x3\n\u0006\n0\nx1; x2; x3\n\u0006\n0 :\nWhat are the basic and nonbasic variables?\n29.1-6\nShow that the following linear program is infeasible:\nmaximize\n3x1\n\u0005\n2x2\nsubject to\nx1\nC\nx2\n\u0002\n2\n\u00052x1\n\u0005\n2x2\n\u0002\n\u000510\nx1; x2\n\u0006\n0 :\n29.1-7\nShow that the following linear program is unbounded:\nmaximize\nx1\n\u0005\nx2\nsubject to\n\u00052x1\nC\nx2\n\u0002\n\u00051\n\u0005x1\n\u0005\n2x2\n\u0002\n\u00052\nx1; x2\n\u0006\n0 :\n29.1-8\nSuppose that we have a general linear program with n variables and m constraints,\nand suppose that we convert it into standard form. Give an upper bound on the\nnumber of variables and constraints in the resulting linear program.\n29.1-9\nGive an example of a linear program for which the feasible region is not bounded,\nbut the optimal objective value is ﬁnite.\n29.2\nFormulating problems as linear programs\n859\n29.2\nFormulating problems as linear programs\nAlthough we shall focus on the simplex algorithm in this chapter, it is also impor-\ntant to be able to recognize when we can formulate a problem as a linear program.\nOnce we cast a problem as a polynomial-sized linear program, we can solve it\nin polynomial time by the ellipsoid algorithm or interior-point methods. Several\nlinear-programming software packages can solve problems efﬁciently, so that once\nthe problem is in the form of a linear program, such a package can solve it.\nWe shall look at several concrete examples of linear-programming problems. We\nstart with two problems that we have already studied: the single-source shortest-\npaths problem (see Chapter 24) and the maximum-ﬂow problem (see Chapter 26).\nWe then describe the minimum-cost-ﬂow problem. Although the minimum-cost-\nﬂow problem has a polynomial-time algorithm that is not based on linear program-",
    "parent_3731c38c-b668-491d-8c8b-be880894108c": "paths problem (see Chapter 24) and the maximum-ﬂow problem (see Chapter 26).\nWe then describe the minimum-cost-ﬂow problem. Although the minimum-cost-\nﬂow problem has a polynomial-time algorithm that is not based on linear program-\nming, we won’t describe the algorithm. Finally, we describe the multicommodity-\nﬂow problem, for which the only known polynomial-time algorithm is based on\nlinear programming.\nWhen we solved graph problems in Part VI, we used attribute notation, such\nas \u0003:d and .u; \u0003/:f. Linear programs typically use subscripted variables rather\nthan objects with attached attributes, however. Therefore, when we express vari-\nables in linear programs, we shall indicate vertices and edges through subscripts.\nFor example, we denote the shortest-path weight for vertex \u0003 not by \u0003:d but by d\u0005.\nSimilarly, we denote the ﬂow from vertex u to vertex \u0003 not by .u; \u0003/:f but by fu\u0005.\nFor quantities that are given as inputs to problems, such as edge weights or capac-\nities, we shall continue to use notations such as w.u; \u0003/ and c.u:\u0003/.\nShortest paths\nWe can formulate the single-source shortest-paths problem as a linear program.\nIn this section, we shall focus on how to formulate the single-pair shortest-path\nproblem, leaving the extension to the more general single-source shortest-paths\nproblem as Exercise 29.2-3.\nIn the single-pair shortest-path problem, we are given a weighted, directed graph\nG D .V; E/, with weight function w W E ! R mapping edges to real-valued\nweights, a source vertex s, and destination vertex t. We wish to compute the\nvalue dt, which is the weight of a shortest path from s to t. To express this prob-\nlem as a linear program, we need to determine a set of variables and constraints that\ndeﬁne when we have a shortest path from s to t. Fortunately, the Bellman-Ford al-\ngorithm does exactly this. When the Bellman-Ford algorithm terminates, it has\ncomputed, for each vertex \u0003, a value d\u0005 (using subscript notation here rather than",
    "parent_08628cef-3d7e-42a1-be40-19f49de1bbe9": "deﬁne when we have a shortest path from s to t. Fortunately, the Bellman-Ford al-\ngorithm does exactly this. When the Bellman-Ford algorithm terminates, it has\ncomputed, for each vertex \u0003, a value d\u0005 (using subscript notation here rather than\nattribute notation) such that for each edge .u; \u0003/ 2 E, we have d\u0005 \u0002 du C w.u; \u0003/.\n860\nChapter 29\nLinear Programming\nThe source vertex initially receives a value ds D 0, which never changes. Thus\nwe obtain the following linear program to compute the shortest-path weight from s\nto t:\nmaximize\ndt\n(29.44)\nsubject to\nd\u0005\n\u0002\ndu C w.u; \u0003/\nfor each edge .u; \u0003/ 2 E ;\n(29.45)\nds\nD\n0 :\n(29.46)\nYou might be surprised that this linear program maximizes an objective function\nwhen it is supposed to compute shortest paths. We do not want to minimize the\nobjective function, since then setting Nd\u0005 D 0 for all \u0003 2 V would yield an optimal\nsolution to the linear program without solving the shortest-paths problem. We\nmaximize because an optimal solution to the shortest-paths problem sets each Nd\u0005\nto minuW.u;\u0005/2E\n˚ Ndu C w.u; \u0003/",
    "parent_0f7675ab-415b-4b9f-b059-4388d26afdfd": ", so that Nd\u0005 is the largest value that is less than or\nequal to all of the values in the set\n˚ Ndu C w.u; \u0003/",
    "parent_f1cbed11-d9ff-4862-bca2-ff999edc1586": ". We want to maximize d\u0005\nfor all vertices \u0003 on a shortest path from s to t subject to these constraints on all\nvertices \u0003, and maximizing dt achieves this goal.\nThis linear program has jV j variables d\u0005, one for each vertex \u0003 2 V . It also\nhas jEj C 1 constraints: one for each edge, plus the additional constraint that the\nsource vertex’s shortest-path weight always has the value 0.\nMaximum ﬂow\nNext, we express the maximum-ﬂow problem as a linear program. Recall that we\nare given a directed graph G D .V; E/ in which each edge .u; \u0003/ 2 E has a\nnonnegative capacity c.u; \u0003/ \u0006 0, and two distinguished vertices: a source s and\na sink t. As deﬁned in Section 26.1, a ﬂow is a nonnegative real-valued function\nf W V \t V ! R that satisﬁes the capacity constraint and ﬂow conservation. A\nmaximum ﬂow is a ﬂow that satisﬁes these constraints and maximizes the ﬂow\nvalue, which is the total ﬂow coming out of the source minus the total ﬂow into the\nsource. A ﬂow, therefore, satisﬁes linear constraints, and the value of a ﬂow is a\nlinear function. Recalling also that we assume that c.u; \u0003/ D 0 if .u; \u0003/ 62 E and\nthat there are no antiparallel edges, we can express the maximum-ﬂow problem as\na linear program:\nmaximize\nX\n\u00052V\nfs\u0005\n\u0005\nX\n\u00052V\nf\u0005s\n(29.47)\nsubject to\nfu\u0005\n\u0002\nc.u; \u0003/\nfor each u; \u0003 2 V ;\n(29.48)\nX\n\u00052V\nf\u0005u\nD\nX\n\u00052V\nfu\u0005\nfor each u 2 V \u0005 fs; tg ;\n(29.49)\nfu\u0005\n\u0006\n0\nfor each u; \u0003 2 V :\n(29.50)\n29.2\nFormulating problems as linear programs\n861\nThis linear program has jV j2 variables, corresponding to the ﬂow between each\npair of vertices, and it has 2 jV j2 C jV j \u0005 2 constraints.\nIt is usually more efﬁcient to solve a smaller-sized linear program. The linear\nprogram in (29.47)–(29.50) has, for ease of notation, a ﬂow and capacity of 0 for\neach pair of vertices u; \u0003 with .u; \u0003/ 62 E. It would be more efﬁcient to rewrite the\nlinear program so that it has O.V C E/ constraints. Exercise 29.2-5 asks you to\ndo so.\nMinimum-cost ﬂow",
    "parent_206f0f8f-7a01-4dcc-96af-f80f7aa59e1e": "program in (29.47)–(29.50) has, for ease of notation, a ﬂow and capacity of 0 for\neach pair of vertices u; \u0003 with .u; \u0003/ 62 E. It would be more efﬁcient to rewrite the\nlinear program so that it has O.V C E/ constraints. Exercise 29.2-5 asks you to\ndo so.\nMinimum-cost ﬂow\nIn this section, we have used linear programming to solve problems for which we\nalready knew efﬁcient algorithms. In fact, an efﬁcient algorithm designed specif-\nically for a problem, such as Dijkstra’s algorithm for the single-source shortest-\npaths problem, or the push-relabel method for maximum ﬂow, will often be more\nefﬁcient than linear programming, both in theory and in practice.\nThe real power of linear programming comes from the ability to solve new prob-\nlems. Recall the problem faced by the politician in the beginning of this chapter.\nThe problem of obtaining a sufﬁcient number of votes, while not spending too\nmuch money, is not solved by any of the algorithms that we have studied in this\nbook, yet we can solve it by linear programming. Books abound with such real-\nworld problems that linear programming can solve. Linear programming is also\nparticularly useful for solving variants of problems for which we may not already\nknow of an efﬁcient algorithm.\nConsider, for example, the following generalization of the maximum-ﬂow prob-\nlem. Suppose that, in addition to a capacity c.u; \u0003/ for each edge .u; \u0003/, we are\ngiven a real-valued cost a.u; \u0003/. As in the maximum-ﬂow problem, we assume that\nc.u; \u0003/ D 0 if .u; \u0003/ 62 E, and that there are no antiparallel edges. If we send fu\u0005\nunits of ﬂow over edge .u; \u0003/, we incur a cost of a.u; \u0003/fu\u0005. We are also given a\nﬂow demand d. We wish to send d units of ﬂow from s to t while minimizing the\ntotal cost P\n.u;\u0005/2E a.u; \u0003/fu\u0005 incurred by the ﬂow. This problem is known as the\nminimum-cost-ﬂow problem.\nFigure 29.3(a) shows an example of the minimum-cost-ﬂow problem. We wish\nto send 4 units of ﬂow from s to t while incurring the minimum total cost. Any",
    "parent_1ef3b834-3256-48c2-acbf-89d2d61c61ee": "total cost P\n.u;\u0005/2E a.u; \u0003/fu\u0005 incurred by the ﬂow. This problem is known as the\nminimum-cost-ﬂow problem.\nFigure 29.3(a) shows an example of the minimum-cost-ﬂow problem. We wish\nto send 4 units of ﬂow from s to t while incurring the minimum total cost. Any\nparticular legal ﬂow, that is, a function f satisfying constraints (29.48)–(29.49),\nincurs a total cost of P\n.u;\u0005/2E a.u; \u0003/fu\u0005. We wish to ﬁnd the particular 4-unit\nﬂow that minimizes this cost. Figure 29.3(b) shows an optimal solution, with total\ncost P\n.u;\u0005/2E a.u; \u0003/fu\u0005 D .2 \u0003 2/ C .5 \u0003 2/ C .3 \u0003 1/ C .7 \u0003 1/ C .1 \u0003 3/ D 27:\nThere are polynomial-time algorithms speciﬁcally designed for the minimum-\ncost-ﬂow problem, but they are beyond the scope of this book. We can, however,\nexpress the minimum-cost-ﬂow problem as a linear program. The linear program\nlooks similar to the one for the maximum-ﬂow problem with the additional con-\n862\nChapter 29\nLinear Programming\ns\nx\nt\ny\n(a)\nc = 1\na = 3\nc = 5\na = 2\nc = 4\na = 1\nc = 2\na = 7\nc = 2\na = 5\ns\nx\nt\ny\n(b)\n1/1\na = 3\n2/5\na = 2\n3/4\na = 1\n1/2\na = 7\n2/2\na = 5\nFigure 29.3\n(a) An example of a minimum-cost-ﬂow problem. We denote the capacities by c and\nthe costs by a. Vertex s is the source and vertex t is the sink, and we wish to send 4 units of ﬂow\nfrom s to t. (b) A solution to the minimum-cost ﬂow problem in which 4 units of ﬂow are sent from s\nto t. For each edge, the ﬂow and capacity are written as ﬂow/capacity.\nstraint that the value of the ﬂow be exactly d units, and with the new objective\nfunction of minimizing the cost:\nminimize\nX\n.u;\u0005/2E\na.u; \u0003/fu\u0005\n(29.51)\nsubject to\nfu\u0005\n\u0002\nc.u; \u0003/\nfor each u; \u0003 2 V ;\nX\n\u00052V\nf\u0005u \u0005\nX\n\u00052V\nfu\u0005\nD\n0\nfor each u 2 V \u0005 fs; tg ;\nX\n\u00052V\nfs\u0005 \u0005\nX\n\u00052V\nf\u0005s\nD\nd ;\nfu\u0005\n\u0006\n0\nfor each u; \u0003 2 V :\n(29.52)\nMulticommodity ﬂow\nAs a ﬁnal example, we consider another ﬂow problem. Suppose that the Lucky\nPuck company from Section 26.1 decides to diversify its product line and ship\nnot only hockey pucks, but also hockey sticks and hockey helmets. Each piece of",
    "parent_ce4ecf24-b24f-4c71-9c41-52a328a84639": "f\u0005s\nD\nd ;\nfu\u0005\n\u0006\n0\nfor each u; \u0003 2 V :\n(29.52)\nMulticommodity ﬂow\nAs a ﬁnal example, we consider another ﬂow problem. Suppose that the Lucky\nPuck company from Section 26.1 decides to diversify its product line and ship\nnot only hockey pucks, but also hockey sticks and hockey helmets. Each piece of\nequipment is manufactured in its own factory, has its own warehouse, and must\nbe shipped, each day, from factory to warehouse. The sticks are manufactured in\nVancouver and must be shipped to Saskatoon, and the helmets are manufactured in\nEdmonton and must be shipped to Regina. The capacity of the shipping network\ndoes not change, however, and the different items, or commodities, must share the\nsame network.\nThis example is an instance of a multicommodity-ﬂow problem. In this problem,\nwe are again given a directed graph G D .V; E/ in which each edge .u; \u0003/ 2 E\nhas a nonnegative capacity c.u; \u0003/ \u0006 0. As in the maximum-ﬂow problem, we im-\nplicitly assume that c.u; \u0003/ D 0 for .u; \u0003/ 62 E, and that the graph has no antipar-\n29.2\nFormulating problems as linear programs\n863\nallel edges. In addition, we are given k different commodities, K1; K2; : : : ; Kk,\nwhere we specify commodity i by the triple Ki D .si; ti; di/. Here, vertex si is\nthe source of commodity i, vertex ti is the sink of commodity i, and di is the de-\nmand for commodity i, which is the desired ﬂow value for the commodity from si\nto ti. We deﬁne a ﬂow for commodity i, denoted by fi, (so that fiu\u0005 is the ﬂow of\ncommodity i from vertex u to vertex \u0003) to be a real-valued function that satisﬁes\nthe ﬂow-conservation and capacity constraints. We now deﬁne fu\u0005, the aggregate\nﬂow, to be the sum of the various commodity ﬂows, so that fu\u0005 D Pk\niD1 fiu\u0005. The\naggregate ﬂow on edge .u; \u0003/ must be no more than the capacity of edge .u; \u0003/.\nWe are not trying to minimize any objective function in this problem; we need\nonly determine whether such a ﬂow exists. Thus, we write a linear program with a\n“null” objective function:",
    "parent_dac55675-c77a-4e02-8d5b-73c78980aa9e": "iD1 fiu\u0005. The\naggregate ﬂow on edge .u; \u0003/ must be no more than the capacity of edge .u; \u0003/.\nWe are not trying to minimize any objective function in this problem; we need\nonly determine whether such a ﬂow exists. Thus, we write a linear program with a\n“null” objective function:\nminimize\n0\nsubject to\nk\nX\niD1\nfiu\u0005\n\u0002\nc.u; \u0003/\nfor each u; \u0003 2 V ;\nX\n\u00052V\nfiu\u0005 \u0005\nX\n\u00052V\nfi\u0005u\nD\n0\nfor each i D 1; 2; : : : ; k and\nfor each u 2 V \u0005 fsi; tig ;\nX\n\u00052V\nfi;si;\u0005 \u0005\nX\n\u00052V\nfi;\u0005;si\nD\ndi\nfor each i D 1; 2; : : : ; k ;\nfiu\u0005\n\u0006\n0\nfor each u; \u0003 2 V and\nfor each i D 1; 2; : : : ; k :\nThe only known polynomial-time algorithm for this problem expresses it as a linear\nprogram and then solves it with a polynomial-time linear-programming algorithm.\nExercises\n29.2-1\nPut the single-pair shortest-path linear program from (29.44)–(29.46) into standard\nform.\n29.2-2\nWrite out explicitly the linear program corresponding to ﬁnding the shortest path\nfrom node s to node y in Figure 24.2(a).\n29.2-3\nIn the single-source shortest-paths problem, we want to ﬁnd the shortest-path\nweights from a source vertex s to all vertices \u0003 2 V . Given a graph G, write a\n864\nChapter 29\nLinear Programming\nlinear program for which the solution has the property that d\u0005 is the shortest-path\nweight from s to \u0003 for each vertex \u0003 2 V .\n29.2-4\nWrite out explicitly the linear program corresponding to ﬁnding the maximum ﬂow\nin Figure 26.1(a).\n29.2-5\nRewrite the linear program for maximum ﬂow (29.47)–(29.50) so that it uses only\nO.V C E/ constraints.\n29.2-6\nWrite a linear program that, given a bipartite graph G D .V; E/, solves the maxi-\nmum-bipartite-matching problem.\n29.2-7\nIn the minimum-cost multicommodity-ﬂow problem, we are given directed graph\nG D .V; E/ in which each edge .u; \u0003/ 2 E has a nonnegative capacity c.u; \u0003/ \u0006 0\nand a cost a.u; \u0003/. As in the multicommodity-ﬂow problem, we are given k dif-\nferent commodities, K1; K2; : : : ; Kk, where we specify commodity i by the triple",
    "parent_cac2721a-2d83-4cda-9fa4-4680809dbe0c": "G D .V; E/ in which each edge .u; \u0003/ 2 E has a nonnegative capacity c.u; \u0003/ \u0006 0\nand a cost a.u; \u0003/. As in the multicommodity-ﬂow problem, we are given k dif-\nferent commodities, K1; K2; : : : ; Kk, where we specify commodity i by the triple\nKi D .si; ti; di/. We deﬁne the ﬂow fi for commodity i and the aggregate ﬂow fu\u0005\non edge .u; \u0003/ as in the multicommodity-ﬂow problem. A feasible ﬂow is one\nin which the aggregate ﬂow on each edge .u; \u0003/ is no more than the capacity of\nedge .u; \u0003/. The cost of a ﬂow is P\nu;\u00052V a.u; \u0003/fu\u0005, and the goal is to ﬁnd the\nfeasible ﬂow of minimum cost. Express this problem as a linear program.\n29.3\nThe simplex algorithm\nThe simplex algorithm is the classical method for solving linear programs. In con-\ntrast to most of the other algorithms in this book, its running time is not polynomial\nin the worst case. It does yield insight into linear programs, however, and is often\nremarkably fast in practice.\nIn addition to having a geometric interpretation, described earlier in this chapter,\nthe simplex algorithm bears some similarity to Gaussian elimination, discussed in\nSection 28.1. Gaussian elimination begins with a system of linear equalities whose\nsolution is unknown. In each iteration, we rewrite this system in an equivalent\nform that has some additional structure. After some number of iterations, we have\nrewritten the system so that the solution is simple to obtain. The simplex algo-\nrithm proceeds in a similar manner, and we can view it as Gaussian elimination for\ninequalities.\n29.3\nThe simplex algorithm\n865\nWe now describe the main idea behind an iteration of the simplex algorithm.\nAssociated with each iteration will be a “basic solution” that we can easily obtain\nfrom the slack form of the linear program: set each nonbasic variable to 0 and\ncompute the values of the basic variables from the equality constraints. An iteration\nconverts one slack form into an equivalent slack form. The objective value of the",
    "parent_49219a34-6349-4946-a434-65bf1867c3c2": "from the slack form of the linear program: set each nonbasic variable to 0 and\ncompute the values of the basic variables from the equality constraints. An iteration\nconverts one slack form into an equivalent slack form. The objective value of the\nassociated basic feasible solution will be no less than that at the previous iteration,\nand usually greater. To achieve this increase in the objective value, we choose a\nnonbasic variable such that if we were to increase that variable’s value from 0, then\nthe objective value would increase, too. The amount by which we can increase\nthe variable is limited by the other constraints. In particular, we raise it until some\nbasic variable becomes 0. We then rewrite the slack form, exchanging the roles\nof that basic variable and the chosen nonbasic variable. Although we have used a\nparticular setting of the variables to guide the algorithm, and we shall use it in our\nproofs, the algorithm does not explicitly maintain this solution. It simply rewrites\nthe linear program until an optimal solution becomes “obvious.”\nAn example of the simplex algorithm\nWe begin with an extended example. Consider the following linear program in\nstandard form:\nmaximize\n3x1\nC\nx2\nC\n2x3\n(29.53)\nsubject to\nx1\nC\nx2\nC\n3x3\n\u0002\n30\n(29.54)\n2x1\nC\n2x2\nC\n5x3\n\u0002\n24\n(29.55)\n4x1\nC\nx2\nC\n2x3\n\u0002\n36\n(29.56)\nx1; x2; x3\n\u0006\n0 :\n(29.57)\nIn order to use the simplex algorithm, we must convert the linear program into\nslack form; we saw how to do so in Section 29.1. In addition to being an algebraic\nmanipulation, slack is a useful algorithmic concept. Recalling from Section 29.1\nthat each variable has a corresponding nonnegativity constraint, we say that an\nequality constraint is tight for a particular setting of its nonbasic variables if they\ncause the constraint’s basic variable to become 0. Similarly, a setting of the non-\nbasic variables that would make a basic variable become negative violates that",
    "parent_df0b639a-5595-41ce-931d-d27d4db0f494": "equality constraint is tight for a particular setting of its nonbasic variables if they\ncause the constraint’s basic variable to become 0. Similarly, a setting of the non-\nbasic variables that would make a basic variable become negative violates that\nconstraint. Thus, the slack variables explicitly maintain how far each constraint is\nfrom being tight, and so they help to determine how much we can increase values\nof nonbasic variables without violating any constraints.\nAssociating the slack variables x4, x5, and x6 with inequalities (29.54)–(29.56),\nrespectively, and putting the linear program into slack form, we obtain\n866\nChapter 29\nLinear Programming\n´\nD\n3x1\nC\nx2\nC\n2x3\n(29.58)\nx4\nD\n30\n\u0005\nx1\n\u0005\nx2\n\u0005\n3x3\n(29.59)\nx5\nD\n24\n\u0005\n2x1\n\u0005\n2x2\n\u0005\n5x3\n(29.60)\nx6\nD\n36\n\u0005\n4x1\n\u0005\nx2\n\u0005\n2x3 :\n(29.61)\nThe system of constraints (29.59)–(29.61) has 3 equations and 6 variables. Any\nsetting of the variables x1, x2, and x3 deﬁnes values for x4, x5, and x6; therefore,\nwe have an inﬁnite number of solutions to this system of equations. A solution is\nfeasible if all of x1; x2; : : : ; x6 are nonnegative, and there can be an inﬁnite num-\nber of feasible solutions as well. The inﬁnite number of possible solutions to a\nsystem such as this one will be useful in later proofs. We focus on the basic solu-\ntion: set all the (nonbasic) variables on the right-hand side to 0 and then compute\nthe values of the (basic) variables on the left-hand side. In this example, the ba-\nsic solution is . Nx1; Nx2; : : : ; Nx6/ D .0; 0; 0; 30; 24; 36/ and it has objective value\n´ D .3 \u0003 0/ C .1 \u0003 0/ C .2 \u0003 0/ D 0. Observe that this basic solution sets Nxi D bi\nfor each i 2 B. An iteration of the simplex algorithm rewrites the set of equations\nand the objective function so as to put a different set of variables on the right-\nhand side. Thus, a different basic solution is associated with the rewritten problem.\nWe emphasize that the rewrite does not in any way change the underlying linear-",
    "parent_e1d83714-9576-4007-a417-7a735892c5e7": "and the objective function so as to put a different set of variables on the right-\nhand side. Thus, a different basic solution is associated with the rewritten problem.\nWe emphasize that the rewrite does not in any way change the underlying linear-\nprogramming problem; the problem at one iteration has the identical set of feasible\nsolutions as the problem at the previous iteration. The problem does, however,\nhave a different basic solution than that of the previous iteration.\nIf a basic solution is also feasible, we call it a basic feasible solution. As we run\nthe simplex algorithm, the basic solution is almost always a basic feasible solution.\nWe shall see in Section 29.5, however, that for the ﬁrst few iterations of the simplex\nalgorithm, the basic solution might not be feasible.\nOur goal, in each iteration, is to reformulate the linear program so that the basic\nsolution has a greater objective value. We select a nonbasic variable xe whose\ncoefﬁcient in the objective function is positive, and we increase the value of xe as\nmuch as possible without violating any of the constraints. The variable xe becomes\nbasic, and some other variable xl becomes nonbasic. The values of other basic\nvariables and of the objective function may also change.\nTo continue the example, let’s think about increasing the value of x1. As we\nincrease x1, the values of x4, x5, and x6 all decrease. Because we have a nonnega-\ntivity constraint for each variable, we cannot allow any of them to become negative.\nIf x1 increases above 30, then x4 becomes negative, and x5 and x6 become nega-\ntive when x1 increases above 12 and 9, respectively. The third constraint (29.61) is\nthe tightest constraint, and it limits how much we can increase x1. Therefore, we\nswitch the roles of x1 and x6. We solve equation (29.61) for x1 and obtain\nx1 D 9 \u0005 x2\n4 \u0005 x3\n2 \u0005 x6\n4 :\n(29.62)\n29.3\nThe simplex algorithm\n867\nTo rewrite the other equations with x6 on the right-hand side, we substitute for x1",
    "parent_de2095f5-2c8a-4339-acd6-17a7b2eff431": "switch the roles of x1 and x6. We solve equation (29.61) for x1 and obtain\nx1 D 9 \u0005 x2\n4 \u0005 x3\n2 \u0005 x6\n4 :\n(29.62)\n29.3\nThe simplex algorithm\n867\nTo rewrite the other equations with x6 on the right-hand side, we substitute for x1\nusing equation (29.62). Doing so for equation (29.59), we obtain\nx4\nD\n30 \u0005 x1 \u0005 x2 \u0005 3x3\nD\n30 \u0005\n\u0004\n9 \u0005 x2\n4 \u0005 x3\n2 \u0005 x6\n4\n\u0005\n\u0005 x2 \u0005 3x3\nD\n21 \u0005 3x2\n4\n\u0005 5x3\n2\nC x6\n4 :\n(29.63)\nSimilarly, we combine equation (29.62) with constraint (29.60) and with objective\nfunction (29.58) to rewrite our linear program in the following form:\n´\nD\n27\nC\nx2\n4\nC\nx3\n2\n\u0005\n3x6\n4\n(29.64)\nx1\nD\n9\n\u0005\nx2\n4\n\u0005\nx3\n2\n\u0005\nx6\n4\n(29.65)\nx4\nD\n21\n\u0005\n3x2\n4\n\u0005\n5x3\n2\nC\nx6\n4\n(29.66)\nx5\nD\n6\n\u0005\n3x2\n2\n\u0005\n4x3\nC\nx6\n2\n:\n(29.67)\nWe call this operation a pivot. As demonstrated above, a pivot chooses a nonbasic\nvariable xe, called the entering variable, and a basic variable xl, called the leaving\nvariable, and exchanges their roles.\nThe linear program described in equations (29.64)–(29.67) is equivalent to the\nlinear program described in equations (29.58)–(29.61). We perform two operations\nin the simplex algorithm: rewrite equations so that variables move between the left-\nhand side and the right-hand side, and substitute one equation into another. The ﬁrst\noperation trivially creates an equivalent problem, and the second, by elementary\nlinear algebra, also creates an equivalent problem. (See Exercise 29.3-3.)\nTo demonstrate this equivalence, observe that our original basic solution .0; 0;\n0; 30; 24; 36/ satisﬁes the new equations (29.65)–(29.67) and has objective value\n27 C .1=4/ \u0003 0 C .1=2/ \u0003 0 \u0005 .3=4/ \u0003 36 D 0. The basic solution associated with the\nnew linear program sets the nonbasic values to 0 and is .9; 0; 0; 21; 6; 0/, with ob-\njective value ´ D 27. Simple arithmetic veriﬁes that this solution also satisﬁes\nequations (29.59)–(29.61) and, when plugged into objective function (29.58), has\nobjective value .3 \u0003 9/ C .1 \u0003 0/ C .2 \u0003 0/ D 27.",
    "parent_0a1886f8-3448-4a2c-9c22-9d017bf792fc": "new linear program sets the nonbasic values to 0 and is .9; 0; 0; 21; 6; 0/, with ob-\njective value ´ D 27. Simple arithmetic veriﬁes that this solution also satisﬁes\nequations (29.59)–(29.61) and, when plugged into objective function (29.58), has\nobjective value .3 \u0003 9/ C .1 \u0003 0/ C .2 \u0003 0/ D 27.\nContinuing the example, we wish to ﬁnd a new variable whose value we wish to\nincrease. We do not want to increase x6, since as its value increases, the objective\nvalue decreases. We can attempt to increase either x2 or x3; let us choose x3. How\nfar can we increase x3 without violating any of the constraints? Constraint (29.65)\nlimits it to 18, constraint (29.66) limits it to 42=5, and constraint (29.67) limits\nit to 3=2. The third constraint is again the tightest one, and therefore we rewrite\nthe third constraint so that x3 is on the left-hand side and x5 is on the right-hand\n868\nChapter 29\nLinear Programming\nside. We then substitute this new equation, x3 D 3=2 \u0005 3x2=8 \u0005 x5=4 C x6=8, into\nequations (29.64)–(29.66) and obtain the new, but equivalent, system\n´\nD\n111\n4\nC\nx2\n16\n\u0005\nx5\n8\n\u0005\n11x6\n16\n(29.68)\nx1\nD\n33\n4\n\u0005\nx2\n16\nC\nx5\n8\n\u0005\n5x6\n16\n(29.69)\nx3\nD\n3\n2\n\u0005\n3x2\n8\n\u0005\nx5\n4\nC\nx6\n8\n(29.70)\nx4\nD\n69\n4\nC\n3x2\n16\nC\n5x5\n8\n\u0005\nx6\n16 :\n(29.71)\nThis system has the associated basic solution .33=4; 0; 3=2; 69=4; 0; 0/, with ob-\njective value 111=4. Now the only way to increase the objective value is to in-\ncrease x2. The three constraints give upper bounds of 132, 4, and 1, respectively.\n(We get an upper bound of 1 from constraint (29.71) because, as we increase x2,\nthe value of the basic variable x4 increases also. This constraint, therefore, places\nno restriction on how much we can increase x2.) We increase x2 to 4, and it be-\ncomes nonbasic. Then we solve equation (29.70) for x2 and substitute in the other\nequations to obtain\n´\nD\n28\n\u0005\nx3\n6\n\u0005\nx5\n6\n\u0005\n2x6\n3\n(29.72)\nx1\nD\n8\nC\nx3\n6\nC\nx5\n6\n\u0005\nx6\n3\n(29.73)\nx2\nD\n4\n\u0005\n8x3\n3\n\u0005\n2x5\n3\nC\nx6\n3\n(29.74)\nx4\nD\n18\n\u0005\nx3\n2\nC\nx5\n2\n:\n(29.75)",
    "parent_5b9e6535-6ad3-4688-9403-f384b6e331c3": "comes nonbasic. Then we solve equation (29.70) for x2 and substitute in the other\nequations to obtain\n´\nD\n28\n\u0005\nx3\n6\n\u0005\nx5\n6\n\u0005\n2x6\n3\n(29.72)\nx1\nD\n8\nC\nx3\n6\nC\nx5\n6\n\u0005\nx6\n3\n(29.73)\nx2\nD\n4\n\u0005\n8x3\n3\n\u0005\n2x5\n3\nC\nx6\n3\n(29.74)\nx4\nD\n18\n\u0005\nx3\n2\nC\nx5\n2\n:\n(29.75)\nAt this point, all coefﬁcients in the objective function are negative. As we shall see\nlater in this chapter, this situation occurs only when we have rewritten the linear\nprogram so that the basic solution is an optimal solution. Thus, for this problem,\nthe solution .8; 4; 0; 18; 0; 0/, with objective value 28, is optimal. We can now\nreturn to our original linear program given in (29.53)–(29.57). The only variables\nin the original linear program are x1, x2, and x3, and so our solution is x1 D 8,\nx2 D 4, and x3 D 0, with objective value .3 \u0003 8/ C .1 \u0003 4/ C .2 \u0003 0/ D 28. Note\nthat the values of the slack variables in the ﬁnal solution measure how much slack\nremains in each inequality. Slack variable x4 is 18, and in inequality (29.54), the\nleft-hand side, with value 8 C 4 C 0 D 12, is 18 less than the right-hand side of 30.\nSlack variables x5 and x6 are 0 and indeed, in inequalities (29.55) and (29.56),\nthe left-hand and right-hand sides are equal. Observe also that even though the\ncoefﬁcients in the original slack form are integral, the coefﬁcients in the other\nlinear programs are not necessarily integral, and the intermediate solutions are not\n29.3\nThe simplex algorithm\n869\nnecessarily integral. Furthermore, the ﬁnal solution to a linear program need not\nbe integral; it is purely coincidental that this example has an integral solution.\nPivoting\nWe now formalize the procedure for pivoting. The procedure PIVOT takes as in-\nput a slack form, given by the tuple .N; B; A; b; c; \u0003/, the index l of the leav-\ning variable xl, and the index e of the entering variable xe. It returns the tuple\n. yN; yB; y\nA; yb; yc; y\u0003/ describing the new slack form. (Recall again that the entries of\nthe m\tn matrices A and y",
    "parent_5bd84641-05a4-417e-b5c6-288a3f4448a6": "put a slack form, given by the tuple .N; B; A; b; c; \u0003/, the index l of the leav-\ning variable xl, and the index e of the entering variable xe. It returns the tuple\n. yN; yB; y\nA; yb; yc; y\u0003/ describing the new slack form. (Recall again that the entries of\nthe m\tn matrices A and y\nA are actually the negatives of the coefﬁcients that appear\nin the slack form.)\nPIVOT.N; B; A; b; c; \u0003; l; e/\n1\n// Compute the coefﬁcients of the equation for new basic variable xe.\n2\nlet y\nA be a new m \t n matrix\n3\nybe D bl=ale\n4\nfor each j 2 N \u0005 feg\n5\nyaej D alj=ale\n6\nyael D 1=ale\n7\n// Compute the coefﬁcients of the remaining constraints.\n8\nfor each i 2 B \u0005 flg\n9\nybi D bi \u0005 aieybe\n10\nfor each j 2 N \u0005 feg\n11\nyaij D aij \u0005 aieyaej\n12\nyail D \u0005aieyael\n13\n// Compute the objective function.\n14\ny\u0003 D \u0003 C ceybe\n15\nfor each j 2 N \u0005 feg\n16\nycj D cj \u0005 ceyaej\n17\nycl D \u0005ceyael\n18\n// Compute new sets of basic and nonbasic variables.\n19\nyN D N \u0005 feg [ flg\n20\nyB D B \u0005 flg [ feg\n21\nreturn . yN; yB; y\nA; yb; yc; y\u0003/\nPIVOT works as follows. Lines 3–6 compute the coefﬁcients in the new equation\nfor xe by rewriting the equation that has xl on the left-hand side to instead have xe\non the left-hand side. Lines 8–12 update the remaining equations by substituting\nthe right-hand side of this new equation for each occurrence of xe. Lines 14–17\ndo the same substitution for the objective function, and lines 19 and 20 update the\n870\nChapter 29\nLinear Programming\nsets of nonbasic and basic variables. Line 21 returns the new slack form. As given,\nif ale D 0, PIVOT would cause an error by dividing by 0, but as we shall see in the\nproofs of Lemmas 29.2 and 29.12, we call PIVOT only when ale ¤ 0.\nWe now summarize the effect that PIVOT has on the values of the variables in\nthe basic solution.\nLemma 29.1\nConsider a call to PIVOT.N; B; A; b; c; \u0003; l; e/ in which ale ¤ 0. Let the values\nreturned from the call be . yN; yB; y\nA; yb; yc; y\u0003/, and let Nx denote the basic solution after\nthe call. Then\n1. Nxj D 0 for each j 2 yN .",
    "parent_dcda10e5-fc43-4644-9143-e66a33580765": "the basic solution.\nLemma 29.1\nConsider a call to PIVOT.N; B; A; b; c; \u0003; l; e/ in which ale ¤ 0. Let the values\nreturned from the call be . yN; yB; y\nA; yb; yc; y\u0003/, and let Nx denote the basic solution after\nthe call. Then\n1. Nxj D 0 for each j 2 yN .\n2. Nxe D bl=ale.\n3. Nxi D bi \u0005 aieybe for each i 2 yB \u0005 feg.\nProof\nThe ﬁrst statement is true because the basic solution always sets all non-\nbasic variables to 0. When we set each nonbasic variable to 0 in a constraint\nxi D ybi \u0005\nX\nj2 y\nN\nyaijxj ;\nwe have that Nxi D ybi for each i 2 yB. Since e 2 yB, line 3 of PIVOT gives\nNxe D ybe D bl=ale ;\nwhich proves the second statement. Similarly, using line 9 for each i 2 yB \u0005 feg,\nwe have\nNxi D ybi D bi \u0005 aieybe ;\nwhich proves the third statement.\nThe formal simplex algorithm\nWe are now ready to formalize the simplex algorithm, which we demonstrated by\nexample. That example was a particularly nice one, and we could have had several\nother issues to address:\n\u0002\nHow do we determine whether a linear program is feasible?\n\u0002\nWhat do we do if the linear program is feasible, but the initial basic solution is\nnot feasible?\n\u0002\nHow do we determine whether a linear program is unbounded?\n\u0002\nHow do we choose the entering and leaving variables?\n29.3\nThe simplex algorithm\n871\nIn Section 29.5, we shall show how to determine whether a problem is feasible,\nand if so, how to ﬁnd a slack form in which the initial basic solution is feasible.\nTherefore, let us assume that we have a procedure INITIALIZE-SIMPLEX.A; b; c/\nthat takes as input a linear program in standard form, that is, an m \t n matrix\nA D .aij/, an m-vector b D .bi/, and an n-vector c D .cj/. If the problem is\ninfeasible, the procedure returns a message that the program is infeasible and then\nterminates. Otherwise, the procedure returns a slack form for which the initial\nbasic solution is feasible.\nThe procedure SIMPLEX takes as input a linear program in standard form, as just",
    "parent_140923c1-ca78-46c3-9178-6ca55e06b01f": "infeasible, the procedure returns a message that the program is infeasible and then\nterminates. Otherwise, the procedure returns a slack form for which the initial\nbasic solution is feasible.\nThe procedure SIMPLEX takes as input a linear program in standard form, as just\ndescribed. It returns an n-vector Nx D . Nxj/ that is an optimal solution to the linear\nprogram described in (29.19)–(29.21).\nSIMPLEX.A; b; c/\n1\n.N; B; A; b; c; \u0003/ D INITIALIZE-SIMPLEX.A; b; c/\n2\nlet \f be a new vector of length n\n3\nwhile some index j 2 N has cj > 0\n4\nchoose an index e 2 N for which ce > 0\n5\nfor each index i 2 B\n6\nif aie > 0\n7\n\fi D bi=aie\n8\nelse \fi D 1\n9\nchoose an index l 2 B that minimizes \fi\n10\nif \fl == 1\n11\nreturn “unbounded”\n12\nelse .N; B; A; b; c; \u0003/ D PIVOT.N; B; A; b; c; \u0003; l; e/\n13\nfor i D 1 to n\n14\nif i 2 B\n15\nNxi D bi\n16\nelse Nxi D 0\n17\nreturn . Nx1; Nx2; : : : ; Nxn/\nThe SIMPLEX procedure works as follows. In line 1, it calls the procedure\nINITIALIZE-SIMPLEX.A; b; c/, described above, which either determines that the\nlinear program is infeasible or returns a slack form for which the basic solution is\nfeasible. The while loop of lines 3–12 forms the main part of the algorithm. If all\ncoefﬁcients in the objective function are negative, then the while loop terminates.\nOtherwise, line 4 selects a variable xe, whose coefﬁcient in the objective function\nis positive, as the entering variable. Although we may choose any such variable as\nthe entering variable, we assume that we use some prespeciﬁed deterministic rule.\nNext, lines 5–9 check each constraint and pick the one that most severely limits\nthe amount by which we can increase xe without violating any of the nonnegativ-\n872\nChapter 29\nLinear Programming\nity constraints; the basic variable associated with this constraint is xl. Again, we\nare free to choose one of several variables as the leaving variable, but we assume\nthat we use some prespeciﬁed deterministic rule. If none of the constraints lim-",
    "parent_ed795e50-482d-4d54-8234-2a0089515528": "872\nChapter 29\nLinear Programming\nity constraints; the basic variable associated with this constraint is xl. Again, we\nare free to choose one of several variables as the leaving variable, but we assume\nthat we use some prespeciﬁed deterministic rule. If none of the constraints lim-\nits the amount by which the entering variable can increase, the algorithm returns\n“unbounded” in line 11. Otherwise, line 12 exchanges the roles of the entering\nand leaving variables by calling PIVOT.N; B; A; b; c; \u0003; l; e/, as described above.\nLines 13–16 compute a solution Nx1; Nx2; : : : ; Nxn for the original linear-programming\nvariables by setting all the nonbasic variables to 0 and each basic variable Nxi to bi,\nand line 17 returns these values.\nTo show that SIMPLEX is correct, we ﬁrst show that if SIMPLEX has an initial\nfeasible solution and eventually terminates, then it either returns a feasible solution\nor determines that the linear program is unbounded. Then, we show that SIMPLEX\nterminates. Finally, in Section 29.4 (Theorem 29.10) we show that the solution\nreturned is optimal.\nLemma 29.2\nGiven a linear program .A; b; c/, suppose that the call to INITIALIZE-SIMPLEX in\nline 1 of SIMPLEX returns a slack form for which the basic solution is feasible.\nThen if SIMPLEX returns a solution in line 17, that solution is a feasible solution to\nthe linear program. If SIMPLEX returns “unbounded” in line 11, the linear program\nis unbounded.\nProof\nWe use the following three-part loop invariant:\nAt the start of each iteration of the while loop of lines 3–12,\n1. the slack form is equivalent to the slack form returned by the call of\nINITIALIZE-SIMPLEX,\n2. for each i 2 B, we have bi \u0006 0, and\n3. the basic solution associated with the slack form is feasible.\nInitialization: The equivalence of the slack forms is trivial for the ﬁrst itera-\ntion. We assume, in the statement of the lemma, that the call to INITIALIZE-\nSIMPLEX in line 1 of SIMPLEX returns a slack form for which the basic solution",
    "parent_49eb6e2a-34a1-4dc4-a6ff-a199a772a256": "Initialization: The equivalence of the slack forms is trivial for the ﬁrst itera-\ntion. We assume, in the statement of the lemma, that the call to INITIALIZE-\nSIMPLEX in line 1 of SIMPLEX returns a slack form for which the basic solution\nis feasible. Thus, the third part of the invariant is true. Because the basic so-\nlution is feasible, each basic variable xi is nonnegative. Furthermore, since the\nbasic solution sets each basic variable xi to bi, we have that bi \u0006 0 for all\ni 2 B. Thus, the second part of the invariant holds.\nMaintenance: We shall show that each iteration of the while loop maintains the\nloop invariant, assuming that the return statement in line 11 does not execute.\nWe shall handle the case in which line 11 executes when we discuss termination.\n29.3\nThe simplex algorithm\n873\nAn iteration of the while loop exchanges the role of a basic and a nonbasic\nvariable by calling the PIVOT procedure. By Exercise 29.3-3, the slack form is\nequivalent to the one from the previous iteration which, by the loop invariant,\nis equivalent to the initial slack form.\nWe now demonstrate the second part of the loop invariant. We assume that at\nthe start of each iteration of the while loop, bi \u0006 0 for each i 2 B, and we shall\nshow that these inequalities remain true after the call to PIVOT in line 12. Since\nthe only changes to the variables bi and the set B of basic variables occur in this\nassignment, it sufﬁces to show that line 12 maintains this part of the invariant.\nWe let bi, aij, and B refer to values before the call of PIVOT, and ybi refer to\nvalues returned from PIVOT.\nFirst, we observe that ybe \u0006 0 because bl \u0006 0 by the loop invariant, ale > 0 by\nlines 6 and 9 of SIMPLEX, and ybe D bl=ale by line 3 of PIVOT.\nFor the remaining indices i 2 B \u0005 flg, we have that\nybi\nD\nbi \u0005 aieybe\n(by line 9 of PIVOT)\nD\nbi \u0005 aie.bl=ale/\n(by line 3 of PIVOT) .\n(29.76)\nWe have two cases to consider, depending on whether aie > 0 or aie \u0002 0.\nIf aie > 0, then since we chose l such that",
    "parent_88a4bfd4-dc9d-4051-a5ff-6ec3b5a7b108": "For the remaining indices i 2 B \u0005 flg, we have that\nybi\nD\nbi \u0005 aieybe\n(by line 9 of PIVOT)\nD\nbi \u0005 aie.bl=ale/\n(by line 3 of PIVOT) .\n(29.76)\nWe have two cases to consider, depending on whether aie > 0 or aie \u0002 0.\nIf aie > 0, then since we chose l such that\nbl=ale \u0002 bi=aie\nfor all i 2 B ;\n(29.77)\nwe have\nybi\nD\nbi \u0005 aie.bl=ale/\n(by equation (29.76))\n\u0006\nbi \u0005 aie.bi=aie/\n(by inequality (29.77))\nD\nbi \u0005 bi\nD\n0 ;\nand thus ybi \u0006 0. If aie \u0002 0, then because ale, bi, and bl are all nonnegative,\nequation (29.76) implies that ybi must be nonnegative, too.\nWe now argue that the basic solution is feasible, i.e., that all variables have non-\nnegative values. The nonbasic variables are set to 0 and thus are nonnegative.\nEach basic variable xi is deﬁned by the equation\nxi D bi \u0005\nX\nj2N\naijxj :\nThe basic solution sets Nxi D bi. Using the second part of the loop invariant, we\nconclude that each basic variable Nxi is nonnegative.\n874\nChapter 29\nLinear Programming\nTermination: The while loop can terminate in one of two ways. If it terminates\nbecause of the condition in line 3, then the current basic solution is feasible and\nline 17 returns this solution. The other way it terminates is by returning “un-\nbounded” in line 11. In this case, for each iteration of the for loop in lines 5–8,\nwhen line 6 is executed, we ﬁnd that aie \u0002 0. Consider the solution Nx deﬁned as\nNxi D\n\u0002\n1\nif i D e ;\n0\nif i 2 N \u0005 feg ;\nbi \u0005 P\nj2N aij Nxj\nif i 2 B :\nWe now show that this solution is feasible, i.e., that all variables are nonneg-\native. The nonbasic variables other than Nxe are 0, and Nxe D 1 > 0; thus all\nnonbasic variables are nonnegative. For each basic variable Nxi, we have\nNxi\nD\nbi \u0005\nX\nj2N\naij Nxj\nD\nbi \u0005 aie Nxe :\nThe loop invariant implies that bi \u0006 0, and we have aie \u0002 0 and Nxe D 1 > 0.\nThus, Nxi \u0006 0.\nNow we show that the objective value for the solution Nx is unbounded. From\nequation (29.42), the objective value is\n´\nD\n\u0003 C\nX\nj2N\ncj Nxj\nD\n\u0003 C ce Nxe :",
    "parent_4b2553c4-80ec-4429-a828-267c29b3028f": "Nxi\nD\nbi \u0005\nX\nj2N\naij Nxj\nD\nbi \u0005 aie Nxe :\nThe loop invariant implies that bi \u0006 0, and we have aie \u0002 0 and Nxe D 1 > 0.\nThus, Nxi \u0006 0.\nNow we show that the objective value for the solution Nx is unbounded. From\nequation (29.42), the objective value is\n´\nD\n\u0003 C\nX\nj2N\ncj Nxj\nD\n\u0003 C ce Nxe :\nSince ce > 0 (by line 4 of SIMPLEX) and Nxe D 1, the objective value is 1,\nand thus the linear program is unbounded.\nIt remains to show that SIMPLEX terminates, and when it does terminate, the\nsolution it returns is optimal. Section 29.4 will address optimality. We now discuss\ntermination.\nTermination\nIn the example given in the beginning of this section, each iteration of the simplex\nalgorithm increased the objective value associated with the basic solution. As Ex-\nercise 29.3-2 asks you to show, no iteration of SIMPLEX can decrease the objective\nvalue associated with the basic solution. Unfortunately, it is possible that an itera-\ntion leaves the objective value unchanged. This phenomenon is called degeneracy,\nand we shall now study it in greater detail.\n29.3\nThe simplex algorithm\n875\nThe assignment in line 14 of PIVOT, y\u0003 D \u0003 C ceybe, changes the objective value.\nSince SIMPLEX calls PIVOT only when ce > 0, the only way for the objective\nvalue to remain unchanged (i.e., y\u0003 D \u0003) is for ybe to be 0. This value is assigned\nas ybe D bl=ale in line 3 of PIVOT. Since we always call PIVOT with ale ¤ 0, we\nsee that for ybe to equal 0, and hence the objective value to be unchanged, we must\nhave bl D 0.\nIndeed, this situation can occur. Consider the linear program\n´\nD\nx1\nC\nx2\nC\nx3\nx4\nD\n8\n\u0005\nx1\n\u0005\nx2\nx5\nD\nx2\n\u0005\nx3 :\nSuppose that we choose x1 as the entering variable and x4 as the leaving variable.\nAfter pivoting, we obtain\n´\nD\n8\nC\nx3\n\u0005\nx4\nx1\nD\n8\n\u0005\nx2\n\u0005\nx4\nx5\nD\nx2\n\u0005\nx3\n:\nAt this point, our only choice is to pivot with x3 entering and x5 leaving. Since\nb5 D 0, the objective value of 8 remains unchanged after pivoting:\n´\nD\n8\nC\nx2\n\u0005\nx4\n\u0005\nx5\nx1\nD\n8\n\u0005\nx2\n\u0005\nx4\nx3\nD\nx2\n\u0005\nx5 :",
    "parent_962fa40e-8a58-454d-b493-8dc448396cec": "After pivoting, we obtain\n´\nD\n8\nC\nx3\n\u0005\nx4\nx1\nD\n8\n\u0005\nx2\n\u0005\nx4\nx5\nD\nx2\n\u0005\nx3\n:\nAt this point, our only choice is to pivot with x3 entering and x5 leaving. Since\nb5 D 0, the objective value of 8 remains unchanged after pivoting:\n´\nD\n8\nC\nx2\n\u0005\nx4\n\u0005\nx5\nx1\nD\n8\n\u0005\nx2\n\u0005\nx4\nx3\nD\nx2\n\u0005\nx5 :\nThe objective value has not changed, but our slack form has. Fortunately, if we\npivot again, with x2 entering and x1 leaving, the objective value increases (to 16),\nand the simplex algorithm can continue.\nDegeneracy can prevent the simplex algorithm from terminating, because it can\nlead to a phenomenon known as cycling: the slack forms at two different itera-\ntions of SIMPLEX are identical. Because of degeneracy, SIMPLEX could choose a\nsequence of pivot operations that leave the objective value unchanged but repeat\na slack form within the sequence. Since SIMPLEX is a deterministic algorithm, if\nit cycles, then it will cycle through the same series of slack forms forever, never\nterminating.\nCycling is the only reason that SIMPLEX might not terminate. To show this fact,\nwe must ﬁrst develop some additional machinery.\nAt each iteration, SIMPLEX maintains A, b, c, and \u0003 in addition to the sets\nN and B. Although we need to explicitly maintain A, b, c, and \u0003 in order to\nimplement the simplex algorithm efﬁciently, we can get by without maintaining\nthem. In other words, the sets of basic and nonbasic variables sufﬁce to uniquely\ndetermine the slack form. Before proving this fact, we prove a useful algebraic\nlemma.\n876\nChapter 29\nLinear Programming\nLemma 29.3\nLet I be a set of indices. For each j 2 I, let ˛j and ˇj be real numbers, and let xj\nbe a real-valued variable. Let \n be any real number. Suppose that for any settings\nof the xj, we have\nX\nj2I\n˛jxj D \n C\nX\nj2I\nˇjxj :\n(29.78)\nThen ˛j D ˇj for each j 2 I, and \n D 0.\nProof\nSince equation (29.78) holds for any values of the xj, we can use particular\nvalues to draw conclusions about ˛, ˇ, and \n. If we let xj D 0 for each j 2 I,\nwe conclude that",
    "parent_db8ae75a-ebcc-45c6-a5e4-0350c7440441": "of the xj, we have\nX\nj2I\n˛jxj D \n C\nX\nj2I\nˇjxj :\n(29.78)\nThen ˛j D ˇj for each j 2 I, and \n D 0.\nProof\nSince equation (29.78) holds for any values of the xj, we can use particular\nvalues to draw conclusions about ˛, ˇ, and \n. If we let xj D 0 for each j 2 I,\nwe conclude that \n D 0. Now pick an arbitrary index j 2 I, and set xj D 1 and\nxk D 0 for all k ¤ j . Then we must have ˛j D ˇj. Since we picked j as any\nindex in I, we conclude that ˛j D ˇj for each j 2 I.\nA particular linear program has many different slack forms; recall that each slack\nform has the same set of feasible and optimal solutions as the original linear pro-\ngram. We now show that the slack form of a linear program is uniquely determined\nby the set of basic variables. That is, given the set of basic variables, a unique slack\nform (unique set of coefﬁcients and right-hand sides) is associated with those basic\nvariables.\nLemma 29.4\nLet .A; b; c/ be a linear program in standard form. Given a set B of basic variables,\nthe associated slack form is uniquely determined.\nProof\nAssume for the purpose of contradiction that there are two different slack\nforms with the same set B of basic variables. The slack forms must also have\nidentical sets N D f1; 2; : : : ; n C mg \u0005 B of nonbasic variables. We write the ﬁrst\nslack form as\n´\nD\n\u0003 C\nX\nj2N\ncjxj\n(29.79)\nxi\nD\nbi \u0005\nX\nj2N\naijxj for i 2 B ;\n(29.80)\nand the second as\n´\nD\n\u00030 C\nX\nj2N\nc0\njxj\n(29.81)\nxi\nD\nb0\ni \u0005\nX\nj2N\na0\nijxj for i 2 B :\n(29.82)\n29.3\nThe simplex algorithm\n877\nConsider the system of equations formed by subtracting each equation in\nline (29.82) from the corresponding equation in line (29.80). The resulting sys-\ntem is\n0 D .bi \u0005 b0\ni/ \u0005\nX\nj2N\n.aij \u0005 a0\nij/xj\nfor i 2 B\nor, equivalently,\nX\nj2N\naijxj D .bi \u0005 b0\ni/ C\nX\nj2N\na0\nijxj\nfor i 2 B :\nNow, for each i 2 B, apply Lemma 29.3 with ˛j D aij, ˇj D a0\nij, \n D bi \u0005b0\ni, and\nI D N . Since ˛i D ˇi, we have that aij D a0\nij for each j 2 N , and since \n D 0,\nwe have that bi D b0",
    "parent_d33cef91-ff6e-41dd-9632-1c1531fc1b4c": "i/ \u0005\nX\nj2N\n.aij \u0005 a0\nij/xj\nfor i 2 B\nor, equivalently,\nX\nj2N\naijxj D .bi \u0005 b0\ni/ C\nX\nj2N\na0\nijxj\nfor i 2 B :\nNow, for each i 2 B, apply Lemma 29.3 with ˛j D aij, ˇj D a0\nij, \n D bi \u0005b0\ni, and\nI D N . Since ˛i D ˇi, we have that aij D a0\nij for each j 2 N , and since \n D 0,\nwe have that bi D b0\ni. Thus, for the two slack forms, A and b are identical to A0\nand b0. Using a similar argument, Exercise 29.3-1 shows that it must also be the\ncase that c D c0 and \u0003 D \u00030, and hence that the slack forms must be identical.\nWe can now show that cycling is the only possible reason that SIMPLEX might\nnot terminate.\nLemma 29.5\nIf SIMPLEX fails to terminate in at most\n\u000bnCm\nm\n\f\niterations, then it cycles.\nProof\nBy Lemma 29.4, the set B of basic variables uniquely determines a slack\nform. There are n C m variables and jBj D m, and therefore, there are at most\n\u000bnCm\nm\n\f\nways to choose B. Thus, there are only at most\n\u000bnCm\nm\n\f\nunique slack forms.\nTherefore, if SIMPLEX runs for more than\n\u000bnCm\nm\n\f\niterations, it must cycle.\nCycling is theoretically possible, but extremely rare. We can prevent it by choos-\ning the entering and leaving variables somewhat more carefully. One option is to\nperturb the input slightly so that it is impossible to have two solutions with the\nsame objective value. Another option is to break ties by always choosing the vari-\nable with the smallest index, a strategy known as Bland’s rule. We omit the proof\nthat these strategies avoid cycling.\nLemma 29.6\nIf lines 4 and 9 of SIMPLEX always break ties by choosing the variable with the\nsmallest index, then SIMPLEX must terminate.\nWe conclude this section with the following lemma.\n878\nChapter 29\nLinear Programming\nLemma 29.7\nAssuming that INITIALIZE-SIMPLEX returns a slack form for which the basic so-\nlution is feasible, SIMPLEX either reports that a linear program is unbounded, or it\nterminates with a feasible solution in at most\n\u000bnCm\nm\n\f\niterations.\nProof",
    "parent_f7a55e95-79f4-4554-818a-50c6c53b1ac3": "878\nChapter 29\nLinear Programming\nLemma 29.7\nAssuming that INITIALIZE-SIMPLEX returns a slack form for which the basic so-\nlution is feasible, SIMPLEX either reports that a linear program is unbounded, or it\nterminates with a feasible solution in at most\n\u000bnCm\nm\n\f\niterations.\nProof\nLemmas 29.2 and 29.6 show that if INITIALIZE-SIMPLEX returns a slack\nform for which the basic solution is feasible, SIMPLEX either reports that a linear\nprogram is unbounded, or it terminates with a feasible solution. By the contra-\npositive of Lemma 29.5, if SIMPLEX terminates with a feasible solution, then it\nterminates in at most\n\u000bnCm\nm\n\f\niterations.\nExercises\n29.3-1\nComplete the proof of Lemma 29.4 by showing that it must be the case that c D c0\nand \u0003 D \u00030.\n29.3-2\nShow that the call to PIVOT in line 12 of SIMPLEX never decreases the value of \u0003.\n29.3-3\nProve that the slack form given to the PIVOT procedure and the slack form that the\nprocedure returns are equivalent.\n29.3-4\nSuppose we convert a linear program .A; b; c/ in standard form to slack form.\nShow that the basic solution is feasible if and only if bi \u0006 0 for i D 1; 2; : : : ; m.\n29.3-5\nSolve the following linear program using SIMPLEX:\nmaximize\n18x1\nC\n12:5x2\nsubject to\nx1\nC\nx2\n\u0002\n20\nx1\n\u0002\n12\nx2\n\u0002\n16\nx1; x2\n\u0006\n0 :\n29.4\nDuality\n879\n29.3-6\nSolve the following linear program using SIMPLEX:\nmaximize\n5x1\n\u0005\n3x2\nsubject to\nx1\n\u0005\nx2\n\u0002\n1\n2x1\nC\nx2\n\u0002\n2\nx1; x2\n\u0006\n0 :\n29.3-7\nSolve the following linear program using SIMPLEX:\nminimize\nx1\nC\nx2\nC\nx3\nsubject to\n2x1\nC\n7:5x2\nC\n3x3\n\u0006\n10000\n20x1\nC\n5x2\nC\n10x3\n\u0006\n30000\nx1; x2; x3\n\u0006\n0 :\n29.3-8\nIn the proof of Lemma 29.5, we argued that there are at most\n\u000bmCn\nn\n\f\nways to choose\na set B of basic variables. Give an example of a linear program in which there are\nstrictly fewer than\n\u000bmCn\nn\n\f\nways to choose the set B.\n29.4\nDuality\nWe have proven that, under certain assumptions, SIMPLEX terminates. We have not\nyet shown that it actually ﬁnds an optimal solution to a linear program, however.",
    "parent_308c58f5-38e0-4ecf-9a69-527efe3ebace": "strictly fewer than\n\u000bmCn\nn\n\f\nways to choose the set B.\n29.4\nDuality\nWe have proven that, under certain assumptions, SIMPLEX terminates. We have not\nyet shown that it actually ﬁnds an optimal solution to a linear program, however.\nIn order to do so, we introduce a powerful concept called linear-programming\nduality.\nDuality enables us to prove that a solution is indeed optimal. We saw an exam-\nple of duality in Chapter 26 with Theorem 26.6, the max-ﬂow min-cut theorem.\nSuppose that, given an instance of a maximum-ﬂow problem, we ﬁnd a ﬂow f\nwith value jf j. How do we know whether f is a maximum ﬂow? By the max-ﬂow\nmin-cut theorem, if we can ﬁnd a cut whose value is also jf j, then we have ver-\niﬁed that f is indeed a maximum ﬂow. This relationship provides an example of\nduality: given a maximization problem, we deﬁne a related minimization problem\nsuch that the two problems have the same optimal objective values.\nGiven a linear program in which the objective is to maximize, we shall describe\nhow to formulate a dual linear program in which the objective is to minimize and\n880\nChapter 29\nLinear Programming\nwhose optimal value is identical to that of the original linear program. When refer-\nring to dual linear programs, we call the original linear program the primal.\nGiven a primal linear program in standard form, as in (29.16)–(29.18), we deﬁne\nthe dual linear program as\nminimize\nm\nX\niD1\nbiyi\n(29.83)\nsubject to\nm\nX\niD1\naijyi\n\u0006\ncj\nfor j D 1; 2; : : : ; n ;\n(29.84)\nyi\n\u0006\n0\nfor i D 1; 2; : : : ; m :\n(29.85)\nTo form the dual, we change the maximization to a minimization, exchange the\nroles of coefﬁcients on the right-hand sides and the objective function, and replace\neach less-than-or-equal-to by a greater-than-or-equal-to. Each of the m constraints\nin the primal has an associated variable yi in the dual, and each of the n constraints\nin the dual has an associated variable xj in the primal. For example, consider the",
    "parent_e33abdb8-69ee-4cc8-8417-29bea017ac1e": "each less-than-or-equal-to by a greater-than-or-equal-to. Each of the m constraints\nin the primal has an associated variable yi in the dual, and each of the n constraints\nin the dual has an associated variable xj in the primal. For example, consider the\nlinear program given in (29.53)–(29.57). The dual of this linear program is\nminimize\n30y1\nC\n24y2\nC\n36y3\n(29.86)\nsubject to\ny1\nC\n2y2\nC\n4y3\n\u0006\n3\n(29.87)\ny1\nC\n2y2\nC\ny3\n\u0006\n1\n(29.88)\n3y1\nC\n5y2\nC\n2y3\n\u0006\n2\n(29.89)\ny1; y2; y3\n\u0006\n0 :\n(29.90)\nWe shall show in Theorem 29.10 that the optimal value of the dual linear pro-\ngram is always equal to the optimal value of the primal linear program. Further-\nmore, the simplex algorithm actually implicitly solves both the primal and the dual\nlinear programs simultaneously, thereby providing a proof of optimality.\nWe begin by demonstrating weak duality, which states that any feasible solu-\ntion to the primal linear program has a value no greater than that of any feasible\nsolution to the dual linear program.\nLemma 29.8 (Weak linear-programming duality)\nLet Nx be any feasible solution to the primal linear program in (29.16)–(29.18) and\nlet Ny be any feasible solution to the dual linear program in (29.83)–(29.85). Then,\nwe have\nn\nX\njD1\ncj Nxj \u0002\nm\nX\niD1\nbi Nyi :\n29.4\nDuality\n881\nProof\nWe have\nn\nX\njD1\ncj Nxj\n\u0002\nn\nX\njD1\n m\nX\niD1\naij Nyi\n!\nNxj\n(by inequalities (29.84))\nD\nm\nX\niD1\n n\nX\njD1\naij Nxj\n!\nNyi\n\u0002\nm\nX\niD1\nbi Nyi\n(by inequalities (29.17)) .\nCorollary 29.9\nLet Nx be a feasible solution to a primal linear program .A; b; c/, and let Ny be a\nfeasible solution to the corresponding dual linear program. If\nn\nX\njD1\ncj Nxj D\nm\nX\niD1\nbi Nyi ;\nthen Nx and Ny are optimal solutions to the primal and dual linear programs, respec-\ntively.\nProof\nBy Lemma 29.8, the objective value of a feasible solution to the primal\ncannot exceed that of a feasible solution to the dual. The primal linear program is\na maximization problem and the dual is a minimization problem. Thus, if feasible",
    "parent_74d57543-afaf-4595-9573-f10239cf6357": "tively.\nProof\nBy Lemma 29.8, the objective value of a feasible solution to the primal\ncannot exceed that of a feasible solution to the dual. The primal linear program is\na maximization problem and the dual is a minimization problem. Thus, if feasible\nsolutions Nx and Ny have the same objective value, neither can be improved.\nBefore proving that there always is a dual solution whose value is equal to that\nof an optimal primal solution, we describe how to ﬁnd such a solution. When\nwe ran the simplex algorithm on the linear program in (29.53)–(29.57), the ﬁnal\niteration yielded the slack form (29.72)–(29.75) with objective ´ D 28 \u0005 x3=6 \u0005\nx5=6\u00052x6=3, B D f1; 2; 4g, and N D f3; 5; 6g. As we shall show below, the basic\nsolution associated with the ﬁnal slack form is indeed an optimal solution to the\nlinear program; an optimal solution to linear program (29.53)–(29.57) is therefore\n. Nx1; Nx2; Nx3/ D .8; 4; 0/, with objective value .3 \u0003 8/ C .1 \u0003 4/ C .2 \u0003 0/ D 28. As\nwe also show below, we can read off an optimal dual solution: the negatives of the\ncoefﬁcients of the primal objective function are the values of the dual variables.\nMore precisely, suppose that the last slack form of the primal is\n´\nD\n\u00030 C\nX\nj2N\nc0\njxj\nxi\nD\nb0\ni \u0005\nX\nj2N\na0\nijxj\nfor i 2 B :\n882\nChapter 29\nLinear Programming\nThen, to produce an optimal dual solution, we set\nNyi D\n(\n\u0005c0\nnCi\nif .n C i/ 2 N ;\n0\notherwise :\n(29.91)\nThus, an optimal solution to the dual linear program deﬁned in (29.86)–(29.90)\nis Ny1 D 0 (since n C 1 D 4 2 B), Ny2 D \u0005c0\n5 D 1=6, and Ny3 D \u0005c0\n6 D 2=3.\nEvaluating the dual objective function (29.86), we obtain an objective value of\n.30 \u0003 0/ C .24 \u0003 .1=6// C .36 \u0003 .2=3// D 28, which conﬁrms that the objective value\nof the primal is indeed equal to the objective value of the dual. Combining these\ncalculations with Lemma 29.8 yields a proof that the optimal objective value of the\nprimal linear program is 28. We now show that this approach applies in general:",
    "parent_97447fec-95c6-40ef-8150-6a2ea51bb6ad": "of the primal is indeed equal to the objective value of the dual. Combining these\ncalculations with Lemma 29.8 yields a proof that the optimal objective value of the\nprimal linear program is 28. We now show that this approach applies in general:\nwe can ﬁnd an optimal solution to the dual and simultaneously prove that a solution\nto the primal is optimal.\nTheorem 29.10 (Linear-programming duality)\nSuppose that SIMPLEX returns values Nx D . Nx1; Nx2; : : : ; Nxn/ for the primal lin-\near program .A; b; c/. Let N and B denote the nonbasic and basic variables for\nthe ﬁnal slack form, let c0 denote the coefﬁcients in the ﬁnal slack form, and let\nNy D . Ny1; Ny2; : : : ; Nym/ be deﬁned by equation (29.91). Then Nx is an optimal so-\nlution to the primal linear program, Ny is an optimal solution to the dual linear\nprogram, and\nn\nX\njD1\ncj Nxj D\nm\nX\niD1\nbi Nyi :\n(29.92)\nProof\nBy Corollary 29.9, if we can ﬁnd feasible solutions Nx and Ny that satisfy\nequation (29.92), then Nx and Ny must be optimal primal and dual solutions. We\nshall now show that the solutions Nx and Ny described in the statement of the theorem\nsatisfy equation (29.92).\nSuppose that we run SIMPLEX on a primal linear program, as given in lines\n(29.16)–(29.18). The algorithm proceeds through a series of slack forms until it\nterminates with a ﬁnal slack form with objective function\n´ D \u00030 C\nX\nj2N\nc0\njxj :\n(29.93)\nSince SIMPLEX terminated with a solution, by the condition in line 3 we know that\nc0\nj \u0002 0 for all j 2 N :\n(29.94)\n29.4\nDuality\n883\nIf we deﬁne\nc0\nj D 0 for all j 2 B ;\n(29.95)\nwe can rewrite equation (29.93) as\n´ D \u00030 C\nX\nj2N\nc0\njxj\nD \u00030 C\nX\nj2N\nc0\njxj C\nX\nj2B\nc0\njxj (because c0\nj D 0 if j 2 B)\nD \u00030 C\nnCm\nX\njD1\nc0\njxj\n(because N [ B D f1; 2; : : : ; n C mg) .\n(29.96)\nFor the basic solution Nx associated with this ﬁnal slack form, Nxj D 0 for all j 2 N,\nand ´ D \u00030. Since all slack forms are equivalent, if we evaluate the original objec-\ntive function on Nx, we must obtain the same objective value:\nn\nX",
    "parent_e3de1610-494b-4f32-892a-8131a6e34309": "jD1\nc0\njxj\n(because N [ B D f1; 2; : : : ; n C mg) .\n(29.96)\nFor the basic solution Nx associated with this ﬁnal slack form, Nxj D 0 for all j 2 N,\nand ´ D \u00030. Since all slack forms are equivalent, if we evaluate the original objec-\ntive function on Nx, we must obtain the same objective value:\nn\nX\njD1\ncj Nxj\nD\n\u00030 C\nnCm\nX\njD1\nc0\nj Nxj\n(29.97)\nD\n\u00030 C\nX\nj2N\nc0\nj Nxj C\nX\nj2B\nc0\nj Nxj\nD\n\u00030 C\nX\nj2N\n.c0\nj \u0003 0/ C\nX\nj2B\n.0 \u0003 Nxj/\n(29.98)\nD\n\u00030 :\nWe shall now show that Ny, deﬁned by equation (29.91), is feasible for the dual\nlinear program and that its objective value Pm\niD1 bi Nyi equals Pn\njD1 cj Nxj. Equa-\ntion (29.97) says that the ﬁrst and last slack forms, evaluated at Nx, are equal. More\ngenerally, the equivalence of all slack forms implies that for any set of values\nx D .x1; x2; : : : ; xn/, we have\nn\nX\njD1\ncjxj D \u00030 C\nnCm\nX\njD1\nc0\njxj :\nTherefore, for any particular set of values Nx D . Nx1; Nx2; : : : ; Nxn/, we have\n884\nChapter 29\nLinear Programming\nn\nX\njD1\ncj Nxj\nD\n\u00030 C\nnCm\nX\njD1\nc0\nj Nxj\nD\n\u00030 C\nn\nX\njD1\nc0\nj Nxj C\nnCm\nX\njDnC1\nc0\nj Nxj\nD\n\u00030 C\nn\nX\njD1\nc0\nj Nxj C\nm\nX\niD1\nc0\nnCi NxnCi\nD\n\u00030 C\nn\nX\njD1\nc0\nj Nxj C\nm\nX\niD1\n.\u0005 Nyi/ NxnCi\n(by equations (29.91) and (29.95))\nD\n\u00030 C\nn\nX\njD1\nc0\nj Nxj C\nm\nX\niD1\n.\u0005 Nyi/\n \nbi \u0005\nn\nX\njD1\naij Nxj\n!\n(by equation (29.32))\nD\n\u00030 C\nn\nX\njD1\nc0\nj Nxj \u0005\nm\nX\niD1\nbi Nyi C\nm\nX\niD1\nn\nX\njD1\n.aij Nxj/ Nyi\nD\n\u00030 C\nn\nX\njD1\nc0\nj Nxj \u0005\nm\nX\niD1\nbi Nyi C\nn\nX\njD1\nm\nX\niD1\n.aij Nyi/ Nxj\nD\n \n\u00030 \u0005\nm\nX\niD1\nbi Nyi\n!\nC\nn\nX\njD1\n \nc0\nj C\nm\nX\niD1\naij Nyi\n!\nNxj ;\nso that\nn\nX\njD1\ncj Nxj D\n \n\u00030 \u0005\nm\nX\niD1\nbi Nyi\n!\nC\nn\nX\njD1\n \nc0\nj C\nm\nX\niD1\naij Nyi\n!\nNxj :\n(29.99)\nApplying Lemma 29.3 to equation (29.99), we obtain\n\u00030 \u0005\nm\nX\niD1\nbi Nyi\nD\n0 ;\n(29.100)\nc0\nj C\nm\nX\niD1\naij Nyi\nD\ncj\nfor j D 1; 2; : : : ; n :\n(29.101)\nBy equation (29.100), we have that Pm\niD1 bi Nyi D \u00030, and hence the objective value\nof the dual\n\u0004Pm\niD1 bi Nyi\n\u0005\nis equal to that of the primal (\u00030). It remains to show\n29.4\nDuality\n885",
    "parent_e5249c2f-2bb8-4dd5-b573-d57ea67d832d": "\u00030 \u0005\nm\nX\niD1\nbi Nyi\nD\n0 ;\n(29.100)\nc0\nj C\nm\nX\niD1\naij Nyi\nD\ncj\nfor j D 1; 2; : : : ; n :\n(29.101)\nBy equation (29.100), we have that Pm\niD1 bi Nyi D \u00030, and hence the objective value\nof the dual\n\u0004Pm\niD1 bi Nyi\n\u0005\nis equal to that of the primal (\u00030). It remains to show\n29.4\nDuality\n885\nthat the solution Ny is feasible for the dual problem. From inequalities (29.94) and\nequations (29.95), we have that c0\nj \u0002 0 for all j D 1; 2; : : : ; n C m. Hence, for any\nj D 1; 2; : : : ; n, equations (29.101) imply that\ncj\nD\nc0\nj C\nm\nX\niD1\naij Nyi\n\u0002\nm\nX\niD1\naij Nyi ;\nwhich satisﬁes the constraints (29.84) of the dual. Finally, since c0\nj \u0002 0 for each\nj 2 N [B, when we set Ny according to equation (29.91), we have that each Nyi \u0006 0,\nand so the nonnegativity constraints are satisﬁed as well.\nWe have shown that, given a feasible linear program, if INITIALIZE-SIMPLEX\nreturns a feasible solution, and if SIMPLEX terminates without returning “un-\nbounded,” then the solution returned is indeed an optimal solution. We have also\nshown how to construct an optimal solution to the dual linear program.\nExercises\n29.4-1\nFormulate the dual of the linear program given in Exercise 29.3-5.\n29.4-2\nSuppose that we have a linear program that is not in standard form. We could\nproduce the dual by ﬁrst converting it to standard form, and then taking the dual.\nIt would be more convenient, however, to be able to produce the dual directly.\nExplain how we can directly take the dual of an arbitrary linear program.\n29.4-3\nWrite down the dual of the maximum-ﬂow linear program, as given in lines\n(29.47)–(29.50) on page 860.\nExplain how to interpret this formulation as a\nminimum-cut problem.\n29.4-4\nWrite down the dual of the minimum-cost-ﬂow linear program, as given in lines\n(29.51)–(29.52) on page 862. Explain how to interpret this problem in terms of\ngraphs and ﬂows.\n29.4-5\nShow that the dual of the dual of a linear program is the primal linear program.\n886\nChapter 29\nLinear Programming\n29.4-6",
    "parent_d76c4e56-3b68-4ee8-8758-5d22a5ebd224": "(29.51)–(29.52) on page 862. Explain how to interpret this problem in terms of\ngraphs and ﬂows.\n29.4-5\nShow that the dual of the dual of a linear program is the primal linear program.\n886\nChapter 29\nLinear Programming\n29.4-6\nWhich result from Chapter 26 can be interpreted as weak duality for the maximum-\nﬂow problem?\n29.5\nThe initial basic feasible solution\nIn this section, we ﬁrst describe how to test whether a linear program is feasible,\nand if it is, how to produce a slack form for which the basic solution is feasible.\nWe conclude by proving the fundamental theorem of linear programming, which\nsays that the SIMPLEX procedure always produces the correct result.\nFinding an initial solution\nIn Section 29.3, we assumed that we had a procedure INITIALIZE-SIMPLEX that\ndetermines whether a linear program has any feasible solutions, and if it does, gives\na slack form for which the basic solution is feasible. We describe this procedure\nhere.\nA linear program can be feasible, yet the initial basic solution might not be\nfeasible. Consider, for example, the following linear program:\nmaximize\n2x1\n\u0005\nx2\n(29.102)\nsubject to\n2x1\n\u0005\nx2\n\u0002\n2\n(29.103)\nx1\n\u0005\n5x2\n\u0002\n\u00054\n(29.104)\nx1; x2\n\u0006\n0 :\n(29.105)\nIf we were to convert this linear program to slack form, the basic solution would\nset x1 D 0 and x2 D 0. This solution violates constraint (29.104), and so it is not a\nfeasible solution. Thus, INITIALIZE-SIMPLEX cannot just return the obvious slack\nform. In order to determine whether a linear program has any feasible solutions,\nwe will formulate an auxiliary linear program. For this auxiliary linear program,\nwe can ﬁnd (with a little work) a slack form for which the basic solution is feasible.\nFurthermore, the solution of this auxiliary linear program determines whether the\ninitial linear program is feasible and if so, it provides a feasible solution with which\nwe can initialize SIMPLEX.\nLemma 29.11\nLet L be a linear program in standard form, given as in (29.16)–(29.18). Let x0 be",
    "parent_533301c2-3a17-46ab-bf25-508c1cf23c24": "Furthermore, the solution of this auxiliary linear program determines whether the\ninitial linear program is feasible and if so, it provides a feasible solution with which\nwe can initialize SIMPLEX.\nLemma 29.11\nLet L be a linear program in standard form, given as in (29.16)–(29.18). Let x0 be\na new variable, and let Laux be the following linear program with n C 1 variables:\n29.5\nThe initial basic feasible solution\n887\nmaximize\n\u0005x0\n(29.106)\nsubject to\nn\nX\njD1\naijxj \u0005 x0\n\u0002\nbi\nfor i D 1; 2; : : : ; m ;\n(29.107)\nxj\n\u0006\n0\nfor j D 0; 1; : : : ; n :\n(29.108)\nThen L is feasible if and only if the optimal objective value of Laux is 0.\nProof\nSuppose that L has a feasible solution Nx D . Nx1; Nx2; : : : ; Nxn/. Then the\nsolution Nx0 D 0 combined with Nx is a feasible solution to Laux with objective\nvalue 0. Since x0 \u0006 0 is a constraint of Laux and the objective function is to\nmaximize \u0005x0, this solution must be optimal for Laux.\nConversely, suppose that the optimal objective value of Laux is 0. Then Nx0 D 0,\nand the remaining solution values of Nx satisfy the constraints of L.\nWe now describe our strategy to ﬁnd an initial basic feasible solution for a linear\nprogram L in standard form:\nINITIALIZE-SIMPLEX.A; b; c/\n1\nlet k be the index of the minimum bi\n2\nif bk \u0006 0\n// is the initial basic solution feasible?\n3\nreturn .f1; 2; : : : ; ng ; fn C 1; n C 2; : : : ; n C mg ; A; b; c; 0/\n4\nform Laux by adding \u0005x0 to the left-hand side of each constraint\nand setting the objective function to \u0005x0\n5\nlet .N; B; A; b; c; \u0003/ be the resulting slack form for Laux\n6\nl D n C k\n7\n// Laux has n C 1 nonbasic variables and m basic variables.\n8\n.N; B; A; b; c; \u0003/ D PIVOT.N; B; A; b; c; \u0003; l; 0/\n9\n// The basic solution is now feasible for Laux.\n10\niterate the while loop of lines 3–12 of SIMPLEX until an optimal solution\nto Laux is found\n11\nif the optimal solution to Laux sets Nx0 to 0\n12\nif Nx0 is basic\n13\nperform one (degenerate) pivot to make it nonbasic\n14",
    "parent_0632db0c-deca-4b17-93c7-cbb6ee7231ff": "9\n// The basic solution is now feasible for Laux.\n10\niterate the while loop of lines 3–12 of SIMPLEX until an optimal solution\nto Laux is found\n11\nif the optimal solution to Laux sets Nx0 to 0\n12\nif Nx0 is basic\n13\nperform one (degenerate) pivot to make it nonbasic\n14\nfrom the ﬁnal slack form of Laux, remove x0 from the constraints and\nrestore the original objective function of L, but replace each basic\nvariable in this objective function by the right-hand side of its\nassociated constraint\n15\nreturn the modiﬁed ﬁnal slack form\n16\nelse return “infeasible”\n888\nChapter 29\nLinear Programming\nINITIALIZE-SIMPLEX works as follows. In lines 1–3, we implicitly test the\nbasic solution to the initial slack form for L given by N D f1; 2; : : : ; ng, B D\nfn C 1; n C 2; : : : ; n C mg, Nxi D bi for all i 2 B, and Nxj D 0 for all j 2 N .\n(Creating the slack form requires no explicit effort, as the values of A, b, and c are\nthe same in both slack and standard forms.) If line 2 ﬁnds this basic solution to be\nfeasible—that is, Nxi \u0006 0 for all i 2 N [ B—then line 3 returns the slack form.\nOtherwise, in line 4, we form the auxiliary linear program Laux as in Lemma 29.11.\nSince the initial basic solution to L is not feasible, the initial basic solution to the\nslack form for Laux cannot be feasible either. To ﬁnd a basic feasible solution, we\nperform a single pivot operation. Line 6 selects l D n C k as the index of the\nbasic variable that will be the leaving variable in the upcoming pivot operation.\nSince the basic variables are xnC1; xnC2; : : : ; xnCm, the leaving variable xl will be\nthe one with the most negative value. Line 8 performs that call of PIVOT, with\nx0 entering and xl leaving. We shall see shortly that the basic solution resulting\nfrom this call of PIVOT will be feasible. Now that we have a slack form for which\nthe basic solution is feasible, we can, in line 10, repeatedly call PIVOT to fully",
    "parent_25dbbd32-70dc-4ea9-8e20-dc4b89dacd8f": "x0 entering and xl leaving. We shall see shortly that the basic solution resulting\nfrom this call of PIVOT will be feasible. Now that we have a slack form for which\nthe basic solution is feasible, we can, in line 10, repeatedly call PIVOT to fully\nsolve the auxiliary linear program. As the test in line 11 demonstrates, if we ﬁnd\nan optimal solution to Laux with objective value 0, then in lines 12–14, we create\na slack form for L for which the basic solution is feasible. To do so, we ﬁrst,\nin lines 12–13, handle the degenerate case in which x0 may still be basic with\nvalue Nx0 D 0. In this case, we perform a pivot step to remove x0 from the basis,\nusing any e 2 N such that a0e ¤ 0 as the entering variable. The new basic\nsolution remains feasible; the degenerate pivot does not change the value of any\nvariable. Next we delete all x0 terms from the constraints and restore the original\nobjective function for L. The original objective function may contain both basic\nand nonbasic variables. Therefore, in the objective function we replace each basic\nvariable by the right-hand side of its associated constraint. Line 15 then returns\nthis modiﬁed slack form. If, on the other hand, line 11 discovers that the original\nlinear program L is infeasible, then line 16 returns this information.\nWe now demonstrate the operation of INITIALIZE-SIMPLEX on the linear pro-\ngram (29.102)–(29.105). This linear program is feasible if we can ﬁnd nonneg-\native values for x1 and x2 that satisfy inequalities (29.103) and (29.104). Using\nLemma 29.11, we formulate the auxiliary linear program\nmaximize\n\u0005x0\n(29.109)\nsubject to\n2x1\n\u0005\nx2\n\u0005\nx0\n\u0002\n2\n(29.110)\nx1\n\u0005\n5x2\n\u0005\nx0\n\u0002\n\u00054\n(29.111)\nx1; x2; x0\n\u0006\n0 :\nBy Lemma 29.11, if the optimal objective value of this auxiliary linear program\nis 0, then the original linear program has a feasible solution. If the optimal objective\n29.5\nThe initial basic feasible solution\n889\nvalue of this auxiliary linear program is negative, then the original linear program",
    "parent_92f21f4b-10bd-43b3-8421-b401a38b259b": "By Lemma 29.11, if the optimal objective value of this auxiliary linear program\nis 0, then the original linear program has a feasible solution. If the optimal objective\n29.5\nThe initial basic feasible solution\n889\nvalue of this auxiliary linear program is negative, then the original linear program\ndoes not have a feasible solution.\nWe write this linear program in slack form, obtaining\n´\nD\n\u0005\nx0\nx3\nD\n2\n\u0005\n2x1\nC\nx2\nC\nx0\nx4\nD\n\u00054\n\u0005\nx1\nC\n5x2\nC\nx0 :\nWe are not out of the woods yet, because the basic solution, which would set\nx4 D \u00054, is not feasible for this auxiliary linear program. We can, however, with\none call to PIVOT, convert this slack form into one in which the basic solution is\nfeasible. As line 8 indicates, we choose x0 to be the entering variable. In line 6, we\nchoose as the leaving variable x4, which is the basic variable whose value in the\nbasic solution is most negative. After pivoting, we have the slack form\n´\nD\n\u00054\n\u0005\nx1\nC\n5x2\n\u0005\nx4\nx0\nD\n4\nC\nx1\n\u0005\n5x2\nC\nx4\nx3\nD\n6\n\u0005\nx1\n\u0005\n4x2\nC\nx4 :\nThe associated basic solution is . Nx0; Nx1; Nx2; Nx3; Nx4/ D .4; 0; 0; 6; 0/, which is feasi-\nble. We now repeatedly call PIVOT until we obtain an optimal solution to Laux. In\nthis case, one call to PIVOT with x2 entering and x0 leaving yields\n´\nD\n\u0005\nx0\nx2\nD\n4\n5\n\u0005\nx0\n5\nC\nx1\n5\nC\nx4\n5\nx3\nD\n14\n5\nC\n4x0\n5\n\u0005\n9x1\n5\nC\nx4\n5\n:\nThis slack form is the ﬁnal solution to the auxiliary problem. Since this solution\nhas x0 D 0, we know that our initial problem was feasible. Furthermore, since\nx0 D 0, we can just remove it from the set of constraints. We then restore the\noriginal objective function, with appropriate substitutions made to include only\nnonbasic variables. In our example, we get the objective function\n2x1 \u0005 x2 D 2x1 \u0005\n\u00024\n5 \u0005 x0\n5 C x1\n5 C x4\n5\n\u0003\n:\nSetting x0 D 0 and simplifying, we get the objective function\n\u00054\n5 C 9x1\n5\n\u0005 x4\n5 ;\nand the slack form\n890\nChapter 29\nLinear Programming\n´\nD\n\u00054\n5\nC\n9x1\n5\n\u0005\nx4\n5\nx2\nD\n4\n5\nC\nx1\n5\nC\nx4\n5\nx3\nD\n14\n5\n\u0005\n9x1\n5\nC\nx4\n5\n:",
    "parent_bba168a4-cae6-42ce-8ee4-a33229b2065e": "2x1 \u0005 x2 D 2x1 \u0005\n\u00024\n5 \u0005 x0\n5 C x1\n5 C x4\n5\n\u0003\n:\nSetting x0 D 0 and simplifying, we get the objective function\n\u00054\n5 C 9x1\n5\n\u0005 x4\n5 ;\nand the slack form\n890\nChapter 29\nLinear Programming\n´\nD\n\u00054\n5\nC\n9x1\n5\n\u0005\nx4\n5\nx2\nD\n4\n5\nC\nx1\n5\nC\nx4\n5\nx3\nD\n14\n5\n\u0005\n9x1\n5\nC\nx4\n5\n:\nThis slack form has a feasible basic solution, and we can return it to procedure\nSIMPLEX.\nWe now formally show the correctness of INITIALIZE-SIMPLEX.\nLemma 29.12\nIf a linear program L has no feasible solution, then INITIALIZE-SIMPLEX returns\n“infeasible.” Otherwise, it returns a valid slack form for which the basic solution\nis feasible.\nProof\nFirst suppose that the linear program L has no feasible solution. Then by\nLemma 29.11, the optimal objective value of Laux, deﬁned in (29.106)–(29.108),\nis nonzero, and by the nonnegativity constraint on x0, the optimal objective value\nmust be negative. Furthermore, this objective value must be ﬁnite, since setting\nxi D 0, for i D 1; 2; : : : ; n, and x0 D jminm\niD1 fbigj is feasible, and this solution\nhas objective value \u0005 jminm\niD1 fbigj. Therefore, line 10 of INITIALIZE-SIMPLEX\nﬁnds a solution with a nonpositive objective value. Let Nx be the basic solution\nassociated with the ﬁnal slack form. We cannot have Nx0 D 0, because then Laux\nwould have objective value 0, which contradicts that the objective value is negative.\nThus the test in line 11 results in line 16 returning “infeasible.”\nSuppose now that the linear program L does have a feasible solution. From\nExercise 29.3-4, we know that if bi \u0006 0 for i D 1; 2; : : : ; m, then the basic solution\nassociated with the initial slack form is feasible. In this case, lines 2–3 return the\nslack form associated with the input. (Converting the standard form to slack form\nis easy, since A, b, and c are the same in both.)\nIn the remainder of the proof, we handle the case in which the linear program is\nfeasible but we do not return in line 3. We argue that in this case, lines 4–10 ﬁnd a",
    "parent_23909ae7-73e1-4d68-b3d8-c5a6364f850f": "slack form associated with the input. (Converting the standard form to slack form\nis easy, since A, b, and c are the same in both.)\nIn the remainder of the proof, we handle the case in which the linear program is\nfeasible but we do not return in line 3. We argue that in this case, lines 4–10 ﬁnd a\nfeasible solution to Laux with objective value 0. First, by lines 1–2, we must have\nbk < 0 ;\nand\nbk \u0002 bi\nfor each i 2 B :\n(29.112)\nIn line 8, we perform one pivot operation in which the leaving variable xl (recall\nthat l D n C k, so that bl < 0) is the left-hand side of the equation with mini-\nmum bi, and the entering variable is x0, the extra added variable. We now show\n29.5\nThe initial basic feasible solution\n891\nthat after this pivot, all entries of b are nonnegative, and hence the basic solution\nto Laux is feasible. Letting Nx be the basic solution after the call to PIVOT, and\nletting yb and yB be values returned by PIVOT, Lemma 29.1 implies that\nNxi D\n(\nbi \u0005 aieybe\nif i 2 yB \u0005 feg ;\nbl=ale\nif i D e :\n(29.113)\nThe call to PIVOT in line 8 has e D 0. If we rewrite inequalities (29.107), to\ninclude coefﬁcients ai0,\nn\nX\njD0\naijxj \u0002 bi\nfor i D 1; 2; : : : ; m ;\n(29.114)\nthen\nai0 D aie D \u00051 for each i 2 B :\n(29.115)\n(Note that ai0 is the coefﬁcient of x0 as it appears in inequalities (29.114), not\nthe negation of the coefﬁcient, because Laux is in standard rather than slack form.)\nSince l 2 B, we also have that ale D \u00051. Thus, bl=ale > 0, and so Nxe > 0. For\nthe remaining basic variables, we have\nNxi\nD\nbi \u0005 aieybe\n(by equation (29.113))\nD\nbi \u0005 aie.bl=ale/\n(by line 3 of PIVOT)\nD\nbi \u0005 bl\n(by equation (29.115) and ale D \u00051)\n\u0006\n0\n(by inequality (29.112)) ,\nwhich implies that each basic variable is now nonnegative. Hence the basic solu-\ntion after the call to PIVOT in line 8 is feasible. We next execute line 10, which\nsolves Laux. Since we have assumed that L has a feasible solution, Lemma 29.11\nimplies that Laux has an optimal solution with objective value 0. Since all the slack",
    "parent_15f7d466-f418-4a9d-a69f-f8ab6624d6a5": "tion after the call to PIVOT in line 8 is feasible. We next execute line 10, which\nsolves Laux. Since we have assumed that L has a feasible solution, Lemma 29.11\nimplies that Laux has an optimal solution with objective value 0. Since all the slack\nforms are equivalent, the ﬁnal basic solution to Laux must have Nx0 D 0, and after\nremoving x0 from the linear program, we obtain a slack form that is feasible for L.\nLine 15 then returns this slack form.\nFundamental theorem of linear programming\nWe conclude this chapter by showing that the SIMPLEX procedure works. In par-\nticular, any linear program either is infeasible, is unbounded, or has an optimal\nsolution with a ﬁnite objective value. In each case, SIMPLEX acts appropriately.\n892\nChapter 29\nLinear Programming\nTheorem 29.13 (Fundamental theorem of linear programming)\nAny linear program L, given in standard form, either\n1. has an optimal solution with a ﬁnite objective value,\n2. is infeasible, or\n3. is unbounded.\nIf L is infeasible, SIMPLEX returns “infeasible.” If L is unbounded, SIMPLEX\nreturns “unbounded.” Otherwise, SIMPLEX returns an optimal solution with a ﬁnite\nobjective value.\nProof\nBy Lemma 29.12, if linear program L is infeasible, then SIMPLEX returns\n“infeasible.” Now suppose that the linear program L is feasible. By Lemma 29.12,\nINITIALIZE-SIMPLEX returns a slack form for which the basic solution is feasible.\nBy Lemma 29.7, therefore, SIMPLEX either returns “unbounded” or terminates\nwith a feasible solution. If it terminates with a ﬁnite solution, then Theorem 29.10\ntells us that this solution is optimal. On the other hand, if SIMPLEX returns “un-\nbounded,” Lemma 29.2 tells us the linear program L is indeed unbounded. Since\nSIMPLEX always terminates in one of these ways, the proof is complete.\nExercises\n29.5-1\nGive detailed pseudocode to implement lines 5 and 14 of INITIALIZE-SIMPLEX.\n29.5-2\nShow that when the main loop of SIMPLEX is run by INITIALIZE-SIMPLEX, it can\nnever return “unbounded.”\n29.5-3",
    "parent_c413fa3a-120c-44fd-a381-3f26ce71a20b": "SIMPLEX always terminates in one of these ways, the proof is complete.\nExercises\n29.5-1\nGive detailed pseudocode to implement lines 5 and 14 of INITIALIZE-SIMPLEX.\n29.5-2\nShow that when the main loop of SIMPLEX is run by INITIALIZE-SIMPLEX, it can\nnever return “unbounded.”\n29.5-3\nSuppose that we are given a linear program L in standard form, and suppose that\nfor both L and the dual of L, the basic solutions associated with the initial slack\nforms are feasible. Show that the optimal objective value of L is 0.\n29.5-4\nSuppose that we allow strict inequalities in a linear program. Show that in this\ncase, the fundamental theorem of linear programming does not hold.\n29.5\nThe initial basic feasible solution\n893\n29.5-5\nSolve the following linear program using SIMPLEX:\nmaximize\nx1\nC\n3x2\nsubject to\nx1\n\u0005\nx2\n\u0002\n8\n\u0005x1\n\u0005\nx2\n\u0002\n\u00053\n\u0005x1\nC\n4x2\n\u0002\n2\nx1; x2\n\u0006\n0 :\n29.5-6\nSolve the following linear program using SIMPLEX:\nmaximize\nx1\n\u0005\n2x2\nsubject to\nx1\nC\n2x2\n\u0002\n4\n\u00052x1\n\u0005\n6x2\n\u0002\n\u000512\nx2\n\u0002\n1\nx1; x2\n\u0006\n0 :\n29.5-7\nSolve the following linear program using SIMPLEX:\nmaximize\nx1\nC\n3x2\nsubject to\n\u0005x1\nC\nx2\n\u0002\n\u00051\n\u0005x1\n\u0005\nx2\n\u0002\n\u00053\n\u0005x1\nC\n4x2\n\u0002\n2\nx1; x2\n\u0006\n0 :\n29.5-8\nSolve the linear program given in (29.6)–(29.10).\n29.5-9\nConsider the following 1-variable linear program, which we call P :\nmaximize\ntx\nsubject to\nrx\n\u0002\ns\nx\n\u0006\n0 ;\nwhere r, s, and t are arbitrary real numbers. Let D be the dual of P .\n894\nChapter 29\nLinear Programming\nState for which values of r, s, and t you can assert that\n1. Both P and D have optimal solutions with ﬁnite objective values.\n2. P is feasible, but D is infeasible.\n3. D is feasible, but P is infeasible.\n4. Neither P nor D is feasible.\nProblems\n29-1\nLinear-inequality feasibility\nGiven a set of m linear inequalities on n variables x1; x2; : : : ; xn, the linear-\ninequality feasibility problem asks whether there is a setting of the variables that\nsimultaneously satisﬁes each of the inequalities.\na. Show that if we have an algorithm for linear programming, we can use it to",
    "parent_f7c49f39-e1ad-41ef-9896-5dd9d36a53f4": "Given a set of m linear inequalities on n variables x1; x2; : : : ; xn, the linear-\ninequality feasibility problem asks whether there is a setting of the variables that\nsimultaneously satisﬁes each of the inequalities.\na. Show that if we have an algorithm for linear programming, we can use it to\nsolve a linear-inequality feasibility problem. The number of variables and con-\nstraints that you use in the linear-programming problem should be polynomial\nin n and m.\nb. Show that if we have an algorithm for the linear-inequality feasibility problem,\nwe can use it to solve a linear-programming problem. The number of variables\nand linear inequalities that you use in the linear-inequality feasibility problem\nshould be polynomial in n and m, the number of variables and constraints in\nthe linear program.\n29-2\nComplementary slackness\nComplementary slackness describes a relationship between the values of primal\nvariables and dual constraints and between the values of dual variables and pri-\nmal constraints. Let Nx be a feasible solution to the primal linear program given\nin (29.16)–(29.18), and let Ny be a feasible solution to the dual linear program given\nin (29.83)–(29.85). Complementary slackness states that the following conditions\nare necessary and sufﬁcient for Nx and Ny to be optimal:\nm\nX\niD1\naij Nyi D cj or Nxj D 0\nfor j D 1; 2; : : : ; n\nand\nn\nX\njD1\naij Nxj D bi or Nyi D 0\nfor i D 1; 2; : : : ; m :\nProblems for Chapter 29\n895\na. Verify that complementary slackness holds for the linear program in lines\n(29.53)–(29.57).\nb. Prove that complementary slackness holds for any primal linear program and\nits corresponding dual.\nc. Prove that a feasible solution Nx to a primal linear program given in lines\n(29.16)–(29.18) is optimal if and only if there exist values Ny D . Ny1; Ny2; : : : ; Nym/\nsuch that\n1. Ny is a feasible solution to the dual linear program given in (29.83)–(29.85),\n2. Pm\niD1 aij Nyi D cj for all j such that Nxj > 0, and\n3. Nyi D 0 for all i such that Pn",
    "parent_67c83a3b-95dd-4770-9b36-7be7ed910c97": "(29.16)–(29.18) is optimal if and only if there exist values Ny D . Ny1; Ny2; : : : ; Nym/\nsuch that\n1. Ny is a feasible solution to the dual linear program given in (29.83)–(29.85),\n2. Pm\niD1 aij Nyi D cj for all j such that Nxj > 0, and\n3. Nyi D 0 for all i such that Pn\njD1 aij Nxj < bi.\n29-3\nInteger linear programming\nAn integer linear-programming problem is a linear-programming problem with\nthe additional constraint that the variables x must take on integral values. Exer-\ncise 34.5-3 shows that just determining whether an integer linear program has a\nfeasible solution is NP-hard, which means that there is no known polynomial-time\nalgorithm for this problem.\na. Show that weak duality (Lemma 29.8) holds for an integer linear program.\nb. Show that duality (Theorem 29.10) does not always hold for an integer linear\nprogram.\nc. Given a primal linear program in standard form, let us deﬁne P to be the opti-\nmal objective value for the primal linear program, D to be the optimal objective\nvalue for its dual, IP to be the optimal objective value for the integer version of\nthe primal (that is, the primal with the added constraint that the variables take\non integer values), and ID to be the optimal objective value for the integer ver-\nsion of the dual. Assuming that both the primal integer program and the dual\ninteger program are feasible and bounded, show that\nIP \u0002 P D D \u0002 ID :\n29-4\nFarkas’s lemma\nLet A be an m \t n matrix and c be an n-vector. Then Farkas’s lemma states that\nexactly one of the systems\n896\nChapter 29\nLinear Programming\nAx\n\u0002\n0 ;\ncTx\n>\n0\nand\nATy\nD\nc ;\ny\n\u0006\n0\nis solvable, where x is an n-vector and y is an m-vector. Prove Farkas’s lemma.\n29-5\nMinimum-cost circulation\nIn this problem, we consider a variant of the minimum-cost-ﬂow problem from\nSection 29.2 in which we are not given a demand, a source, or a sink. Instead,\nwe are given, as before, a ﬂow network and edge costs a.u; \u0003/. A ﬂow is feasible",
    "parent_845ba042-1db5-44d2-aefb-aaed9f1f3cc9": "29-5\nMinimum-cost circulation\nIn this problem, we consider a variant of the minimum-cost-ﬂow problem from\nSection 29.2 in which we are not given a demand, a source, or a sink. Instead,\nwe are given, as before, a ﬂow network and edge costs a.u; \u0003/. A ﬂow is feasible\nif it satisﬁes the capacity constraint on every edge and ﬂow conservation at every\nvertex. The goal is to ﬁnd, among all feasible ﬂows, the one of minimum cost. We\ncall this problem the minimum-cost-circulation problem.\na. Formulate the minimum-cost-circulation problem as a linear program.\nb. Suppose that for all edges .u; \u0003/ 2 E, we have a.u; \u0003/ > 0. Characterize an\noptimal solution to the minimum-cost-circulation problem.\nc. Formulate the maximum-ﬂow problem as a minimum-cost-circulation problem\nlinear program. That is given a maximum-ﬂow problem instance G D .V; E/\nwith source s, sink t and edge capacities c, create a minimum-cost-circulation\nproblem by giving a (possibly different) network G0 D .V 0; E0/ with edge\ncapacities c0 and edge costs a0 such that you can discern a solution to the\nmaximum-ﬂow problem from a solution to the minimum-cost-circulation prob-\nlem.\nd. Formulate the single-source shortest-path problem as a minimum-cost-circu-\nlation problem linear program.\nChapter notes\nThis chapter only begins to study the wide ﬁeld of linear programming. A num-\nber of books are devoted exclusively to linear programming, including those by\nChv´atal [69], Gass [130], Karloff [197], Schrijver [303], and Vanderbei [344].\nMany other books give a good coverage of linear programming, including those\nby Papadimitriou and Steiglitz [271] and Ahuja, Magnanti, and Orlin [7]. The\ncoverage in this chapter draws on the approach taken by Chv´atal.\nNotes for Chapter 29\n897\nThe simplex algorithm for linear programming was invented by G. Dantzig\nin 1947. Shortly after, researchers discovered how to formulate a number of prob-\nlems in a variety of ﬁelds as linear programs and solve them with the simplex",
    "parent_117d0373-08c4-4025-928d-9b5b83bc63a3": "Notes for Chapter 29\n897\nThe simplex algorithm for linear programming was invented by G. Dantzig\nin 1947. Shortly after, researchers discovered how to formulate a number of prob-\nlems in a variety of ﬁelds as linear programs and solve them with the simplex\nalgorithm. As a result, applications of linear programming ﬂourished, along with\nseveral algorithms. Variants of the simplex algorithm remain the most popular\nmethods for solving linear-programming problems. This history appears in a num-\nber of places, including the notes in [69] and [197].\nThe ellipsoid algorithm was the ﬁrst polynomial-time algorithm for linear pro-\ngramming and is due to L. G. Khachian in 1979; it was based on earlier work by\nN. Z. Shor, D. B. Judin, and A. S. Nemirovskii. Gr¨otschel, Lov´asz, and Schrijver\n[154] describe how to use the ellipsoid algorithm to solve a variety of problems in\ncombinatorial optimization. To date, the ellipsoid algorithm does not appear to be\ncompetitive with the simplex algorithm in practice.\nKarmarkar’s paper [198] includes a description of the ﬁrst interior-point algo-\nrithm. Many subsequent researchers designed interior-point algorithms. Good sur-\nveys appear in the article of Goldfarb and Todd [141] and the book by Ye [361].\nAnalysis of the simplex algorithm remains an active area of research. V. Klee\nand G. J. Minty constructed an example on which the simplex algorithm runs\nthrough 2n \u0005 1 iterations. The simplex algorithm usually performs very well in\npractice and many researchers have tried to give theoretical justiﬁcation for this\nempirical observation. A line of research begun by K. H. Borgwardt, and carried\non by many others, shows that under certain probabilistic assumptions on the in-\nput, the simplex algorithm converges in expected polynomial time. Spielman and\nTeng [322] made progress in this area, introducing the “smoothed analysis of algo-\nrithms” and applying it to the simplex algorithm.",
    "parent_4e77dad1-6ab6-4ffc-b0b2-7702bdd41e87": "on by many others, shows that under certain probabilistic assumptions on the in-\nput, the simplex algorithm converges in expected polynomial time. Spielman and\nTeng [322] made progress in this area, introducing the “smoothed analysis of algo-\nrithms” and applying it to the simplex algorithm.\nThe simplex algorithm is known to run efﬁciently in certain special cases. Par-\nticularly noteworthy is the network-simplex algorithm, which is the simplex al-\ngorithm, specialized to network-ﬂow problems. For certain network problems,\nincluding the shortest-paths, maximum-ﬂow, and minimum-cost-ﬂow problems,\nvariants of the network-simplex algorithm run in polynomial time. See, for exam-\nple, the article by Orlin [268] and the citations therein.\n30\nPolynomials and the FFT\nThe straightforward method of adding two polynomials of degree n takes ‚.n/\ntime, but the straightforward method of multiplying them takes ‚.n2/ time. In this\nchapter, we shall show how the fast Fourier transform, or FFT, can reduce the time\nto multiply polynomials to ‚.n lg n/.\nThe most common use for Fourier transforms, and hence the FFT, is in signal\nprocessing. A signal is given in the time domain: as a function mapping time to\namplitude. Fourier analysis allows us to express the signal as a weighted sum of\nphase-shifted sinusoids of varying frequencies. The weights and phases associated\nwith the frequencies characterize the signal in the frequency domain. Among the\nmany everyday applications of FFT’s are compression techniques used to encode\ndigital video and audio information, including MP3 ﬁles. Several ﬁne books delve\ninto the rich area of signal processing; the chapter notes reference a few of them.\nPolynomials\nA polynomial in the variable x over an algebraic ﬁeld F represents a function A.x/\nas a formal sum:\nA.x/ D\nn\u00031\nX\njD0\najxj :\nWe call the values a0; a1; : : : ; an\u00031 the coefﬁcients of the polynomial. The co-\nefﬁcients are drawn from a ﬁeld F , typically the set C of complex numbers. A",
    "parent_a38d522e-97d9-4573-905a-99b0dd5e30c0": "Polynomials\nA polynomial in the variable x over an algebraic ﬁeld F represents a function A.x/\nas a formal sum:\nA.x/ D\nn\u00031\nX\njD0\najxj :\nWe call the values a0; a1; : : : ; an\u00031 the coefﬁcients of the polynomial. The co-\nefﬁcients are drawn from a ﬁeld F , typically the set C of complex numbers. A\npolynomial A.x/ has degree k if its highest nonzero coefﬁcient is ak; we write\nthat degree.A/ D k. Any integer strictly greater than the degree of a polynomial\nis a degree-bound of that polynomial. Therefore, the degree of a polynomial of\ndegree-bound n may be any integer between 0 and n \u0005 1, inclusive.\nWe can deﬁne a variety of operations on polynomials. For polynomial addi-\ntion, if A.x/ and B.x/ are polynomials of degree-bound n, their sum is a polyno-\nChapter 30\nPolynomials and the FFT\n899\nmial C.x/, also of degree-bound n, such that C.x/ D A.x/ C B.x/ for all x in the\nunderlying ﬁeld. That is, if\nA.x/ D\nn\u00031\nX\njD0\najxj\nand\nB.x/ D\nn\u00031\nX\njD0\nbjxj ;\nthen\nC.x/ D\nn\u00031\nX\njD0\ncjxj ;\nwhere cj D aj C bj for j D 0; 1; : : : ; n \u0005 1.\nFor example, if we have the\npolynomials A.x/ D 6x3 C 7x2 \u0005 10x C 9 and B.x/ D \u00052x3 C 4x \u0005 5, then\nC.x/ D 4x3 C 7x2 \u0005 6x C 4.\nFor polynomial multiplication, if A.x/ and B.x/ are polynomials of degree-\nbound n, their product C.x/ is a polynomial of degree-bound 2n \u0005 1 such that\nC.x/ D A.x/B.x/ for all x in the underlying ﬁeld. You probably have multi-\nplied polynomials before, by multiplying each term in A.x/ by each term in B.x/\nand then combining terms with equal powers.\nFor example, we can multiply\nA.x/ D 6x3 C 7x2 \u0005 10x C 9 and B.x/ D \u00052x3 C 4x \u0005 5 as follows:\n6x3 C\n7x2 \u0005 10x C\n9\n\u0005\n2x3\nC\n4x \u0005\n5\n\u0005 30x3 \u0005 35x2 C 50x \u0005 45\n24x4 C 28x3 \u0005 40x2 C 36x\n\u0005 12x6 \u0005 14x5 C 20x4 \u0005 18x3\n\u0005 12x6 \u0005 14x5 C 44x4 \u0005 20x3 \u0005 75x2 C 86x \u0005 45\nAnother way to express the product C.x/ is\nC.x/ D\n2n\u00032\nX\njD0\ncjxj ;\n(30.1)\nwhere\ncj D\nj\nX\nkD0\nakbj\u0003k :\n(30.2)\n900\nChapter 30\nPolynomials and the FFT\nNote that degree.C/ D degree.A/ C degree.B/, implying that if A is a polyno-",
    "parent_8c8c4c2d-b510-454d-a471-ff50336c47b5": "\u0005 12x6 \u0005 14x5 C 20x4 \u0005 18x3\n\u0005 12x6 \u0005 14x5 C 44x4 \u0005 20x3 \u0005 75x2 C 86x \u0005 45\nAnother way to express the product C.x/ is\nC.x/ D\n2n\u00032\nX\njD0\ncjxj ;\n(30.1)\nwhere\ncj D\nj\nX\nkD0\nakbj\u0003k :\n(30.2)\n900\nChapter 30\nPolynomials and the FFT\nNote that degree.C/ D degree.A/ C degree.B/, implying that if A is a polyno-\nmial of degree-bound na and B is a polynomial of degree-bound nb, then C is a\npolynomial of degree-bound na C nb \u0005 1. Since a polynomial of degree-bound k\nis also a polynomial of degree-bound k C 1, we will normally say that the product\npolynomial C is a polynomial of degree-bound na C nb.\nChapter outline\nSection 30.1 presents two ways to represent polynomials: the coefﬁcient represen-\ntation and the point-value representation. The straightforward methods for multi-\nplying polynomials—equations (30.1) and (30.2)—take ‚.n2/ time when we rep-\nresent polynomials in coefﬁcient form, but only ‚.n/ time when we represent them\nin point-value form. We can, however, multiply polynomials using the coefﬁcient\nrepresentation in only ‚.n lg n/ time by converting between the two representa-\ntions. To see why this approach works, we must ﬁrst study complex roots of unity,\nwhich we do in Section 30.2. Then, we use the FFT and its inverse, also described\nin Section 30.2, to perform the conversions. Section 30.3 shows how to implement\nthe FFT quickly in both serial and parallel models.\nThis chapter uses complex numbers extensively, and within this chapter we use\nthe symbol i exclusively to denote\np\n\u00051.\n30.1\nRepresenting polynomials\nThe coefﬁcient and point-value representations of polynomials are in a sense equiv-\nalent; that is, a polynomial in point-value form has a unique counterpart in co-\nefﬁcient form. In this section, we introduce the two representations and show\nhow to combine them so that we can multiply two degree-bound n polynomials\nin ‚.n lg n/ time.\nCoefﬁcient representation\nA coefﬁcient representation of a polynomial A.x/ D Pn\u00031\njD0 ajxj of degree-",
    "parent_6d93e377-28e1-485a-b0c5-38935567296f": "efﬁcient form. In this section, we introduce the two representations and show\nhow to combine them so that we can multiply two degree-bound n polynomials\nin ‚.n lg n/ time.\nCoefﬁcient representation\nA coefﬁcient representation of a polynomial A.x/ D Pn\u00031\njD0 ajxj of degree-\nbound n is a vector of coefﬁcients a D .a0; a1; : : : ; an\u00031/. In matrix equations\nin this chapter, we shall generally treat vectors as column vectors.\nThe coefﬁcient representation is convenient for certain operations on polyno-\nmials. For example, the operation of evaluating the polynomial A.x/ at a given\npoint x0 consists of computing the value of A.x0/. We can evaluate a polynomial\nin ‚.n/ time using Horner’s rule:\nA.x0/ D a0 C x0.a1 C x0.a2 C \u0003 \u0003 \u0003 C x0.an\u00032 C x0.an\u00031// \u0003 \u0003 \u0003// :\n30.1\nRepresenting polynomials\n901\nSimilarly, adding two polynomials represented by the coefﬁcient vectors a D\n.a0; a1; : : : ; an\u00031/ and b D .b0; b1; : : : ; bn\u00031/ takes ‚.n/ time: we just produce\nthe coefﬁcient vector c D .c0; c1; : : : ; cn\u00031/, where cj D aj C bj for j D\n0; 1; : : : ; n \u0005 1.\nNow, consider multiplying two degree-bound n polynomials A.x/ and B.x/ rep-\nresented in coefﬁcient form. If we use the method described by equations (30.1)\nand (30.2), multiplying polynomials takes time ‚.n2/, since we must multiply\neach coefﬁcient in the vector a by each coefﬁcient in the vector b. The operation\nof multiplying polynomials in coefﬁcient form seems to be considerably more difﬁ-\ncult than that of evaluating a polynomial or adding two polynomials. The resulting\ncoefﬁcient vector c, given by equation (30.2), is also called the convolution of the\ninput vectors a and b, denoted c D a ˝ b. Since multiplying polynomials and\ncomputing convolutions are fundamental computational problems of considerable\npractical importance, this chapter concentrates on efﬁcient algorithms for them.\nPoint-value representation\nA point-value representation of a polynomial A.x/ of degree-bound n is a set of\nn point-value pairs",
    "parent_95ae8749-b03c-47a9-8297-78bc6f7b63f2": "computing convolutions are fundamental computational problems of considerable\npractical importance, this chapter concentrates on efﬁcient algorithms for them.\nPoint-value representation\nA point-value representation of a polynomial A.x/ of degree-bound n is a set of\nn point-value pairs\nf.x0; y0/; .x1; y1/; : : : ; .xn\u00031; yn\u00031/g\nsuch that all of the xk are distinct and\nyk D A.xk/\n(30.3)\nfor k D 0; 1; : : : ; n \u0005 1. A polynomial has many different point-value representa-\ntions, since we can use any set of n distinct points x0; x1; : : : ; xn\u00031 as a basis for\nthe representation.\nComputing a point-value representation for a polynomial given in coefﬁcient\nform is in principle straightforward, since all we have to do is select n distinct\npoints x0; x1; : : : ; xn\u00031 and then evaluate A.xk/ for k D 0; 1; : : : ; n \u0005 1. With\nHorner’s method, evaluating a polynomial at n points takes time ‚.n2/. We shall\nsee later that if we choose the points xk cleverly, we can accelerate this computation\nto run in time ‚.n lg n/.\nThe inverse of evaluation—determining the coefﬁcient form of a polynomial\nfrom a point-value representation—is interpolation. The following theorem shows\nthat interpolation is well deﬁned when the desired interpolating polynomial must\nhave a degree-bound equal to the given number of point-value pairs.\nTheorem 30.1 (Uniqueness of an interpolating polynomial)\nFor any set f.x0; y0/; .x1; y1/; : : : ; .xn\u00031; yn\u00031/g of n point-value pairs such that\nall the xk values are distinct, there is a unique polynomial A.x/ of degree-bound n\nsuch that yk D A.xk/ for k D 0; 1; : : : ; n \u0005 1.\n902\nChapter 30\nPolynomials and the FFT\nProof\nThe proof relies on the existence of the inverse of a certain matrix. Equa-\ntion (30.3) is equivalent to the matrix equation\n˙ 1\nx0\nx2\n0\n\u0003 \u0003 \u0003\nxn\u00031\n0\n1\nx1\nx2\n1\n\u0003 \u0003 \u0003\nxn\u00031\n1\n:::\n:::\n:::\n:::\n:::\n1\nxn\u00031\nx2\nn\u00031\n\u0003 \u0003 \u0003\nxn\u00031\nn\u00031\n\u0007˙ a0\na1\n:::\nan\u00031\n\u0007\nD\n˙ y0\ny1\n:::\nyn\u00031\n\u0007\n:\n(30.4)",
    "parent_113c4db1-4938-40df-8a3b-3fe0403cc10d": "Proof\nThe proof relies on the existence of the inverse of a certain matrix. Equa-\ntion (30.3) is equivalent to the matrix equation\n˙ 1\nx0\nx2\n0\n\u0003 \u0003 \u0003\nxn\u00031\n0\n1\nx1\nx2\n1\n\u0003 \u0003 \u0003\nxn\u00031\n1\n:::\n:::\n:::\n:::\n:::\n1\nxn\u00031\nx2\nn\u00031\n\u0003 \u0003 \u0003\nxn\u00031\nn\u00031\n\u0007˙ a0\na1\n:::\nan\u00031\n\u0007\nD\n˙ y0\ny1\n:::\nyn\u00031\n\u0007\n:\n(30.4)\nThe matrix on the left is denoted V.x0; x1; : : : ; xn\u00031/ and is known as a Vander-\nmonde matrix. By Problem D-1, this matrix has determinant\nY\n0\u0005j<k\u0005n\u00031\n.xk \u0005 xj/ ;\nand therefore, by Theorem D.5, it is invertible (that is, nonsingular) if the xk are\ndistinct. Thus, we can solve for the coefﬁcients aj uniquely given the point-value\nrepresentation:\na D V.x0; x1; : : : ; xn\u00031/\u00031y :\nThe proof of Theorem 30.1 describes an algorithm for interpolation based on\nsolving the set (30.4) of linear equations. Using the LU decomposition algorithms\nof Chapter 28, we can solve these equations in time O.n3/.\nA faster algorithm for n-point interpolation is based on Lagrange’s formula:\nA.x/ D\nn\u00031\nX\nkD0\nyk\nY\nj¤k\n.x \u0005 xj/\nY\nj¤k\n.xk \u0005 xj/\n:\n(30.5)\nYou may wish to verify that the right-hand side of equation (30.5) is a polynomial\nof degree-bound n that satisﬁes A.xk/ D yk for all k. Exercise 30.1-5 asks you\nhow to compute the coefﬁcients of A using Lagrange’s formula in time ‚.n2/.\nThus, n-point evaluation and interpolation are well-deﬁned inverse operations\nthat transform between the coefﬁcient representation of a polynomial and a point-\nvalue representation.1\nThe algorithms described above for these problems take\ntime ‚.n2/.\nThe point-value representation is quite convenient for many operations on poly-\nnomials. For addition, if C.x/ D A.x/ C B.x/, then C.xk/ D A.xk/ C B.xk/ for\nany point xk. More precisely, if we have a point-value representation for A,\n1Interpolation is a notoriously tricky problem from the point of view of numerical stability. Although\nthe approaches described here are mathematically correct, small differences in the inputs or round-off",
    "parent_e9df0f65-ff12-489b-924f-cca19fb5185e": "any point xk. More precisely, if we have a point-value representation for A,\n1Interpolation is a notoriously tricky problem from the point of view of numerical stability. Although\nthe approaches described here are mathematically correct, small differences in the inputs or round-off\nerrors during computation can cause large differences in the result.\n30.1\nRepresenting polynomials\n903\nf.x0; y0/; .x1; y1/; : : : ; .xn\u00031; yn\u00031/g ;\nand for B,\nf.x0; y0\n0/; .x1; y0\n1/; : : : ; .xn\u00031; y0\nn\u00031/g\n(note that A and B are evaluated at the same n points), then a point-value repre-\nsentation for C is\nf.x0; y0 C y0\n0/; .x1; y1 C y0\n1/; : : : ; .xn\u00031; yn\u00031 C y0\nn\u00031/g :\nThus, the time to add two polynomials of degree-bound n in point-value form\nis ‚.n/.\nSimilarly, the point-value representation is convenient for multiplying polyno-\nmials. If C.x/ D A.x/B.x/, then C.xk/ D A.xk/B.xk/ for any point xk, and\nwe can pointwise multiply a point-value representation for A by a point-value rep-\nresentation for B to obtain a point-value representation for C. We must face the\nproblem, however, that degree.C/ D degree.A/ C degree.B/; if A and B are of\ndegree-bound n, then C is of degree-bound 2n. A standard point-value represen-\ntation for A and B consists of n point-value pairs for each polynomial. When we\nmultiply these together, we get n point-value pairs, but we need 2n pairs to interpo-\nlate a unique polynomial C of degree-bound 2n. (See Exercise 30.1-4.) We must\ntherefore begin with “extended” point-value representations for A and for B con-\nsisting of 2n point-value pairs each. Given an extended point-value representation\nfor A,\nf.x0; y0/; .x1; y1/; : : : ; .x2n\u00031; y2n\u00031/g ;\nand a corresponding extended point-value representation for B,\nf.x0; y0\n0/; .x1; y0\n1/; : : : ; .x2n\u00031; y0\n2n\u00031/g ;\nthen a point-value representation for C is\nf.x0; y0y0\n0/; .x1; y1y0\n1/; : : : ; .x2n\u00031; y2n\u00031y0\n2n\u00031/g :\nGiven two input polynomials in extended point-value form, we see that the time to",
    "parent_f70e7f83-7a7b-4350-93ee-0210b837ffcd": "f.x0; y0\n0/; .x1; y0\n1/; : : : ; .x2n\u00031; y0\n2n\u00031/g ;\nthen a point-value representation for C is\nf.x0; y0y0\n0/; .x1; y1y0\n1/; : : : ; .x2n\u00031; y2n\u00031y0\n2n\u00031/g :\nGiven two input polynomials in extended point-value form, we see that the time to\nmultiply them to obtain the point-value form of the result is ‚.n/, much less than\nthe time required to multiply polynomials in coefﬁcient form.\nFinally, we consider how to evaluate a polynomial given in point-value form at a\nnew point. For this problem, we know of no simpler approach than converting the\npolynomial to coefﬁcient form ﬁrst, and then evaluating it at the new point.\nFast multiplication of polynomials in coefﬁcient form\nCan we use the linear-time multiplication method for polynomials in point-value\nform to expedite polynomial multiplication in coefﬁcient form? The answer hinges\n904\nChapter 30\nPolynomials and the FFT\na0; a1; : : : ; an\u00031\nb0; b1; : : : ; bn\u00031\nc0; c1; : : : ; c2n\u00032\nOrdinary multiplication\nTime ‚.n2/\nEvaluation\nTime ‚.n lg n/\nTime ‚.n lg n/\nInterpolation\nPointwise multiplication\nTime ‚.n/\nA.!0\n2n/; B.!0\n2n/\nA.!1\n2n/; B.!1\n2n/\nA.!2n\u00031\n2n\n/; B.!2n\u00031\n2n\n/\n:::\n:::\nC.!0\n2n/\nC.!1\n2n/\nC.!2n\u00031\n2n\n/\nCoefﬁcient\nPoint-value\nrepresentations\nrepresentations\nFigure 30.1\nA graphical outline of an efﬁcient polynomial-multiplication process. Representations\non the top are in coefﬁcient form, while those on the bottom are in point-value form. The arrows\nfrom left to right correspond to the multiplication operation. The !2n terms are complex .2n/th roots\nof unity.\non whether we can convert a polynomial quickly from coefﬁcient form to point-\nvalue form (evaluate) and vice versa (interpolate).\nWe can use any points we want as evaluation points, but by choosing the eval-\nuation points carefully, we can convert between representations in only ‚.n lg n/\ntime. As we shall see in Section 30.2, if we choose “complex roots of unity” as\nthe evaluation points, we can produce a point-value representation by taking the",
    "parent_0f9c88ac-3e34-4f60-9cb0-2b9316055f7c": "uation points carefully, we can convert between representations in only ‚.n lg n/\ntime. As we shall see in Section 30.2, if we choose “complex roots of unity” as\nthe evaluation points, we can produce a point-value representation by taking the\ndiscrete Fourier transform (or DFT) of a coefﬁcient vector. We can perform the\ninverse operation, interpolation, by taking the “inverse DFT” of point-value pairs,\nyielding a coefﬁcient vector. Section 30.2 will show how the FFT accomplishes\nthe DFT and inverse DFT operations in ‚.n lg n/ time.\nFigure 30.1 shows this strategy graphically. One minor detail concerns degree-\nbounds. The product of two polynomials of degree-bound n is a polynomial of\ndegree-bound 2n. Before evaluating the input polynomials A and B, therefore,\nwe ﬁrst double their degree-bounds to 2n by adding n high-order coefﬁcients of 0.\nBecause the vectors have 2n elements, we use “complex .2n/th roots of unity,”\nwhich are denoted by the !2n terms in Figure 30.1.\nGiven the FFT, we have the following ‚.n lg n/-time procedure for multiplying\ntwo polynomials A.x/ and B.x/ of degree-bound n, where the input and output\nrepresentations are in coefﬁcient form. We assume that n is a power of 2; we can\nalways meet this requirement by adding high-order zero coefﬁcients.\n1. Double degree-bound: Create coefﬁcient representations of A.x/ and B.x/ as\ndegree-bound 2n polynomials by adding n high-order zero coefﬁcients to each.\n30.1\nRepresenting polynomials\n905\n2. Evaluate: Compute point-value representations of A.x/ and B.x/ of length 2n\nby applying the FFT of order 2n on each polynomial. These representations\ncontain the values of the two polynomials at the .2n/th roots of unity.\n3. Pointwise multiply: Compute a point-value representation for the polynomial\nC.x/ D A.x/B.x/ by multiplying these values together pointwise. This repre-\nsentation contains the value of C.x/ at each .2n/th root of unity.\n4. Interpolate: Create the coefﬁcient representation of the polynomial C.x/ by",
    "parent_70dbb58a-aaf3-4546-aa04-a697a3db52e2": "C.x/ D A.x/B.x/ by multiplying these values together pointwise. This repre-\nsentation contains the value of C.x/ at each .2n/th root of unity.\n4. Interpolate: Create the coefﬁcient representation of the polynomial C.x/ by\napplying the FFT on 2n point-value pairs to compute the inverse DFT.\nSteps (1) and (3) take time ‚.n/, and steps (2) and (4) take time ‚.n lg n/. Thus,\nonce we show how to use the FFT, we will have proven the following.\nTheorem 30.2\nWe can multiply two polynomials of degree-bound n in time ‚.n lg n/, with both\nthe input and output representations in coefﬁcient form.\nExercises\n30.1-1\nMultiply the polynomials A.x/ D 7x3 \u0005 x2 C x \u0005 10 and B.x/ D 8x3 \u0005 6x C 3\nusing equations (30.1) and (30.2).\n30.1-2\nAnother way to evaluate a polynomial A.x/ of degree-bound n at a given point x0\nis to divide A.x/ by the polynomial .x \u0005x0/, obtaining a quotient polynomial q.x/\nof degree-bound n \u0005 1 and a remainder r, such that\nA.x/ D q.x/.x \u0005 x0/ C r :\nClearly, A.x0/ D r. Show how to compute the remainder r and the coefﬁcients\nof q.x/ in time ‚.n/ from x0 and the coefﬁcients of A.\n30.1-3\nDerive a point-value representation for Arev.x/ D Pn\u00031\njD0 an\u00031\u0003jxj from a point-\nvalue representation for A.x/ D Pn\u00031\njD0 ajxj, assuming that none of the points is 0.\n30.1-4\nProve that n distinct point-value pairs are necessary to uniquely specify a polyno-\nmial of degree-bound n, that is, if fewer than n distinct point-value pairs are given,\nthey fail to specify a unique polynomial of degree-bound n. (Hint: Using Theo-\nrem 30.1, what can you say about a set of n \u0005 1 point-value pairs to which you add\none more arbitrarily chosen point-value pair?)\n906\nChapter 30\nPolynomials and the FFT\n30.1-5\nShow how to use equation (30.5) to interpolate in time ‚.n2/. (Hint: First compute\nthe coefﬁcient representation of the polynomial Q\nj.x \u0005 xj/ and then divide by\n.x \u0005xk/ as necessary for the numerator of each term; see Exercise 30.1-2. You can\ncompute each of the n denominators in time O.n/.)",
    "parent_af080f9e-f930-4987-b8a1-72cd0942271e": "Show how to use equation (30.5) to interpolate in time ‚.n2/. (Hint: First compute\nthe coefﬁcient representation of the polynomial Q\nj.x \u0005 xj/ and then divide by\n.x \u0005xk/ as necessary for the numerator of each term; see Exercise 30.1-2. You can\ncompute each of the n denominators in time O.n/.)\n30.1-6\nExplain what is wrong with the “obvious” approach to polynomial division using\na point-value representation, i.e., dividing the corresponding y values. Discuss\nseparately the case in which the division comes out exactly and the case in which\nit doesn’t.\n30.1-7\nConsider two sets A and B, each having n integers in the range from 0 to 10n. We\nwish to compute the Cartesian sum of A and B, deﬁned by\nC D fx C y W x 2 A and y 2 Bg :\nNote that the integers in C are in the range from 0 to 20n. We want to ﬁnd the\nelements of C and the number of times each element of C is realized as a sum of\nelements in A and B. Show how to solve the problem in O.n lg n/ time. (Hint:\nRepresent A and B as polynomials of degree at most 10n.)\n30.2\nThe DFT and FFT\nIn Section 30.1, we claimed that if we use complex roots of unity, we can evaluate\nand interpolate polynomials in ‚.n lg n/ time. In this section, we deﬁne complex\nroots of unity and study their properties, deﬁne the DFT, and then show how the\nFFT computes the DFT and its inverse in ‚.n lg n/ time.\nComplex roots of unity\nA complex nth root of unity is a complex number ! such that\n!n D 1 :\nThere are exactly n complex nth roots of unity: e2\u0003ik=n for k D 0; 1; : : : ; n \u0005 1.\nTo interpret this formula, we use the deﬁnition of the exponential of a complex\nnumber:\neiu D cos.u/ C i sin.u/ :\nFigure 30.2 shows that the n complex roots of unity are equally spaced around the\ncircle of unit radius centered at the origin of the complex plane. The value\n30.2\nThe DFT and FFT\n907\n1\n\u00051\ni\n\u0005i\n!0\n8 D !8\n8\n!1\n8\n!2\n8\n!3\n8\n!4\n8\n!5\n8\n!6\n8\n!7\n8\nFigure 30.2\nThe values of !0\n8; !1\n8; : : : ; !7\n8 in the complex plane, where !8 D e2\u0003i=8 is the prin-",
    "parent_4c915478-0c71-465e-9a49-c27767dcec8e": "circle of unit radius centered at the origin of the complex plane. The value\n30.2\nThe DFT and FFT\n907\n1\n\u00051\ni\n\u0005i\n!0\n8 D !8\n8\n!1\n8\n!2\n8\n!3\n8\n!4\n8\n!5\n8\n!6\n8\n!7\n8\nFigure 30.2\nThe values of !0\n8; !1\n8; : : : ; !7\n8 in the complex plane, where !8 D e2\u0003i=8 is the prin-\ncipal 8th root of unity.\n!n D e2\u0003i=n\n(30.6)\nis the principal nth root of unity;2 all other complex nth roots of unity are powers\nof !n.\nThe n complex nth roots of unity,\n!0\nn; !1\nn; : : : ; !n\u00031\nn\n;\nform a group under multiplication (see Section 31.3). This group has the same\nstructure as the additive group .Zn; C/ modulo n, since !n\nn D !0\nn D 1 implies that\n!j\nn!k\nn D !jCk\nn\nD !.jCk/ mod n\nn\n. Similarly, !\u00031\nn\nD !n\u00031\nn\n. The following lemmas\nfurnish some essential properties of the complex nth roots of unity.\nLemma 30.3 (Cancellation lemma)\nFor any integers n \u0006 0, k \u0006 0, and d > 0,\n!dk\ndn D !k\nn :\n(30.7)\nProof\nThe lemma follows directly from equation (30.6), since\n!dk\ndn\nD\n\u000b\ne2\u0003i=dn\fdk\nD\n\u000b\ne2\u0003i=n\fk\nD\n!k\nn :\n2Many other authors deﬁne !n differently: !n D e\u00032\u0003i=n. This alternative deﬁnition tends to be\nused for signal-processing applications. The underlying mathematics is substantially the same with\neither deﬁnition of !n.\n908\nChapter 30\nPolynomials and the FFT\nCorollary 30.4\nFor any even integer n > 0,\n!n=2\nn\nD !2 D \u00051 :\nProof\nThe proof is left as Exercise 30.2-1.\nLemma 30.5 (Halving lemma)\nIf n > 0 is even, then the squares of the n complex nth roots of unity are the n=2\ncomplex .n=2/th roots of unity.\nProof\nBy the cancellation lemma, we have .!k\nn/2 D !k\nn=2, for any nonnegative\ninteger k. Note that if we square all of the complex nth roots of unity, then we\nobtain each .n=2/th root of unity exactly twice, since\n.!kCn=2\nn\n/2\nD\n!2kCn\nn\nD\n!2k\nn !n\nn\nD\n!2k\nn\nD\n.!k\nn/2 :\nThus, !k\nn and !kCn=2\nn\nhave the same square.\nWe could also have used Corol-\nlary 30.4 to prove this property, since !n=2\nn\nD \u00051 implies !kCn=2\nn\nD \u0005!k\nn, and\nthus .!kCn=2\nn\n/2 D .!k\nn/2.",
    "parent_798d6e02-2c10-4ba7-9d66-3cb68ea61bfb": "obtain each .n=2/th root of unity exactly twice, since\n.!kCn=2\nn\n/2\nD\n!2kCn\nn\nD\n!2k\nn !n\nn\nD\n!2k\nn\nD\n.!k\nn/2 :\nThus, !k\nn and !kCn=2\nn\nhave the same square.\nWe could also have used Corol-\nlary 30.4 to prove this property, since !n=2\nn\nD \u00051 implies !kCn=2\nn\nD \u0005!k\nn, and\nthus .!kCn=2\nn\n/2 D .!k\nn/2.\nAs we shall see, the halving lemma is essential to our divide-and-conquer ap-\nproach for converting between coefﬁcient and point-value representations of poly-\nnomials, since it guarantees that the recursive subproblems are only half as large.\nLemma 30.6 (Summation lemma)\nFor any integer n \u0006 1 and nonzero integer k not divisible by n,\nn\u00031\nX\njD0\n\u000b\n!k\nn\n\fj D 0 :\nProof\nEquation (A.5) applies to complex values as well as to reals, and so we\nhave\n30.2\nThe DFT and FFT\n909\nn\u00031\nX\njD0\n\u000b\n!k\nn\n\fj\nD\n.!k\nn/n \u0005 1\n!k\nn \u0005 1\nD\n.!n\nn/k \u0005 1\n!k\nn \u0005 1\nD\n.1/k \u0005 1\n!k\nn \u0005 1\nD\n0 :\nBecause we require that k is not divisible by n, and because !k\nn D 1 only when k\nis divisible by n, we ensure that the denominator is not 0.\nThe DFT\nRecall that we wish to evaluate a polynomial\nA.x/ D\nn\u00031\nX\njD0\najxj\nof degree-bound n at !0\nn; !1\nn; !2\nn; : : : ; !n\u00031\nn\n(that is, at the n complex nth roots of\nunity).3 We assume that A is given in coefﬁcient form: a D .a0; a1; : : : ; an\u00031/. Let\nus deﬁne the results yk, for k D 0; 1; : : : ; n \u0005 1, by\nyk\nD\nA.!k\nn/\nD\nn\u00031\nX\njD0\naj!kj\nn :\n(30.8)\nThe vector y D .y0; y1; : : : ; yn\u00031/ is the discrete Fourier transform (DFT) of the\ncoefﬁcient vector a D .a0; a1; : : : ; an\u00031/. We also write y D DFTn.a/.\nThe FFT\nBy using a method known as the fast Fourier transform (FFT), which takes ad-\nvantage of the special properties of the complex roots of unity, we can compute\nDFTn.a/ in time ‚.n lg n/, as opposed to the ‚.n2/ time of the straightforward\nmethod. We assume throughout that n is an exact power of 2. Although strategies\n3The length n is actually what we referred to as 2n in Section 30.1, since we double the degree-bound",
    "parent_743f04cd-dd64-4fda-9494-9b8f33ee5771": "DFTn.a/ in time ‚.n lg n/, as opposed to the ‚.n2/ time of the straightforward\nmethod. We assume throughout that n is an exact power of 2. Although strategies\n3The length n is actually what we referred to as 2n in Section 30.1, since we double the degree-bound\nof the given polynomials prior to evaluation. In the context of polynomial multiplication, therefore,\nwe are actually working with complex .2n/th roots of unity.\n910\nChapter 30\nPolynomials and the FFT\nfor dealing with non-power-of-2 sizes are known, they are beyond the scope of this\nbook.\nThe FFT method employs a divide-and-conquer strategy, using the even-indexed\nand odd-indexed coefﬁcients of A.x/ separately to deﬁne the two new polynomials\nAŒ0\u0004.x/ and AŒ1\u0004.x/ of degree-bound n=2:\nAŒ0\u0004.x/\nD\na0 C a2x C a4x2 C \u0003 \u0003 \u0003 C an\u00032xn=2\u00031 ;\nAŒ1\u0004.x/\nD\na1 C a3x C a5x2 C \u0003 \u0003 \u0003 C an\u00031xn=2\u00031 :\nNote that AŒ0\u0004 contains all the even-indexed coefﬁcients of A (the binary represen-\ntation of the index ends in 0) and AŒ1\u0004 contains all the odd-indexed coefﬁcients (the\nbinary representation of the index ends in 1). It follows that\nA.x/ D AŒ0\u0004.x2/ C xAŒ1\u0004.x2/ ;\n(30.9)\nso that the problem of evaluating A.x/ at !0\nn; !1\nn; : : : ; !n\u00031\nn\nreduces to\n1. evaluating the degree-bound n=2 polynomials AŒ0\u0004.x/ and AŒ1\u0004.x/ at the points\n.!0\nn/2; .!1\nn/2; : : : ; .!n\u00031\nn\n/2 ;\n(30.10)\nand then\n2. combining the results according to equation (30.9).\nBy the halving lemma, the list of values (30.10) consists not of n distinct val-\nues but only of the n=2 complex .n=2/th roots of unity, with each root occurring\nexactly twice. Therefore, we recursively evaluate the polynomials AŒ0\u0004 and AŒ1\u0004\nof degree-bound n=2 at the n=2 complex .n=2/th roots of unity. These subprob-\nlems have exactly the same form as the original problem, but are half the size.\nWe have now successfully divided an n-element DFTn computation into two n=2-\nelement DFTn=2 computations. This decomposition is the basis for the follow-",
    "parent_6b2eb31e-e94d-4cf0-b643-6752c084c4ab": "lems have exactly the same form as the original problem, but are half the size.\nWe have now successfully divided an n-element DFTn computation into two n=2-\nelement DFTn=2 computations. This decomposition is the basis for the follow-\ning recursive FFT algorithm, which computes the DFT of an n-element vector\na D .a0; a1; : : : ; an\u00031/, where n is a power of 2.\n30.2\nThe DFT and FFT\n911\nRECURSIVE-FFT.a/\n1\nn D a:length\n// n is a power of 2\n2\nif n == 1\n3\nreturn a\n4\n!n D e2\u0003i=n\n5\n! D 1\n6\naŒ0\u0004 D .a0; a2; : : : ; an\u00032/\n7\naŒ1\u0004 D .a1; a3; : : : ; an\u00031/\n8\nyŒ0\u0004 D RECURSIVE-FFT.aŒ0\u0004/\n9\nyŒ1\u0004 D RECURSIVE-FFT.aŒ1\u0004/\n10\nfor k D 0 to n=2 \u0005 1\n11\nyk D yŒ0\u0004\nk C ! yŒ1\u0004\nk\n12\nykC.n=2/ D yŒ0\u0004\nk \u0005 ! yŒ1\u0004\nk\n13\n! D ! !n\n14\nreturn y\n// y is assumed to be a column vector\nThe RECURSIVE-FFT procedure works as follows. Lines 2–3 represent the basis\nof the recursion; the DFT of one element is the element itself, since in this case\ny0\nD\na0 !0\n1\nD\na0 \u0003 1\nD\na0 :\nLines 6–7 deﬁne the coefﬁcient vectors for the polynomials AŒ0\u0004 and AŒ1\u0004. Lines\n4, 5, and 13 guarantee that ! is updated properly so that whenever lines 11–12\nare executed, we have ! D !k\nn. (Keeping a running value of ! from iteration\nto iteration saves time over computing !k\nn from scratch each time through the for\nloop.) Lines 8–9 perform the recursive DFTn=2 computations, setting, for k D\n0; 1; : : : ; n=2 \u0005 1,\nyŒ0\u0004\nk\nD\nAŒ0\u0004.!k\nn=2/ ;\nyŒ1\u0004\nk\nD\nAŒ1\u0004.!k\nn=2/ ;\nor, since !k\nn=2 D !2k\nn by the cancellation lemma,\nyŒ0\u0004\nk\nD\nAŒ0\u0004.!2k\nn / ;\nyŒ1\u0004\nk\nD\nAŒ1\u0004.!2k\nn / :\n912\nChapter 30\nPolynomials and the FFT\nLines 11–12 combine the results of the recursive DFTn=2 calculations. For y0; y1;\n: : : ; yn=2\u00031, line 11 yields\nyk\nD\nyŒ0\u0004\nk C !k\nnyŒ1\u0004\nk\nD\nAŒ0\u0004.!2k\nn / C !k\nnAŒ1\u0004.!2k\nn /\nD\nA.!k\nn/\n(by equation (30.9)) .\nFor yn=2; yn=2C1; : : : ; yn\u00031, letting k D 0; 1; : : : ; n=2 \u0005 1, line 12 yields\nykC.n=2/\nD\nyŒ0\u0004\nk \u0005 !k\nnyŒ1\u0004\nk\nD\nyŒ0\u0004\nk C !kC.n=2/\nn\nyŒ1\u0004\nk\n(since !kC.n=2/\nn\nD \u0005!k\nn)\nD\nAŒ0\u0004.!2k\nn / C !kC.n=2/\nn\nAŒ1\u0004.!2k\nn /\nD\nAŒ0\u0004.!2kCn\nn\n/ C !kC.n=2/\nn",
    "parent_e14466e4-ad7c-4043-a001-7597f59c2563": "n / C !k\nnAŒ1\u0004.!2k\nn /\nD\nA.!k\nn/\n(by equation (30.9)) .\nFor yn=2; yn=2C1; : : : ; yn\u00031, letting k D 0; 1; : : : ; n=2 \u0005 1, line 12 yields\nykC.n=2/\nD\nyŒ0\u0004\nk \u0005 !k\nnyŒ1\u0004\nk\nD\nyŒ0\u0004\nk C !kC.n=2/\nn\nyŒ1\u0004\nk\n(since !kC.n=2/\nn\nD \u0005!k\nn)\nD\nAŒ0\u0004.!2k\nn / C !kC.n=2/\nn\nAŒ1\u0004.!2k\nn /\nD\nAŒ0\u0004.!2kCn\nn\n/ C !kC.n=2/\nn\nAŒ1\u0004.!2kCn\nn\n/\n(since !2kCn\nn\nD !2k\nn )\nD\nA.!kC.n=2/\nn\n/\n(by equation (30.9)) .\nThus, the vector y returned by RECURSIVE-FFT is indeed the DFT of the input\nvector a.\nLines 11 and 12 multiply each value yŒ1\u0004\nk\nby !k\nn, for k D 0; 1; : : : ; n=2 \u0005 1.\nLine 11 adds this product to yŒ0\u0004\nk , and line 12 subtracts it. Because we use each\nfactor !k\nn in both its positive and negative forms, we call the factors !k\nn twiddle\nfactors.\nTo determine the running time of procedure RECURSIVE-FFT, we note that\nexclusive of the recursive calls, each invocation takes time ‚.n/, where n is the\nlength of the input vector. The recurrence for the running time is therefore\nT .n/\nD\n2T .n=2/ C ‚.n/\nD\n‚.n lg n/ :\nThus, we can evaluate a polynomial of degree-bound n at the complex nth roots of\nunity in time ‚.n lg n/ using the fast Fourier transform.\nInterpolation at the complex roots of unity\nWe now complete the polynomial multiplication scheme by showing how to in-\nterpolate the complex roots of unity by a polynomial, which enables us to convert\nfrom point-value form back to coefﬁcient form. We interpolate by writing the DFT\nas a matrix equation and then looking at the form of the matrix inverse.\nFrom equation (30.4), we can write the DFT as the matrix product y D Vna,\nwhere Vn is a Vandermonde matrix containing the appropriate powers of !n:\n30.2\nThe DFT and FFT\n913\n\u0005\ny0\ny1\ny2\ny3\n:::\nyn\u00031\n\u0006\nD\n\u0005\n1\n1\n1\n1\n\u0003 \u0003 \u0003\n1\n1\n!n\n!2\nn\n!3\nn\n\u0003 \u0003 \u0003\n!n\u00031\nn\n1\n!2\nn\n!4\nn\n!6\nn\n\u0003 \u0003 \u0003\n!2.n\u00031/\nn\n1\n!3\nn\n!6\nn\n!9\nn\n\u0003 \u0003 \u0003\n!3.n\u00031/\nn\n:::\n:::\n:::\n:::\n:::\n:::\n1 !n\u00031\nn\n!2.n\u00031/\nn\n!3.n\u00031/\nn\n\u0003 \u0003 \u0003 !.n\u00031/.n\u00031/\nn\n\u0006\u0005\na0\na1\na2\na3\n:::\nan\u00031\n\u0006\n:\nThe .k; j / entry of Vn is !kj\nn , for j; k D 0; 1; : : : ; n \u0005 1. The exponents of the",
    "parent_7dfc1dbb-6d30-4d11-ad09-cf2a1b443756": "1\n1\n1\n1\n\u0003 \u0003 \u0003\n1\n1\n!n\n!2\nn\n!3\nn\n\u0003 \u0003 \u0003\n!n\u00031\nn\n1\n!2\nn\n!4\nn\n!6\nn\n\u0003 \u0003 \u0003\n!2.n\u00031/\nn\n1\n!3\nn\n!6\nn\n!9\nn\n\u0003 \u0003 \u0003\n!3.n\u00031/\nn\n:::\n:::\n:::\n:::\n:::\n:::\n1 !n\u00031\nn\n!2.n\u00031/\nn\n!3.n\u00031/\nn\n\u0003 \u0003 \u0003 !.n\u00031/.n\u00031/\nn\n\u0006\u0005\na0\na1\na2\na3\n:::\nan\u00031\n\u0006\n:\nThe .k; j / entry of Vn is !kj\nn , for j; k D 0; 1; : : : ; n \u0005 1. The exponents of the\nentries of Vn form a multiplication table.\nFor the inverse operation, which we write as a D DFT\u00031\nn .y/, we proceed by\nmultiplying y by the matrix V \u00031\nn , the inverse of Vn.\nTheorem 30.7\nFor j; k D 0; 1; : : : ; n \u0005 1, the .j; k/ entry of V \u00031\nn\nis !\u0003kj\nn\n=n.\nProof\nWe show that V \u00031\nn Vn D In, the n \t n identity matrix. Consider the .j; j 0/\nentry of V \u00031\nn Vn:\nŒV \u00031\nn Vn\u0002jj 0\nD\nn\u00031\nX\nkD0\n.!\u0003kj\nn\n=n/.!kj 0\nn /\nD\nn\u00031\nX\nkD0\n!k.j 0\u0003j/\nn\n=n :\nThis summation equals 1 if j 0 D j , and it is 0 otherwise by the summation lemma\n(Lemma 30.6). Note that we rely on \u0005.n \u0005 1/ \u0002 j 0 \u0005 j \u0002 n \u0005 1, so that j 0 \u0005 j is\nnot divisible by n, in order for the summation lemma to apply.\nGiven the inverse matrix V \u00031\nn , we have that DFT\u00031\nn .y/ is given by\naj D 1\nn\nn\u00031\nX\nkD0\nyk!\u0003kj\nn\n(30.11)\nfor j D 0; 1; : : : ; n \u0005 1. By comparing equations (30.8) and (30.11), we see that\nby modifying the FFT algorithm to switch the roles of a and y, replace !n by !\u00031\nn ,\nand divide each element of the result by n, we compute the inverse DFT (see Ex-\nercise 30.2-4). Thus, we can compute DFT\u00031\nn in ‚.n lg n/ time as well.\nWe see that, by using the FFT and the inverse FFT, we can transform a poly-\nnomial of degree-bound n back and forth between its coefﬁcient representation\nand a point-value representation in time ‚.n lg n/. In the context of polynomial\nmultiplication, we have shown the following.\n914\nChapter 30\nPolynomials and the FFT\nTheorem 30.8 (Convolution theorem)\nFor any two vectors a and b of length n, where n is a power of 2,\na ˝ b D DFT\u00031\n2n.DFT2n.a/ \u0003 DFT2n.b// ;\nwhere the vectors a and b are padded with 0s to length 2n and \u0003 denotes the com-\nponentwise product of two 2n-element vectors.\nExercises",
    "parent_b2eeb770-0b48-4717-baa0-42a887ea9b71": "Theorem 30.8 (Convolution theorem)\nFor any two vectors a and b of length n, where n is a power of 2,\na ˝ b D DFT\u00031\n2n.DFT2n.a/ \u0003 DFT2n.b// ;\nwhere the vectors a and b are padded with 0s to length 2n and \u0003 denotes the com-\nponentwise product of two 2n-element vectors.\nExercises\n30.2-1\nProve Corollary 30.4.\n30.2-2\nCompute the DFT of the vector .0; 1; 2; 3/.\n30.2-3\nDo Exercise 30.1-1 by using the ‚.n lg n/-time scheme.\n30.2-4\nWrite pseudocode to compute DFT\u00031\nn in ‚.n lg n/ time.\n30.2-5\nDescribe the generalization of the FFT procedure to the case in which n is a power\nof 3. Give a recurrence for the running time, and solve the recurrence.\n30.2-6\n?\nSuppose that instead of performing an n-element FFT over the ﬁeld of complex\nnumbers (where n is even), we use the ring Zm of integers modulo m, where\nm D 2tn=2 C 1 and t is an arbitrary positive integer. Use ! D 2t instead of !n\nas a principal nth root of unity, modulo m. Prove that the DFT and the inverse DFT\nare well deﬁned in this system.\n30.2-7\nGiven a list of values ´0; ´1; : : : ; ´n\u00031 (possibly with repetitions), show how to ﬁnd\nthe coefﬁcients of a polynomial P.x/ of degree-bound n C 1 that has zeros only\nat ´0; ´1; : : : ; ´n\u00031 (possibly with repetitions). Your procedure should run in time\nO.n lg2 n/. (Hint: The polynomial P.x/ has a zero at ´j if and only if P.x/ is a\nmultiple of .x \u0005 ´j/.)\n30.2-8\n?\nThe chirp transform of a vector a D .a0; a1; : : : ; an\u00031/ is the vector y D\n.y0; y1; : : : ; yn\u00031/, where yk D Pn\u00031\njD0 aj´kj and ´ is any complex number. The\n30.3\nEfﬁcient FFT implementations\n915\nDFT is therefore a special case of the chirp transform, obtained by taking ´ D !n.\nShow how to evaluate the chirp transform in time O.n lg n/ for any complex num-\nber ´. (Hint: Use the equation\nyk D ´k2=2\nn\u00031\nX\njD0\n\u0004\naj´j 2=2\u0005 \u0004\n´\u0003.k\u0003j/2=2\u0005\nto view the chirp transform as a convolution.)\n30.3\nEfﬁcient FFT implementations\nSince the practical applications of the DFT, such as signal processing, demand the",
    "parent_b8d72525-13b3-4df8-8f72-0b55b5b280ba": "ber ´. (Hint: Use the equation\nyk D ´k2=2\nn\u00031\nX\njD0\n\u0004\naj´j 2=2\u0005 \u0004\n´\u0003.k\u0003j/2=2\u0005\nto view the chirp transform as a convolution.)\n30.3\nEfﬁcient FFT implementations\nSince the practical applications of the DFT, such as signal processing, demand the\nutmost speed, this section examines two efﬁcient FFT implementations. First, we\nshall examine an iterative version of the FFT algorithm that runs in ‚.n lg n/ time\nbut can have a lower constant hidden in the ‚-notation than the recursive version\nin Section 30.2. (Depending on the exact implementation, the recursive version\nmay use the hardware cache more efﬁciently.) Then, we shall use the insights that\nled us to the iterative implementation to design an efﬁcient parallel FFT circuit.\nAn iterative FFT implementation\nWe ﬁrst note that the for loop of lines 10–13 of RECURSIVE-FFT involves com-\nputing the value !k\nn yŒ1\u0004\nk\ntwice. In compiler terminology, we call such a value a\ncommon subexpression. We can change the loop to compute it only once, storing\nit in a temporary variable t.\nfor k D 0 to n=2 \u0005 1\nt D ! yŒ1\u0004\nk\nyk D yŒ0\u0004\nk C t\nykC.n=2/ D yŒ0\u0004\nk \u0005 t\n! D ! !n\nThe operation in this loop, multiplying the twiddle factor ! D !k\nn by yŒ1\u0004\nk , storing\nthe product into t, and adding and subtracting t from yŒ0\u0004\nk , is known as a butterﬂy\noperation and is shown schematically in Figure 30.3.\nWe now show how to make the FFT algorithm iterative rather than recursive\nin structure. In Figure 30.4, we have arranged the input vectors to the recursive\ncalls in an invocation of RECURSIVE-FFT in a tree structure, where the initial\ncall is for n D 8. The tree has one node for each call of the procedure, labeled\n916\nChapter 30\nPolynomials and the FFT\n+\n–\n•\n(a)\n(b)\nyŒ0\u0004\nk\nyŒ0\u0004\nk\nyŒ1\u0004\nk\nyŒ1\u0004\nk\n!k\nn\n!k\nn\nyŒ0\u0004\nk C !k\nnyŒ1\u0004\nk\nyŒ0\u0004\nk C !k\nnyŒ1\u0004\nk\nyŒ0\u0004\nk \u0005 !k\nnyŒ1\u0004\nk\nyŒ0\u0004\nk \u0005 !k\nnyŒ1\u0004\nk\nFigure 30.3\nA butterﬂy operation. (a) The two input values enter from the left, the twiddle fac-\ntor !k\nn is multiplied by yŒ1\u0004",
    "parent_d6fa84cd-1f67-4eae-8bf6-608850c57640": "916\nChapter 30\nPolynomials and the FFT\n+\n–\n•\n(a)\n(b)\nyŒ0\u0004\nk\nyŒ0\u0004\nk\nyŒ1\u0004\nk\nyŒ1\u0004\nk\n!k\nn\n!k\nn\nyŒ0\u0004\nk C !k\nnyŒ1\u0004\nk\nyŒ0\u0004\nk C !k\nnyŒ1\u0004\nk\nyŒ0\u0004\nk \u0005 !k\nnyŒ1\u0004\nk\nyŒ0\u0004\nk \u0005 !k\nnyŒ1\u0004\nk\nFigure 30.3\nA butterﬂy operation. (a) The two input values enter from the left, the twiddle fac-\ntor !k\nn is multiplied by yŒ1\u0004\nk , and the sum and difference are output on the right. (b) A simpliﬁed\ndrawing of a butterﬂy operation. We will use this representation in a parallel FFT circuit.\n(a0,a1,a2,a3,a4,a5,a6,a7)\n(a0,a2,a4,a6)\n(a0,a4)\n(a2,a6)\n(a0)\n(a4)\n(a2)\n(a6)\n(a1,a3,a5,a7)\n(a1,a5)\n(a1)\n(a5)\n(a3,a7)\n(a3)\n(a7)\nFigure 30.4\nThe tree of input vectors to the recursive calls of the RECURSIVE-FFT procedure. The\ninitial invocation is for n D 8.\nby the corresponding input vector. Each RECURSIVE-FFT invocation makes two\nrecursive calls, unless it has received a 1-element vector. The ﬁrst call appears in\nthe left child, and the second call appears in the right child.\nLooking at the tree, we observe that if we could arrange the elements of the\ninitial vector a into the order in which they appear in the leaves, we could trace\nthe execution of the RECURSIVE-FFT procedure, but bottom up instead of top\ndown. First, we take the elements in pairs, compute the DFT of each pair using\none butterﬂy operation, and replace the pair with its DFT. The vector then holds\nn=2 2-element DFTs. Next, we take these n=2 DFTs in pairs and compute the\nDFT of the four vector elements they come from by executing two butterﬂy oper-\nations, replacing two 2-element DFTs with one 4-element DFT. The vector then\nholds n=4 4-element DFTs. We continue in this manner until the vector holds two\n.n=2/-element DFTs, which we combine using n=2 butterﬂy operations into the\nﬁnal n-element DFT.\nTo turn this bottom-up approach into code, we use an array AŒ0 : : n \u0005 1\u0002 that\ninitially holds the elements of the input vector a in the order in which they appear\n30.3\nEfﬁcient FFT implementations\n917",
    "parent_7b1f3a0c-0cec-4861-8266-84d8ebf5ed14": ".n=2/-element DFTs, which we combine using n=2 butterﬂy operations into the\nﬁnal n-element DFT.\nTo turn this bottom-up approach into code, we use an array AŒ0 : : n \u0005 1\u0002 that\ninitially holds the elements of the input vector a in the order in which they appear\n30.3\nEfﬁcient FFT implementations\n917\nin the leaves of the tree of Figure 30.4. (We shall show later how to determine this\norder, which is known as a bit-reversal permutation.) Because we have to combine\nDFTs on each level of the tree, we introduce a variable s to count the levels, ranging\nfrom 1 (at the bottom, when we are combining pairs to form 2-element DFTs)\nto lg n (at the top, when we are combining two .n=2/-element DFTs to produce the\nﬁnal result). The algorithm therefore has the following structure:\n1\nfor s D 1 to lg n\n2\nfor k D 0 to n \u0005 1 by 2s\n3\ncombine the two 2s\u00031-element DFTs in\nAŒk : : k C 2s\u00031 \u0005 1\u0002 and AŒk C 2s\u00031 : : k C 2s \u0005 1\u0002\ninto one 2s-element DFT in AŒk : : k C 2s \u0005 1\u0002\nWe can express the body of the loop (line 3) as more precise pseudocode. We\ncopy the for loop from the RECURSIVE-FFT procedure, identifying yŒ0\u0004 with\nAŒk : : k C 2s\u00031 \u0005 1\u0002 and yŒ1\u0004 with AŒk C 2s\u00031 : : k C 2s \u0005 1\u0002. The twiddle fac-\ntor used in each butterﬂy operation depends on the value of s; it is a power of !m,\nwhere m D 2s. (We introduce the variable m solely for the sake of readability.)\nWe introduce another temporary variable u that allows us to perform the butterﬂy\noperation in place. When we replace line 3 of the overall structure by the loop\nbody, we get the following pseudocode, which forms the basis of the parallel im-\nplementation we shall present later. The code ﬁrst calls the auxiliary procedure\nBIT-REVERSE-COPY.a; A/ to copy vector a into array A in the initial order in\nwhich we need the values.\nITERATIVE-FFT.a/\n1\nBIT-REVERSE-COPY.a; A/\n2\nn D a:length\n// n is a power of 2\n3\nfor s D 1 to lg n\n4\nm D 2s\n5\n!m D e2\u0003i=m\n6\nfor k D 0 to n \u0005 1 by m\n7\n! D 1\n8\nfor j D 0 to m=2 \u0005 1\n9\nt D ! AŒk C j C m=2\u0002\n10\nu D AŒk C j \u0002",
    "parent_da51191a-e72b-460d-ada3-b1bc236d7dfd": "which we need the values.\nITERATIVE-FFT.a/\n1\nBIT-REVERSE-COPY.a; A/\n2\nn D a:length\n// n is a power of 2\n3\nfor s D 1 to lg n\n4\nm D 2s\n5\n!m D e2\u0003i=m\n6\nfor k D 0 to n \u0005 1 by m\n7\n! D 1\n8\nfor j D 0 to m=2 \u0005 1\n9\nt D ! AŒk C j C m=2\u0002\n10\nu D AŒk C j \u0002\n11\nAŒk C j \u0002 D u C t\n12\nAŒk C j C m=2\u0002 D u \u0005 t\n13\n! D ! !m\n14\nreturn A\nHow does BIT-REVERSE-COPY get the elements of the input vector a into the\ndesired order in the array A? The order in which the leaves appear in Figure 30.4\n918\nChapter 30\nPolynomials and the FFT\nis a bit-reversal permutation.\nThat is, if we let rev.k/ be the lg n-bit integer\nformed by reversing the bits of the binary representation of k, then we want to\nplace vector element ak in array position AŒrev.k/\u0002. In Figure 30.4, for exam-\nple, the leaves appear in the order 0; 4; 2; 6; 1; 5; 3; 7; this sequence in binary is\n000; 100; 010; 110; 001; 101; 011; 111, and when we reverse the bits of each value\nwe get the sequence 000; 001; 010; 011; 100; 101; 110; 111. To see that we want a\nbit-reversal permutation in general, we note that at the top level of the tree, indices\nwhose low-order bit is 0 go into the left subtree and indices whose low-order bit\nis 1 go into the right subtree. Stripping off the low-order bit at each level, we con-\ntinue this process down the tree, until we get the order given by the bit-reversal\npermutation at the leaves.\nSince we can easily compute the function rev.k/, the BIT-REVERSE-COPY pro-\ncedure is simple:\nBIT-REVERSE-COPY.a; A/\n1\nn D a:length\n2\nfor k D 0 to n \u0005 1\n3\nAŒrev.k/\u0002 D ak\nThe iterative FFT implementation runs in time ‚.n lg n/.\nThe call to BIT-\nREVERSE-COPY.a; A/ certainly runs in O.n lg n/ time, since we iterate n times\nand can reverse an integer between 0 and n \u0005 1, with lg n bits, in O.lg n/ time.\n(In practice, because we usually know the initial value of n in advance, we would\nprobably code a table mapping k to rev.k/, making BIT-REVERSE-COPY run in",
    "parent_2950dc78-6543-4e07-a97e-b39978e6c0c0": "and can reverse an integer between 0 and n \u0005 1, with lg n bits, in O.lg n/ time.\n(In practice, because we usually know the initial value of n in advance, we would\nprobably code a table mapping k to rev.k/, making BIT-REVERSE-COPY run in\n‚.n/ time with a low hidden constant. Alternatively, we could use the clever amor-\ntized reverse binary counter scheme described in Problem 17-1.) To complete the\nproof that ITERATIVE-FFT runs in time ‚.n lg n/, we show that L.n/, the number\nof times the body of the innermost loop (lines 8–13) executes, is ‚.n lg n/. The\nfor loop of lines 6–13 iterates n=m D n=2s times for each value of s, and the\ninnermost loop of lines 8–13 iterates m=2 D 2s\u00031 times. Thus,\nL.n/\nD\nlg n\nX\nsD1\nn\n2s \u0003 2s\u00031\nD\nlg n\nX\nsD1\nn\n2\nD\n‚.n lg n/ :\n30.3\nEfﬁcient FFT implementations\n919\na0\na1\na2\na3\na4\na5\na6\na7\ny0\ny1\ny2\ny3\ny4\ny5\ny6\ny7\nstage s D 1\nstage s D 2\nstage s D 3\n!0\n2\n!0\n2\n!0\n2\n!0\n2\n!0\n4\n!0\n4\n!1\n4\n!1\n4\n!0\n8\n!1\n8\n!2\n8\n!3\n8\nFigure 30.5\nA circuit that computes the FFT in parallel, here shown on n D 8 inputs. Each\nbutterﬂy operation takes as input the values on two wires, along with a twiddle factor, and it produces\nas outputs the values on two wires. The stages of butterﬂies are labeled to correspond to iterations\nof the outermost loop of the ITERATIVE-FFT procedure. Only the top and bottom wires passing\nthrough a butterﬂy interact with it; wires that pass through the middle of a butterﬂy do not affect\nthat butterﬂy, nor are their values changed by that butterﬂy. For example, the top butterﬂy in stage 2\nhas nothing to do with wire 1 (the wire whose output is labeled y1); its inputs and outputs are only\non wires 0 and 2 (labeled y0 and y2, respectively). This circuit has depth ‚.lg n/ and performs\n‚.n lg n/ butterﬂy operations altogether.\nA parallel FFT circuit\nWe can exploit many of the properties that allowed us to implement an efﬁcient\niterative FFT algorithm to produce an efﬁcient parallel algorithm for the FFT. We",
    "parent_214843e4-0c6c-41ca-a1dc-693dc0839c6e": "‚.n lg n/ butterﬂy operations altogether.\nA parallel FFT circuit\nWe can exploit many of the properties that allowed us to implement an efﬁcient\niterative FFT algorithm to produce an efﬁcient parallel algorithm for the FFT. We\nwill express the parallel FFT algorithm as a circuit. Figure 30.5 shows a parallel\nFFT circuit, which computes the FFT on n inputs, for n D 8. The circuit begins\nwith a bit-reverse permutation of the inputs, followed by lg n stages, each stage\nconsisting of n=2 butterﬂies executed in parallel. The depth of the circuit—the\nmaximum number of computational elements between any output and any input\nthat can reach it—is therefore ‚.lg n/.\nThe leftmost part of the parallel FFT circuit performs the bit-reverse permuta-\ntion, and the remainder mimics the iterative ITERATIVE-FFT procedure. Because\neach iteration of the outermost for loop performs n=2 independent butterﬂy opera-\ntions, the circuit performs them in parallel. The value of s in each iteration within\n920\nChapter 30\nPolynomials and the FFT\nITERATIVE-FFT corresponds to a stage of butterﬂies shown in Figure 30.5. For\ns D 1; 2; : : : ; lg n, stage s consists of n=2s groups of butterﬂies (corresponding to\neach value of k in ITERATIVE-FFT), with 2s\u00031 butterﬂies per group (corresponding\nto each value of j in ITERATIVE-FFT). The butterﬂies shown in Figure 30.5 corre-\nspond to the butterﬂy operations of the innermost loop (lines 9–12 of ITERATIVE-\nFFT). Note also that the twiddle factors used in the butterﬂies correspond to those\nused in ITERATIVE-FFT: in stage s, we use !0\nm; !1\nm; : : : ; !m=2\u00031\nm\n, where m D 2s.\nExercises\n30.3-1\nShow how ITERATIVE-FFT computes the DFT of the input vector .0; 2; 3; \u00051; 4;\n5; 7; 9/.\n30.3-2\nShow how to implement an FFT algorithm with the bit-reversal permutation occur-\nring at the end, rather than at the beginning, of the computation. (Hint: Consider\nthe inverse DFT.)\n30.3-3\nHow many times does ITERATIVE-FFT compute twiddle factors in each stage?",
    "parent_e419be6f-e68a-41c3-9c88-197872598320": "5; 7; 9/.\n30.3-2\nShow how to implement an FFT algorithm with the bit-reversal permutation occur-\nring at the end, rather than at the beginning, of the computation. (Hint: Consider\nthe inverse DFT.)\n30.3-3\nHow many times does ITERATIVE-FFT compute twiddle factors in each stage?\nRewrite ITERATIVE-FFT to compute twiddle factors only 2s\u00031 times in stage s.\n30.3-4\n?\nSuppose that the adders within the butterﬂy operations of the FFT circuit some-\ntimes fail in such a manner that they always produce a zero output, independent\nof their inputs. Suppose that exactly one adder has failed, but that you don’t know\nwhich one. Describe how you can identify the failed adder by supplying inputs to\nthe overall FFT circuit and observing the outputs. How efﬁcient is your method?\nProblems\n30-1\nDivide-and-conquer multiplication\na. Show how to multiply two linear polynomials ax C b and cx C d using only\nthree multiplications. (Hint: One of the multiplications is .a C b/ \u0003 .c C d/.)\nb. Give two divide-and-conquer algorithms for multiplying two polynomials of\ndegree-bound n in ‚.nlg 3/ time. The ﬁrst algorithm should divide the input\npolynomial coefﬁcients into a high half and a low half, and the second algorithm\nshould divide them according to whether their index is odd or even.\nProblems for Chapter 30\n921\nc. Show how to multiply two n-bit integers in O.nlg 3/ steps, where each step\noperates on at most a constant number of 1-bit values.\n30-2\nToeplitz matrices\nA Toeplitz matrix is an n \t n matrix A D .aij/ such that aij D ai\u00031;j\u00031 for\ni D 2; 3; : : : ; n and j D 2; 3; : : : ; n.\na. Is the sum of two Toeplitz matrices necessarily Toeplitz? What about the prod-\nuct?\nb. Describe how to represent a Toeplitz matrix so that you can add two n \t n\nToeplitz matrices in O.n/ time.\nc. Give an O.n lg n/-time algorithm for multiplying an n \t n Toeplitz matrix by a\nvector of length n. Use your representation from part (b).\nd. Give an efﬁcient algorithm for multiplying two n\tn Toeplitz matrices. Analyze",
    "parent_bdd09d79-9bbe-4b37-921a-22373b84c712": "Toeplitz matrices in O.n/ time.\nc. Give an O.n lg n/-time algorithm for multiplying an n \t n Toeplitz matrix by a\nvector of length n. Use your representation from part (b).\nd. Give an efﬁcient algorithm for multiplying two n\tn Toeplitz matrices. Analyze\nits running time.\n30-3\nMultidimensional fast Fourier transform\nWe can generalize the 1-dimensional discrete Fourier transform deﬁned by equa-\ntion (30.8) to d dimensions. The input is a d-dimensional array A D .aj1;j2;:::;jd /\nwhose dimensions are n1; n2; : : : ; nd, where n1n2 \u0003 \u0003 \u0003 nd D n.\nWe deﬁne the\nd-dimensional discrete Fourier transform by the equation\nyk1;k2;:::;kd D\nn1\u00031\nX\nj1D0\nn2\u00031\nX\nj2D0\n\u0003 \u0003 \u0003\nnd \u00031\nX\njd D0\naj1;j2;:::;jd !j1k1\nn1\n!j2k2\nn2\n\u0003 \u0003 \u0003 !jd kd\nnd\nfor 0 \u0002 k1 < n1, 0 \u0002 k2 < n2, . . . , 0 \u0002 kd < nd.\na. Show that we can compute a d-dimensional DFT by computing 1-dimensional\nDFTs on each dimension in turn. That is, we ﬁrst compute n=n1 separate\n1-dimensional DFTs along dimension 1. Then, using the result of the DFTs\nalong dimension 1 as the input, we compute n=n2 separate 1-dimensional DFTs\nalong dimension 2. Using this result as the input, we compute n=n3 separate\n1-dimensional DFTs along dimension 3, and so on, through dimension d.\nb. Show that the ordering of dimensions does not matter, so that we can compute\na d-dimensional DFT by computing the 1-dimensional DFTs in any order of\nthe d dimensions.\n922\nChapter 30\nPolynomials and the FFT\nc. Show that if we compute each 1-dimensional DFT by computing the fast Four-\nier transform, the total time to compute a d-dimensional DFT is O.n lg n/,\nindependent of d.\n30-4\nEvaluating all derivatives of a polynomial at a point\nGiven a polynomial A.x/ of degree-bound n, we deﬁne its tth derivative by\nA.t/.x/ D\n„\nA.x/\nif t D 0 ;\nd\ndxA.t\u00031/.x/\nif 1 \u0002 t \u0002 n \u0005 1 ;\n0\nif t \u0006 n :\nFrom the coefﬁcient representation .a0; a1; : : : ; an\u00031/ of A.x/ and a given point x0,\nwe wish to determine A.t/.x0/ for t D 0; 1; : : : ; n \u0005 1.",
    "parent_bf02c66a-ad2a-4d39-a1ee-fc23126f492e": "Given a polynomial A.x/ of degree-bound n, we deﬁne its tth derivative by\nA.t/.x/ D\n„\nA.x/\nif t D 0 ;\nd\ndxA.t\u00031/.x/\nif 1 \u0002 t \u0002 n \u0005 1 ;\n0\nif t \u0006 n :\nFrom the coefﬁcient representation .a0; a1; : : : ; an\u00031/ of A.x/ and a given point x0,\nwe wish to determine A.t/.x0/ for t D 0; 1; : : : ; n \u0005 1.\na. Given coefﬁcients b0; b1; : : : ; bn\u00031 such that\nA.x/ D\nn\u00031\nX\njD0\nbj.x \u0005 x0/j ;\nshow how to compute A.t/.x0/, for t D 0; 1; : : : ; n \u0005 1, in O.n/ time.\nb. Explain how to ﬁnd b0; b1; : : : ; bn\u00031 in O.n lg n/ time, given A.x0 C !k\nn/ for\nk D 0; 1; : : : ; n \u0005 1.\nc. Prove that\nA.x0 C !k\nn/ D\nn\u00031\nX\nrD0\n \n!kr\nn\nrŠ\nn\u00031\nX\njD0\nf .j /g.r \u0005 j /\n!\n;\nwhere f .j / D aj \u0003 j Š and\ng.l/ D\n(\nx\u0003l\n0 =.\u0005l/Š\nif \u0005.n \u0005 1/ \u0002 l \u0002 0 ;\n0\nif 1 \u0002 l \u0002 n \u0005 1 :\nd. Explain how to evaluate A.x0 C !k\nn/ for k D 0; 1; : : : ; n \u0005 1 in O.n lg n/\ntime. Conclude that we can evaluate all nontrivial derivatives of A.x/ at x0 in\nO.n lg n/ time.\nProblems for Chapter 30\n923\n30-5\nPolynomial evaluation at multiple points\nWe have seen how to evaluate a polynomial of degree-bound n at a single point in\nO.n/ time using Horner’s rule. We have also discovered how to evaluate such a\npolynomial at all n complex roots of unity in O.n lg n/ time using the FFT. We\nshall now show how to evaluate a polynomial of degree-bound n at n arbitrary\npoints in O.n lg2 n/ time.\nTo do so, we shall assume that we can compute the polynomial remainder when\none such polynomial is divided by another in O.n lg n/ time, a result that we state\nwithout proof. For example, the remainder of 3x3 C x2 \u0005 3x C 1 when divided by\nx2 C x C 2 is\n.3x3 C x2 \u0005 3x C 1/ mod .x2 C x C 2/ D \u00057x C 5 :\nGiven the coefﬁcient representation of a polynomial A.x/ D Pn\u00031\nkD0 akxk and\nn points x0; x1; : : : ; xn\u00031, we wish to compute the n values A.x0/; A.x1/; : : : ;\nA.xn\u00031/. For 0 \u0002 i \u0002 j \u0002 n \u0005 1, deﬁne the polynomials Pij.x/ D Qj\nkDi.x \u0005 xk/\nand Qij.x/ D A.x/ mod Pij.x/. Note that Qij .x/ has degree at most j \u0005 i.\na. Prove that A.x/ mod .x \u0005 ´/ D A.´/ for any point ´.",
    "parent_9972e1ab-7eee-474b-ba0f-3f7d679bbdc9": "n points x0; x1; : : : ; xn\u00031, we wish to compute the n values A.x0/; A.x1/; : : : ;\nA.xn\u00031/. For 0 \u0002 i \u0002 j \u0002 n \u0005 1, deﬁne the polynomials Pij.x/ D Qj\nkDi.x \u0005 xk/\nand Qij.x/ D A.x/ mod Pij.x/. Note that Qij .x/ has degree at most j \u0005 i.\na. Prove that A.x/ mod .x \u0005 ´/ D A.´/ for any point ´.\nb. Prove that Qkk.x/ D A.xk/ and that Q0;n\u00031.x/ D A.x/.\nc. Prove that for i \u0002 k \u0002 j , we have Qik.x/ D Qij.x/ mod Pik.x/ and\nQkj .x/ D Qij.x/ mod Pkj .x/.\nd. Give an O.n lg2 n/-time algorithm to evaluate A.x0/; A.x1/; : : : ; A.xn\u00031/.\n30-6\nFFT using modular arithmetic\nAs deﬁned, the discrete Fourier transform requires us to compute with complex\nnumbers, which can result in a loss of precision due to round-off errors. For some\nproblems, the answer is known to contain only integers, and by using a variant of\nthe FFT based on modular arithmetic, we can guarantee that the answer is calcu-\nlated exactly. An example of such a problem is that of multiplying two polynomials\nwith integer coefﬁcients. Exercise 30.2-6 gives one approach, using a modulus of\nlength \u0004.n/ bits to handle a DFT on n points. This problem gives another ap-\nproach, which uses a modulus of the more reasonable length O.lg n/; it requires\nthat you understand the material of Chapter 31. Let n be a power of 2.\na. Suppose that we search for the smallest k such that p D kn C 1 is prime. Give\na simple heuristic argument why we might expect k to be approximately ln n.\n(The value of k might be much larger or smaller, but we can reasonably expect\nto examine O.lg n/ candidate values of k on average.) How does the expected\nlength of p compare to the length of n?\n924\nChapter 30\nPolynomials and the FFT\nLet g be a generator of Z\u0004\np, and let w D gk mod p.\nb. Argue that the DFT and the inverse DFT are well-deﬁned inverse operations\nmodulo p, where w is used as a principal nth root of unity.\nc. Show how to make the FFT and its inverse work modulo p in time O.n lg n/,",
    "parent_6510d5b7-bed4-4832-936c-44513cc4605c": "Polynomials and the FFT\nLet g be a generator of Z\u0004\np, and let w D gk mod p.\nb. Argue that the DFT and the inverse DFT are well-deﬁned inverse operations\nmodulo p, where w is used as a principal nth root of unity.\nc. Show how to make the FFT and its inverse work modulo p in time O.n lg n/,\nwhere operations on words of O.lg n/ bits take unit time. Assume that the\nalgorithm is given p and w.\nd. Compute the DFT modulo p D 17 of the vector .0; 5; 3; 7; 7; 2; 1; 6/. Note that\ng D 3 is a generator of Z\u0004\n17.\nChapter notes\nVan Loan’s book [343] provides an outstanding treatment of the fast Fourier trans-\nform. Press, Teukolsky, Vetterling, and Flannery [283, 284] have a good descrip-\ntion of the fast Fourier transform and its applications. For an excellent introduction\nto signal processing, a popular FFT application area, see the texts by Oppenheim\nand Schafer [266] and Oppenheim and Willsky [267]. The Oppenheim and Schafer\nbook also shows how to handle cases in which n is not an integer power of 2.\nFourier analysis is not limited to 1-dimensional data. It is widely used in image\nprocessing to analyze data in 2 or more dimensions. The books by Gonzalez and\nWoods [146] and Pratt [281] discuss multidimensional Fourier transforms and their\nuse in image processing, and books by Tolimieri, An, and Lu [338] and Van Loan\n[343] discuss the mathematics of multidimensional fast Fourier transforms.\nCooley and Tukey [76] are widely credited with devising the FFT in the 1960s.\nThe FFT had in fact been discovered many times previously, but its importance was\nnot fully realized before the advent of modern digital computers. Although Press,\nTeukolsky, Vetterling, and Flannery attribute the origins of the method to Runge\nand K¨onig in 1924, an article by Heideman, Johnson, and Burrus [163] traces the\nhistory of the FFT as far back as C. F. Gauss in 1805.\nFrigo and Johnson [117] developed a fast and ﬂexible implementation of the",
    "parent_e02028a9-ad5d-4802-b47d-fc06c10f0b6a": "Teukolsky, Vetterling, and Flannery attribute the origins of the method to Runge\nand K¨onig in 1924, an article by Heideman, Johnson, and Burrus [163] traces the\nhistory of the FFT as far back as C. F. Gauss in 1805.\nFrigo and Johnson [117] developed a fast and ﬂexible implementation of the\nFFT, called FFTW (“fastest Fourier transform in the West”). FFTW is designed for\nsituations requiring multiple DFT computations on the same problem size. Before\nactually computing the DFTs, FFTW executes a “planner,” which, by a series of\ntrial runs, determines how best to decompose the FFT computation for the given\nproblem size on the host machine. FFTW adapts to use the hardware cache ef-\nﬁciently, and once subproblems are small enough, FFTW solves them with opti-\nmized, straight-line code. Furthermore, FFTW has the unusual advantage of taking\n‚.n lg n/ time for any problem size n, even when n is a large prime.\nNotes for Chapter 30\n925\nAlthough the standard Fourier transform assumes that the input represents points\nthat are uniformly spaced in the time domain, other techniques can approximate the\nFFT on “nonequispaced” data. The article by Ware [348] provides an overview.\n31\nNumber-Theoretic Algorithms\nNumber theory was once viewed as a beautiful but largely useless subject in pure\nmathematics. Today number-theoretic algorithms are used widely, due in large part\nto the invention of cryptographic schemes based on large prime numbers. These\nschemes are feasible because we can ﬁnd large primes easily, and they are secure\nbecause we do not know how to factor the product of large primes (or solve related\nproblems, such as computing discrete logarithms) efﬁciently. This chapter presents\nsome of the number theory and related algorithms that underlie such applications.\nSection 31.1 introduces basic concepts of number theory, such as divisibility,\nmodular equivalence, and unique factorization. Section 31.2 studies one of the",
    "parent_94c39c6b-340b-4b44-b9c8-0a836f38d59b": "some of the number theory and related algorithms that underlie such applications.\nSection 31.1 introduces basic concepts of number theory, such as divisibility,\nmodular equivalence, and unique factorization. Section 31.2 studies one of the\nworld’s oldest algorithms: Euclid’s algorithm for computing the greatest common\ndivisor of two integers. Section 31.3 reviews concepts of modular arithmetic. Sec-\ntion 31.4 then studies the set of multiples of a given number a, modulo n, and shows\nhow to ﬁnd all solutions to the equation ax \b b .mod n/ by using Euclid’s algo-\nrithm. The Chinese remainder theorem is presented in Section 31.5. Section 31.6\nconsiders powers of a given number a, modulo n, and presents a repeated-squaring\nalgorithm for efﬁciently computing ab mod n, given a, b, and n. This operation is\nat the heart of efﬁcient primality testing and of much modern cryptography. Sec-\ntion 31.7 then describes the RSA public-key cryptosystem. Section 31.8 examines\na randomized primality test. We can use this test to ﬁnd large primes efﬁciently,\nwhich we need to do in order to create keys for the RSA cryptosystem. Finally,\nSection 31.9 reviews a simple but effective heuristic for factoring small integers. It\nis a curious fact that factoring is one problem people may wish to be intractable,\nsince the security of RSA depends on the difﬁculty of factoring large integers.\nSize of inputs and cost of arithmetic computations\nBecause we shall be working with large integers, we need to adjust how we think\nabout the size of an input and about the cost of elementary arithmetic operations.\nIn this chapter, a “large input” typically means an input containing “large in-\ntegers” rather than an input containing “many integers” (as for sorting). Thus,\n31.1\nElementary number-theoretic notions\n927\nwe shall measure the size of an input in terms of the number of bits required to\nrepresent that input, not just the number of integers in the input. An algorithm",
    "parent_4af3e7fb-9ac1-4136-8e93-20479ece3687": "tegers” rather than an input containing “many integers” (as for sorting). Thus,\n31.1\nElementary number-theoretic notions\n927\nwe shall measure the size of an input in terms of the number of bits required to\nrepresent that input, not just the number of integers in the input. An algorithm\nwith integer inputs a1; a2; : : : ; ak is a polynomial-time algorithm if it runs in time\npolynomial in lg a1; lg a2; : : : ; lg ak, that is, polynomial in the lengths of its binary-\nencoded inputs.\nIn most of this book, we have found it convenient to think of the elemen-\ntary arithmetic operations (multiplications, divisions, or computing remainders)\nas primitive operations that take one unit of time. By counting the number of such\narithmetic operations that an algorithm performs, we have a basis for making a\nreasonable estimate of the algorithm’s actual running time on a computer. Elemen-\ntary operations can be time-consuming, however, when their inputs are large. It\nthus becomes convenient to measure how many bit operations a number-theoretic\nalgorithm requires. In this model, multiplying two ˇ-bit integers by the ordinary\nmethod uses ‚.ˇ2/ bit operations. Similarly, we can divide a ˇ-bit integer by a\nshorter integer or take the remainder of a ˇ-bit integer when divided by a shorter in-\nteger in time ‚.ˇ2/ by simple algorithms. (See Exercise 31.1-12.) Faster methods\nare known. For example, a simple divide-and-conquer method for multiplying two\nˇ-bit integers has a running time of ‚.ˇlg 3/, and the fastest known method has\na running time of ‚.ˇ lg ˇ lg lg ˇ/. For practical purposes, however, the ‚.ˇ2/\nalgorithm is often best, and we shall use this bound as a basis for our analyses.\nWe shall generally analyze algorithms in this chapter in terms of both the number\nof arithmetic operations and the number of bit operations they require.\n31.1\nElementary number-theoretic notions\nThis section provides a brief review of notions from elementary number theory",
    "parent_d3abcfcc-d57c-4e36-87bf-08ac56ffb676": "We shall generally analyze algorithms in this chapter in terms of both the number\nof arithmetic operations and the number of bit operations they require.\n31.1\nElementary number-theoretic notions\nThis section provides a brief review of notions from elementary number theory\nconcerning the set Z D f: : : ; \u00052; \u00051; 0; 1; 2; : : :g of integers and the set N D\nf0; 1; 2; : : :g of natural numbers.\nDivisibility and divisors\nThe notion of one integer being divisible by another is key to the theory of numbers.\nThe notation d j a (read “d divides a”) means that a D kd for some integer k.\nEvery integer divides 0. If a > 0 and d j a, then jdj \u0002 jaj. If d j a, then we also\nsay that a is a multiple of d. If d does not divide a, we write d −a.\nIf d j a and d \u0006 0, we say that d is a divisor of a. Note that d j a if and only\nif \u0005d j a, so that no generality is lost by deﬁning the divisors to be nonnegative,\nwith the understanding that the negative of any divisor of a also divides a. A\n928\nChapter 31\nNumber-Theoretic Algorithms\ndivisor of a nonzero integer a is at least 1 but not greater than jaj. For example, the\ndivisors of 24 are 1, 2, 3, 4, 6, 8, 12, and 24.\nEvery positive integer a is divisible by the trivial divisors 1 and a. The nontrivial\ndivisors of a are the factors of a. For example, the factors of 20 are 2, 4, 5, and 10.\nPrime and composite numbers\nAn integer a > 1 whose only divisors are the trivial divisors 1 and a is a prime\nnumber or, more simply, a prime. Primes have many special properties and play a\ncritical role in number theory. The ﬁrst 20 primes, in order, are\n2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71 :\nExercise 31.1-2 asks you to prove that there are inﬁnitely many primes. An integer\na > 1 that is not prime is a composite number or, more simply, a composite. For\nexample, 39 is composite because 3 j 39. We call the integer 1 a unit, and it is\nneither prime nor composite. Similarly, the integer 0 and all negative integers are",
    "parent_f5cbede9-2c1b-45ec-801b-ee3b6be6f8ea": "a > 1 that is not prime is a composite number or, more simply, a composite. For\nexample, 39 is composite because 3 j 39. We call the integer 1 a unit, and it is\nneither prime nor composite. Similarly, the integer 0 and all negative integers are\nneither prime nor composite.\nThe division theorem, remainders, and modular equivalence\nGiven an integer n, we can partition the integers into those that are multiples of n\nand those that are not multiples of n. Much number theory is based upon reﬁning\nthis partition by classifying the nonmultiples of n according to their remainders\nwhen divided by n. The following theorem provides the basis for this reﬁnement.\nWe omit the proof (but see, for example, Niven and Zuckerman [265]).\nTheorem 31.1 (Division theorem)\nFor any integer a and any positive integer n, there exist unique integers q and r\nsuch that 0 \u0002 r < n and a D qn C r.\nThe value q D ba=nc is the quotient of the division. The value r D a mod n\nis the remainder (or residue) of the division. We have that n j a if and only if\na mod n D 0.\nWe can partition the integers into n equivalence classes according to their re-\nmainders modulo n. The equivalence class modulo n containing an integer a is\nŒa\u0002n D fa C kn W k 2 Zg :\nFor example, Œ3\u00027 D f: : : ; \u000511; \u00054; 3; 10; 17; : : :g; we can also denote this set by\nŒ\u00054\u00027 and Œ10\u00027. Using the notation deﬁned on page 54, we can say that writing\na 2 Œb\u0002n is the same as writing a \b b .mod n/. The set of all such equivalence\nclasses is\n31.1\nElementary number-theoretic notions\n929\nZn D fŒa\u0002n W 0 \u0002 a \u0002 n \u0005 1g :\n(31.1)\nWhen you see the deﬁnition\nZn D f0; 1; : : : ; n \u0005 1g ;\n(31.2)\nyou should read it as equivalent to equation (31.1) with the understanding that 0\nrepresents Œ0\u0002n, 1 represents Œ1\u0002n, and so on; each class is represented by its smallest\nnonnegative element. You should keep the underlying equivalence classes in mind,\nhowever. For example, if we refer to \u00051 as a member of Zn, we are really referring",
    "parent_8d68ae3c-2715-4b8b-ba79-2a247e83f38c": "represents Œ0\u0002n, 1 represents Œ1\u0002n, and so on; each class is represented by its smallest\nnonnegative element. You should keep the underlying equivalence classes in mind,\nhowever. For example, if we refer to \u00051 as a member of Zn, we are really referring\nto Œn \u0005 1\u0002n, since \u00051 \b n \u0005 1 .mod n/.\nCommon divisors and greatest common divisors\nIf d is a divisor of a and d is also a divisor of b, then d is a common divisor of a\nand b. For example, the divisors of 30 are 1, 2, 3, 5, 6, 10, 15, and 30, and so the\ncommon divisors of 24 and 30 are 1, 2, 3, and 6. Note that 1 is a common divisor\nof any two integers.\nAn important property of common divisors is that\nd j a and d j b implies d j .a C b/ and d j .a \u0005 b/ :\n(31.3)\nMore generally, we have that\nd j a and d j b implies d j .ax C by/\n(31.4)\nfor any integers x and y. Also, if a j b, then either jaj \u0002 jbj or b D 0, which\nimplies that\na j b and b j a implies a D ˙b :\n(31.5)\nThe greatest common divisor of two integers a and b, not both zero, is the\nlargest of the common divisors of a and b; we denote it by gcd.a; b/. For example,\ngcd.24; 30/ D 6, gcd.5; 7/ D 1, and gcd.0; 9/ D 9. If a and b are both nonzero,\nthen gcd.a; b/ is an integer between 1 and min.jaj ; jbj/. We deﬁne gcd.0; 0/ to\nbe 0; this deﬁnition is necessary to make standard properties of the gcd function\n(such as equation (31.9) below) universally valid.\nThe following are elementary properties of the gcd function:\ngcd.a; b/\nD\ngcd.b; a/ ;\n(31.6)\ngcd.a; b/\nD\ngcd.\u0005a; b/ ;\n(31.7)\ngcd.a; b/\nD\ngcd.jaj ; jbj/ ;\n(31.8)\ngcd.a; 0/\nD\njaj ;\n(31.9)\ngcd.a; ka/\nD\njaj\nfor any k 2 Z :\n(31.10)\nThe following theorem provides an alternative and useful characterization of\ngcd.a; b/.\n930\nChapter 31\nNumber-Theoretic Algorithms\nTheorem 31.2\nIf a and b are any integers, not both zero, then gcd.a; b/ is the smallest positive\nelement of the set fax C by W x; y 2 Zg of linear combinations of a and b.\nProof\nLet s be the smallest positive such linear combination of a and b, and let",
    "parent_e374827e-d5a1-4342-99ee-5729d6138ecb": "930\nChapter 31\nNumber-Theoretic Algorithms\nTheorem 31.2\nIf a and b are any integers, not both zero, then gcd.a; b/ is the smallest positive\nelement of the set fax C by W x; y 2 Zg of linear combinations of a and b.\nProof\nLet s be the smallest positive such linear combination of a and b, and let\ns D ax C by for some x; y 2 Z. Let q D ba=sc. Equation (3.8) then implies\na mod s\nD\na \u0005 qs\nD\na \u0005 q.ax C by/\nD\na .1 \u0005 qx/ C b .\u0005qy/ ;\nand so a mod s is a linear combination of a and b as well.\nBut, since 0 \u0002\na mod s < s, we have that a mod s D 0, because s is the smallest positive such lin-\near combination. Therefore, we have that s j a and, by analogous reasoning, s j b.\nThus, s is a common divisor of a and b, and so gcd.a; b/ \u0006 s. Equation (31.4)\nimplies that gcd.a; b/ j s, since gcd.a; b/ divides both a and b and s is a linear\ncombination of a and b. But gcd.a; b/ j s and s > 0 imply that gcd.a; b/ \u0002 s.\nCombining gcd.a; b/ \u0006 s and gcd.a; b/ \u0002 s yields gcd.a; b/ D s. We conclude\nthat s is the greatest common divisor of a and b.\nCorollary 31.3\nFor any integers a and b, if d j a and d j b, then d j gcd.a; b/.\nProof\nThis corollary follows from equation (31.4), because gcd.a; b/ is a linear\ncombination of a and b by Theorem 31.2.\nCorollary 31.4\nFor all integers a and b and any nonnegative integer n,\ngcd.an; bn/ D n gcd.a; b/ :\nProof\nIf n D 0, the corollary is trivial. If n > 0, then gcd.an; bn/ is the smallest\npositive element of the set fanx C bny W x; y 2 Zg, which is n times the smallest\npositive element of the set fax C by W x; y 2 Zg.\nCorollary 31.5\nFor all positive integers n, a, and b, if n j ab and gcd.a; n/ D 1, then n j b.\nProof\nWe leave the proof as Exercise 31.1-5.\n31.1\nElementary number-theoretic notions\n931\nRelatively prime integers\nTwo integers a and b are relatively prime if their only common divisor is 1, that\nis, if gcd.a; b/ D 1. For example, 8 and 15 are relatively prime, since the divisors",
    "parent_d5fd1795-cda2-424f-ad56-f8f85b0dd43c": "Proof\nWe leave the proof as Exercise 31.1-5.\n31.1\nElementary number-theoretic notions\n931\nRelatively prime integers\nTwo integers a and b are relatively prime if their only common divisor is 1, that\nis, if gcd.a; b/ D 1. For example, 8 and 15 are relatively prime, since the divisors\nof 8 are 1, 2, 4, and 8, and the divisors of 15 are 1, 3, 5, and 15. The following\ntheorem states that if two integers are each relatively prime to an integer p, then\ntheir product is relatively prime to p.\nTheorem 31.6\nFor any integers a, b, and p, if both gcd.a; p/ D 1 and gcd.b; p/ D 1, then\ngcd.ab; p/ D 1.\nProof\nIt follows from Theorem 31.2 that there exist integers x, y, x0, and y0 such\nthat\nax C py\nD\n1 ;\nbx0 C py0\nD\n1 :\nMultiplying these equations and rearranging, we have\nab.xx0/ C p.ybx0 C y0ax C pyy0/ D 1 :\nSince 1 is thus a positive linear combination of ab and p, an appeal to Theo-\nrem 31.2 completes the proof.\nIntegers n1, n2, . . . , nk are pairwise relatively prime if, whenever i ¤ j , we\nhave gcd.ni; nj/ D 1.\nUnique factorization\nAn elementary but important fact about divisibility by primes is the following.\nTheorem 31.7\nFor all primes p and all integers a and b, if p j ab, then p j a or p j b (or both).\nProof\nAssume for the purpose of contradiction that p j ab, but that p −a and\np −b. Thus, gcd.a; p/ D 1 and gcd.b; p/ D 1, since the only divisors of p are 1\nand p, and we assume that p divides neither a nor b. Theorem 31.6 then implies\nthat gcd.ab; p/ D 1, contradicting our assumption that p j ab, since p j ab\nimplies gcd.ab; p/ D p. This contradiction completes the proof.\nA consequence of Theorem 31.7 is that we can uniquely factor any composite\ninteger into a product of primes.\n932\nChapter 31\nNumber-Theoretic Algorithms\nTheorem 31.8 (Unique factorization)\nThere is exactly one way to write any composite integer a as a product of the form\na D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr ;\nwhere the pi are prime, p1 < p2 < \u0003 \u0003 \u0003 < pr, and the ei are positive integers.\nProof",
    "parent_cdad6d98-7ed9-4cf9-8668-e8ea29ead16d": "932\nChapter 31\nNumber-Theoretic Algorithms\nTheorem 31.8 (Unique factorization)\nThere is exactly one way to write any composite integer a as a product of the form\na D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr ;\nwhere the pi are prime, p1 < p2 < \u0003 \u0003 \u0003 < pr, and the ei are positive integers.\nProof\nWe leave the proof as Exercise 31.1-11.\nAs an example, the number 6000 is uniquely factored into primes as 24 \u0003 3 \u0003 53.\nExercises\n31.1-1\nProve that if a > b > 0 and c D a C b, then c mod a D b.\n31.1-2\nProve that there are inﬁnitely many primes. (Hint: Show that none of the primes\np1; p2; : : : ; pk divide .p1p2 \u0003 \u0003 \u0003 pk/ C 1.)\n31.1-3\nProve that if a j b and b j c, then a j c.\n31.1-4\nProve that if p is prime and 0 < k < p, then gcd.k; p/ D 1.\n31.1-5\nProve Corollary 31.5.\n31.1-6\nProve that if p is prime and 0 < k < p, then p j\n\u000bp\nk\n\f\n. Conclude that for all integers\na and b and all primes p,\n.a C b/p \b ap C bp .mod p/ :\n31.1-7\nProve that if a and b are any positive integers such that a j b, then\n.x mod b/ mod a D x mod a\nfor any x. Prove, under the same assumptions, that\nx \b y .mod b/ implies x \b y .mod a/\nfor any integers x and y.\n31.2\nGreatest common divisor\n933\n31.1-8\nFor any integer k > 0, an integer n is a kth power if there exists an integer a such\nthat ak D n. Furthermore, n > 1 is a nontrivial power if it is a kth power for\nsome integer k > 1. Show how to determine whether a given ˇ-bit integer n is a\nnontrivial power in time polynomial in ˇ.\n31.1-9\nProve equations (31.6)–(31.10).\n31.1-10\nShow that the gcd operator is associative. That is, prove that for all integers a, b,\nand c,\ngcd.a; gcd.b; c// D gcd.gcd.a; b/; c/ :\n31.1-11\n?\nProve Theorem 31.8.\n31.1-12\nGive efﬁcient algorithms for the operations of dividing a ˇ-bit integer by a shorter\ninteger and of taking the remainder of a ˇ-bit integer when divided by a shorter\ninteger. Your algorithms should run in time ‚.ˇ2/.\n31.1-13\nGive an efﬁcient algorithm to convert a given ˇ-bit (binary) integer to a decimal",
    "parent_04a390f7-d17c-4334-9288-1ed1b2e13d4e": "integer and of taking the remainder of a ˇ-bit integer when divided by a shorter\ninteger. Your algorithms should run in time ‚.ˇ2/.\n31.1-13\nGive an efﬁcient algorithm to convert a given ˇ-bit (binary) integer to a decimal\nrepresentation. Argue that if multiplication or division of integers whose length\nis at most ˇ takes time M.ˇ/, then we can convert binary to decimal in time\n‚.M.ˇ/ lg ˇ/. (Hint: Use a divide-and-conquer approach, obtaining the top and\nbottom halves of the result with separate recursions.)\n31.2\nGreatest common divisor\nIn this section, we describe Euclid’s algorithm for efﬁciently computing the great-\nest common divisor of two integers. When we analyze the running time, we shall\nsee a surprising connection with the Fibonacci numbers, which yield a worst-case\ninput for Euclid’s algorithm.\nWe restrict ourselves in this section to nonnegative integers. This restriction is\njustiﬁed by equation (31.8), which states that gcd.a; b/ D gcd.jaj ; jbj/.\n934\nChapter 31\nNumber-Theoretic Algorithms\nIn principle, we can compute gcd.a; b/ for positive integers a and b from the\nprime factorizations of a and b. Indeed, if\na\nD\npe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr ;\n(31.11)\nb\nD\npf1\n1 pf2\n2 \u0003 \u0003 \u0003 pfr\nr\n;\n(31.12)\nwith zero exponents being used to make the set of primes p1; p2; : : : ; pr the same\nfor both a and b, then, as Exercise 31.2-1 asks you to show,\ngcd.a; b/ D pmin.e1;f1/\n1\npmin.e2;f2/\n2\n\u0003 \u0003 \u0003 pmin.er;fr/\nr\n:\n(31.13)\nAs we shall show in Section 31.9, however, the best algorithms to date for factoring\ndo not run in polynomial time. Thus, this approach to computing greatest common\ndivisors seems unlikely to yield an efﬁcient algorithm.\nEuclid’s algorithm for computing greatest common divisors relies on the follow-\ning theorem.\nTheorem 31.9 (GCD recursion theorem)\nFor any nonnegative integer a and any positive integer b,\ngcd.a; b/ D gcd.b; a mod b/ :\nProof\nWe shall show that gcd.a; b/ and gcd.b; a mod b/ divide each other, so",
    "parent_5fcab588-3976-4dce-9c84-effd78d57433": "Euclid’s algorithm for computing greatest common divisors relies on the follow-\ning theorem.\nTheorem 31.9 (GCD recursion theorem)\nFor any nonnegative integer a and any positive integer b,\ngcd.a; b/ D gcd.b; a mod b/ :\nProof\nWe shall show that gcd.a; b/ and gcd.b; a mod b/ divide each other, so\nthat by equation (31.5) they must be equal (since they are both nonnegative).\nWe ﬁrst show that gcd.a; b/ j gcd.b; a mod b/. If we let d D gcd.a; b/, then\nd j a and d j b. By equation (3.8), a mod b D a \u0005 qb, where q D ba=bc.\nSince a mod b is thus a linear combination of a and b, equation (31.4) implies that\nd j .a mod b/. Therefore, since d j b and d j .a mod b/, Corollary 31.3 implies\nthat d j gcd.b; a mod b/ or, equivalently, that\ngcd.a; b/ j gcd.b; a mod b/:\n(31.14)\nShowing that gcd.b; a mod b/ j gcd.a; b/ is almost the same. If we now let\nd D gcd.b; a mod b/, then d j b and d j .a mod b/. Since a D qb C .a mod b/,\nwhere q D ba=bc, we have that a is a linear combination of b and .a mod b/. By\nequation (31.4), we conclude that d j a. Since d j b and d j a, we have that\nd j gcd.a; b/ by Corollary 31.3 or, equivalently, that\ngcd.b; a mod b/ j gcd.a; b/:\n(31.15)\nUsing equation (31.5) to combine equations (31.14) and (31.15) completes the\nproof.\n31.2\nGreatest common divisor\n935\nEuclid’s algorithm\nThe Elements of Euclid (circa 300 B.C.) describes the following gcd algorithm,\nalthough it may be of even earlier origin. We express Euclid’s algorithm as a\nrecursive program based directly on Theorem 31.9. The inputs a and b are arbitrary\nnonnegative integers.\nEUCLID.a; b/\n1\nif b == 0\n2\nreturn a\n3\nelse return EUCLID.b; a mod b/\nAs an example of the running of EUCLID, consider the computation of gcd.30; 21/:\nEUCLID.30; 21/\nD\nEUCLID.21; 9/\nD\nEUCLID.9; 3/\nD\nEUCLID.3; 0/\nD\n3 :\nThis computation calls EUCLID recursively three times.\nThe correctness of EUCLID follows from Theorem 31.9 and the property that if",
    "parent_4f3218a6-f060-40c0-8d17-598088da70cd": "As an example of the running of EUCLID, consider the computation of gcd.30; 21/:\nEUCLID.30; 21/\nD\nEUCLID.21; 9/\nD\nEUCLID.9; 3/\nD\nEUCLID.3; 0/\nD\n3 :\nThis computation calls EUCLID recursively three times.\nThe correctness of EUCLID follows from Theorem 31.9 and the property that if\nthe algorithm returns a in line 2, then b D 0, so that equation (31.9) implies that\ngcd.a; b/ D gcd.a; 0/ D a. The algorithm cannot recurse indeﬁnitely, since the\nsecond argument strictly decreases in each recursive call and is always nonnegative.\nTherefore, EUCLID always terminates with the correct answer.\nThe running time of Euclid’s algorithm\nWe analyze the worst-case running time of EUCLID as a function of the size of\na and b. We assume with no loss of generality that a > b \u0006 0. To justify this\nassumption, observe that if b > a \u0006 0, then EUCLID.a; b/ immediately makes the\nrecursive call EUCLID.b; a/. That is, if the ﬁrst argument is less than the second\nargument, EUCLID spends one recursive call swapping its arguments and then pro-\nceeds. Similarly, if b D a > 0, the procedure terminates after one recursive call,\nsince a mod b D 0.\nThe overall running time of EUCLID is proportional to the number of recursive\ncalls it makes. Our analysis makes use of the Fibonacci numbers Fk, deﬁned by\nthe recurrence (3.22).\nLemma 31.10\nIf a > b \u0006 1 and the call EUCLID.a; b/ performs k \u0006 1 recursive calls, then\na \u0006 FkC2 and b \u0006 FkC1.\n936\nChapter 31\nNumber-Theoretic Algorithms\nProof\nThe proof proceeds by induction on k. For the basis of the induction, let\nk D 1. Then, b \u0006 1 D F2, and since a > b, we must have a \u0006 2 D F3. Since\nb > .a mod b/, in each recursive call the ﬁrst argument is strictly larger than the\nsecond; the assumption that a > b therefore holds for each recursive call.\nAssume inductively that the lemma holds if k \u0005 1 recursive calls are made; we\nshall then prove that the lemma holds for k recursive calls. Since k > 0, we have",
    "parent_6502a139-d77f-4cbb-a77f-ce89b2fac3e6": "second; the assumption that a > b therefore holds for each recursive call.\nAssume inductively that the lemma holds if k \u0005 1 recursive calls are made; we\nshall then prove that the lemma holds for k recursive calls. Since k > 0, we have\nb > 0, and EUCLID.a; b/ calls EUCLID.b; a mod b/ recursively, which in turn\nmakes k \u0005 1 recursive calls. The inductive hypothesis then implies that b \u0006 FkC1\n(thus proving part of the lemma), and a mod b \u0006 Fk. We have\nb C .a mod b/\nD\nb C .a \u0005 b ba=bc/\n\u0002\na ;\nsince a > b > 0 implies ba=bc \u0006 1. Thus,\na\n\u0006\nb C .a mod b/\n\u0006\nFkC1 C Fk\nD\nFkC2 :\nThe following theorem is an immediate corollary of this lemma.\nTheorem 31.11 (Lam´e’s theorem)\nFor any integer k \u0006 1, if a > b \u0006 1 and b < FkC1, then the call EUCLID.a; b/\nmakes fewer than k recursive calls.\nWe can show that the upper bound of Theorem 31.11 is the best possible by\nshowing that the call EUCLID.FkC1; Fk/ makes exactly k \u0005 1 recursive calls\nwhen k \u0006 2. We use induction on k. For the base case, k D 2, and the call\nEUCLID.F3; F2/ makes exactly one recursive call, to EUCLID.1; 0/. (We have to\nstart at k D 2, because when k D 1 we do not have F2 > F1.) For the induc-\ntive step, assume that EUCLID.Fk; Fk\u00031/ makes exactly k \u0005 2 recursive calls. For\nk > 2, we have Fk > Fk\u00031 > 0 and FkC1 D Fk CFk\u00031, and so by Exercise 31.1-1,\nwe have FkC1 mod Fk D Fk\u00031. Thus, we have\ngcd.FkC1; Fk/\nD\ngcd.Fk; FkC1 mod Fk/\nD\ngcd.Fk; Fk\u00031/ :\nTherefore, the call EUCLID.FkC1; Fk/ recurses one time more than the call\nEUCLID.Fk; Fk\u00031/, or exactly k \u0005 1 times, meeting the upper bound of Theo-\nrem 31.11.\nSince Fk is approximately \u0007k=\np\n5, where \u0007 is the golden ratio .1 C\np\n5/=2 de-\nﬁned by equation (3.24), the number of recursive calls in EUCLID is O.lg b/. (See\n31.2\nGreatest common divisor\n937\na\nb\nba=bc\nd\nx\ny\n99\n78\n1\n3\n\u000511\n14\n78\n21\n3\n3\n3\n\u000511\n21\n15\n1\n3\n\u00052\n3\n15\n6\n2\n3\n1\n\u00052\n6\n3\n2\n3\n0\n1\n3\n0\n—\n3\n1\n0\nFigure 31.1\nHow EXTENDED-EUCLID computes gcd.99; 78/. Each line shows one level of the",
    "parent_ba93d903-d8e5-43d6-8295-93b4ac04b71e": "31.2\nGreatest common divisor\n937\na\nb\nba=bc\nd\nx\ny\n99\n78\n1\n3\n\u000511\n14\n78\n21\n3\n3\n3\n\u000511\n21\n15\n1\n3\n\u00052\n3\n15\n6\n2\n3\n1\n\u00052\n6\n3\n2\n3\n0\n1\n3\n0\n—\n3\n1\n0\nFigure 31.1\nHow EXTENDED-EUCLID computes gcd.99; 78/. Each line shows one level of the\nrecursion: the values of the inputs a and b, the computed value ba=bc, and the values d, x, and y\nreturned. The triple .d; x; y/ returned becomes the triple .d 0; x0; y0/ used at the next higher level\nof recursion. The call EXTENDED-EUCLID.99; 78/ returns .3; \u000511; 14/, so that gcd.99; 78/ D 3 D\n99 \u0003 .\u000511/ C 78 \u0003 14.\nExercise 31.2-5 for a tighter bound.) Therefore, if we call EUCLID on two ˇ-bit\nnumbers, then it performs O.ˇ/ arithmetic operations and O.ˇ3/ bit operations\n(assuming that multiplication and division of ˇ-bit numbers take O.ˇ2/ bit oper-\nations). Problem 31-2 asks you to show an O.ˇ2/ bound on the number of bit\noperations.\nThe extended form of Euclid’s algorithm\nWe now rewrite Euclid’s algorithm to compute additional useful information.\nSpeciﬁcally, we extend the algorithm to compute the integer coefﬁcients x and y\nsuch that\nd D gcd.a; b/ D ax C by :\n(31.16)\nNote that x and y may be zero or negative. We shall ﬁnd these coefﬁcients useful\nlater for computing modular multiplicative inverses. The procedure EXTENDED-\nEUCLID takes as input a pair of nonnegative integers and returns a triple of the\nform .d; x; y/ that satisﬁes equation (31.16).\nEXTENDED-EUCLID.a; b/\n1\nif b == 0\n2\nreturn .a; 1; 0/\n3\nelse .d 0; x0; y0/ D EXTENDED-EUCLID.b; a mod b/\n4\n.d; x; y/ D .d 0; y0; x0 \u0005 ba=bc y0/\n5\nreturn .d; x; y/\nFigure 31.1 illustrates how EXTENDED-EUCLID computes gcd.99; 78/.\nThe EXTENDED-EUCLID procedure is a variation of the EUCLID procedure.\nLine 1 is equivalent to the test “b == 0” in line 1 of EUCLID. If b D 0, then\n938\nChapter 31\nNumber-Theoretic Algorithms\nEXTENDED-EUCLID returns not only d D a in line 2, but also the coefﬁcients\nx D 1 and y D 0, so that a D ax C by. If b ¤ 0, EXTENDED-EUCLID ﬁrst",
    "parent_bab34ba6-aaa5-4f48-9597-ca0e25685354": "Line 1 is equivalent to the test “b == 0” in line 1 of EUCLID. If b D 0, then\n938\nChapter 31\nNumber-Theoretic Algorithms\nEXTENDED-EUCLID returns not only d D a in line 2, but also the coefﬁcients\nx D 1 and y D 0, so that a D ax C by. If b ¤ 0, EXTENDED-EUCLID ﬁrst\ncomputes .d 0; x0; y0/ such that d 0 D gcd.b; a mod b/ and\nd 0 D bx0 C .a mod b/y0 :\n(31.17)\nAs for EUCLID, we have in this case d D gcd.a; b/ D d 0 D gcd.b; a mod b/.\nTo obtain x and y such that d D ax C by, we start by rewriting equation (31.17)\nusing the equation d D d 0 and equation (3.8):\nd\nD\nbx0 C .a \u0005 b ba=bc/y0\nD\nay0 C b.x0 \u0005 ba=bc y0/ :\nThus, choosing x D y0 and y D x0 \u0005ba=bc y0 satisﬁes the equation d D ax Cby,\nproving the correctness of EXTENDED-EUCLID.\nSince the number of recursive calls made in EUCLID is equal to the number\nof recursive calls made in EXTENDED-EUCLID, the running times of EUCLID\nand EXTENDED-EUCLID are the same, to within a constant factor. That is, for\na > b > 0, the number of recursive calls is O.lg b/.\nExercises\n31.2-1\nProve that equations (31.11) and (31.12) imply equation (31.13).\n31.2-2\nCompute the values .d; x; y/ that the call EXTENDED-EUCLID.899; 493/ returns.\n31.2-3\nProve that for all integers a, k, and n,\ngcd.a; n/ D gcd.a C kn; n/ :\n31.2-4\nRewrite EUCLID in an iterative form that uses only a constant amount of memory\n(that is, stores only a constant number of integer values).\n31.2-5\nIf a > b \u0006 0, show that the call EUCLID.a; b/ makes at most 1 C log\u0007 b recursive\ncalls. Improve this bound to 1 C log\u0007.b= gcd.a; b//.\n31.2-6\nWhat does EXTENDED-EUCLID.FkC1; Fk/ return? Prove your answer correct.\n31.3\nModular arithmetic\n939\n31.2-7\nDeﬁne the gcd function for more than two arguments by the recursive equation\ngcd.a0; a1; : : : ; an/ D gcd.a0; gcd.a1; a2; : : : ; an//. Show that the gcd function\nreturns the same answer independent of the order in which its arguments are speci-\nﬁed. Also show how to ﬁnd integers x0; x1; : : : ; xn such that gcd.a0; a1; : : : ; an/ D",
    "parent_a00e171b-dbbc-402e-8154-0b4a1f0e1f2e": "gcd.a0; a1; : : : ; an/ D gcd.a0; gcd.a1; a2; : : : ; an//. Show that the gcd function\nreturns the same answer independent of the order in which its arguments are speci-\nﬁed. Also show how to ﬁnd integers x0; x1; : : : ; xn such that gcd.a0; a1; : : : ; an/ D\na0x0 C a1x1 C \u0003 \u0003 \u0003 C anxn. Show that the number of divisions performed by your\nalgorithm is O.n C lg.max fa0; a1; : : : ; ang//.\n31.2-8\nDeﬁne lcm.a1; a2; : : : ; an/ to be the least common multiple of the n integers\na1; a2; : : : ; an, that is, the smallest nonnegative integer that is a multiple of each ai.\nShow how to compute lcm.a1; a2; : : : ; an/ efﬁciently using the (two-argument) gcd\noperation as a subroutine.\n31.2-9\nProve that n1, n2, n3, and n4 are pairwise relatively prime if and only if\ngcd.n1n2; n3n4/ D gcd.n1n3; n2n4/ D 1 :\nMore generally, show that n1; n2; : : : ; nk are pairwise relatively prime if and only\nif a set of dlg ke pairs of numbers derived from the ni are relatively prime.\n31.3\nModular arithmetic\nInformally, we can think of modular arithmetic as arithmetic as usual over the\nintegers, except that if we are working modulo n, then every result x is replaced\nby the element of f0; 1; : : : ; n \u0005 1g that is equivalent to x, modulo n (that is, x is\nreplaced by x mod n). This informal model sufﬁces if we stick to the operations\nof addition, subtraction, and multiplication. A more formal model for modular\narithmetic, which we now give, is best described within the framework of group\ntheory.\nFinite groups\nA group .S; ˚/ is a set S together with a binary operation ˚ deﬁned on S for\nwhich the following properties hold:\n1. Closure: For all a, b 2 S, we have a ˚ b 2 S.\n2. Identity: There exists an element e 2 S, called the identity of the group, such\nthat e ˚ a D a ˚ e D a for all a 2 S.\n3. Associativity: For all a, b, c 2 S, we have .a ˚ b/ ˚ c D a ˚ .b ˚ c/.\n940\nChapter 31\nNumber-Theoretic Algorithms\n4. Inverses: For each a 2 S, there exists a unique element b 2 S, called the",
    "parent_53f26183-3a5f-4eb1-a683-ce6f1735387f": "that e ˚ a D a ˚ e D a for all a 2 S.\n3. Associativity: For all a, b, c 2 S, we have .a ˚ b/ ˚ c D a ˚ .b ˚ c/.\n940\nChapter 31\nNumber-Theoretic Algorithms\n4. Inverses: For each a 2 S, there exists a unique element b 2 S, called the\ninverse of a, such that a ˚ b D b ˚ a D e.\nAs an example, consider the familiar group .Z; C/ of the integers Z under the\noperation of addition: 0 is the identity, and the inverse of a is \u0005a. If a group .S; ˚/\nsatisﬁes the commutative law a ˚ b D b ˚ a for all a; b 2 S, then it is an abelian\ngroup. If a group .S; ˚/ satisﬁes jSj < 1, then it is a ﬁnite group.\nThe groups deﬁned by modular addition and multiplication\nWe can form two ﬁnite abelian groups by using addition and multiplication mod-\nulo n, where n is a positive integer. These groups are based on the equivalence\nclasses of the integers modulo n, deﬁned in Section 31.1.\nTo deﬁne a group on Zn, we need to have suitable binary operations, which\nwe obtain by redeﬁning the ordinary operations of addition and multiplication.\nWe can easily deﬁne addition and multiplication operations for Zn, because the\nequivalence class of two integers uniquely determines the equivalence class of their\nsum or product. That is, if a \b a0 .mod n/ and b \b b0 .mod n/, then\na C b\n\b\na0 C b0 .mod n/ ;\nab\n\b\na0b0\n.mod n/ :\nThus, we deﬁne addition and multiplication modulo n, denoted Cn and \u0003n, by\nŒa\u0002n Cn Œb\u0002n\nD\nŒa C b\u0002n ;\n(31.18)\nŒa\u0002n \u0003n Œb\u0002n\nD\nŒab\u0002n :\n(We can deﬁne subtraction similarly on Zn by Œa\u0002n \u0005n Œb\u0002n D Œa \u0005 b\u0002n, but divi-\nsion is more complicated, as we shall see.) These facts justify the common and\nconvenient practice of using the smallest nonnegative element of each equivalence\nclass as its representative when performing computations in Zn. We add, subtract,\nand multiply as usual on the representatives, but we replace each result x by the\nrepresentative of its class, that is, by x mod n.\nUsing this deﬁnition of addition modulo n, we deﬁne the additive group",
    "parent_4a15c4f6-367e-4a3a-b6e6-5ad594a8c1cc": "class as its representative when performing computations in Zn. We add, subtract,\nand multiply as usual on the representatives, but we replace each result x by the\nrepresentative of its class, that is, by x mod n.\nUsing this deﬁnition of addition modulo n, we deﬁne the additive group\nmodulo n as .Zn; Cn/. The size of the additive group modulo n is jZnj D n.\nFigure 31.2(a) gives the operation table for the group .Z6; C6/.\nTheorem 31.12\nThe system .Zn; Cn/ is a ﬁnite abelian group.\nProof\nEquation (31.18) shows that .Zn; Cn/ is closed. Associativity and com-\nmutativity of Cn follow from the associativity and commutativity of C:\n31.3\nModular arithmetic\n941\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n0\n1\n2\n3\n4\n5\n(a)\n1\n2\n4\n7\n8\n11\n13\n14\n1\n2\n4\n7\n8\n11\n13\n14\n1\n2\n4\n7\n8\n11\n13\n14\n2\n4\n8\n14\n1\n7\n11\n13\n4\n8\n1\n13\n2\n14\n7\n11\n7\n14\n13\n4\n11\n2\n1\n8\n8\n1\n2\n11\n4\n13\n14\n7\n11\n7\n14\n2\n13\n1\n8\n4\n13\n11\n7\n1\n14\n8\n4\n2\n14\n13\n11\n8\n7\n4\n2\n1\n(b)\n+6\n·15\nFigure 31.2\nTwo ﬁnite groups. Equivalence classes are denoted by their representative elements.\n(a) The group .Z6; C6/. (b) The group .Z\u0004\n15; \u000315/.\n.Œa\u0002n Cn Œb\u0002n/ Cn Œc\u0002n\nD\nŒa C b\u0002n Cn Œc\u0002n\nD\nŒ.a C b/ C c\u0002n\nD\nŒa C .b C c/\u0002n\nD\nŒa\u0002n Cn Œb C c\u0002n\nD\nŒa\u0002n Cn .Œb\u0002n Cn Œc\u0002n/ ;\nŒa\u0002n Cn Œb\u0002n\nD\nŒa C b\u0002n\nD\nŒb C a\u0002n\nD\nŒb\u0002n Cn Œa\u0002n :\nThe identity element of .Zn; Cn/ is 0 (that is, Œ0\u0002n). The (additive) inverse of\nan element a (that is, of Œa\u0002n) is the element \u0005a (that is, Œ\u0005a\u0002n or Œn \u0005 a\u0002n), since\nŒa\u0002n Cn Œ\u0005a\u0002n D Œa \u0005 a\u0002n D Œ0\u0002n.\nUsing the deﬁnition of multiplication modulo n, we deﬁne the multiplicative\ngroup modulo n as .Z\u0004\nn; \u0003n/. The elements of this group are the set Z\u0004\nn of elements\nin Zn that are relatively prime to n, so that each one has a unique inverse, modulo n:\nZ\u0004\nn D fŒa\u0002n 2 Zn W gcd.a; n/ D 1g :\nTo see that Z\u0004\nn is well deﬁned, note that for 0 \u0002 a < n, we have a \b .a C kn/\n.mod n/ for all integers k. By Exercise 31.2-3, therefore, gcd.a; n/ D 1 implies",
    "parent_67d3a03b-8ec4-4a4b-a0dd-48de0ef43fae": "n of elements\nin Zn that are relatively prime to n, so that each one has a unique inverse, modulo n:\nZ\u0004\nn D fŒa\u0002n 2 Zn W gcd.a; n/ D 1g :\nTo see that Z\u0004\nn is well deﬁned, note that for 0 \u0002 a < n, we have a \b .a C kn/\n.mod n/ for all integers k. By Exercise 31.2-3, therefore, gcd.a; n/ D 1 implies\ngcd.a C kn; n/ D 1 for all integers k. Since Œa\u0002n D fa C kn W k 2 Zg, the set Z\u0004\nn\nis well deﬁned. An example of such a group is\nZ\u0004\n15 D f1; 2; 4; 7; 8; 11; 13; 14g ;\n942\nChapter 31\nNumber-Theoretic Algorithms\nwhere the group operation is multiplication modulo 15. (Here we denote an el-\nement Œa\u000215 as a; for example, we denote Œ7\u000215 as 7.) Figure 31.2(b) shows the\ngroup .Z\u0004\n15; \u000315/. For example, 8 \u0003 11 \b 13 .mod 15/, working in Z\u0004\n15. The iden-\ntity for this group is 1.\nTheorem 31.13\nThe system .Z\u0004\nn; \u0003n/ is a ﬁnite abelian group.\nProof\nTheorem 31.6 implies that .Z\u0004\nn; \u0003n/ is closed. Associativity and commu-\ntativity can be proved for \u0003n as they were for Cn in the proof of Theorem 31.12.\nThe identity element is Œ1\u0002n. To show the existence of inverses, let a be an element\nof Z\u0004\nn and let .d; x; y/ be returned by EXTENDED-EUCLID.a; n/. Then, d D 1,\nsince a 2 Z\u0004\nn, and\nax C ny D 1\n(31.19)\nor, equivalently,\nax \b 1 .mod n/ :\nThus, Œx\u0002n is a multiplicative inverse of Œa\u0002n, modulo n. Furthermore, we claim\nthat Œx\u0002n 2 Z\u0004\nn. To see why, equation (31.19) demonstrates that the smallest pos-\nitive linear combination of x and n must be 1. Therefore, Theorem 31.2 implies\nthat gcd.x; n/ D 1. We defer the proof that inverses are uniquely deﬁned until\nCorollary 31.26.\nAs an example of computing multiplicative inverses, suppose that a D 5 and\nn D 11. Then EXTENDED-EUCLID.a; n/ returns .d; x; y/ D .1; \u00052; 1/, so that\n1 D 5 \u0003 .\u00052/ C 11 \u0003 1. Thus, Œ\u00052\u000211 (i.e., Œ9\u000211) is the multiplicative inverse of Œ5\u000211.\nWhen working with the groups .Zn; Cn/ and .Z\u0004\nn; \u0003n/ in the remainder of this\nchapter, we follow the convenient practice of denoting equivalence classes by their",
    "parent_36e15ab0-86bd-4144-8f8e-4e6cd8ef844d": "1 D 5 \u0003 .\u00052/ C 11 \u0003 1. Thus, Œ\u00052\u000211 (i.e., Œ9\u000211) is the multiplicative inverse of Œ5\u000211.\nWhen working with the groups .Zn; Cn/ and .Z\u0004\nn; \u0003n/ in the remainder of this\nchapter, we follow the convenient practice of denoting equivalence classes by their\nrepresentative elements and denoting the operations Cn and \u0003n by the usual arith-\nmetic notations C and \u0003 (or juxtaposition, so that ab D a \u0003 b) respectively. Also,\nequivalences modulo n may also be interpreted as equations in Zn. For example,\nthe following two statements are equivalent:\nax\n\b\nb .mod n/ ;\nŒa\u0002n \u0003n Œx\u0002n\nD\nŒb\u0002n :\nAs a further convenience, we sometimes refer to a group .S; ˚/ merely as S\nwhen the operation ˚ is understood from context. We may thus refer to the groups\n.Zn; Cn/ and .Z\u0004\nn; \u0003n/ as Zn and Z\u0004\nn, respectively.\nWe denote the (multiplicative) inverse of an element a by .a\u00031 mod n/. Division\nin Z\u0004\nn is deﬁned by the equation a=b \b ab\u00031 .mod n/. For example, in Z\u0004\n15\n31.3\nModular arithmetic\n943\nwe have that 7\u00031 \b 13 .mod 15/, since 7 \u0003 13 D 91 \b 1 .mod 15/, so that\n4=7 \b 4 \u0003 13 \b 7 .mod 15/.\nThe size of Z\u0004\nn is denoted \u0007.n/. This function, known as Euler’s phi function,\nsatisﬁes the equation\n\u0007.n/ D n\nY\np W p is prime and p j n\n\u0002\n1 \u0005 1\np\n\u0003\n;\n(31.20)\nso that p runs over all the primes dividing n (including n itself, if n is prime).\nWe shall not prove this formula here. Intuitively, we begin with a list of the n\nremainders f0; 1; : : : ; n \u0005 1g and then, for each prime p that divides n, cross out\nevery multiple of p in the list. For example, since the prime divisors of 45 are 3\nand 5,\n\u0007.45/\nD\n45\n\u0002\n1 \u0005 1\n3\n\u0003 \u0002\n1 \u0005 1\n5\n\u0003\nD\n45\n\u00022\n3\n\u0003 \u00024\n5\n\u0003\nD\n24 :\nIf p is prime, then Z\u0004\np D f1; 2; : : : ; p \u0005 1g, and\n\u0007.p/\nD\np\n\u0002\n1 \u0005 1\np\n\u0003\nD\np \u0005 1 :\n(31.21)\nIf n is composite, then \u0007.n/ < n \u0005 1, although it can be shown that\n\u0007.n/ >\nn\ne\b ln ln n C\n3\nln ln n\n(31.22)\nfor n \u0006 3, where \n D 0:5772156649 : : : is Euler’s constant. A somewhat simpler\n(but looser) lower bound for n > 5 is\n\u0007.n/ >\nn\n6 ln ln n :\n(31.23)",
    "parent_e7e6b5b6-5ec3-4e60-9fc8-8617a5cbc8a4": "\u0007.p/\nD\np\n\u0002\n1 \u0005 1\np\n\u0003\nD\np \u0005 1 :\n(31.21)\nIf n is composite, then \u0007.n/ < n \u0005 1, although it can be shown that\n\u0007.n/ >\nn\ne\b ln ln n C\n3\nln ln n\n(31.22)\nfor n \u0006 3, where \n D 0:5772156649 : : : is Euler’s constant. A somewhat simpler\n(but looser) lower bound for n > 5 is\n\u0007.n/ >\nn\n6 ln ln n :\n(31.23)\nThe lower bound (31.22) is essentially the best possible, since\nlim inf\nn!1\n\u0007.n/\nn= ln ln n D e\u0003\b :\n(31.24)\nSubgroups\nIf .S; ˚/ is a group, S 0 \u0007 S, and .S 0; ˚/ is also a group, then .S 0; ˚/ is a subgroup\nof .S; ˚/. For example, the even integers form a subgroup of the integers under the\noperation of addition. The following theorem provides a useful tool for recognizing\nsubgroups.\n944\nChapter 31\nNumber-Theoretic Algorithms\nTheorem 31.14 (A nonempty closed subset of a ﬁnite group is a subgroup)\nIf .S; ˚/ is a ﬁnite group and S 0 is any nonempty subset of S such that a ˚ b 2 S 0\nfor all a; b 2 S 0, then .S 0; ˚/ is a subgroup of .S; ˚/.\nProof\nWe leave the proof as Exercise 31.3-3.\nFor example, the set f0; 2; 4; 6g forms a subgroup of Z8, since it is nonempty\nand closed under the operation C (that is, it is closed under C8).\nThe following theorem provides an extremely useful constraint on the size of a\nsubgroup; we omit the proof.\nTheorem 31.15 (Lagrange’s theorem)\nIf .S; ˚/ is a ﬁnite group and .S 0; ˚/ is a subgroup of .S; ˚/, then jS 0j is a divisor\nof jSj.\nA subgroup S 0 of a group S is a proper subgroup if S 0 ¤ S. We shall use the\nfollowing corollary in our analysis in Section 31.8 of the Miller-Rabin primality\ntest procedure.\nCorollary 31.16\nIf S 0 is a proper subgroup of a ﬁnite group S, then jS 0j \u0002 jSj =2.\nSubgroups generated by an element\nTheorem 31.14 gives us an easy way to produce a subgroup of a ﬁnite group .S; ˚/:\nchoose an element a and take all elements that can be generated from a using the\ngroup operation. Speciﬁcally, deﬁne a.k/ for k \u0006 1 by\na.k/ D\nk\nM\niD1\na D\na ˚ a ˚ \u0003 \u0003 \u0003 ˚ a\nœ\nk\n:",
    "parent_33987d76-b8c9-4552-acf0-091799009285": "Subgroups generated by an element\nTheorem 31.14 gives us an easy way to produce a subgroup of a ﬁnite group .S; ˚/:\nchoose an element a and take all elements that can be generated from a using the\ngroup operation. Speciﬁcally, deﬁne a.k/ for k \u0006 1 by\na.k/ D\nk\nM\niD1\na D\na ˚ a ˚ \u0003 \u0003 \u0003 ˚ a\nœ\nk\n:\nFor example, if we take a D 2 in the group Z6, the sequence a.1/; a.2/; a.3/; : : : is\n2; 4; 0; 2; 4; 0; 2; 4; 0; : : : :\nIn the group Zn, we have a.k/ D ka mod n, and in the group Z\u0004\nn, we have a.k/ D\nak mod n. We deﬁne the subgroup generated by a, denoted hai or .hai; ˚/, by\nhai D fa.k/ W k \u0006 1g :\nWe say that a generates the subgroup hai or that a is a generator of hai. Since S is\nﬁnite, hai is a ﬁnite subset of S, possibly including all of S. Since the associativity\nof ˚ implies\n31.3\nModular arithmetic\n945\na.i/ ˚ a.j/ D a.iCj/ ;\nhai is closed and therefore, by Theorem 31.14, hai is a subgroup of S. For example,\nin Z6, we have\nh0i\nD\nf0g ;\nh1i\nD\nf0; 1; 2; 3; 4; 5g ;\nh2i\nD\nf0; 2; 4g :\nSimilarly, in Z\u0004\n7, we have\nh1i\nD\nf1g ;\nh2i\nD\nf1; 2; 4g ;\nh3i\nD\nf1; 2; 3; 4; 5; 6g :\nThe order of a (in the group S), denoted ord.a/, is deﬁned as the smallest posi-\ntive integer t such that a.t/ D e.\nTheorem 31.17\nFor any ﬁnite group .S; ˚/ and any a 2 S, the order of a is equal to the size of the\nsubgroup it generates, or ord.a/ D jhaij.\nProof\nLet t D ord.a/. Since a.t/ D e and a.tCk/ D a.t/ ˚ a.k/ D a.k/ for\nk \u0006 1, if i > t, then a.i/ D a.j/ for some j < i. Thus, as we generate ele-\nments by a, we see no new elements after a.t/. Thus, hai D fa.1/; a.2/; : : : ; a.t/g,\nand so jhaij \u0002 t. To show that jhaij \u0006 t, we show that each element of the se-\nquence a.1/; a.2/; : : : ; a.t/ is distinct. Suppose for the purpose of contradiction that\na.i/ D a.j/ for some i and j satisfying 1 \u0002 i < j \u0002 t. Then, a.iCk/ D a.jCk/\nfor k \u0006 0. But this equality implies that a.iC.t\u0003j// D a.jC.t\u0003j// D e, a contradic-\ntion, since i C.t \u0005j / < t but t is the least positive value such that a.t/ D e. There-",
    "parent_85143592-4baa-4485-bd22-12152a1a4506": "a.i/ D a.j/ for some i and j satisfying 1 \u0002 i < j \u0002 t. Then, a.iCk/ D a.jCk/\nfor k \u0006 0. But this equality implies that a.iC.t\u0003j// D a.jC.t\u0003j// D e, a contradic-\ntion, since i C.t \u0005j / < t but t is the least positive value such that a.t/ D e. There-\nfore, each element of the sequence a.1/; a.2/; : : : ; a.t/ is distinct, and jhaij \u0006 t. We\nconclude that ord.a/ D jhaij.\nCorollary 31.18\nThe sequence a.1/; a.2/; : : : is periodic with period t D ord.a/; that is, a.i/ D a.j/\nif and only if i \b j .mod t/.\nConsistent with the above corollary, we deﬁne a.0/ as e and a.i/ as a.i mod t/,\nwhere t D ord.a/, for all integers i.\nCorollary 31.19\nIf .S; ˚/ is a ﬁnite group with identity e, then for all a 2 S,\na.jSj/ D e :\n946\nChapter 31\nNumber-Theoretic Algorithms\nProof\nLagrange’s theorem (Theorem 31.15) implies that ord.a/ j jSj, and so\njSj \b 0 .mod t/, where t D ord.a/. Therefore, a.jSj/ D a.0/ D e.\nExercises\n31.3-1\nDraw the group operation tables for the groups .Z4; C4/ and .Z\u0004\n5; \u00035/. Show that\nthese groups are isomorphic by exhibiting a one-to-one correspondence ˛ between\ntheir elements such that a C b \b c .mod 4/ if and only if ˛.a/ \u0003 ˛.b/ \b ˛.c/\n.mod 5/.\n31.3-2\nList all subgroups of Z9 and of Z\u0004\n13.\n31.3-3\nProve Theorem 31.14.\n31.3-4\nShow that if p is prime and e is a positive integer, then\n\u0007.pe/ D pe\u00031.p \u0005 1/ :\n31.3-5\nShow that for any integer n > 1 and for any a 2 Z\u0004\nn, the function fa W Z\u0004\nn ! Z\u0004\nn\ndeﬁned by fa.x/ D ax mod n is a permutation of Z\u0004\nn.\n31.4\nSolving modular linear equations\nWe now consider the problem of ﬁnding solutions to the equation\nax \b b .mod n/ ;\n(31.25)\nwhere a > 0 and n > 0. This problem has several applications; for example,\nwe shall use it as part of the procedure for ﬁnding keys in the RSA public-key\ncryptosystem in Section 31.7. We assume that a, b, and n are given, and we wish\nto ﬁnd all values of x, modulo n, that satisfy equation (31.25). The equation may\nhave zero, one, or more than one such solution.",
    "parent_2abc795e-99af-4cd6-9f88-ecdad242a1c3": "we shall use it as part of the procedure for ﬁnding keys in the RSA public-key\ncryptosystem in Section 31.7. We assume that a, b, and n are given, and we wish\nto ﬁnd all values of x, modulo n, that satisfy equation (31.25). The equation may\nhave zero, one, or more than one such solution.\nLet hai denote the subgroup of Zn generated by a. Since hai D fa.x/ W x > 0g D\nfax mod n W x > 0g, equation (31.25) has a solution if and only if Œb\u0002 2 hai. La-\ngrange’s theorem (Theorem 31.15) tells us that jhaij must be a divisor of n. The\nfollowing theorem gives us a precise characterization of hai.\n31.4\nSolving modular linear equations\n947\nTheorem 31.20\nFor any positive integers a and n, if d D gcd.a; n/, then\nhai D hdi D f0; d; 2d; : : : ; ..n=d/ \u0005 1/dg\n(31.26)\nin Zn, and thus\njhaij D n=d :\nProof\nWe begin by showing that d 2 hai. Recall that EXTENDED-EUCLID.a; n/\nproduces integers x0 and y0 such that ax0 C ny0 D d. Thus, ax0 \b d .mod n/, so\nthat d 2 hai. In other words, d is a multiple of a in Zn.\nSince d 2 hai, it follows that every multiple of d belongs to hai, because any\nmultiple of a multiple of a is itself a multiple of a. Thus, hai contains every element\nin f0; d; 2d; : : : ; ..n=d/ \u0005 1/dg. That is, hdi \u0007 hai.\nWe now show that hai \u0007 hdi. If m 2 hai, then m D ax mod n for some\ninteger x, and so m D ax C ny for some integer y. However, d j a and d j n, and\nso d j m by equation (31.4). Therefore, m 2 hdi.\nCombining these results, we have that hai D hdi. To see that jhaij D n=d,\nobserve that there are exactly n=d multiples of d between 0 and n\u00051, inclusive.\nCorollary 31.21\nThe equation ax \b b .mod n/ is solvable for the unknown x if and only if d j b,\nwhere d D gcd.a; n/.\nProof\nThe equation ax \b b .mod n/ is solvable if and only if Œb\u0002 2 hai, which\nis the same as saying\n.b mod n/ 2 f0; d; 2d; : : : ; ..n=d/ \u0005 1/dg ;\nby Theorem 31.20. If 0 \u0002 b < n, then b 2 hai if and only if d j b, since the\nmembers of hai are precisely the multiples of d. If b < 0 or b \u0006 n, the corollary",
    "parent_b7ed1908-77c6-45bf-aa53-4e17802eaddd": "The equation ax \b b .mod n/ is solvable if and only if Œb\u0002 2 hai, which\nis the same as saying\n.b mod n/ 2 f0; d; 2d; : : : ; ..n=d/ \u0005 1/dg ;\nby Theorem 31.20. If 0 \u0002 b < n, then b 2 hai if and only if d j b, since the\nmembers of hai are precisely the multiples of d. If b < 0 or b \u0006 n, the corollary\nthen follows from the observation that d j b if and only if d j .b mod n/, since b\nand b mod n differ by a multiple of n, which is itself a multiple of d.\nCorollary 31.22\nThe equation ax \b b .mod n/ either has d distinct solutions modulo n, where\nd D gcd.a; n/, or it has no solutions.\nProof\nIf ax \b b .mod n/ has a solution, then b 2 hai. By Theorem 31.17,\nord.a/ D jhaij, and so Corollary 31.18 and Theorem 31.20 imply that the sequence\nai mod n, for i D 0; 1; : : :, is periodic with period jhaij D n=d. If b 2 hai, then b\nappears exactly d times in the sequence ai mod n, for i D 0; 1; : : : ; n \u0005 1, since\n948\nChapter 31\nNumber-Theoretic Algorithms\nthe length-.n=d/ block of values hai repeats exactly d times as i increases from 0\nto n\u00051. The indices x of the d positions for which ax mod n D b are the solutions\nof the equation ax \b b .mod n/.\nTheorem 31.23\nLet d D gcd.a; n/, and suppose that d D ax0 C ny0 for some integers x0 and y0\n(for example, as computed by EXTENDED-EUCLID). If d j b, then the equation\nax \b b .mod n/ has as one of its solutions the value x0, where\nx0 D x0.b=d/ mod n :\nProof\nWe have\nax0\n\b\nax0.b=d/ .mod n/\n\b\nd.b=d/\n.mod n/\n(because ax0 \b d .mod n/)\n\b\nb\n.mod n/ ;\nand thus x0 is a solution to ax \b b .mod n/.\nTheorem 31.24\nSuppose that the equation ax \b b .mod n/ is solvable (that is, d j b, where\nd D gcd.a; n/) and that x0 is any solution to this equation. Then, this equa-\ntion has exactly d distinct solutions, modulo n, given by xi D x0 C i.n=d/ for\ni D 0; 1; : : : ; d \u0005 1.\nProof\nBecause n=d > 0 and 0 \u0002 i.n=d/ < n for i D 0; 1; : : : ; d \u0005 1, the\nvalues x0; x1; : : : ; xd\u00031 are all distinct, modulo n. Since x0 is a solution of ax \b b",
    "parent_3f7b9755-e96d-413b-9cc2-f1ba8503a858": "tion has exactly d distinct solutions, modulo n, given by xi D x0 C i.n=d/ for\ni D 0; 1; : : : ; d \u0005 1.\nProof\nBecause n=d > 0 and 0 \u0002 i.n=d/ < n for i D 0; 1; : : : ; d \u0005 1, the\nvalues x0; x1; : : : ; xd\u00031 are all distinct, modulo n. Since x0 is a solution of ax \b b\n.mod n/, we have ax0 mod n \b b .mod n/. Thus, for i D 0; 1; : : : ; d \u0005 1, we\nhave\naxi mod n D a.x0 C in=d/ mod n\nD .ax0 C ain=d/ mod n\nD ax0 mod n\n(because d j a implies that ain=d is a multiple of n)\n\b b .mod n/ ;\nand hence axi \b b .mod n/, making xi a solution, too. By Corollary 31.22, the\nequation ax \b b .mod n/ has exactly d solutions, so that x0; x1; : : : ; xd\u00031 must\nbe all of them.\nWe have now developed the mathematics needed to solve the equation ax \b b\n.mod n/; the following algorithm prints all solutions to this equation. The inputs\na and n are arbitrary positive integers, and b is an arbitrary integer.\n31.4\nSolving modular linear equations\n949\nMODULAR-LINEAR-EQUATION-SOLVER.a; b; n/\n1\n.d; x0; y0/ D EXTENDED-EUCLID.a; n/\n2\nif d j b\n3\nx0 D x0.b=d/ mod n\n4\nfor i D 0 to d \u0005 1\n5\nprint .x0 C i.n=d// mod n\n6\nelse print “no solutions”\nAs an example of the operation of this procedure, consider the equation 14x \b\n30 .mod 100/ (here, a D 14, b D 30, and n D 100). Calling EXTENDED-\nEUCLID in line 1, we obtain .d; x0; y0/ D .2; \u00057; 1/. Since 2 j 30, lines 3–5\nexecute. Line 3 computes x0 D .\u00057/.15/ mod 100 D 95. The loop on lines 4–5\nprints the two solutions 95 and 45.\nThe procedure MODULAR-LINEAR-EQUATION-SOLVER works as follows.\nLine 1 computes d D gcd.a; n/, along with two values x0 and y0 such that d D\nax0 C ny0, demonstrating that x0 is a solution to the equation ax0 \b d .mod n/.\nIf d does not divide b, then the equation ax \b b .mod n/ has no solution, by\nCorollary 31.21. Line 2 checks to see whether d j b; if not, line 6 reports that there\nare no solutions. Otherwise, line 3 computes a solution x0 to ax \b b .mod n/,\nin accordance with Theorem 31.23. Given one solution, Theorem 31.24 states that",
    "parent_96f0eec5-e3d3-4dc8-969f-2e44316c2ea0": "Corollary 31.21. Line 2 checks to see whether d j b; if not, line 6 reports that there\nare no solutions. Otherwise, line 3 computes a solution x0 to ax \b b .mod n/,\nin accordance with Theorem 31.23. Given one solution, Theorem 31.24 states that\nadding multiples of .n=d/, modulo n, yields the other d \u0005 1 solutions. The for\nloop of lines 4–5 prints out all d solutions, beginning with x0 and spaced n=d\napart, modulo n.\nMODULAR-LINEAR-EQUATION-SOLVER performs O.lg n C gcd.a; n// arith-\nmetic operations, since EXTENDED-EUCLID performs O.lg n/ arithmetic opera-\ntions, and each iteration of the for loop of lines 4–5 performs a constant number of\narithmetic operations.\nThe following corollaries of Theorem 31.24 give specializations of particular\ninterest.\nCorollary 31.25\nFor any n > 1, if gcd.a; n/ D 1, then the equation ax \b b .mod n/ has a unique\nsolution, modulo n.\nIf b D 1, a common case of considerable interest, the x we are looking for is a\nmultiplicative inverse of a, modulo n.\nCorollary 31.26\nFor any n > 1, if gcd.a; n/ D 1, then the equation ax \b 1 .mod n/ has a unique\nsolution, modulo n. Otherwise, it has no solution.\n950\nChapter 31\nNumber-Theoretic Algorithms\nThanks to Corollary 31.26, we can use the notation a\u00031 mod n to refer to the\nmultiplicative inverse of a, modulo n, when a and n are relatively prime.\nIf\ngcd.a; n/ D 1, then the unique solution to the equation ax \b 1 .mod n/ is the\ninteger x returned by EXTENDED-EUCLID, since the equation\ngcd.a; n/ D 1 D ax C ny\nimplies ax \b 1 .mod n/. Thus, we can compute a\u00031 mod n efﬁciently using\nEXTENDED-EUCLID.\nExercises\n31.4-1\nFind all solutions to the equation 35x \b 10 .mod 50/.\n31.4-2\nProve that the equation ax \b ay .mod n/ implies x \b y .mod n/ whenever\ngcd.a; n/ D 1. Show that the condition gcd.a; n/ D 1 is necessary by supplying a\ncounterexample with gcd.a; n/ > 1.\n31.4-3\nConsider the following change to line 3 of the procedure MODULAR-LINEAR-\nEQUATION-SOLVER:\n3\nx0 D x0.b=d/ mod .n=d/",
    "parent_0802e0be-5483-43d4-b0fa-e81e09d568ea": "gcd.a; n/ D 1. Show that the condition gcd.a; n/ D 1 is necessary by supplying a\ncounterexample with gcd.a; n/ > 1.\n31.4-3\nConsider the following change to line 3 of the procedure MODULAR-LINEAR-\nEQUATION-SOLVER:\n3\nx0 D x0.b=d/ mod .n=d/\nWill this work? Explain why or why not.\n31.4-4\n?\nLet p be prime and f .x/ \b f0 C f1x C \u0003 \u0003 \u0003 C ftxt .mod p/ be a polyno-\nmial of degree t, with coefﬁcients fi drawn from Zp.\nWe say that a 2 Zp\nis a zero of f if f .a/ \b 0 .mod p/.\nProve that if a is a zero of f , then\nf .x/ \b .x \u0005 a/g.x/ .mod p/ for some polynomial g.x/ of degree t \u0005 1. Prove\nby induction on t that if p is prime, then a polynomial f .x/ of degree t can have\nat most t distinct zeros modulo p.\n31.5\nThe Chinese remainder theorem\nAround A.D. 100, the Chinese mathematician Sun-Ts˘u solved the problem of ﬁnd-\ning those integers x that leave remainders 2, 3, and 2 when divided by 3, 5, and 7\nrespectively. One such solution is x D 23; all solutions are of the form 23 C 105k\n31.5\nThe Chinese remainder theorem\n951\nfor arbitrary integers k. The “Chinese remainder theorem” provides a correspon-\ndence between a system of equations modulo a set of pairwise relatively prime\nmoduli (for example, 3, 5, and 7) and an equation modulo their product (for exam-\nple, 105).\nThe Chinese remainder theorem has two major applications.\nLet the inte-\nger n be factored as n D n1n2 \u0003 \u0003 \u0003 nk, where the factors ni are pairwise relatively\nprime. First, the Chinese remainder theorem is a descriptive “structure theorem”\nthat describes the structure of Zn as identical to that of the Cartesian product\nZn1 \t Zn2 \t \u0003 \u0003 \u0003 \t Znk with componentwise addition and multiplication modulo ni\nin the ith component. Second, this description helps us to design efﬁcient algo-\nrithms, since working in each of the systems Zni can be more efﬁcient (in terms of\nbit operations) than working modulo n.\nTheorem 31.27 (Chinese remainder theorem)\nLet n D n1n2 \u0003 \u0003 \u0003 nk, where the ni are pairwise relatively prime. Consider the",
    "parent_da313e99-72b3-44bf-946a-b7e66e2327f9": "rithms, since working in each of the systems Zni can be more efﬁcient (in terms of\nbit operations) than working modulo n.\nTheorem 31.27 (Chinese remainder theorem)\nLet n D n1n2 \u0003 \u0003 \u0003 nk, where the ni are pairwise relatively prime. Consider the\ncorrespondence\na $ .a1; a2; : : : ; ak/ ;\n(31.27)\nwhere a 2 Zn, ai 2 Zni, and\nai D a mod ni\nfor i D 1; 2; : : : ; k. Then, mapping (31.27) is a one-to-one correspondence (bijec-\ntion) between Zn and the Cartesian product Zn1 \tZn2 \t\u0003 \u0003 \u0003 \tZnk. Operations per-\nformed on the elements of Zn can be equivalently performed on the corresponding\nk-tuples by performing the operations independently in each coordinate position in\nthe appropriate system. That is, if\na\n$\n.a1; a2; : : : ; ak/ ;\nb\n$\n.b1; b2; : : : ; bk/ ;\nthen\n.a C b/ mod n\n$\n..a1 C b1/ mod n1; : : : ; .ak C bk/ mod nk/ ;\n(31.28)\n.a \u0005 b/ mod n\n$\n..a1 \u0005 b1/ mod n1; : : : ; .ak \u0005 bk/ mod nk/ ;\n(31.29)\n.ab/ mod n\n$\n.a1b1 mod n1; : : : ; akbk mod nk/ :\n(31.30)\nProof\nTransforming between the two representations is fairly straightforward.\nGoing from a to .a1; a2; : : : ; ak/ is quite easy and requires only k “mod” opera-\ntions.\nComputing a from inputs .a1; a2; : : : ; ak/ is a bit more complicated. We begin\nby deﬁning mi D n=ni for i D 1; 2; : : : ; k; thus mi is the product of all of the nj’s\nother than ni: mi D n1n2 \u0003 \u0003 \u0003 ni\u00031niC1 \u0003 \u0003 \u0003 nk. We next deﬁne\n952\nChapter 31\nNumber-Theoretic Algorithms\nci D mi.m\u00031\ni\nmod ni/\n(31.31)\nfor i D 1; 2; : : : ; k. Equation (31.31) is always well deﬁned: since mi and ni are\nrelatively prime (by Theorem 31.6), Corollary 31.26 guarantees that m\u00031\ni\nmod ni\nexists. Finally, we can compute a as a function of a1, a2, . . . , ak as follows:\na \b .a1c1 C a2c2 C \u0003 \u0003 \u0003 C akck/\n.mod n/ :\n(31.32)\nWe now show that equation (31.32) ensures that a \b ai .mod ni/ for i D\n1; 2; : : : ; k. Note that if j ¤ i, then mj \b 0 .mod ni/, which implies that cj \b\nmj \b 0 .mod ni/. Note also that ci \b 1 .mod ni/, from equation (31.31). We",
    "parent_1175890c-f331-4163-a792-ce2e670e77b1": "a \b .a1c1 C a2c2 C \u0003 \u0003 \u0003 C akck/\n.mod n/ :\n(31.32)\nWe now show that equation (31.32) ensures that a \b ai .mod ni/ for i D\n1; 2; : : : ; k. Note that if j ¤ i, then mj \b 0 .mod ni/, which implies that cj \b\nmj \b 0 .mod ni/. Note also that ci \b 1 .mod ni/, from equation (31.31). We\nthus have the appealing and useful correspondence\nci $ .0; 0; : : : ; 0; 1; 0; : : : ; 0/ ;\na vector that has 0s everywhere except in the ith coordinate, where it has a 1; the ci\nthus form a “basis” for the representation, in a certain sense. For each i, therefore,\nwe have\na\n\b\naici\n.mod ni/\n\b\naimi.m\u00031\ni\nmod ni/ .mod ni/\n\b\nai\n.mod ni/ ;\nwhich is what we wished to show: our method of computing a from the ai’s pro-\nduces a result a that satisﬁes the constraints a \b ai .mod ni/ for i D 1; 2; : : : ; k.\nThe correspondence is one-to-one, since we can transform in both directions.\nFinally, equations (31.28)–(31.30) follow directly from Exercise 31.1-7, since\nx mod ni D .x mod n/ mod ni for any x and i D 1; 2; : : : ; k.\nWe shall use the following corollaries later in this chapter.\nCorollary 31.28\nIf n1; n2; : : : ; nk are pairwise relatively prime and n D n1n2 \u0003 \u0003 \u0003 nk, then for any\nintegers a1; a2; : : : ; ak, the set of simultaneous equations\nx \b ai .mod ni/ ;\nfor i D 1; 2; : : : ; k, has a unique solution modulo n for the unknown x.\nCorollary 31.29\nIf n1; n2; : : : ; nk are pairwise relatively prime and n D n1n2 \u0003 \u0003 \u0003 nk, then for all\nintegers x and a,\nx \b a .mod ni/\nfor i D 1; 2; : : : ; k if and only if\nx \b a .mod n/ :\n31.5\nThe Chinese remainder theorem\n953\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n0\n0\n40\n15\n55\n30\n5\n45\n20\n60\n35\n10\n50\n25\n1\n26\n1\n41\n16\n56\n31\n6\n46\n21\n61\n36\n11\n51\n2\n52\n27\n2\n42\n17\n57\n32\n7\n47\n22\n62\n37\n12\n3\n13\n53\n28\n3\n43\n18\n58\n33\n8\n48\n23\n63\n38\n4\n39\n14\n54\n29\n4\n44\n19\n59\n34\n9\n49\n24\n64\nFigure 31.3\nAn illustration of the Chinese remainder theorem for n1 D 5 and n2 D 13. For this\nexample, c1 D 26 and c2 D 40. In row i, column j is shown the value of a, modulo 65, such",
    "parent_857da766-e0cf-4089-9482-c743c8c939d3": "52\n27\n2\n42\n17\n57\n32\n7\n47\n22\n62\n37\n12\n3\n13\n53\n28\n3\n43\n18\n58\n33\n8\n48\n23\n63\n38\n4\n39\n14\n54\n29\n4\n44\n19\n59\n34\n9\n49\n24\n64\nFigure 31.3\nAn illustration of the Chinese remainder theorem for n1 D 5 and n2 D 13. For this\nexample, c1 D 26 and c2 D 40. In row i, column j is shown the value of a, modulo 65, such\nthat a mod 5 D i and a mod 13 D j. Note that row 0, column 0 contains a 0. Similarly, row 4,\ncolumn 12 contains a 64 (equivalent to \u00051). Since c1 D 26, moving down a row increases a by 26.\nSimilarly, c2 D 40 means that moving right by a column increases a by 40. Increasing a by 1\ncorresponds to moving diagonally downward and to the right, wrapping around from the bottom to\nthe top and from the right to the left.\nAs an example of the application of the Chinese remainder theorem, suppose we\nare given the two equations\na\n\b\n2 .mod 5/ ;\na\n\b\n3 .mod 13/ ;\nso that a1 D 2, n1 D m2 D 5, a2 D 3, and n2 D m1 D 13, and we wish\nto compute a mod 65, since n D n1n2 D 65. Because 13\u00031 \b 2 .mod 5/ and\n5\u00031 \b 8 .mod 13/, we have\nc1\nD\n13.2 mod 5/\nD\n26 ;\nc2\nD\n5.8 mod 13/\nD\n40 ;\nand\na\n\b\n2 \u0003 26 C 3 \u0003 40 .mod 65/\n\b\n52 C 120\n.mod 65/\n\b\n42\n.mod 65/ :\nSee Figure 31.3 for an illustration of the Chinese remainder theorem, modulo 65.\nThus, we can work modulo n by working modulo n directly or by working in the\ntransformed representation using separate modulo ni computations, as convenient.\nThe computations are entirely equivalent.\nExercises\n31.5-1\nFind all solutions to the equations x \b 4 .mod 5/ and x \b 5 .mod 11/.\n954\nChapter 31\nNumber-Theoretic Algorithms\n31.5-2\nFind all integers x that leave remainders 1, 2, 3 when divided by 9, 8, 7 respectively.\n31.5-3\nArgue that, under the deﬁnitions of Theorem 31.27, if gcd.a; n/ D 1, then\n.a\u00031 mod n/ $ ..a\u00031\n1\nmod n1/; .a\u00031\n2\nmod n2/; : : : ; .a\u00031\nk\nmod nk// :\n31.5-4\nUnder the deﬁnitions of Theorem 31.27, prove that for any polynomial f , the num-\nber of roots of the equation f .x/ \b 0 .mod n/ equals the product of the number",
    "parent_758f383d-4d14-4874-b9d1-946482852f8b": ".a\u00031 mod n/ $ ..a\u00031\n1\nmod n1/; .a\u00031\n2\nmod n2/; : : : ; .a\u00031\nk\nmod nk// :\n31.5-4\nUnder the deﬁnitions of Theorem 31.27, prove that for any polynomial f , the num-\nber of roots of the equation f .x/ \b 0 .mod n/ equals the product of the number\nof roots of each of the equations f .x/ \b 0 .mod n1/, f .x/ \b 0 .mod n2/, . . . ,\nf .x/ \b 0 .mod nk/.\n31.6\nPowers of an element\nJust as we often consider the multiples of a given element a, modulo n, we consider\nthe sequence of powers of a, modulo n, where a 2 Z\u0004\nn:\na0; a1; a2; a3; : : : ;\n(31.33)\nmodulo n. Indexing from 0, the 0th value in this sequence is a0 mod n D 1, and\nthe ith value is ai mod n. For example, the powers of 3 modulo 7 are\ni\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\u0003 \u0003 \u0003\n3i mod 7\n1\n3\n2\n6\n4\n5\n1\n3\n2\n6\n4\n5\n\u0003 \u0003 \u0003\nwhereas the powers of 2 modulo 7 are\ni\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\u0003 \u0003 \u0003\n2i mod 7\n1\n2\n4\n1\n2\n4\n1\n2\n4\n1\n2\n4\n\u0003 \u0003 \u0003\nIn this section, let hai denote the subgroup of Z\u0004\nn generated by a by repeated\nmultiplication, and let ordn.a/ (the “order of a, modulo n”) denote the order of a\nin Z\u0004\nn. For example, h2i D f1; 2; 4g in Z\u0004\n7, and ord7.2/ D 3. Using the deﬁnition of\nthe Euler phi function \u0007.n/ as the size of Z\u0004\nn (see Section 31.3), we now translate\nCorollary 31.19 into the notation of Z\u0004\nn to obtain Euler’s theorem and specialize it\nto Z\u0004\np, where p is prime, to obtain Fermat’s theorem.\nTheorem 31.30 (Euler’s theorem)\nFor any integer n > 1,\na\u0007.n/ \b 1 .mod n/ for all a 2 Z\u0004\nn :\n31.6\nPowers of an element\n955\nTheorem 31.31 (Fermat’s theorem)\nIf p is prime, then\nap\u00031 \b 1 .mod p/ for all a 2 Z\u0004\np :\nProof\nBy equation (31.21), \u0007.p/ D p \u0005 1 if p is prime.\nFermat’s theorem applies to every element in Zp except 0, since 0 62 Z\u0004\np. For all\na 2 Zp, however, we have ap \b a .mod p/ if p is prime.\nIf ordn.g/ D jZ\u0004\nnj, then every element in Z\u0004\nn is a power of g, modulo n, and\ng is a primitive root or a generator of Z\u0004\nn. For example, 3 is a primitive root,\nmodulo 7, but 2 is not a primitive root, modulo 7. If Z\u0004\nn possesses a primitive",
    "parent_e8ea3815-1590-411e-85ef-353017b0ef8e": "a 2 Zp, however, we have ap \b a .mod p/ if p is prime.\nIf ordn.g/ D jZ\u0004\nnj, then every element in Z\u0004\nn is a power of g, modulo n, and\ng is a primitive root or a generator of Z\u0004\nn. For example, 3 is a primitive root,\nmodulo 7, but 2 is not a primitive root, modulo 7. If Z\u0004\nn possesses a primitive\nroot, the group Z\u0004\nn is cyclic. We omit the proof of the following theorem, which is\nproven by Niven and Zuckerman [265].\nTheorem 31.32\nThe values of n > 1 for which Z\u0004\nn is cyclic are 2, 4, pe, and 2pe, for all primes\np > 2 and all positive integers e.\nIf g is a primitive root of Z\u0004\nn and a is any element of Z\u0004\nn, then there exists a ´ such\nthat g´ \b a .mod n/. This ´ is a discrete logarithm or an index of a, modulo n,\nto the base g; we denote this value as indn;g.a/.\nTheorem 31.33 (Discrete logarithm theorem)\nIf g is a primitive root of Z\u0004\nn, then the equation gx \b gy .mod n/ holds if and\nonly if the equation x \b y .mod \u0007.n// holds.\nProof\nSuppose ﬁrst that x \b y .mod \u0007.n//. Then, x D y C k\u0007.n/ for some\ninteger k. Therefore,\ngx\n\b\ngyCk\u0007.n/\n.mod n/\n\b\ngy \u0003 .g\u0007.n//k .mod n/\n\b\ngy \u0003 1k\n.mod n/\n(by Euler’s theorem)\n\b\ngy\n.mod n/ :\nConversely, suppose that gx \b gy .mod n/. Because the sequence of powers of g\ngenerates every element of hgi and jhgij D \u0007.n/, Corollary 31.18 implies that\nthe sequence of powers of g is periodic with period \u0007.n/. Therefore, if gx \b gy\n.mod n/, then we must have x \b y .mod \u0007.n//.\nWe now turn our attention to the square roots of 1, modulo a prime power. The\nfollowing theorem will be useful in our development of a primality-testing algo-\nrithm in Section 31.8.\n956\nChapter 31\nNumber-Theoretic Algorithms\nTheorem 31.34\nIf p is an odd prime and e \u0006 1, then the equation\nx2 \b 1 .mod pe/\n(31.34)\nhas only two solutions, namely x D 1 and x D \u00051.\nProof\nEquation (31.34) is equivalent to\npe j .x \u0005 1/.x C 1/ :\nSince p > 2, we can have p j .x \u0005 1/ or p j .x C 1/, but not both. (Otherwise,\nby property (31.3), p would also divide their difference .x C 1/ \u0005 .x \u0005 1/ D 2.)",
    "parent_d050bcc8-c8b0-45f5-bac6-0ec9f27313ff": "x2 \b 1 .mod pe/\n(31.34)\nhas only two solutions, namely x D 1 and x D \u00051.\nProof\nEquation (31.34) is equivalent to\npe j .x \u0005 1/.x C 1/ :\nSince p > 2, we can have p j .x \u0005 1/ or p j .x C 1/, but not both. (Otherwise,\nby property (31.3), p would also divide their difference .x C 1/ \u0005 .x \u0005 1/ D 2.)\nIf p −.x \u0005 1/, then gcd.pe; x \u0005 1/ D 1, and by Corollary 31.5, we would have\npe j .x C 1/. That is, x \b \u00051 .mod pe/. Symmetrically, if p −.x C 1/,\nthen gcd.pe; x C 1/ D 1, and Corollary 31.5 implies that pe j .x \u0005 1/, so that\nx \b 1 .mod pe/. Therefore, either x \b \u00051 .mod pe/ or x \b 1 .mod pe/.\nA number x is a nontrivial square root of 1, modulo n, if it satisﬁes the equation\nx2 \b 1 .mod n/ but x is equivalent to neither of the two “trivial” square roots:\n1 or \u00051, modulo n. For example, 6 is a nontrivial square root of 1, modulo 35.\nWe shall use the following corollary to Theorem 31.34 in the correctness proof in\nSection 31.8 for the Miller-Rabin primality-testing procedure.\nCorollary 31.35\nIf there exists a nontrivial square root of 1, modulo n, then n is composite.\nProof\nBy the contrapositive of Theorem 31.34, if there exists a nontrivial square\nroot of 1, modulo n, then n cannot be an odd prime or a power of an odd prime.\nIf x2 \b 1 .mod 2/, then x \b 1 .mod 2/, and so all square roots of 1, modulo 2,\nare trivial. Thus, n cannot be prime. Finally, we must have n > 1 for a nontrivial\nsquare root of 1 to exist. Therefore, n must be composite.\nRaising to powers with repeated squaring\nA frequently occurring operation in number-theoretic computations is raising one\nnumber to a power modulo another number, also known as modular exponentia-\ntion. More precisely, we would like an efﬁcient way to compute ab mod n, where\na and b are nonnegative integers and n is a positive integer. Modular exponenti-\nation is an essential operation in many primality-testing routines and in the RSA\npublic-key cryptosystem. The method of repeated squaring solves this problem",
    "parent_3bd1726b-1e5c-46c0-a61b-edc0b17f27b9": "a and b are nonnegative integers and n is a positive integer. Modular exponenti-\nation is an essential operation in many primality-testing routines and in the RSA\npublic-key cryptosystem. The method of repeated squaring solves this problem\nefﬁciently using the binary representation of b.\nLet hbk; bk\u00031; : : : ; b1; b0i be the binary representation of b. (That is, the binary\nrepresentation is k C 1 bits long, bk is the most signiﬁcant bit, and b0 is the least\n31.6\nPowers of an element\n957\ni\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\nbi\n1\n0\n0\n0\n1\n1\n0\n0\n0\n0\nc\n1\n2\n4\n8\n17\n35\n70\n140\n280\n560\nd\n7\n49\n157\n526\n160\n241\n298\n166\n67\n1\nFigure 31.4\nThe results of MODULAR-EXPONENTIATION when computing ab .mod n/, where\na D 7, b D 560 D h1000110000i, and n D 561. The values are shown after each execution of the\nfor loop. The ﬁnal result is 1.\nsigniﬁcant bit.) The following procedure computes ac mod n as c is increased by\ndoublings and incrementations from 0 to b.\nMODULAR-EXPONENTIATION.a; b; n/\n1\nc D 0\n2\nd D 1\n3\nlet hbk; bk\u00031; : : : ; b0i be the binary representation of b\n4\nfor i D k downto 0\n5\nc D 2c\n6\nd D .d \u0003 d/ mod n\n7\nif bi == 1\n8\nc D c C 1\n9\nd D .d \u0003 a/ mod n\n10\nreturn d\nThe essential use of squaring in line 6 of each iteration explains the name “repeated\nsquaring.” As an example, for a D 7, b D 560, and n D 561, the algorithm\ncomputes the sequence of values modulo 561 shown in Figure 31.4; the sequence\nof exponents used appears in the row of the table labeled by c.\nThe variable c is not really needed by the algorithm but is included for the fol-\nlowing two-part loop invariant:\nJust prior to each iteration of the for loop of lines 4–9,\n1. The value of c is the same as the preﬁx hbk;bk\u00031;: : : ;biC1i of the binary\nrepresentation of b, and\n2. d D ac mod n.\nWe use this loop invariant as follows:\nInitialization: Initially, i D k, so that the preﬁx hbk; bk\u00031; : : : ; biC1i is empty,\nwhich corresponds to c D 0. Moreover, d D 1 D a0 mod n.\n958\nChapter 31\nNumber-Theoretic Algorithms",
    "parent_bec54caa-c515-414f-82e9-c51ff922a16c": "representation of b, and\n2. d D ac mod n.\nWe use this loop invariant as follows:\nInitialization: Initially, i D k, so that the preﬁx hbk; bk\u00031; : : : ; biC1i is empty,\nwhich corresponds to c D 0. Moreover, d D 1 D a0 mod n.\n958\nChapter 31\nNumber-Theoretic Algorithms\nMaintenance: Let c0 and d 0 denote the values of c and d at the end of an iteration\nof the for loop, and thus the values prior to the next iteration. Each iteration\nupdates c0 D 2c (if bi D 0) or c0 D 2c C1 (if bi D 1), so that c will be correct\nprior to the next iteration. If bi D 0, then d 0 D d 2 mod n D .ac/2 mod n D\na2c mod n D ac0 mod n. If bi D 1, then d 0 D d 2a mod n D .ac/2a mod n D\na2cC1 mod n D ac0 mod n. In either case, d D ac mod n prior to the next\niteration.\nTermination: At termination, i D \u00051. Thus, c D b, since c has the value of the\npreﬁx hbk; bk\u00031; : : : ; b0i of b’s binary representation. Hence d D ac mod n D\nab mod n.\nIf the inputs a, b, and n are ˇ-bit numbers, then the total number of arith-\nmetic operations required is O.ˇ/ and the total number of bit operations required\nis O.ˇ3/.\nExercises\n31.6-1\nDraw a table showing the order of every element in Z\u0004\n11. Pick the smallest primitive\nroot g and compute a table giving ind11;g.x/ for all x 2 Z\u0004\n11.\n31.6-2\nGive a modular exponentiation algorithm that examines the bits of b from right to\nleft instead of left to right.\n31.6-3\nAssuming that you know \u0007.n/, explain how to compute a\u00031 mod n for any a 2 Z\u0004\nn\nusing the procedure MODULAR-EXPONENTIATION.\n31.7\nThe RSA public-key cryptosystem\nWith a public-key cryptosystem, we can encrypt messages sent between two com-\nmunicating parties so that an eavesdropper who overhears the encrypted messages\nwill not be able to decode them. A public-key cryptosystem also enables a party\nto append an unforgeable “digital signature” to the end of an electronic message.\nSuch a signature is the electronic version of a handwritten signature on a paper doc-",
    "parent_33c9dfb7-272a-4bff-9340-50d7b74e48ce": "will not be able to decode them. A public-key cryptosystem also enables a party\nto append an unforgeable “digital signature” to the end of an electronic message.\nSuch a signature is the electronic version of a handwritten signature on a paper doc-\nument. It can be easily checked by anyone, forged by no one, yet loses its validity\nif any bit of the message is altered. It therefore provides authentication of both the\nidentity of the signer and the contents of the signed message. It is the perfect tool\n31.7\nThe RSA public-key cryptosystem\n959\nfor electronically signed business contracts, electronic checks, electronic purchase\norders, and other electronic communications that parties wish to authenticate.\nThe RSA public-key cryptosystem relies on the dramatic difference between the\nease of ﬁnding large prime numbers and the difﬁculty of factoring the product of\ntwo large prime numbers. Section 31.8 describes an efﬁcient procedure for ﬁnding\nlarge prime numbers, and Section 31.9 discusses the problem of factoring large\nintegers.\nPublic-key cryptosystems\nIn a public-key cryptosystem, each participant has both a public key and a secret\nkey. Each key is a piece of information. For example, in the RSA cryptosystem,\neach key consists of a pair of integers. The participants “Alice” and “Bob” are\ntraditionally used in cryptography examples; we denote their public and secret\nkeys as PA, SA for Alice and PB, SB for Bob.\nEach participant creates his or her own public and secret keys. Secret keys are\nkept secret, but public keys can be revealed to anyone or even published. In fact,\nit is often convenient to assume that everyone’s public key is available in a pub-\nlic directory, so that any participant can easily obtain the public key of any other\nparticipant.\nThe public and secret keys specify functions that can be applied to any message.\nLet D denote the set of permissible messages. For example, D might be the set of",
    "parent_572464fa-a8d9-4dc8-a22f-6366d3f98b22": "lic directory, so that any participant can easily obtain the public key of any other\nparticipant.\nThe public and secret keys specify functions that can be applied to any message.\nLet D denote the set of permissible messages. For example, D might be the set of\nall ﬁnite-length bit sequences. In the simplest, and original, formulation of public-\nkey cryptography, we require that the public and secret keys specify one-to-one\nfunctions from D to itself. We denote the function corresponding to Alice’s public\nkey PA by PA./ and the function corresponding to her secret key SA by SA./. The\nfunctions PA./ and SA./ are thus permutations of D. We assume that the functions\nPA./ and SA./ are efﬁciently computable given the corresponding key PA or SA.\nThe public and secret keys for any participant are a “matched pair” in that they\nspecify functions that are inverses of each other. That is,\nM\nD\nSA.PA.M// ;\n(31.35)\nM\nD\nPA.SA.M//\n(31.36)\nfor any message M 2 D. Transforming M with the two keys PA and SA succes-\nsively, in either order, yields the message M back.\nIn a public-key cryptosystem, we require that no one but Alice be able to com-\npute the function SA./ in any practical amount of time. This assumption is crucial\nto keeping encrypted mail sent to Alice private and to knowing that Alice’s digi-\ntal signatures are authentic. Alice must keep SA secret; if she does not, she loses\nher uniqueness and the cryptosystem cannot provide her with unique capabilities.\nThe assumption that only Alice can compute SA./ must hold even though everyone\n960\nChapter 31\nNumber-Theoretic Algorithms\ndecrypt\ncommunication channel\nencrypt\nBob\nAlice\neavesdropper\nM\nM\nPA\nSA\nC\nC D PA.M/\nFigure 31.5\nEncryption in a public key system. Bob encrypts the message M using Alice’s public\nkey PA and transmits the resulting ciphertext C D PA.M/ over a communication channel to Al-\nice. An eavesdropper who captures the transmitted ciphertext gains no information about M. Alice",
    "parent_aa63e4c5-30dd-41f1-9057-36e5770ca11f": "SA\nC\nC D PA.M/\nFigure 31.5\nEncryption in a public key system. Bob encrypts the message M using Alice’s public\nkey PA and transmits the resulting ciphertext C D PA.M/ over a communication channel to Al-\nice. An eavesdropper who captures the transmitted ciphertext gains no information about M. Alice\nreceives C and decrypts it using her secret key to obtain the original message M D SA.C/.\nknows PA and can compute PA./, the inverse function to SA./, efﬁciently. In order\nto design a workable public-key cryptosystem, we must ﬁgure out how to create\na system in which we can reveal a transformation PA./ without thereby revealing\nhow to compute the corresponding inverse transformation SA./. This task appears\nformidable, but we shall see how to accomplish it.\nIn a public-key cryptosystem, encryption works as shown in Figure 31.5. Sup-\npose Bob wishes to send Alice a message M encrypted so that it will look like\nunintelligible gibberish to an eavesdropper. The scenario for sending the message\ngoes as follows.\n\u0002\nBob obtains Alice’s public key PA (from a public directory or directly from\nAlice).\n\u0002\nBob computes the ciphertext C D PA.M/ corresponding to the message M\nand sends C to Alice.\n\u0002\nWhen Alice receives the ciphertext C, she applies her secret key SA to retrieve\nthe original message: SA.C/ D SA.PA.M// D M.\nBecause SA./ and PA./ are inverse functions, Alice can compute M from C. Be-\ncause only Alice is able to compute SA./, Alice is the only one who can compute M\nfrom C. Because Bob encrypts M using PA./, only Alice can understand the trans-\nmitted message.\nWe can just as easily implement digital signatures within our formulation of a\npublic-key cryptosystem. (There are other ways of approaching the problem of\nconstructing digital signatures, but we shall not go into them here.) Suppose now\nthat Alice wishes to send Bob a digitally signed response M 0. Figure 31.6 shows\nhow the digital-signature scenario proceeds.\n\u0002",
    "parent_ac5a6fa3-b854-414b-a0c8-17a982e7d7ba": "public-key cryptosystem. (There are other ways of approaching the problem of\nconstructing digital signatures, but we shall not go into them here.) Suppose now\nthat Alice wishes to send Bob a digitally signed response M 0. Figure 31.6 shows\nhow the digital-signature scenario proceeds.\n\u0002\nAlice computes her digital signature \t for the message M 0 using her secret\nkey SA and the equation \t D SA.M 0/.\n31.7\nThe RSA public-key cryptosystem\n961\nsign\ncommunication channel\nverify\n=?\naccept\nBob\nAlice\nM 0\nM 0\nPA\nSA\n\t\n.M 0; \t/\n\t D SA.M 0/\nFigure 31.6\nDigital signatures in a public-key system. Alice signs the message M 0 by appending\nher digital signature \t D SA.M 0/ to it. She transmits the message/signature pair .M 0; \t/ to Bob,\nwho veriﬁes it by checking the equation M 0 D PA.\t/. If the equation holds, he accepts .M 0; \t/ as\na message that Alice has signed.\n\u0002\nAlice sends the message/signature pair .M 0; \t/ to Bob.\n\u0002\nWhen Bob receives .M 0; \t/, he can verify that it originated from Alice by us-\ning Alice’s public key to verify the equation M 0 D PA.\t/. (Presumably, M 0\ncontains Alice’s name, so Bob knows whose public key to use.) If the equation\nholds, then Bob concludes that the message M 0 was actually signed by Alice.\nIf the equation fails to hold, Bob concludes either that the message M 0 or the\ndigital signature \t was corrupted by transmission errors or that the pair .M 0; \t/\nis an attempted forgery.\nBecause a digital signature provides both authentication of the signer’s identity and\nauthentication of the contents of the signed message, it is analogous to a handwrit-\nten signature at the end of a written document.\nA digital signature must be veriﬁable by anyone who has access to the signer’s\npublic key. A signed message can be veriﬁed by one party and then passed on to\nother parties who can also verify the signature. For example, the message might\nbe an electronic check from Alice to Bob. After Bob veriﬁes Alice’s signature on",
    "parent_8521c58a-063a-411a-8a86-95d3bc17f2fe": "public key. A signed message can be veriﬁed by one party and then passed on to\nother parties who can also verify the signature. For example, the message might\nbe an electronic check from Alice to Bob. After Bob veriﬁes Alice’s signature on\nthe check, he can give the check to his bank, who can then also verify the signature\nand effect the appropriate funds transfer.\nA signed message is not necessarily encrypted; the message can be “in the clear”\nand not protected from disclosure. By composing the above protocols for encryp-\ntion and for signatures, we can create messages that are both signed and encrypted.\nThe signer ﬁrst appends his or her digital signature to the message and then en-\ncrypts the resulting message/signature pair with the public key of the intended re-\ncipient. The recipient decrypts the received message with his or her secret key to\nobtain both the original message and its digital signature. The recipient can then\nverify the signature using the public key of the signer. The corresponding com-\nbined process using paper-based systems would be to sign the paper document and\n962\nChapter 31\nNumber-Theoretic Algorithms\nthen seal the document inside a paper envelope that is opened only by the intended\nrecipient.\nThe RSA cryptosystem\nIn the RSA public-key cryptosystem, a participant creates his or her public and\nsecret keys with the following procedure:\n1. Select at random two large prime numbers p and q such that p ¤ q. The primes\np and q might be, say, 1024 bits each.\n2. Compute n D pq.\n3. Select a small odd integer e that is relatively prime to \u0007.n/, which, by equa-\ntion (31.20), equals .p \u0005 1/.q \u0005 1/.\n4. Compute d as the multiplicative inverse of e, modulo \u0007.n/. (Corollary 31.26\nguarantees that d exists and is uniquely deﬁned. We can use the technique of\nSection 31.4 to compute d, given e and \u0007.n/.)\n5. Publish the pair P D .e; n/ as the participant’s RSA public key.\n6. Keep secret the pair S D .d; n/ as the participant’s RSA secret key.",
    "parent_2dd0fdae-ca63-43f0-9311-b1778ee3f6b4": "guarantees that d exists and is uniquely deﬁned. We can use the technique of\nSection 31.4 to compute d, given e and \u0007.n/.)\n5. Publish the pair P D .e; n/ as the participant’s RSA public key.\n6. Keep secret the pair S D .d; n/ as the participant’s RSA secret key.\nFor this scheme, the domain D is the set Zn. To transform a message M asso-\nciated with a public key P D .e; n/, compute\nP.M/ D M e mod n :\n(31.37)\nTo transform a ciphertext C associated with a secret key S D .d; n/, compute\nS.C/ D C d mod n :\n(31.38)\nThese equations apply to both encryption and signatures. To create a signature, the\nsigner applies his or her secret key to the message to be signed, rather than to a\nciphertext. To verify a signature, the public key of the signer is applied to it, rather\nthan to a message to be encrypted.\nWe can implement the public-key and secret-key operations using the procedure\nMODULAR-EXPONENTIATION described in Section 31.6. To analyze the running\ntime of these operations, assume that the public key .e; n/ and secret key .d; n/\nsatisfy lg e D O.1/, lg d \u0002 ˇ, and lg n \u0002 ˇ. Then, applying a public key requires\nO.1/ modular multiplications and uses O.ˇ2/ bit operations. Applying a secret\nkey requires O.ˇ/ modular multiplications, using O.ˇ3/ bit operations.\nTheorem 31.36 (Correctness of RSA)\nThe RSA equations (31.37) and (31.38) deﬁne inverse transformations of Zn satis-\nfying equations (31.35) and (31.36).\n31.7\nThe RSA public-key cryptosystem\n963\nProof\nFrom equations (31.37) and (31.38), we have that for any M 2 Zn,\nP.S.M// D S.P.M// D M ed .mod n/ :\nSince e and d are multiplicative inverses modulo \u0007.n/ D .p \u0005 1/.q \u0005 1/,\ned D 1 C k.p \u0005 1/.q \u0005 1/\nfor some integer k. But then, if M 6\b 0 .mod p/, we have\nM ed\n\b\nM.M p\u00031/k.q\u00031/\n.mod p/\n\b\nM..M mod p/p\u00031/k.q\u00031/ .mod p/\n\b\nM.1/k.q\u00031/\n.mod p/\n(by Theorem 31.31)\n\b\nM\n.mod p/ :\nAlso, M ed \b M .mod p/ if M \b 0 .mod p/. Thus,\nM ed \b M\n.mod p/\nfor all M. Similarly,\nM ed \b M\n.mod q/",
    "parent_b9ea416a-ef31-4b91-992f-669b05db71af": "for some integer k. But then, if M 6\b 0 .mod p/, we have\nM ed\n\b\nM.M p\u00031/k.q\u00031/\n.mod p/\n\b\nM..M mod p/p\u00031/k.q\u00031/ .mod p/\n\b\nM.1/k.q\u00031/\n.mod p/\n(by Theorem 31.31)\n\b\nM\n.mod p/ :\nAlso, M ed \b M .mod p/ if M \b 0 .mod p/. Thus,\nM ed \b M\n.mod p/\nfor all M. Similarly,\nM ed \b M\n.mod q/\nfor all M. Thus, by Corollary 31.29 to the Chinese remainder theorem,\nM ed \b M\n.mod n/\nfor all M.\nThe security of the RSA cryptosystem rests in large part on the difﬁculty of fac-\ntoring large integers. If an adversary can factor the modulus n in a public key, then\nthe adversary can derive the secret key from the public key, using the knowledge\nof the factors p and q in the same way that the creator of the public key used them.\nTherefore, if factoring large integers is easy, then breaking the RSA cryptosystem\nis easy. The converse statement, that if factoring large integers is hard, then break-\ning RSA is hard, is unproven. After two decades of research, however, no easier\nmethod has been found to break the RSA public-key cryptosystem than to factor\nthe modulus n. And as we shall see in Section 31.9, factoring large integers is sur-\nprisingly difﬁcult. By randomly selecting and multiplying together two 1024-bit\nprimes, we can create a public key that cannot be “broken” in any feasible amount\nof time with current technology. In the absence of a fundamental breakthrough in\nthe design of number-theoretic algorithms, and when implemented with care fol-\nlowing recommended standards, the RSA cryptosystem is capable of providing a\nhigh degree of security in applications.\nIn order to achieve security with the RSA cryptosystem, however, we should\nuse integers that are quite long—hundreds or even more than one thousand bits\n964\nChapter 31\nNumber-Theoretic Algorithms\nlong—to resist possible advances in the art of factoring.\nAt the time of this\nwriting (2009), RSA moduli were commonly in the range of 768 to 2048 bits.\nTo create moduli of such sizes, we must be able to ﬁnd large primes efﬁciently.",
    "parent_7784ff97-e007-4724-b58c-ee6b95015768": "964\nChapter 31\nNumber-Theoretic Algorithms\nlong—to resist possible advances in the art of factoring.\nAt the time of this\nwriting (2009), RSA moduli were commonly in the range of 768 to 2048 bits.\nTo create moduli of such sizes, we must be able to ﬁnd large primes efﬁciently.\nSection 31.8 addresses this problem.\nFor efﬁciency, RSA is often used in a “hybrid” or “key-management” mode\nwith fast non-public-key cryptosystems. With such a system, the encryption and\ndecryption keys are identical. If Alice wishes to send a long message M to Bob\nprivately, she selects a random key K for the fast non-public-key cryptosystem and\nencrypts M using K, obtaining ciphertext C. Here, C is as long as M, but K\nis quite short. Then, she encrypts K using Bob’s public RSA key. Since K is\nshort, computing PB.K/ is fast (much faster than computing PB.M/). She then\ntransmits .C; PB.K// to Bob, who decrypts PB.K/ to obtain K and then uses K\nto decrypt C, obtaining M.\nWe can use a similar hybrid approach to make digital signatures efﬁciently.\nThis approach combines RSA with a public collision-resistant hash function h—a\nfunction that is easy to compute but for which it is computationally infeasible to\nﬁnd two messages M and M 0 such that h.M/ D h.M 0/. The value h.M/ is\na short (say, 256-bit) “ﬁngerprint” of the message M. If Alice wishes to sign a\nmessage M, she ﬁrst applies h to M to obtain the ﬁngerprint h.M/, which she\nthen encrypts with her secret key. She sends .M; SA.h.M/// to Bob as her signed\nversion of M. Bob can verify the signature by computing h.M/ and verifying\nthat PA applied to SA.h.M// as received equals h.M/. Because no one can create\ntwo messages with the same ﬁngerprint, it is computationally infeasible to alter a\nsigned message and preserve the validity of the signature.\nFinally, we note that the use of certiﬁcates makes distributing public keys much\neasier. For example, assume there is a “trusted authority” T whose public key",
    "parent_b2fca67e-3add-400d-9fbb-540e2bf2e2cb": "signed message and preserve the validity of the signature.\nFinally, we note that the use of certiﬁcates makes distributing public keys much\neasier. For example, assume there is a “trusted authority” T whose public key\nis known by everyone. Alice can obtain from T a signed message (her certiﬁcate)\nstating that “Alice’s public key is PA.” This certiﬁcate is “self-authenticating” since\neveryone knows PT . Alice can include her certiﬁcate with her signed messages,\nso that the recipient has Alice’s public key immediately available in order to verify\nher signature. Because her key was signed by T , the recipient knows that Alice’s\nkey is really Alice’s.\nExercises\n31.7-1\nConsider an RSA key set with p D 11, q D 29, n D 319, and e D 3. What\nvalue of d should be used in the secret key? What is the encryption of the message\nM D 100?\n31.8\nPrimality testing\n965\n31.7-2\nProve that if Alice’s public exponent e is 3 and an adversary obtains Alice’s secret\nexponent d, where 0 < d < \u0007.n/, then the adversary can factor Alice’s modulus n\nin time polynomial in the number of bits in n. (Although you are not asked to prove\nit, you may be interested to know that this result remains true even if the condition\ne D 3 is removed. See Miller [255].)\n31.7-3\n?\nProve that RSA is multiplicative in the sense that\nPA.M1/PA.M2/ \b PA.M1M2/ .mod n/ :\nUse this fact to prove that if an adversary had a procedure that could efﬁciently\ndecrypt 1 percent of messages from Zn encrypted with PA, then he could employ\na probabilistic algorithm to decrypt every message encrypted with PA with high\nprobability.\n?\n31.8\nPrimality testing\nIn this section, we consider the problem of ﬁnding large primes. We begin with a\ndiscussion of the density of primes, proceed to examine a plausible, but incomplete,\napproach to primality testing, and then present an effective randomized primality\ntest due to Miller and Rabin.\nThe density of prime numbers\nFor many applications, such as cryptography, we need to ﬁnd large “random”",
    "parent_3001ee81-db26-4ceb-a507-d9b2888323d4": "approach to primality testing, and then present an effective randomized primality\ntest due to Miller and Rabin.\nThe density of prime numbers\nFor many applications, such as cryptography, we need to ﬁnd large “random”\nprimes. Fortunately, large primes are not too rare, so that it is feasible to test\nrandom integers of the appropriate size until we ﬁnd a prime. The prime distribu-\ntion function \u0006.n/ speciﬁes the number of primes that are less than or equal to n.\nFor example, \u0006.10/ D 4, since there are 4 prime numbers less than or equal to 10,\nnamely, 2, 3, 5, and 7. The prime number theorem gives a useful approximation\nto \u0006.n/.\nTheorem 31.37 (Prime number theorem)\nlim\nn!1\n\u0006.n/\nn= ln n D 1 :\nThe approximation n= ln n gives reasonably accurate estimates of \u0006.n/ even\nfor small n. For example, it is off by less than 6% at n D 109, where \u0006.n/ D\n966\nChapter 31\nNumber-Theoretic Algorithms\n50,847,534 and n= ln n \u0004 48,254,942. (To a number theorist, 109 is a small num-\nber.)\nWe can view the process of randomly selecting an integer n and determining\nwhether it is prime as a Bernoulli trial (see Section C.4). By the prime number\ntheorem, the probability of a success—that is, the probability that n is prime—is\napproximately 1= ln n. The geometric distribution tells us how many trials we need\nto obtain a success, and by equation (C.32), the expected number of trials is ap-\nproximately ln n. Thus, we would expect to examine approximately ln n integers\nchosen randomly near n in order to ﬁnd a prime that is of the same length as n.\nFor example, we expect that ﬁnding a 1024-bit prime would require testing ap-\nproximately ln 21024 \u0004 710 randomly chosen 1024-bit numbers for primality. (Of\ncourse, we can cut this ﬁgure in half by choosing only odd integers.)\nIn the remainder of this section, we consider the problem of determining whether\nor not a large odd integer n is prime. For notational convenience, we assume that n\nhas the prime factorization\nn D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr ;\n(31.39)",
    "parent_8944e908-d9cd-4be0-84d0-8b85cc5c1b6f": "In the remainder of this section, we consider the problem of determining whether\nor not a large odd integer n is prime. For notational convenience, we assume that n\nhas the prime factorization\nn D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr ;\n(31.39)\nwhere r \u0006 1, p1; p2; : : : ; pr are the prime factors of n, and e1; e2; : : : ; er are posi-\ntive integers. The integer n is prime if and only if r D 1 and e1 D 1.\nOne simple approach to the problem of testing for primality is trial division. We\ntry dividing n by each integer 2; 3; : : : ; bpnc. (Again, we may skip even integers\ngreater than 2.) It is easy to see that n is prime if and only if none of the trial divi-\nsors divides n. Assuming that each trial division takes constant time, the worst-case\nrunning time is ‚.pn/, which is exponential in the length of n. (Recall that if n\nis encoded in binary using ˇ bits, then ˇ D dlg.n C 1/e, and so pn D ‚.2ˇ=2/.)\nThus, trial division works well only if n is very small or happens to have a small\nprime factor. When it works, trial division has the advantage that it not only de-\ntermines whether n is prime or composite, but also determines one of n’s prime\nfactors if n is composite.\nIn this section, we are interested only in ﬁnding out whether a given number n\nis prime; if n is composite, we are not concerned with ﬁnding its prime factor-\nization. As we shall see in Section 31.9, computing the prime factorization of a\nnumber is computationally expensive. It is perhaps surprising that it is much easier\nto tell whether or not a given number is prime than it is to determine the prime\nfactorization of the number if it is not prime.\nPseudoprimality testing\nWe now consider a method for primality testing that “almost works” and in fact\nis good enough for many practical applications. Later on, we shall present a re-\n31.8\nPrimality testing\n967\nﬁnement of this method that removes the small defect. Let ZC\nn denote the nonzero\nelements of Zn:\nZC\nn D f1; 2; : : : ; n \u0005 1g :\nIf n is prime, then ZC\nn D Z\u0004\nn.",
    "parent_1c9ea31b-953d-4b7e-9ddb-e987f7d4c885": "is good enough for many practical applications. Later on, we shall present a re-\n31.8\nPrimality testing\n967\nﬁnement of this method that removes the small defect. Let ZC\nn denote the nonzero\nelements of Zn:\nZC\nn D f1; 2; : : : ; n \u0005 1g :\nIf n is prime, then ZC\nn D Z\u0004\nn.\nWe say that n is a base-a pseudoprime if n is composite and\nan\u00031 \b 1 .mod n/ :\n(31.40)\nFermat’s theorem (Theorem 31.31) implies that if n is prime, then n satisﬁes equa-\ntion (31.40) for every a in ZC\nn . Thus, if we can ﬁnd any a 2 ZC\nn such that n does\nnot satisfy equation (31.40), then n is certainly composite. Surprisingly, the con-\nverse almost holds, so that this criterion forms an almost perfect test for primality.\nWe test to see whether n satisﬁes equation (31.40) for a D 2. If not, we declare n\nto be composite by returning COMPOSITE. Otherwise, we return PRIME, guessing\nthat n is prime (when, in fact, all we know is that n is either prime or a base-2\npseudoprime).\nThe following procedure pretends in this manner to be checking the primality\nof n. It uses the procedure MODULAR-EXPONENTIATION from Section 31.6. We\nassume that the input n is an odd integer greater than 2.\nPSEUDOPRIME.n/\n1\nif MODULAR-EXPONENTIATION.2; n \u0005 1; n/ 6\b 1 .mod n/\n2\nreturn COMPOSITE\n// deﬁnitely\n3\nelse return PRIME\n// we hope!\nThis procedure can make errors, but only of one type. That is, if it says that n\nis composite, then it is always correct. If it says that n is prime, however, then it\nmakes an error only if n is a base-2 pseudoprime.\nHow often does this procedure err? Surprisingly rarely. There are only 22 values\nof n less than 10,000 for which it errs; the ﬁrst four such values are 341, 561,\n645, and 1105. We won’t prove it, but the probability that this program makes an\nerror on a randomly chosen ˇ-bit number goes to zero as ˇ ! 1. Using more\nprecise estimates due to Pomerance [279] of the number of base-2 pseudoprimes of\na given size, we may estimate that a randomly chosen 512-bit number that is called",
    "parent_d70fe795-c282-41a3-86f4-300e9ca9f8e3": "error on a randomly chosen ˇ-bit number goes to zero as ˇ ! 1. Using more\nprecise estimates due to Pomerance [279] of the number of base-2 pseudoprimes of\na given size, we may estimate that a randomly chosen 512-bit number that is called\nprime by the above procedure has less than one chance in 1020 of being a base-2\npseudoprime, and a randomly chosen 1024-bit number that is called prime has less\nthan one chance in 1041 of being a base-2 pseudoprime. So if you are merely\ntrying to ﬁnd a large prime for some application, for all practical purposes you\nalmost never go wrong by choosing large numbers at random until one of them\ncauses PSEUDOPRIME to return PRIME. But when the numbers being tested for\nprimality are not randomly chosen, we need a better approach for testing primality.\n968\nChapter 31\nNumber-Theoretic Algorithms\nAs we shall see, a little more cleverness, and some randomization, will yield a\nprimality-testing routine that works well on all inputs.\nUnfortunately, we cannot entirely eliminate all the errors by simply checking\nequation (31.40) for a second base number, say a D 3, because there exist com-\nposite integers n, known as Carmichael numbers, that satisfy equation (31.40) for\nall a 2 Z\u0004\nn. (We note that equation (31.40) does fail when gcd.a; n/ > 1—that\nis, when a 62 Z\u0004\nn—but hoping to demonstrate that n is composite by ﬁnding such\nan a can be difﬁcult if n has only large prime factors.) The ﬁrst three Carmichael\nnumbers are 561, 1105, and 1729. Carmichael numbers are extremely rare; there\nare, for example, only 255 of them less than 100,000,000. Exercise 31.8-2 helps\nexplain why they are so rare.\nWe next show how to improve our primality test so that it won’t be fooled by\nCarmichael numbers.\nThe Miller-Rabin randomized primality test\nThe Miller-Rabin primality test overcomes the problems of the simple test PSEU-\nDOPRIME with two modiﬁcations:\n\u0002\nIt tries several randomly chosen base values a instead of just one base value.\n\u0002",
    "parent_d5326d98-fa52-437d-b3ea-9028ae2cb569": "Carmichael numbers.\nThe Miller-Rabin randomized primality test\nThe Miller-Rabin primality test overcomes the problems of the simple test PSEU-\nDOPRIME with two modiﬁcations:\n\u0002\nIt tries several randomly chosen base values a instead of just one base value.\n\u0002\nWhile computing each modular exponentiation, it looks for a nontrivial square\nroot of 1, modulo n, during the ﬁnal set of squarings. If it ﬁnds one, it stops\nand returns COMPOSITE. Corollary 31.35 from Section 31.6 justiﬁes detecting\ncomposites in this manner.\nThe pseudocode for the Miller-Rabin primality test follows. The input n > 2 is\nthe odd number to be tested for primality, and s is the number of randomly cho-\nsen base values from ZC\nn to be tried. The code uses the random-number generator\nRANDOM described on page 117: RANDOM.1; n \u0005 1/ returns a randomly chosen\ninteger a satisfying 1 \u0002 a \u0002 n\u00051. The code uses an auxiliary procedure WITNESS\nsuch that WITNESS.a; n/ is TRUE if and only if a is a “witness” to the composite-\nness of n—that is, if it is possible using a to prove (in a manner that we shall see)\nthat n is composite. The test WITNESS.a; n/ is an extension of, but more effective\nthan, the test\nan\u00031 6\b 1 .mod n/\nthat formed the basis (using a D 2) for PSEUDOPRIME. We ﬁrst present and\njustify the construction of WITNESS, and then we shall show how we use it in the\nMiller-Rabin primality test. Let n \u0005 1 D 2tu where t \u0006 1 and u is odd; i.e.,\nthe binary representation of n \u0005 1 is the binary representation of the odd integer u\nfollowed by exactly t zeros. Therefore, an\u00031 \b .au/2t .mod n/, so that we can\n31.8\nPrimality testing\n969\ncompute an\u00031 mod n by ﬁrst computing au mod n and then squaring the result t\ntimes successively.\nWITNESS.a; n/\n1\nlet t and u be such that t \u0006 1, u is odd, and n \u0005 1 D 2tu\n2\nx0 D MODULAR-EXPONENTIATION.a; u; n/\n3\nfor i D 1 to t\n4\nxi D x2\ni\u00031 mod n\n5\nif xi == 1 and xi\u00031 ¤ 1 and xi\u00031 ¤ n \u0005 1\n6\nreturn TRUE\n7\nif xt ¤ 1\n8\nreturn TRUE\n9\nreturn FALSE",
    "parent_0ce083b9-ebd9-4123-af36-22d2b2e87350": "times successively.\nWITNESS.a; n/\n1\nlet t and u be such that t \u0006 1, u is odd, and n \u0005 1 D 2tu\n2\nx0 D MODULAR-EXPONENTIATION.a; u; n/\n3\nfor i D 1 to t\n4\nxi D x2\ni\u00031 mod n\n5\nif xi == 1 and xi\u00031 ¤ 1 and xi\u00031 ¤ n \u0005 1\n6\nreturn TRUE\n7\nif xt ¤ 1\n8\nreturn TRUE\n9\nreturn FALSE\nThis pseudocode for WITNESS computes an\u00031 mod n by ﬁrst computing the\nvalue x0 D au mod n in line 2 and then squaring the result t times in a row in the\nfor loop of lines 3–6. By induction on i, the sequence x0, x1, . . . , xt of values\ncomputed satisﬁes the equation xi \b a2iu .mod n/ for i D 0; 1; : : : ; t, so that in\nparticular xt \b an\u00031 .mod n/. After line 4 performs a squaring step, however,\nthe loop may terminate early if lines 5–6 detect that a nontrivial square root of 1\nhas just been discovered. (We shall explain these tests shortly.) If so, the algo-\nrithm stops and returns TRUE. Lines 7–8 return TRUE if the value computed for\nxt \b an\u00031 .mod n/ is not equal to 1, just as the PSEUDOPRIME procedure returns\nCOMPOSITE in this case. Line 9 returns FALSE if we haven’t returned TRUE in\nlines 6 or 8.\nWe now argue that if WITNESS.a; n/ returns TRUE, then we can construct a\nproof that n is composite using a as a witness.\nIf WITNESS returns TRUE from line 8, then it has discovered that xt\nD\nan\u00031 mod n ¤ 1. If n is prime, however, we have by Fermat’s theorem (Theo-\nrem 31.31) that an\u00031 \b 1 .mod n/ for all a 2 ZC\nn . Therefore, n cannot be prime,\nand the equation an\u00031 mod n ¤ 1 proves this fact.\nIf WITNESS returns TRUE from line 6, then it has discovered that xi\u00031 is a non-\ntrivial square root of 1, modulo n, since we have that xi\u00031 6\b ˙1 .mod n/ yet\nxi \b x2\ni\u00031 \b 1 .mod n/. Corollary 31.35 states that only if n is composite can\nthere exist a nontrivial square root of 1 modulo n, so that demonstrating that xi\u00031\nis a nontrivial square root of 1 modulo n proves that n is composite.\nThis completes our proof of the correctness of WITNESS. If we ﬁnd that the call",
    "parent_19243e30-9da8-4066-bfe2-4276a2bf3003": "there exist a nontrivial square root of 1 modulo n, so that demonstrating that xi\u00031\nis a nontrivial square root of 1 modulo n proves that n is composite.\nThis completes our proof of the correctness of WITNESS. If we ﬁnd that the call\nWITNESS.a; n/ returns TRUE, then n is surely composite, and the witness a, along\nwith the reason that the procedure returns TRUE (did it return from line 6 or from\nline 8?), provides a proof that n is composite.\n970\nChapter 31\nNumber-Theoretic Algorithms\nAt this point, we brieﬂy present an alternative description of the behavior of\nWITNESS as a function of the sequence X D hx0; x1; : : : ; xti, which we shall ﬁnd\nuseful later on, when we analyze the efﬁciency of the Miller-Rabin primality test.\nNote that if xi D 1 for some 0 \u0002 i < t, WITNESS might not compute the rest\nof the sequence. If it were to do so, however, each value xiC1; xiC2; : : : ; xt would\nbe 1, and we consider these positions in the sequence X as being all 1s. We have\nfour cases:\n1. X D h: : : ; di, where d ¤ 1: the sequence X does not end in 1. Return TRUE\nin line 8; a is a witness to the compositeness of n (by Fermat’s Theorem).\n2. X D h1; 1; : : : ; 1i: the sequence X is all 1s. Return FALSE; a is not a witness\nto the compositeness of n.\n3. X D h: : : ; \u00051; 1; : : : ; 1i: the sequence X ends in 1, and the last non-1 is equal\nto \u00051. Return FALSE; a is not a witness to the compositeness of n.\n4. X D h: : : ; d; 1; : : : ; 1i, where d ¤ ˙1: the sequence X ends in 1, but the last\nnon-1 is not \u00051. Return TRUE in line 6; a is a witness to the compositeness\nof n, since d is a nontrivial square root of 1.\nWe now examine the Miller-Rabin primality test based on the use of WITNESS.\nAgain, we assume that n is an odd integer greater than 2.\nMILLER-RABIN.n; s/\n1\nfor j D 1 to s\n2\na D RANDOM.1; n \u0005 1/\n3\nif WITNESS.a; n/\n4\nreturn COMPOSITE\n// deﬁnitely\n5\nreturn PRIME\n// almost surely\nThe procedure MILLER-RABIN is a probabilistic search for a proof that n is",
    "parent_3f353c8c-4b1d-442c-8c9c-742adbeab9d6": "Again, we assume that n is an odd integer greater than 2.\nMILLER-RABIN.n; s/\n1\nfor j D 1 to s\n2\na D RANDOM.1; n \u0005 1/\n3\nif WITNESS.a; n/\n4\nreturn COMPOSITE\n// deﬁnitely\n5\nreturn PRIME\n// almost surely\nThe procedure MILLER-RABIN is a probabilistic search for a proof that n is\ncomposite. The main loop (beginning on line 1) picks up to s random values of a\nfrom ZC\nn (line 2). If one of the a’s picked is a witness to the compositeness of n,\nthen MILLER-RABIN returns COMPOSITE on line 4. Such a result is always cor-\nrect, by the correctness of WITNESS. If MILLER-RABIN ﬁnds no witness in s\ntrials, then the procedure assumes that this is because no witnesses exist, and there-\nfore it assumes that n is prime. We shall see that this result is likely to be correct\nif s is large enough, but that there is still a tiny chance that the procedure may be\nunlucky in its choice of a’s and that witnesses do exist even though none has been\nfound.\nTo illustrate the operation of MILLER-RABIN, let n be the Carmichael num-\nber 561, so that n \u0005 1 D 560 D 24 \u0003 35, t D 4, and u D 35. If the pro-\ncedure chooses a D 7 as a base, Figure 31.4 in Section 31.6 shows that WIT-\nNESS computes x0 \b a35 \b 241 .mod 561/ and thus computes the sequence\n31.8\nPrimality testing\n971\nX D h241; 298; 166; 67; 1i. Thus, WITNESS discovers a nontrivial square root\nof 1 in the last squaring step, since a280 \b 67 .mod n/ and a560 \b 1 .mod n/.\nTherefore, a D 7 is a witness to the compositeness of n, WITNESS.7; n/ returns\nTRUE, and MILLER-RABIN returns COMPOSITE.\nIf n is a ˇ-bit number, MILLER-RABIN requires O.sˇ/ arithmetic operations\nand O.sˇ3/ bit operations, since it requires asymptotically no more work than s\nmodular exponentiations.\nError rate of the Miller-Rabin primality test\nIf MILLER-RABIN returns PRIME, then there is a very slim chance that it has made\nan error. Unlike PSEUDOPRIME, however, the chance of error does not depend",
    "parent_614ee01a-6871-4963-a15c-4b9ec7e69831": "modular exponentiations.\nError rate of the Miller-Rabin primality test\nIf MILLER-RABIN returns PRIME, then there is a very slim chance that it has made\nan error. Unlike PSEUDOPRIME, however, the chance of error does not depend\non n; there are no bad inputs for this procedure. Rather, it depends on the size of s\nand the “luck of the draw” in choosing base values a. Moreover, since each test is\nmore stringent than a simple check of equation (31.40), we can expect on general\nprinciples that the error rate should be small for randomly chosen integers n. The\nfollowing theorem presents a more precise argument.\nTheorem 31.38\nIf n is an odd composite number, then the number of witnesses to the composite-\nness of n is at least .n \u0005 1/=2.\nProof\nThe proof shows that the number of nonwitnesses is at most .n \u0005 1/=2,\nwhich implies the theorem.\nWe start by claiming that any nonwitness must be a member of Z\u0004\nn. Why?\nConsider any nonwitness a. It must satisfy an\u00031 \b 1 .mod n/ or, equivalently,\na \u0003 an\u00032 \b 1 .mod n/. Thus, the equation ax \b 1 .mod n/ has a solution,\nnamely an\u00032.\nBy Corollary 31.21, gcd.a; n/ j 1, which in turn implies that\ngcd.a; n/ D 1. Therefore, a is a member of Z\u0004\nn; all nonwitnesses belong to Z\u0004\nn.\nTo complete the proof, we show that not only are all nonwitnesses contained\nin Z\u0004\nn, they are all contained in a proper subgroup B of Z\u0004\nn (recall that we say B\nis a proper subgroup of Z\u0004\nn when B is subgroup of Z\u0004\nn but B is not equal to Z\u0004\nn).\nBy Corollary 31.16, we then have jBj \u0002 jZ\u0004\nnj =2. Since jZ\u0004\nnj \u0002 n \u0005 1, we obtain\njBj \u0002 .n \u0005 1/=2. Therefore, the number of nonwitnesses is at most .n \u0005 1/=2, so\nthat the number of witnesses must be at least .n \u0005 1/=2.\nWe now show how to ﬁnd a proper subgroup B of Z\u0004\nn containing all of the\nnonwitnesses. We break the proof into two cases.\nCase 1: There exists an x 2 Z\u0004\nn such that\nxn\u00031 6\b 1 .mod n/ :\n972\nChapter 31\nNumber-Theoretic Algorithms\nIn other words, n is not a Carmichael number.\nBecause, as we noted earlier,",
    "parent_bcf62386-a77e-4775-b9e6-89b6f338e8a9": "n containing all of the\nnonwitnesses. We break the proof into two cases.\nCase 1: There exists an x 2 Z\u0004\nn such that\nxn\u00031 6\b 1 .mod n/ :\n972\nChapter 31\nNumber-Theoretic Algorithms\nIn other words, n is not a Carmichael number.\nBecause, as we noted earlier,\nCarmichael numbers are extremely rare, case 1 is the main case that arises “in\npractice” (e.g., when n has been chosen randomly and is being tested for primal-\nity).\nLet B D fb 2 Z\u0004\nn W bn\u00031 \b 1 .mod n/g. Clearly, B is nonempty, since 1 2 B.\nSince B is closed under multiplication modulo n, we have that B is a subgroup\nof Z\u0004\nn by Theorem 31.14. Note that every nonwitness belongs to B, since a non-\nwitness a satisﬁes an\u00031 \b 1 .mod n/. Since x 2 Z\u0004\nn \u0005 B, we have that B is a\nproper subgroup of Z\u0004\nn.\nCase 2: For all x 2 Z\u0004\nn,\nxn\u00031 \b 1 .mod n/ :\n(31.41)\nIn other words, n is a Carmichael number. This case is extremely rare in prac-\ntice. However, the Miller-Rabin test (unlike a pseudo-primality test) can efﬁciently\ndetermine that Carmichael numbers are composite, as we now show.\nIn this case, n cannot be a prime power. To see why, let us suppose to the\ncontrary that n D pe, where p is a prime and e > 1. We derive a contradiction\nas follows. Since we assume that n is odd, p must also be odd. Theorem 31.32\nimplies that Z\u0004\nn is a cyclic group: it contains a generator g such that ordn.g/ D\njZ\u0004\nnj D \u0007.n/ D pe.1 \u0005 1=p/ D .p \u0005 1/pe\u00031. (The formula for \u0007.n/ comes from\nequation (31.20).) By equation (31.41), we have gn\u00031 \b 1 .mod n/. Then the\ndiscrete logarithm theorem (Theorem 31.33, taking y D 0) implies that n \u0005 1 \b 0\n.mod \u0007.n//, or\n.p \u0005 1/pe\u00031 j pe \u0005 1 :\nThis is a contradiction for e > 1, since .p \u0005 1/pe\u00031 is divisible by the prime p\nbut pe \u0005 1 is not. Thus, n is not a prime power.\nSince the odd composite number n is not a prime power, we decompose it into\na product n1n2, where n1 and n2 are odd numbers greater than 1 that are relatively\nprime to each other. (There may be several ways to decompose n, and it does not",
    "parent_e4781aa6-02af-4816-8c86-40b65dab87c4": "but pe \u0005 1 is not. Thus, n is not a prime power.\nSince the odd composite number n is not a prime power, we decompose it into\na product n1n2, where n1 and n2 are odd numbers greater than 1 that are relatively\nprime to each other. (There may be several ways to decompose n, and it does not\nmatter which one we choose. For example, if n D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr , then we can\nchoose n1 D pe1\n1 and n2 D pe2\n2 pe3\n3 \u0003 \u0003 \u0003 per\nr .)\nRecall that we deﬁne t and u so that n \u0005 1 D 2tu, where t \u0006 1 and u is odd, and\nthat for an input a, the procedure WITNESS computes the sequence\nX D hau; a2u; a22u; : : : ; a2tui\n(all computations are performed modulo n).\nLet us call a pair .\u0003; j / of integers acceptable if \u0003 2 Z\u0004\nn, j 2 f0; 1; : : : ; tg, and\n\u00032j u \b \u00051 .mod n/ :\n31.8\nPrimality testing\n973\nAcceptable pairs certainly exist since u is odd; we can choose \u0003 D n \u0005 1 and\nj D 0, so that .n\u00051; 0/ is an acceptable pair. Now pick the largest possible j such\nthat there exists an acceptable pair .\u0003; j /, and ﬁx \u0003 so that .\u0003; j / is an acceptable\npair. Let\nB D fx 2 Z\u0004\nn W x2j u \b ˙1 .mod n/g :\nSince B is closed under multiplication modulo n, it is a subgroup of Z\u0004\nn. By Theo-\nrem 31.15, therefore, jBj divides jZ\u0004\nnj. Every nonwitness must be a member of B,\nsince the sequence X produced by a nonwitness must either be all 1s or else contain\na \u00051 no later than the j th position, by the maximality of j . (If .a; j 0/ is acceptable,\nwhere a is a nonwitness, we must have j 0 \u0002 j by how we chose j .)\nWe now use the existence of \u0003 to demonstrate that there exists a w 2 Z\u0004\nn \u0005 B,\nand hence that B is a proper subgroup of Z\u0004\nn. Since \u00032j u \b \u00051 .mod n/, we have\n\u00032j u \b \u00051 .mod n1/ by Corollary 31.29 to the Chinese remainder theorem. By\nCorollary 31.28, there exists a w simultaneously satisfying the equations\nw\n\b\n\u0003 .mod n1/ ;\nw\n\b\n1 .mod n2/ :\nTherefore,\nw2j u\n\b\n\u00051\n.mod n1/ ;\nw2j u\n\b\n1\n.mod n2/ :\nBy Corollary 31.29, w2j u 6\b 1 .mod n1/ implies w2j u 6\b 1 .mod n/, and",
    "parent_1417c78a-2380-46f5-bfaf-79356d8d97ce": "Corollary 31.28, there exists a w simultaneously satisfying the equations\nw\n\b\n\u0003 .mod n1/ ;\nw\n\b\n1 .mod n2/ :\nTherefore,\nw2j u\n\b\n\u00051\n.mod n1/ ;\nw2j u\n\b\n1\n.mod n2/ :\nBy Corollary 31.29, w2j u 6\b 1 .mod n1/ implies w2j u 6\b 1 .mod n/, and\nw2j u 6\b \u00051 .mod n2/ implies w2j u 6\b \u00051 .mod n/. Hence, we conclude that\nw2j u 6\b ˙1 .mod n/, and so w 62 B.\nIt remains to show that w 2 Z\u0004\nn, which we do by ﬁrst working separately mod-\nulo n1 and modulo n2. Working modulo n1, we observe that since \u0003 2 Z\u0004\nn, we\nhave that gcd.\u0003; n/ D 1, and so also gcd.\u0003; n1/ D 1; if \u0003 does not have any com-\nmon divisors with n, then it certainly does not have any common divisors with n1.\nSince w \b \u0003 .mod n1/, we see that gcd.w; n1/ D 1. Working modulo n2, we\nobserve that w \b 1 .mod n2/ implies gcd.w; n2/ D 1. To combine these results,\nwe use Theorem 31.6, which implies that gcd.w; n1n2/ D gcd.w; n/ D 1. That is,\nw 2 Z\u0004\nn.\nTherefore w 2 Z\u0004\nn \u0005 B, and we ﬁnish case 2 with the conclusion that B is a\nproper subgroup of Z\u0004\nn.\nIn either case, we see that the number of witnesses to the compositeness of n is\nat least .n \u0005 1/=2.\nTheorem 31.39\nFor any odd integer n > 2 and positive integer s, the probability that MILLER-\nRABIN.n; s/ errs is at most 2\u0003s.\n974\nChapter 31\nNumber-Theoretic Algorithms\nProof\nUsing Theorem 31.38, we see that if n is composite, then each execution of\nthe for loop of lines 1–4 has a probability of at least 1=2 of discovering a witness x\nto the compositeness of n. MILLER-RABIN makes an error only if it is so unlucky\nas to miss discovering a witness to the compositeness of n on each of the s iterations\nof the main loop. The probability of such a sequence of misses is at most 2\u0003s.\nIf n is prime, MILLER-RABIN always reports PRIME, and if n is composite, the\nchance that MILLER-RABIN reports PRIME is at most 2\u0003s.\nWhen applying MILLER-RABIN to a large randomly chosen integer n, however,\nwe need to consider as well the prior probability that n is prime, in order to cor-",
    "parent_e0da1497-36d8-48c8-99e5-78faa0c11fa6": "If n is prime, MILLER-RABIN always reports PRIME, and if n is composite, the\nchance that MILLER-RABIN reports PRIME is at most 2\u0003s.\nWhen applying MILLER-RABIN to a large randomly chosen integer n, however,\nwe need to consider as well the prior probability that n is prime, in order to cor-\nrectly interpret MILLER-RABIN’s result. Suppose that we ﬁx a bit length ˇ and\nchoose at random an integer n of length ˇ bits to be tested for primality. Let A\ndenote the event that n is prime. By the prime number theorem (Theorem 31.37),\nthe probability that n is prime is approximately\nPr fAg\n\u0004\n1= ln n\n\u0004\n1:443=ˇ :\nNow let B denote the event that MILLER-RABIN returns PRIME. We have that\nPr\n˚\nB j A",
    "parent_fb1cdf08-7ec0-4eba-971c-e4a909dc6f58": "D 0 (or equivalently, that Pr fB j Ag D 1) and Pr\n˚\nB j A\n\n\u0002 2\u0003s (or\nequivalently, that Pr\n˚\nB j A\n\n> 1 \u0005 2\u0003s).\nBut what is Pr fA j Bg, the probability that n is prime, given that MILLER-\nRABIN has returned PRIME? By the alternate form of Bayes’s theorem (equa-\ntion (C.18)) we have\nPr fA j Bg\nD\nPr fAg Pr fB j Ag\nPr fAg Pr fB j Ag C Pr\n˚\nA\n\nPr\n˚\nB j A",
    "parent_75b441db-5973-432b-9c42-c198c4278d2c": "\u0004\n1\n1 C 2\u0003s.ln n \u0005 1/ :\nThis probability does not exceed 1=2 until s exceeds lg.ln n \u0005 1/. Intuitively, that\nmany initial trials are needed just for the conﬁdence derived from failing to ﬁnd a\nwitness to the compositeness of n to overcome the prior bias in favor of n being\ncomposite. For a number with ˇ D 1024 bits, this initial testing requires about\nlg.ln n \u0005 1/\n\u0004\nlg.ˇ=1:443/\n\u0004\n9\ntrials. In any case, choosing s D 50 should sufﬁce for almost any imaginable\napplication.\nIn fact, the situation is much better. If we are trying to ﬁnd large primes by\napplying MILLER-RABIN to large randomly chosen odd integers, then choosing\na small value of s (say 3) is very unlikely to lead to erroneous results, though\n31.9\nInteger factorization\n975\nwe won’t prove it here. The reason is that for a randomly chosen odd composite\ninteger n, the expected number of nonwitnesses to the compositeness of n is likely\nto be very much smaller than .n \u0005 1/=2.\nIf the integer n is not chosen randomly, however, the best that can be proven is\nthat the number of nonwitnesses is at most .n \u0005 1/=4, using an improved version\nof Theorem 31.38. Furthermore, there do exist integers n for which the number of\nnonwitnesses is .n \u0005 1/=4.\nExercises\n31.8-1\nProve that if an odd integer n > 1 is not a prime or a prime power, then there exists\na nontrivial square root of 1 modulo n.\n31.8-2\n?\nIt is possible to strengthen Euler’s theorem slightly to the form\na\t.n/ \b 1 .mod n/ for all a 2 Z\u0004\nn ;\nwhere n D pe1\n1 \u0003 \u0003 \u0003 per\nr and \u0005.n/ is deﬁned by\n\u0005.n/ D lcm.\u0007.pe1\n1 /; : : : ; \u0007.per\nr // :\n(31.42)\nProve that \u0005.n/ j \u0007.n/.\nA composite number n is a Carmichael number if\n\u0005.n/ j n \u0005 1.\nThe smallest Carmichael number is 561 D 3 \u0003 11 \u0003 17; here,\n\u0005.n/ D lcm.2; 10; 16/ D 80, which divides 560. Prove that Carmichael num-\nbers must be both “square-free” (not divisible by the square of any prime) and the\nproduct of at least three primes. (For this reason, they are not very common.)\n31.8-3",
    "parent_978511c5-d017-45cd-8c2d-ca7d0234bb47": "\u0005.n/ D lcm.2; 10; 16/ D 80, which divides 560. Prove that Carmichael num-\nbers must be both “square-free” (not divisible by the square of any prime) and the\nproduct of at least three primes. (For this reason, they are not very common.)\n31.8-3\nProve that if x is a nontrivial square root of 1, modulo n, then gcd.x \u0005 1; n/ and\ngcd.x C 1; n/ are both nontrivial divisors of n.\n?\n31.9\nInteger factorization\nSuppose we have an integer n that we wish to factor, that is, to decompose into a\nproduct of primes. The primality test of the preceding section may tell us that n is\ncomposite, but it does not tell us the prime factors of n. Factoring a large integer n\nseems to be much more difﬁcult than simply determining whether n is prime or\ncomposite. Even with today’s supercomputers and the best algorithms to date, we\ncannot feasibly factor an arbitrary 1024-bit number.\n976\nChapter 31\nNumber-Theoretic Algorithms\nPollard’s rho heuristic\nTrial division by all integers up to R is guaranteed to factor completely any number\nup to R2. For the same amount of work, the following procedure, POLLARD-RHO,\nfactors any number up to R4 (unless we are unlucky). Since the procedure is only\na heuristic, neither its running time nor its success is guaranteed, although the\nprocedure is highly effective in practice. Another advantage of the POLLARD-\nRHO procedure is that it uses only a constant number of memory locations. (If you\nwanted to, you could easily implement POLLARD-RHO on a programmable pocket\ncalculator to ﬁnd factors of small numbers.)\nPOLLARD-RHO.n/\n1\ni D 1\n2\nx1 D RANDOM.0; n \u0005 1/\n3\ny D x1\n4\nk D 2\n5\nwhile TRUE\n6\ni D i C 1\n7\nxi D .x2\ni\u00031 \u0005 1/ mod n\n8\nd D gcd.y \u0005 xi; n/\n9\nif d ¤ 1 and d ¤ n\n10\nprint d\n11\nif i == k\n12\ny D xi\n13\nk D 2k\nThe procedure works as follows. Lines 1–2 initialize i to 1 and x1 to a randomly\nchosen value in Zn. The while loop beginning on line 5 iterates forever, searching\nfor factors of n. During each iteration of the while loop, line 7 uses the recurrence\nxi D .x2",
    "parent_5b8de32b-43b0-410c-bca2-edd336f23210": "print d\n11\nif i == k\n12\ny D xi\n13\nk D 2k\nThe procedure works as follows. Lines 1–2 initialize i to 1 and x1 to a randomly\nchosen value in Zn. The while loop beginning on line 5 iterates forever, searching\nfor factors of n. During each iteration of the while loop, line 7 uses the recurrence\nxi D .x2\ni\u00031 \u0005 1/ mod n\n(31.43)\nto produce the next value of xi in the inﬁnite sequence\nx1; x2; x3; x4; : : : ;\n(31.44)\nwith line 6 correspondingly incrementing i. The pseudocode is written using sub-\nscripted variables xi for clarity, but the program works the same if all of the sub-\nscripts are dropped, since only the most recent value of xi needs to be maintained.\nWith this modiﬁcation, the procedure uses only a constant number of memory lo-\ncations.\nEvery so often, the program saves the most recently generated xi value in the\nvariable y. Speciﬁcally, the values that are saved are the ones whose subscripts are\npowers of 2:\n31.9\nInteger factorization\n977\nx1; x2; x4; x8; x16; : : : :\nLine 3 saves the value x1, and line 12 saves xk whenever i is equal to k. The\nvariable k is initialized to 2 in line 4, and line 13 doubles it whenever line 12\nupdates y. Therefore, k follows the sequence 1; 2; 4; 8; : : : and always gives the\nsubscript of the next value xk to be saved in y.\nLines 8–10 try to ﬁnd a factor of n, using the saved value of y and the cur-\nrent value of xi.\nSpeciﬁcally, line 8 computes the greatest common divisor\nd D gcd.y \u0005 xi; n/. If line 9 ﬁnds d to be a nontrivial divisor of n, then line 10\nprints d.\nThis procedure for ﬁnding a factor may seem somewhat mysterious at ﬁrst.\nNote, however, that POLLARD-RHO never prints an incorrect answer; any num-\nber it prints is a nontrivial divisor of n. POLLARD-RHO might not print anything\nat all, though; it comes with no guarantee that it will print any divisors. We shall\nsee, however, that we have good reason to expect POLLARD-RHO to print a fac-\ntor p of n after ‚.pp/ iterations of the while loop. Thus, if n is composite, we",
    "parent_7a9978ae-418e-4521-88e5-0c54c9cd908f": "at all, though; it comes with no guarantee that it will print any divisors. We shall\nsee, however, that we have good reason to expect POLLARD-RHO to print a fac-\ntor p of n after ‚.pp/ iterations of the while loop. Thus, if n is composite, we\ncan expect this procedure to discover enough divisors to factor n completely after\napproximately n1=4 updates, since every prime factor p of n except possibly the\nlargest one is less than pn.\nWe begin our analysis of how this procedure behaves by studying how long\nit takes a random sequence modulo n to repeat a value. Since Zn is ﬁnite, and\nsince each value in the sequence (31.44) depends only on the previous value, the\nsequence (31.44) eventually repeats itself. Once we reach an xi such that xi D xj\nfor some j < i, we are in a cycle, since xiC1 D xjC1, xiC2 D xjC2, and so on.\nThe reason for the name “rho heuristic” is that, as Figure 31.7 shows, we can draw\nthe sequence x1; x2; : : : ; xj\u00031 as the “tail” of the rho and the cycle xj; xjC1; : : : ; xi\nas the “body” of the rho.\nLet us consider the question of how long it takes for the sequence of xi to repeat.\nThis information is not exactly what we need, but we shall see later how to modify\nthe argument. For the purpose of this estimation, let us assume that the function\nfn.x/ D .x2 \u0005 1/ mod n\nbehaves like a “random” function. Of course, it is not really random, but this as-\nsumption yields results consistent with the observed behavior of POLLARD-RHO.\nWe can then consider each xi to have been independently drawn from Zn according\nto a uniform distribution on Zn. By the birthday-paradox analysis of Section 5.4.1,\nwe expect ‚.pn/ steps to be taken before the sequence cycles.\nNow for the required modiﬁcation. Let p be a nontrivial factor of n such that\ngcd.p; n=p/ D 1. For example, if n has the factorization n D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr , then\nwe may take p to be pe1\n1 . (If e1 D 1, then p is just the smallest prime factor of n,\na good example to keep in mind.)\n978\nChapter 31",
    "parent_3418ee3f-b029-43d4-b520-9378dceed2b2": "gcd.p; n=p/ D 1. For example, if n has the factorization n D pe1\n1 pe2\n2 \u0003 \u0003 \u0003 per\nr , then\nwe may take p to be pe1\n1 . (If e1 D 1, then p is just the smallest prime factor of n,\na good example to keep in mind.)\n978\nChapter 31\nNumber-Theoretic Algorithms\n996\n310\n396\n84\n120\n529\n1053\n595\n339\n814\n1194\n63\n8\n3\n2\n(b)\n(c)\n(a)\n3\n2\n18\n26\n8\n31\n11\n47\n177\n1186\nmod 1387\nmod 19\nmod 73\n8\n6\n16\n63\n3\n2\nx1\nx2\nx3\nx4\nx5\nx6\nx7\nx0\n1\nx0\n2\nx0\n3\nx0\n4\nx0\n5\nx0\n6\nx0\n7\nx00\n1\nx00\n2\nx00\n3\nx00\n4\nx00\n5\nx00\n6\nx00\n7\nFigure 31.7\nPollard’s rho heuristic.\n(a) The values produced by the recurrence xiC1\nD\n.x2\ni \u0005 1/ mod 1387, starting with x1 D 2. The prime factorization of 1387 is 19 \u0003 73. The heavy\narrows indicate the iteration steps that are executed before the factor 19 is discovered. The light\narrows point to unreached values in the iteration, to illustrate the “rho” shape. The shaded values are\nthe y values stored by POLLARD-RHO. The factor 19 is discovered upon reaching x7 D 177, when\ngcd.63 \u0005 177; 1387/ D 19 is computed. The ﬁrst x value that would be repeated is 1186, but the\nfactor 19 is discovered before this value is repeated. (b) The values produced by the same recurrence,\nmodulo 19. Every value xi given in part (a) is equivalent, modulo 19, to the value x0\ni shown here.\nFor example, both x4 D 63 and x7 D 177 are equivalent to 6, modulo 19. (c) The values produced\nby the same recurrence, modulo 73. Every value xi given in part (a) is equivalent, modulo 73, to the\nvalue x00\ni shown here. By the Chinese remainder theorem, each node in part (a) corresponds to a pair\nof nodes, one from part (b) and one from part (c).\nThe sequence hxii induces a corresponding sequence hx0\nii modulo p, where\nx0\ni D xi mod p\nfor all i.\nFurthermore, because fn is deﬁned using only arithmetic operations (squaring\nand subtraction) modulo n, we can compute x0\niC1 from x0\ni; the “modulo p” view of\n31.9\nInteger factorization\n979\nthe sequence is a smaller version of what is happening modulo n:\nx0\niC1\nD\nxiC1 mod p\nD",
    "parent_9dc4e515-8c6f-4f24-ac4a-781fdfa41bfb": "for all i.\nFurthermore, because fn is deﬁned using only arithmetic operations (squaring\nand subtraction) modulo n, we can compute x0\niC1 from x0\ni; the “modulo p” view of\n31.9\nInteger factorization\n979\nthe sequence is a smaller version of what is happening modulo n:\nx0\niC1\nD\nxiC1 mod p\nD\nfn.xi/ mod p\nD\n..x2\ni \u0005 1/ mod n/ mod p\nD\n.x2\ni \u0005 1/ mod p\n(by Exercise 31.1-7)\nD\n..xi mod p/2 \u0005 1/ mod p\nD\n..x0\ni/2 \u0005 1/ mod p\nD\nfp.x0\ni/ :\nThus, although we are not explicitly computing the sequence hx0\nii, this sequence is\nwell deﬁned and obeys the same recurrence as the sequence hxii.\nReasoning as before, we ﬁnd that the expected number of steps before the se-\nquence hx0\nii repeats is ‚.pp/. If p is small compared to n, the sequence hx0\nii might\nrepeat much more quickly than the sequence hxii. Indeed, as parts (b) and (c) of\nFigure 31.7 show, the hx0\nii sequence repeats as soon as two elements of the se-\nquence hxii are merely equivalent modulo p, rather than equivalent modulo n.\nLet t denote the index of the ﬁrst repeated value in the hx0\nii sequence, and let\nu > 0 denote the length of the cycle that has been thereby produced. That is, t\nand u > 0 are the smallest values such that x0\ntCi D x0\ntCuCi for all i \u0006 0. By the\nabove arguments, the expected values of t and u are both ‚.pp/. Note that if\nx0\ntCi D x0\ntCuCi, then p j .xtCuCi \u0005 xtCi/. Thus, gcd.xtCuCi \u0005 xtCi; n/ > 1.\nTherefore, once POLLARD-RHO has saved as y any value xk such that k \u0006 t,\nthen y mod p is always on the cycle modulo p. (If a new value is saved as y,\nthat value is also on the cycle modulo p.) Eventually, k is set to a value that\nis greater than u, and the procedure then makes an entire loop around the cycle\nmodulo p without changing the value of y. The procedure then discovers a factor\nof n when xi “runs into” the previously stored value of y, modulo p, that is, when\nxi \b y .mod p/.\nPresumably, the factor found is the factor p, although it may occasionally hap-",
    "parent_a855284f-b5dc-4410-8323-ab57260b22b4": "modulo p without changing the value of y. The procedure then discovers a factor\nof n when xi “runs into” the previously stored value of y, modulo p, that is, when\nxi \b y .mod p/.\nPresumably, the factor found is the factor p, although it may occasionally hap-\npen that a multiple of p is discovered. Since the expected values of both t and u are\n‚.pp/, the expected number of steps required to produce the factor p is ‚.pp/.\nThis algorithm might not perform quite as expected, for two reasons. First, the\nheuristic analysis of the running time is not rigorous, and it is possible that the cycle\nof values, modulo p, could be much larger than pp. In this case, the algorithm\nperforms correctly but much more slowly than desired. In practice, this issue seems\nto be moot. Second, the divisors of n produced by this algorithm might always be\none of the trivial factors 1 or n. For example, suppose that n D pq, where p\nand q are prime. It can happen that the values of t and u for p are identical with\nthe values of t and u for q, and thus the factor p is always revealed in the same\ngcd operation that reveals the factor q. Since both factors are revealed at the same\n980\nChapter 31\nNumber-Theoretic Algorithms\ntime, the trivial factor pq D n is revealed, which is useless. Again, this problem\nseems to be insigniﬁcant in practice. If necessary, we can restart the heuristic with\na different recurrence of the form xiC1 D .x2\ni \u0005 c/ mod n. (We should avoid the\nvalues c D 0 and c D 2 for reasons we will not go into here, but other values are\nﬁne.)\nOf course, this analysis is heuristic and not rigorous, since the recurrence is\nnot really “random.” Nonetheless, the procedure performs well in practice, and\nit seems to be as efﬁcient as this heuristic analysis indicates. It is the method of\nchoice for ﬁnding small prime factors of a large number. To factor a ˇ-bit compos-\nite number n completely, we only need to ﬁnd all prime factors less than bn1=2c,",
    "parent_a3fd501a-dff4-4770-91ea-5bfc73785871": "it seems to be as efﬁcient as this heuristic analysis indicates. It is the method of\nchoice for ﬁnding small prime factors of a large number. To factor a ˇ-bit compos-\nite number n completely, we only need to ﬁnd all prime factors less than bn1=2c,\nand so we expect POLLARD-RHO to require at most n1=4 D 2ˇ=4 arithmetic opera-\ntions and at most n1=4ˇ2 D 2ˇ=4ˇ2 bit operations. POLLARD-RHO’s ability to ﬁnd\na small factor p of n with an expected number ‚.pp/ of arithmetic operations is\noften its most appealing feature.\nExercises\n31.9-1\nReferring to the execution history shown in Figure 31.7(a), when does POLLARD-\nRHO print the factor 73 of 1387?\n31.9-2\nSuppose that we are given a function f W Zn ! Zn and an initial value x0 2 Zn.\nDeﬁne xi D f .xi\u00031/ for i D 1; 2; : : :. Let t and u > 0 be the smallest values such\nthat xtCi D xtCuCi for i D 0; 1; : : :. In the terminology of Pollard’s rho algorithm,\nt is the length of the tail and u is the length of the cycle of the rho. Give an efﬁcient\nalgorithm to determine t and u exactly, and analyze its running time.\n31.9-3\nHow many steps would you expect POLLARD-RHO to require to discover a factor\nof the form pe, where p is prime and e > 1?\n31.9-4\n?\nOne disadvantage of POLLARD-RHO as written is that it requires one gcd compu-\ntation for each step of the recurrence. Instead, we could batch the gcd computa-\ntions by accumulating the product of several xi values in a row and then using this\nproduct instead of xi in the gcd computation. Describe carefully how you would\nimplement this idea, why it works, and what batch size you would pick as the most\neffective when working on a ˇ-bit number n.\nProblems for Chapter 31\n981\nProblems\n31-1\nBinary gcd algorithm\nMost computers can perform the operations of subtraction, testing the parity (odd\nor even) of a binary integer, and halving more quickly than computing remainders.\nThis problem investigates the binary gcd algorithm, which avoids the remainder\ncomputations used in Euclid’s algorithm.",
    "parent_79c8169e-edf4-468e-9658-0e5f25d804b9": "Most computers can perform the operations of subtraction, testing the parity (odd\nor even) of a binary integer, and halving more quickly than computing remainders.\nThis problem investigates the binary gcd algorithm, which avoids the remainder\ncomputations used in Euclid’s algorithm.\na. Prove that if a and b are both even, then gcd.a; b/ D 2 \u0003 gcd.a=2; b=2/.\nb. Prove that if a is odd and b is even, then gcd.a; b/ D gcd.a; b=2/.\nc. Prove that if a and b are both odd, then gcd.a; b/ D gcd..a \u0005 b/=2; b/.\nd. Design an efﬁcient binary gcd algorithm for input integers a and b, where\na \u0006 b, that runs in O.lg a/ time. Assume that each subtraction, parity test,\nand halving takes unit time.\n31-2\nAnalysis of bit operations in Euclid’s algorithm\na. Consider the ordinary “paper and pencil” algorithm for long division: dividing\na by b, which yields a quotient q and remainder r. Show that this method\nrequires O..1 C lg q/ lg b/ bit operations.\nb. Deﬁne \r.a; b/ D .1 C lg a/.1 C lg b/. Show that the number of bit operations\nperformed by EUCLID in reducing the problem of computing gcd.a; b/ to that\nof computing gcd.b; a mod b/ is at most c.\r.a; b/ \u0005 \r.b; a mod b// for some\nsufﬁciently large constant c > 0.\nc. Show that EUCLID.a; b/ requires O.\r.a; b// bit operations in general and\nO.ˇ2/ bit operations when applied to two ˇ-bit inputs.\n31-3\nThree algorithms for Fibonacci numbers\nThis problem compares the efﬁciency of three methods for computing the nth Fi-\nbonacci number Fn, given n. Assume that the cost of adding, subtracting, or mul-\ntiplying two numbers is O.1/, independent of the size of the numbers.\na. Show that the running time of the straightforward recursive method for com-\nputing Fn based on recurrence (3.22) is exponential in n. (See, for example, the\nFIB procedure on page 775.)\nb. Show how to compute Fn in O.n/ time using memoization.\n982\nChapter 31\nNumber-Theoretic Algorithms\nc. Show how to compute Fn in O.lg n/ time using only integer addition and mul-",
    "parent_9b452d2f-a8e7-49dc-a347-054a4fcb51d2": "puting Fn based on recurrence (3.22) is exponential in n. (See, for example, the\nFIB procedure on page 775.)\nb. Show how to compute Fn in O.n/ time using memoization.\n982\nChapter 31\nNumber-Theoretic Algorithms\nc. Show how to compute Fn in O.lg n/ time using only integer addition and mul-\ntiplication. (Hint: Consider the matrix\n\u0002 0\n1\n1\n1\n\u0003\nand its powers.)\nd. Assume now that adding two ˇ-bit numbers takes ‚.ˇ/ time and that multi-\nplying two ˇ-bit numbers takes ‚.ˇ2/ time. What is the running time of these\nthree methods under this more reasonable cost measure for the elementary arith-\nmetic operations?\n31-4\nQuadratic residues\nLet p be an odd prime. A number a 2 Z\u0004\np is a quadratic residue if the equation\nx2 D a .mod p/ has a solution for the unknown x.\na. Show that there are exactly .p \u0005 1/=2 quadratic residues, modulo p.\nb. If p is prime, we deﬁne the Legendre symbol . a\np/, for a 2 Z\u0004\np, to be 1 if a is a\nquadratic residue modulo p and \u00051 otherwise. Prove that if a 2 Z\u0004\np, then\n\u0004 a\np\n\u0005\n\b a.p\u00031/=2 .mod p/ :\nGive an efﬁcient algorithm that determines whether a given number a is a qua-\ndratic residue modulo p. Analyze the efﬁciency of your algorithm.\nc. Prove that if p is a prime of the form 4k C 3 and a is a quadratic residue in Z\u0004\np,\nthen akC1 mod p is a square root of a, modulo p. How much time is required\nto ﬁnd the square root of a quadratic residue a modulo p?\nd. Describe an efﬁcient randomized algorithm for ﬁnding a nonquadratic residue,\nmodulo an arbitrary prime p, that is, a member of Z\u0004\np that is not a quadratic\nresidue. How many arithmetic operations does your algorithm require on aver-\nage?\nChapter notes\nNiven and Zuckerman [265] provide an excellent introduction to elementary num-\nber theory. Knuth [210] contains a good discussion of algorithms for ﬁnding the\nNotes for Chapter 31\n983\ngreatest common divisor, as well as other basic number-theoretic algorithms. Bach\n[30] and Riesel [295] provide more recent surveys of computational number the-",
    "parent_934b91e3-e5e5-49fc-9466-cda250f4e0c7": "ber theory. Knuth [210] contains a good discussion of algorithms for ﬁnding the\nNotes for Chapter 31\n983\ngreatest common divisor, as well as other basic number-theoretic algorithms. Bach\n[30] and Riesel [295] provide more recent surveys of computational number the-\nory. Dixon [91] gives an overview of factorization and primality testing. The\nconference proceedings edited by Pomerance [280] contains several excellent sur-\nvey articles. More recently, Bach and Shallit [31] have provided an exceptional\noverview of the basics of computational number theory.\nKnuth [210] discusses the origin of Euclid’s algorithm. It appears in Book 7,\nPropositions 1 and 2, of the Greek mathematician Euclid’s Elements, which was\nwritten around 300 B.C. Euclid’s description may have been derived from an al-\ngorithm due to Eudoxus around 375 B.C. Euclid’s algorithm may hold the honor\nof being the oldest nontrivial algorithm; it is rivaled only by an algorithm for mul-\ntiplication known to the ancient Egyptians. Shallit [312] chronicles the history of\nthe analysis of Euclid’s algorithm.\nKnuth attributes a special case of the Chinese remainder theorem (Theo-\nrem 31.27) to the Chinese mathematician Sun-Ts˘u, who lived sometime between\n200 B.C. and A.D. 200—the date is quite uncertain. The same special case was\ngiven by the Greek mathematician Nichomachus around A.D. 100. It was gener-\nalized by Chhin Chiu-Shao in 1247. The Chinese remainder theorem was ﬁnally\nstated and proved in its full generality by L. Euler in 1734.\nThe randomized primality-testing algorithm presented here is due to Miller [255]\nand Rabin [289]; it is the fastest randomized primality-testing algorithm known,\nto within constant factors. The proof of Theorem 31.39 is a slight adaptation of\none suggested by Bach [29]. A proof of a stronger result for MILLER-RABIN\nwas given by Monier [258, 259]. For many years primality-testing was the classic\nexample of a problem where randomization appeared to be necessary to obtain",
    "parent_95b8b056-3deb-4157-8332-56310b58e68f": "one suggested by Bach [29]. A proof of a stronger result for MILLER-RABIN\nwas given by Monier [258, 259]. For many years primality-testing was the classic\nexample of a problem where randomization appeared to be necessary to obtain\nan efﬁcient (polynomial-time) algorithm. In 2002, however, Agrawal, Kayal, and\nSaxema [4] surprised everyone with their deterministic polynomial-time primality-\ntesting algorithm. Until then, the fastest deterministic primality testing algorithm\nknown, due to Cohen and Lenstra [73], ran in time .lg n/O.lg lg lg n/ on input n, which\nis just slightly superpolynomial. Nonetheless, for practical purposes randomized\nprimality-testing algorithms remain more efﬁcient and are preferred.\nThe problem of ﬁnding large “random” primes is nicely discussed in an article\nby Beauchemin, Brassard, Cr´epeau, Goutier, and Pomerance [36].\nThe concept of a public-key cryptosystem is due to Difﬁe and Hellman [87].\nThe RSA cryptosystem was proposed in 1977 by Rivest, Shamir, and Adleman\n[296]. Since then, the ﬁeld of cryptography has blossomed. Our understanding\nof the RSA cryptosystem has deepened, and modern implementations use signif-\nicant reﬁnements of the basic techniques presented here. In addition, many new\ntechniques have been developed for proving cryptosystems to be secure. For ex-\nample, Goldwasser and Micali [142] show that randomization can be an effective\ntool in the design of secure public-key encryption schemes. For signature schemes,\n984\nChapter 31\nNumber-Theoretic Algorithms\nGoldwasser, Micali, and Rivest [143] present a digital-signature scheme for which\nevery conceivable type of forgery is provably as difﬁcult as factoring. Menezes,\nvan Oorschot, and Vanstone [254] provide an overview of applied cryptography.\nThe rho heuristic for integer factorization was invented by Pollard [277]. The\nversion presented here is a variant proposed by Brent [56].\nThe best algorithms for factoring large numbers have a running time that grows",
    "parent_2bb54da2-618f-4e73-b7f2-b1fe8e7a532c": "van Oorschot, and Vanstone [254] provide an overview of applied cryptography.\nThe rho heuristic for integer factorization was invented by Pollard [277]. The\nversion presented here is a variant proposed by Brent [56].\nThe best algorithms for factoring large numbers have a running time that grows\nroughly exponentially with the cube root of the length of the number n to be fac-\ntored. The general number-ﬁeld sieve factoring algorithm (as developed by Buh-\nler, Lenstra, and Pomerance [57] as an extension of the ideas in the number-ﬁeld\nsieve factoring algorithm by Pollard [278] and Lenstra et al. [232] and reﬁned by\nCoppersmith [77] and others) is perhaps the most efﬁcient such algorithm in gen-\neral for large inputs. Although it is difﬁcult to give a rigorous analysis of this\nalgorithm, under reasonable assumptions we can derive a running-time estimate of\nL.1=3; n/1:902Co.1/, where L.˛; n/ D e.ln n/˛.ln ln n/1\u0004˛.\nThe elliptic-curve method due to Lenstra [233] may be more effective for some\ninputs than the number-ﬁeld sieve method, since, like Pollard’s rho method, it can\nﬁnd a small prime factor p quite quickly. With this method, the time to ﬁnd p is\nestimated to be L.1=2; p/\np\n2Co.1/.\n32\nString Matching\nText-editing programs frequently need to ﬁnd all occurrences of a pattern in the\ntext. Typically, the text is a document being edited, and the pattern searched for is a\nparticular word supplied by the user. Efﬁcient algorithms for this problem—called\n“string matching”—can greatly aid the responsiveness of the text-editing program.\nAmong their many other applications, string-matching algorithms search for par-\nticular patterns in DNA sequences. Internet search engines also use them to ﬁnd\nWeb pages relevant to queries.\nWe formalize the string-matching problem as follows.\nWe assume that the\ntext is an array T Œ1 : : n\u0002 of length n and that the pattern is an array P Œ1 : : m\u0002\nof length m \u0002 n. We further assume that the elements of P and T are char-",
    "parent_0b407711-655a-4529-87c4-f637810b3f2c": "Web pages relevant to queries.\nWe formalize the string-matching problem as follows.\nWe assume that the\ntext is an array T Œ1 : : n\u0002 of length n and that the pattern is an array P Œ1 : : m\u0002\nof length m \u0002 n. We further assume that the elements of P and T are char-\nacters drawn from a ﬁnite alphabet †. For example, we may have † D f0,1g\nor † D fa; b; : : : ; zg. The character arrays P and T are often called strings of\ncharacters.\nReferring to Figure 32.1, we say that pattern P occurs with shift s in text T\n(or, equivalently, that pattern P occurs beginning at position s C 1 in text T ) if\n0 \u0002 s \u0002 n \u0005 m and T Œs C 1 : : s C m\u0002 D P Œ1 : : m\u0002 (that is, if T Œs C j \u0002 D P Œj \u0002, for\n1 \u0002 j \u0002 m). If P occurs with shift s in T , then we call s a valid shift; otherwise,\nwe call s an invalid shift. The string-matching problem is the problem of ﬁnding\nall valid shifts with which a given pattern P occurs in a given text T .\na\nb\nc\na\nb\na\na\nb\nc\na\nb\na\nc\na\nb\na\na\npattern P\ntext T\ns = 3\nFigure 32.1\nAn example of the string-matching problem, where we want to ﬁnd all occurrences of\nthe pattern P D abaa in the text T D abcabaabcabac. The pattern occurs only once in the text,\nat shift s D 3, which we call a valid shift. A vertical line connects each character of the pattern to its\nmatching character in the text, and all matched characters are shaded.\n986\nChapter 32\nString Matching\nAlgorithm\nPreprocessing time\nMatching time\nNaive\n0\nO..n \u0005 m C 1/m/\nRabin-Karp\n‚.m/\nO..n \u0005 m C 1/m/\nFinite automaton\nO.m j†j/\n‚.n/\nKnuth-Morris-Pratt\n‚.m/\n‚.n/\nFigure 32.2\nThe string-matching algorithms in this chapter and their preprocessing and matching\ntimes.\nExcept for the naive brute-force algorithm, which we review in Section 32.1,\neach string-matching algorithm in this chapter performs some preprocessing based\non the pattern and then ﬁnds all valid shifts; we call this latter phase “matching.”\nFigure 32.2 shows the preprocessing and matching times for each of the algorithms",
    "parent_51c9a239-ae4e-4af7-92d7-26ca9f0700e4": "each string-matching algorithm in this chapter performs some preprocessing based\non the pattern and then ﬁnds all valid shifts; we call this latter phase “matching.”\nFigure 32.2 shows the preprocessing and matching times for each of the algorithms\nin this chapter. The total running time of each algorithm is the sum of the prepro-\ncessing and matching times. Section 32.2 presents an interesting string-matching\nalgorithm, due to Rabin and Karp. Although the ‚..n \u0005 m C 1/m/ worst-case\nrunning time of this algorithm is no better than that of the naive method, it works\nmuch better on average and in practice. It also generalizes nicely to other pattern-\nmatching problems. Section 32.3 then describes a string-matching algorithm that\nbegins by constructing a ﬁnite automaton speciﬁcally designed to search for occur-\nrences of the given pattern P in a text. This algorithm takes O.m j†j/ preprocess-\ning time, but only ‚.n/ matching time. Section 32.4 presents the similar, but much\ncleverer, Knuth-Morris-Pratt (or KMP) algorithm; it has the same ‚.n/ matching\ntime, and it reduces the preprocessing time to only ‚.m/.\nNotation and terminology\nWe denote by †\u0004 (read “sigma-star”) the set of all ﬁnite-length strings formed\nusing characters from the alphabet †. In this chapter, we consider only ﬁnite-\nlength strings. The zero-length empty string, denoted \", also belongs to †\u0004. The\nlength of a string x is denoted jxj. The concatenation of two strings x and y,\ndenoted xy, has length jxj C jyj and consists of the characters from x followed by\nthe characters from y.\nWe say that a string w is a preﬁx of a string x, denoted w < x, if x D wy for\nsome string y 2 †\u0004. Note that if w < x, then jwj \u0002 jxj. Similarly, we say that a\nstring w is a sufﬁx of a string x, denoted w = x, if x D yw for some y 2 †\u0004. As\nwith a preﬁx, w = x implies jwj \u0002 jxj. For example, we have ab < abcca and\ncca = abcca. The empty string \" is both a sufﬁx and a preﬁx of every string. For",
    "parent_fd68cec4-f0f0-48f8-8c80-0c39ba9d0f64": "string w is a sufﬁx of a string x, denoted w = x, if x D yw for some y 2 †\u0004. As\nwith a preﬁx, w = x implies jwj \u0002 jxj. For example, we have ab < abcca and\ncca = abcca. The empty string \" is both a sufﬁx and a preﬁx of every string. For\nany strings x and y and any character a, we have x = y if and only if xa = ya.\nChapter 32\nString Matching\n987\nx\nz\nx\ny\ny\n(a)\nx\nz\nx\ny\ny\n(b)\nx\nz\nx\ny\ny\n(c)\nFigure 32.3\nA graphical proof of Lemma 32.1. We suppose that x = ´ and y = ´. The three parts\nof the ﬁgure illustrate the three cases of the lemma. Vertical lines connect matching regions (shown\nshaded) of the strings. (a) If jxj \u0002 jyj, then x = y. (b) If jxj \u0006 jyj, then y = x. (c) If jxj D jyj,\nthen x D y.\nAlso note that < and = are transitive relations. The following lemma will be useful\nlater.\nLemma 32.1 (Overlapping-sufﬁx lemma)\nSuppose that x, y, and ´ are strings such that x = ´ and y = ´. If jxj \u0002 jyj,\nthen x = y. If jxj \u0006 jyj, then y = x. If jxj D jyj, then x D y.\nProof\nSee Figure 32.3 for a graphical proof.\nFor brevity of notation, we denote the k-character preﬁx P Œ1 : : k\u0002 of the pattern\nP Œ1 : : m\u0002 by Pk. Thus, P0 D \" and Pm D P D P Œ1 : : m\u0002. Similarly, we denote\nthe k-character preﬁx of the text T by Tk. Using this notation, we can state the\nstring-matching problem as that of ﬁnding all shifts s in the range 0 \u0002 s \u0002 n \u0005 m\nsuch that P = TsCm.\nIn our pseudocode, we allow two equal-length strings to be compared for equal-\nity as a primitive operation. If the strings are compared from left to right and the\ncomparison stops when a mismatch is discovered, we assume that the time taken\nby such a test is a linear function of the number of matching characters discovered.\nTo be precise, the test “x == y” is assumed to take time ‚.t C 1/, where t is the\nlength of the longest string ´ such that ´ < x and ´ < y. (We write ‚.t C 1/\nrather than ‚.t/ to handle the case in which t D 0; the ﬁrst characters compared",
    "parent_26fbae51-d077-4d04-a6de-f598fd9f9457": "To be precise, the test “x == y” is assumed to take time ‚.t C 1/, where t is the\nlength of the longest string ´ such that ´ < x and ´ < y. (We write ‚.t C 1/\nrather than ‚.t/ to handle the case in which t D 0; the ﬁrst characters compared\ndo not match, but it takes a positive amount of time to perform this comparison.)\n988\nChapter 32\nString Matching\n32.1\nThe naive string-matching algorithm\nThe naive algorithm ﬁnds all valid shifts using a loop that checks the condition\nP Œ1 : : m\u0002 D T Œs C 1 : : s C m\u0002 for each of the n \u0005 m C 1 possible values of s.\nNAIVE-STRING-MATCHER.T; P /\n1\nn D T:length\n2\nm D P:length\n3\nfor s D 0 to n \u0005 m\n4\nif P Œ1 : : m\u0002 == T Œs C 1 : : s C m\u0002\n5\nprint “Pattern occurs with shift” s\nFigure 32.4 portrays the naive string-matching procedure as sliding a “template”\ncontaining the pattern over the text, noting for which shifts all of the characters\non the template equal the corresponding characters in the text. The for loop of\nlines 3–5 considers each possible shift explicitly. The test in line 4 determines\nwhether the current shift is valid; this test implicitly loops to check corresponding\ncharacter positions until all positions match successfully or a mismatch is found.\nLine 5 prints out each valid shift s.\nProcedure NAIVE-STRING-MATCHER takes time O..n \u0005 m C 1/m/, and this\nbound is tight in the worst case. For example, consider the text string an (a string\nof n a’s) and the pattern am. For each of the n\u0005mC1 possible values of the shift s,\nthe implicit loop on line 4 to compare corresponding characters must execute m\ntimes to validate the shift. The worst-case running time is thus ‚..n \u0005 m C 1/m/,\nwhich is ‚.n2/ if m D bn=2c. Because it requires no preprocessing, NAIVE-\nSTRING-MATCHER’s running time equals its matching time.\na\nc\na\na\nb\nc\na\na\nb\ns = 0\n(a)\na\nc\na\na\nb\nc\na\na\nb\ns = 1\n(b)\na\nc\na\na\nb\nc\na\na\nb\ns = 2\n(c)\na\nc\na\na\nb\nc\na\na\nb\ns = 3\n(d)\nFigure 32.4\nThe operation of the naive string matcher for the pattern P D aab and the text",
    "parent_f0a2917c-e9f6-4a73-82a8-6bfe4dd47b52": "STRING-MATCHER’s running time equals its matching time.\na\nc\na\na\nb\nc\na\na\nb\ns = 0\n(a)\na\nc\na\na\nb\nc\na\na\nb\ns = 1\n(b)\na\nc\na\na\nb\nc\na\na\nb\ns = 2\n(c)\na\nc\na\na\nb\nc\na\na\nb\ns = 3\n(d)\nFigure 32.4\nThe operation of the naive string matcher for the pattern P D aab and the text\nT D acaabc. We can imagine the pattern P as a template that we slide next to the text. (a)–(d) The\nfour successive alignments tried by the naive string matcher. In each part, vertical lines connect cor-\nresponding regions found to match (shown shaded), and a jagged line connects the ﬁrst mismatched\ncharacter found, if any. The algorithm ﬁnds one occurrence of the pattern, at shift s D 2, shown in\npart (c).\n32.1\nThe naive string-matching algorithm\n989\nAs we shall see, NAIVE-STRING-MATCHER is not an optimal procedure for this\nproblem. Indeed, in this chapter we shall see that the Knuth-Morris-Pratt algorithm\nis much better in the worst case. The naive string-matcher is inefﬁcient because\nit entirely ignores information gained about the text for one value of s when it\nconsiders other values of s. Such information can be quite valuable, however. For\nexample, if P D aaab and we ﬁnd that s D 0 is valid, then none of the shifts 1, 2,\nor 3 are valid, since T Œ4\u0002 D b. In the following sections, we examine several ways\nto make effective use of this sort of information.\nExercises\n32.1-1\nShow the comparisons the naive string matcher makes for the pattern P D 0001\nin the text T D 000010001010001.\n32.1-2\nSuppose that all characters in the pattern P are different. Show how to accelerate\nNAIVE-STRING-MATCHER to run in time O.n/ on an n-character text T .\n32.1-3\nSuppose that pattern P and text T are randomly chosen strings of length m and n,\nrespectively, from the d-ary alphabet †d D f0; 1; : : : ; d \u0005 1g, where d \u0006 2. Show\nthat the expected number of character-to-character comparisons made by the im-\nplicit loop in line 4 of the naive algorithm is\n.n \u0005 m C 1/1 \u0005 d \u0003m\n1 \u0005 d \u00031 \u0002 2.n \u0005 m C 1/",
    "parent_83706ebc-899f-4a76-b834-e3f8fced95ef": "respectively, from the d-ary alphabet †d D f0; 1; : : : ; d \u0005 1g, where d \u0006 2. Show\nthat the expected number of character-to-character comparisons made by the im-\nplicit loop in line 4 of the naive algorithm is\n.n \u0005 m C 1/1 \u0005 d \u0003m\n1 \u0005 d \u00031 \u0002 2.n \u0005 m C 1/\nover all executions of this loop. (Assume that the naive algorithm stops comparing\ncharacters for a given shift once it ﬁnds a mismatch or matches the entire pattern.)\nThus, for randomly chosen strings, the naive algorithm is quite efﬁcient.\n32.1-4\nSuppose we allow the pattern P to contain occurrences of a gap character } that\ncan match an arbitrary string of characters (even one of zero length). For example,\nthe pattern ab}ba}c occurs in the text cabccbacbacab as\nc ab’\nab\ncc’\n}\nba’\nba\ncba\n“\n}\nc’\nc\nab\nand as\nc ab’\nab\nccbac\n—\n}\nba’\nba ’\n}\nc’\nc\nab :\n990\nChapter 32\nString Matching\nNote that the gap character may occur an arbitrary number of times in the pattern\nbut not at all in the text. Give a polynomial-time algorithm to determine whether\nsuch a pattern P occurs in a given text T , and analyze the running time of your\nalgorithm.\n32.2\nThe Rabin-Karp algorithm\nRabin and Karp proposed a string-matching algorithm that performs well in prac-\ntice and that also generalizes to other algorithms for related problems, such as\ntwo-dimensional pattern matching. The Rabin-Karp algorithm uses ‚.m/ prepro-\ncessing time, and its worst-case running time is ‚..n\u0005mC1/m/. Based on certain\nassumptions, however, its average-case running time is better.\nThis algorithm makes use of elementary number-theoretic notions such as the\nequivalence of two numbers modulo a third number. You might want to refer to\nSection 31.1 for the relevant deﬁnitions.\nFor expository purposes, let us assume that † D f0; 1; 2; : : : ; 9g, so that each\ncharacter is a decimal digit. (In the general case, we can assume that each charac-\nter is a digit in radix-d notation, where d D j†j.) We can then view a string of k",
    "parent_dd32b778-f2fb-4b36-99ed-0195aa94fc8b": "Section 31.1 for the relevant deﬁnitions.\nFor expository purposes, let us assume that † D f0; 1; 2; : : : ; 9g, so that each\ncharacter is a decimal digit. (In the general case, we can assume that each charac-\nter is a digit in radix-d notation, where d D j†j.) We can then view a string of k\nconsecutive characters as representing a length-k decimal number. The character\nstring 31415 thus corresponds to the decimal number 31,415. Because we inter-\npret the input characters as both graphical symbols and digits, we ﬁnd it convenient\nin this section to denote them as we would digits, in our standard text font.\nGiven a pattern P Œ1 : : m\u0002, let p denote its corresponding decimal value. In a sim-\nilar manner, given a text T Œ1 : : n\u0002, let ts denote the decimal value of the length-m\nsubstring T Œs C 1 : : s C m\u0002, for s D 0; 1; : : : ; n \u0005 m. Certainly, ts D p if and only\nif T Œs C 1 : : s C m\u0002 D P Œ1 : : m\u0002; thus, s is a valid shift if and only if ts D p. If we\ncould compute p in time ‚.m/ and all the ts values in a total of ‚.n\u0005mC1/ time,1\nthen we could determine all valid shifts s in time ‚.m/ C ‚.n \u0005 m C 1/ D ‚.n/\nby comparing p with each of the ts values. (For the moment, let’s not worry about\nthe possibility that p and the ts values might be very large numbers.)\nWe can compute p in time ‚.m/ using Horner’s rule (see Section 30.1):\np D P Œm\u0002 C 10 .P Œm \u0005 1\u0002 C 10.P Œm \u0005 2\u0002 C \u0003 \u0003 \u0003 C 10.P Œ2\u0002 C 10P Œ1\u0002/ \u0003 \u0003 \u0003// :\nSimilarly, we can compute t0 from T Œ1 : : m\u0002 in time ‚.m/.\n1We write ‚.n \u0005 m C 1/ instead of ‚.n \u0005 m/ because s takes on n \u0005 m C 1 different values. The\n“C1” is signiﬁcant in an asymptotic sense because when m D n, computing the lone ts value takes\n‚.1/ time, not ‚.0/ time.\n32.2\nThe Rabin-Karp algorithm\n991\nTo compute the remaining values t1; t2; : : : ; tn\u0003m in time ‚.n \u0005 m/, we observe\nthat we can compute tsC1 from ts in constant time, since\ntsC1 D 10.ts \u0005 10m\u00031T Œs C 1\u0002/ C T Œs C m C 1\u0002 :\n(32.1)",
    "parent_e2694e80-c46e-4a47-89a9-20d7ec60cf76": "‚.1/ time, not ‚.0/ time.\n32.2\nThe Rabin-Karp algorithm\n991\nTo compute the remaining values t1; t2; : : : ; tn\u0003m in time ‚.n \u0005 m/, we observe\nthat we can compute tsC1 from ts in constant time, since\ntsC1 D 10.ts \u0005 10m\u00031T Œs C 1\u0002/ C T Œs C m C 1\u0002 :\n(32.1)\nSubtracting 10m\u00031T Œs C 1\u0002 removes the high-order digit from ts, multiplying the\nresult by 10 shifts the number left by one digit position, and adding T Œs C m C 1\u0002\nbrings in the appropriate low-order digit. For example, if m D 5 and ts D 31415,\nthen we wish to remove the high-order digit T Œs C 1\u0002 D 3 and bring in the new\nlow-order digit (suppose it is T Œs C 5 C 1\u0002 D 2) to obtain\ntsC1\nD\n10.31415 \u0005 10000 \u0003 3/ C 2\nD\n14152 :\nIf we precompute the constant 10m\u00031 (which we can do in time O.lg m/ using the\ntechniques of Section 31.6, although for this application a straightforward O.m/-\ntime method sufﬁces), then each execution of equation (32.1) takes a constant num-\nber of arithmetic operations. Thus, we can compute p in time ‚.m/, and we can\ncompute all of t0; t1; : : : ; tn\u0003m in time ‚.n \u0005 m C 1/. Therefore, we can ﬁnd all\noccurrences of the pattern P Œ1 : : m\u0002 in the text T Œ1 : : n\u0002 with ‚.m/ preprocessing\ntime and ‚.n \u0005 m C 1/ matching time.\nUntil now, we have intentionally overlooked one problem: p and ts may be\ntoo large to work with conveniently. If P contains m characters, then we cannot\nreasonably assume that each arithmetic operation on p (which is m digits long)\ntakes “constant time.” Fortunately, we can solve this problem easily, as Figure 32.5\nshows: compute p and the ts values modulo a suitable modulus q. We can compute\np modulo q in ‚.m/ time and all the ts values modulo q in ‚.n \u0005 m C 1/ time.\nIf we choose the modulus q as a prime such that 10q just ﬁts within one computer\nword, then we can perform all the necessary computations with single-precision\narithmetic. In general, with a d-ary alphabet f0; 1; : : : ; d \u0005 1g, we choose q so",
    "parent_f4b9c5b3-c49e-400e-b62b-c67970e74870": "If we choose the modulus q as a prime such that 10q just ﬁts within one computer\nword, then we can perform all the necessary computations with single-precision\narithmetic. In general, with a d-ary alphabet f0; 1; : : : ; d \u0005 1g, we choose q so\nthat dq ﬁts within a computer word and adjust the recurrence equation (32.1) to\nwork modulo q, so that it becomes\ntsC1 D .d.ts \u0005 T Œs C 1\u0002h/ C T Œs C m C 1\u0002/ mod q ;\n(32.2)\nwhere h \b d m\u00031 .mod q/ is the value of the digit “1” in the high-order position\nof an m-digit text window.\nThe solution of working modulo q is not perfect, however: ts \b p .mod q/\ndoes not imply that ts D p. On the other hand, if ts 6\b p .mod q/, then we\ndeﬁnitely have that ts ¤ p, so that shift s is invalid. We can thus use the test\nts \b p .mod q/ as a fast heuristic test to rule out invalid shifts s. Any shift s for\nwhich ts \b p .mod q/ must be tested further to see whether s is really valid or\nwe just have a spurious hit. This additional test explicitly checks the condition\n992\nChapter 32\nString Matching\n2\n3\n5\n9\n0\n2\n3\n1\n4\n1\n5\n2\n6\n7\n3\n9\n9\n2\n1\n7\n(a)\nmod 13\n2\n3\n5\n9\n0\n2\n3\n1\n4\n1\n5\n2\n6\n7\n3\n9\n9\n2\n1\n7\n(b)\nmod 13\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n8\n9\n3 11 0\n1\n8\n5\n11\n9 11\n7\n10\n4\nvalid\nmatch\nspurious\nhit\n…\n…\n…\n3\n1\n4\n1\n5\n2\n7\n8\nold\nhigh-order\ndigit\nnew\nlow-order\ndigit\n≡(31415 – 3·10000)·10 + 2  (mod 13) \nold\nhigh-order\ndigit\nnew\nlow-order\ndigit\nshift\n≡(7 – 3·3)·10 + 2  (mod 13) \n≡8  (mod 13) \n(c)\n14152\nFigure 32.5\nThe Rabin-Karp algorithm. Each character is a decimal digit, and we compute values\nmodulo 13. (a) A text string. A window of length 5 is shown shaded. The numerical value of the\nshaded number, computed modulo 13, yields the value 7. (b) The same text string with values com-\nputed modulo 13 for each possible position of a length-5 window. Assuming the pattern P D 31415,\nwe look for windows whose value modulo 13 is 7, since 31415 \b 7 .mod 13/. The algorithm ﬁnds",
    "parent_4dd945b0-402f-4796-8a27-232ca4f9bc80": "shaded number, computed modulo 13, yields the value 7. (b) The same text string with values com-\nputed modulo 13 for each possible position of a length-5 window. Assuming the pattern P D 31415,\nwe look for windows whose value modulo 13 is 7, since 31415 \b 7 .mod 13/. The algorithm ﬁnds\ntwo such windows, shown shaded in the ﬁgure. The ﬁrst, beginning at text position 7, is indeed an\noccurrence of the pattern, while the second, beginning at text position 13, is a spurious hit. (c) How\nto compute the value for a window in constant time, given the value for the previous window. The\nﬁrst window has value 31415. Dropping the high-order digit 3, shifting left (multiplying by 10), and\nthen adding in the low-order digit 2 gives us the new value 14152. Because all computations are\nperformed modulo 13, the value for the ﬁrst window is 7, and the value for the new window is 8.\n32.2\nThe Rabin-Karp algorithm\n993\nP Œ1 : : m\u0002 D T Œs C 1 : : s C m\u0002. If q is large enough, then we hope that spurious\nhits occur infrequently enough that the cost of the extra checking is low.\nThe following procedure makes these ideas precise. The inputs to the procedure\nare the text T , the pattern P , the radix d to use (which is typically taken to be j†j),\nand the prime q to use.\nRABIN-KARP-MATCHER.T; P; d; q/\n1\nn D T:length\n2\nm D P:length\n3\nh D d m\u00031 mod q\n4\np D 0\n5\nt0 D 0\n6\nfor i D 1 to m\n// preprocessing\n7\np D .dp C P Œi\u0002/ mod q\n8\nt0 D .dt0 C T Œi\u0002/ mod q\n9\nfor s D 0 to n \u0005 m\n// matching\n10\nif p == ts\n11\nif P Œ1 : : m\u0002 == T Œs C 1 : : s C m\u0002\n12\nprint “Pattern occurs with shift” s\n13\nif s < n \u0005 m\n14\ntsC1 D .d.ts \u0005 T Œs C 1\u0002h/ C T Œs C m C 1\u0002/ mod q\nThe procedure RABIN-KARP-MATCHER works as follows. All characters are\ninterpreted as radix-d digits. The subscripts on t are provided only for clarity; the\nprogram works correctly if all the subscripts are dropped. Line 3 initializes h to the\nvalue of the high-order digit position of an m-digit window. Lines 4–8 compute p",
    "parent_f1d7dba3-6e87-4913-8106-795047ff51d4": "interpreted as radix-d digits. The subscripts on t are provided only for clarity; the\nprogram works correctly if all the subscripts are dropped. Line 3 initializes h to the\nvalue of the high-order digit position of an m-digit window. Lines 4–8 compute p\nas the value of P Œ1 : : m\u0002 mod q and t0 as the value of T Œ1 : : m\u0002 mod q. The for\nloop of lines 9–14 iterates through all possible shifts s, maintaining the following\ninvariant:\nWhenever line 10 is executed, ts D T Œs C 1 : : s C m\u0002 mod q.\nIf p D ts in line 10 (a “hit”), then line 11 checks to see whether P Œ1 : : m\u0002 D\nT Œs C1 : : s Cm\u0002 in order to rule out the possibility of a spurious hit. Line 12 prints\nout any valid shifts that are found. If s < n \u0005 m (checked in line 13), then the for\nloop will execute at least one more time, and so line 14 ﬁrst executes to ensure that\nthe loop invariant holds when we get back to line 10. Line 14 computes the value\nof tsC1 mod q from the value of ts mod q in constant time using equation (32.2)\ndirectly.\nRABIN-KARP-MATCHER takes ‚.m/ preprocessing time, and its matching time\nis ‚..n \u0005 m C 1/m/ in the worst case, since (like the naive string-matching algo-\nrithm) the Rabin-Karp algorithm explicitly veriﬁes every valid shift. If P D am\n994\nChapter 32\nString Matching\nand T D an, then verifying takes time ‚..n\u0005mC1/m/, since each of the n\u0005mC1\npossible shifts is valid.\nIn many applications, we expect few valid shifts—perhaps some constant c of\nthem. In such applications, the expected matching time of the algorithm is only\nO..n \u0005 m C 1/ C cm/ D O.n C m/, plus the time required to process spurious\nhits. We can base a heuristic analysis on the assumption that reducing values mod-\nulo q acts like a random mapping from †\u0004 to Zq. (See the discussion on the use of\ndivision for hashing in Section 11.3.1. It is difﬁcult to formalize and prove such an\nassumption, although one viable approach is to assume that q is chosen randomly",
    "parent_2aba9d25-e9ad-4d82-b3b2-0b358fdebbe5": "ulo q acts like a random mapping from †\u0004 to Zq. (See the discussion on the use of\ndivision for hashing in Section 11.3.1. It is difﬁcult to formalize and prove such an\nassumption, although one viable approach is to assume that q is chosen randomly\nfrom integers of the appropriate size. We shall not pursue this formalization here.)\nWe can then expect that the number of spurious hits is O.n=q/, since we can es-\ntimate the chance that an arbitrary ts will be equivalent to p, modulo q, as 1=q.\nSince there are O.n/ positions at which the test of line 10 fails and we spend O.m/\ntime for each hit, the expected matching time taken by the Rabin-Karp algorithm\nis\nO.n/ C O.m.\u0003 C n=q// ;\nwhere \u0003 is the number of valid shifts. This running time is O.n/ if \u0003 D O.1/ and\nwe choose q \u0006 m. That is, if the expected number of valid shifts is small (O.1/)\nand we choose the prime q to be larger than the length of the pattern, then we\ncan expect the Rabin-Karp procedure to use only O.n C m/ matching time. Since\nm \u0002 n, this expected matching time is O.n/.\nExercises\n32.2-1\nWorking modulo q D 11, how many spurious hits does the Rabin-Karp matcher en-\ncounter in the text T D 3141592653589793 when looking for the pattern P D 26?\n32.2-2\nHow would you extend the Rabin-Karp method to the problem of searching a text\nstring for an occurrence of any one of a given set of k patterns? Start by assuming\nthat all k patterns have the same length. Then generalize your solution to allow the\npatterns to have different lengths.\n32.2-3\nShow how to extend the Rabin-Karp method to handle the problem of looking for\na given m \t m pattern in an n \t n array of characters. (The pattern may be shifted\nvertically and horizontally, but it may not be rotated.)\n32.3\nString matching with ﬁnite automata\n995\n32.2-4\nAlice has a copy of a long n-bit ﬁle A D han\u00031; an\u00032; : : : ; a0i, and Bob similarly\nhas an n-bit ﬁle B D hbn\u00031; bn\u00032; : : : ; b0i. Alice and Bob wish to know if their",
    "parent_c563a03f-4729-4ca1-8d9b-0ca7a2b9a651": "vertically and horizontally, but it may not be rotated.)\n32.3\nString matching with ﬁnite automata\n995\n32.2-4\nAlice has a copy of a long n-bit ﬁle A D han\u00031; an\u00032; : : : ; a0i, and Bob similarly\nhas an n-bit ﬁle B D hbn\u00031; bn\u00032; : : : ; b0i. Alice and Bob wish to know if their\nﬁles are identical. To avoid transmitting all of A or B, they use the following fast\nprobabilistic check. Together, they select a prime q > 1000n and randomly select\nan integer x from f0; 1; : : : ; q \u0005 1g. Then, Alice evaluates\nA.x/ D\n n\u00031\nX\niD0\naixi\n!\nmod q\nand Bob similarly evaluates B.x/. Prove that if A ¤ B, there is at most one\nchance in 1000 that A.x/ D B.x/, whereas if the two ﬁles are the same, A.x/ is\nnecessarily the same as B.x/. (Hint: See Exercise 31.4-4.)\n32.3\nString matching with ﬁnite automata\nMany string-matching algorithms build a ﬁnite automaton—a simple machine for\nprocessing information—that scans the text string T for all occurrences of the pat-\ntern P . This section presents a method for building such an automaton. These\nstring-matching automata are very efﬁcient: they examine each text character ex-\nactly once, taking constant time per text character. The matching time used—after\npreprocessing the pattern to build the automaton—is therefore ‚.n/. The time to\nbuild the automaton, however, can be large if † is large. Section 32.4 describes a\nclever way around this problem.\nWe begin this section with the deﬁnition of a ﬁnite automaton. We then examine\na special string-matching automaton and show how to use it to ﬁnd occurrences\nof a pattern in a text. Finally, we shall show how to construct the string-matching\nautomaton for a given input pattern.\nFinite automata\nA ﬁnite automaton M, illustrated in Figure 32.6, is a 5-tuple .Q; q0; A; †; ı/,\nwhere\n\u0002\nQ is a ﬁnite set of states,\n\u0002\nq0 2 Q is the start state,\n\u0002\nA \u0007 Q is a distinguished set of accepting states,\n\u0002\n† is a ﬁnite input alphabet,\n\u0002\nı is a function from Q \t † into Q, called the transition function of M.\n996\nChapter 32",
    "parent_8212d6bc-6670-4ba0-bea8-0ef9ed3ceb15": "where\n\u0002\nQ is a ﬁnite set of states,\n\u0002\nq0 2 Q is the start state,\n\u0002\nA \u0007 Q is a distinguished set of accepting states,\n\u0002\n† is a ﬁnite input alphabet,\n\u0002\nı is a function from Q \t † into Q, called the transition function of M.\n996\nChapter 32\nString Matching\n1\n0\n0\n0\na\nb\ninput\nstate\n0\n1\n(a)\na\na\nb\nb\n(b)\n0\n1\nFigure 32.6\nA simple two-state ﬁnite automaton with state set Q D f0; 1g, start state q0 D 0,\nand input alphabet † D fa; bg. (a) A tabular representation of the transition function ı. (b) An\nequivalent state-transition diagram. State 1, shown blackend, is the only accepting state. Directed\nedges represent transitions. For example, the edge from state 1 to state 0 labeled b indicates that\nı.1; b/ D 0. This automaton accepts those strings that end in an odd number of a’s. More precisely,\nit accepts a string x if and only if x D y´, where y D \" or y ends with a b, and ´ D ak, where k is\nodd. For example, on input abaaa, including the start state, this automaton enters the sequence of\nstates h0; 1; 0; 1; 0; 1i, and so it accepts this input. For input abbaa, it enters the sequence of states\nh0; 1; 0; 0; 1; 0i, and so it rejects this input.\nThe ﬁnite automaton begins in state q0 and reads the characters of its input string\none at a time. If the automaton is in state q and reads input character a, it moves\n(“makes a transition”) from state q to state ı.q; a/. Whenever its current state q is\na member of A, the machine M has accepted the string read so far. An input that\nis not accepted is rejected.\nA ﬁnite automaton M induces a function \u0007, called the ﬁnal-state function,\nfrom †\u0004 to Q such that \u0007.w/ is the state M ends up in after scanning the string w.\nThus, M accepts a string w if and only if \u0007.w/ 2 A. We deﬁne the function \u0007\nrecursively, using the transition function:\n\u0007.\"/\nD\nq0 ;\n\u0007.wa/\nD\nı.\u0007.w/; a/\nfor w 2 †\u0004; a 2 † .\nString-matching automata\nFor a given pattern P , we construct a string-matching automaton in a preprocess-",
    "parent_36570568-1fef-478c-9863-8176170448ef": "Thus, M accepts a string w if and only if \u0007.w/ 2 A. We deﬁne the function \u0007\nrecursively, using the transition function:\n\u0007.\"/\nD\nq0 ;\n\u0007.wa/\nD\nı.\u0007.w/; a/\nfor w 2 †\u0004; a 2 † .\nString-matching automata\nFor a given pattern P , we construct a string-matching automaton in a preprocess-\ning step before using it to search the text string. Figure 32.7 illustrates how we\nconstruct the automaton for the pattern P D ababaca. From now on, we shall\nassume that P is a given ﬁxed pattern string; for brevity, we shall not indicate the\ndependence upon P in our notation.\nIn order to specify the string-matching automaton corresponding to a given pat-\ntern P Œ1 : : m\u0002, we ﬁrst deﬁne an auxiliary function \t, called the sufﬁx function\ncorresponding to P . The function \t maps †\u0004 to f0; 1; : : : ; mg such that \t.x/ is the\nlength of the longest preﬁx of P that is also a sufﬁx of x:\n\t.x/ D max fk W Pk = xg :\n(32.3)\n32.3\nString matching with ﬁnite automata\n997\n0\n1\n2\n3\n4\n5\n6\n7\na\nb\na\nb\na\nc\na\nb\na\na\na\na\nb\n(a)\n1\n0\n0\n1\n2\n0\n3\n0\n0\n1\n4\n0\n5\n0\n0\n1\n4\n6\n7\n0\n0\n1\n2\n0\n0\n1\n2\n3\n4\n5\n6\n7\nstate\ninput\na\nb\nc\na\nb\na\nb\na\nc\na\nP\n(b)\n1\n2\n3\n4\n5\n6\n7\n8\n9 10 11\na\nb\na\nb\na\nb\na\nc\na\nb\na\n0\n1\n2\n3\n4\n5\n4\n5\n6\n7\n2\n3\n—\n—\n(c)\ni\nT Œi\u0002\nstate \u0007.Ti/\nFigure 32.7\n(a) A state-transition diagram for the string-matching automaton that accepts all\nstrings ending in the string ababaca. State 0 is the start state, and state 7 (shown blackened) is\nthe only accepting state. A directed edge from state i to state j labeled a represents ı.i; a/ D j. The\nright-going edges forming the “spine” of the automaton, shown heavy in the ﬁgure, correspond to\nsuccessful matches between pattern and input characters. The left-going edges correspond to failing\nmatches. Some edges corresponding to failing matches are omitted; by convention, if a state i has\nno outgoing edge labeled a for some a 2 †, then ı.i; a/ D 0. (b) The corresponding transition\nfunction ı, and the pattern string P D ababaca. The entries corresponding to successful matches",
    "parent_95f78da4-d988-4cfb-9175-dfdb3ed8834f": "matches. Some edges corresponding to failing matches are omitted; by convention, if a state i has\nno outgoing edge labeled a for some a 2 †, then ı.i; a/ D 0. (b) The corresponding transition\nfunction ı, and the pattern string P D ababaca. The entries corresponding to successful matches\nbetween pattern and input characters are shown shaded. (c) The operation of the automaton on the\ntext T D abababacaba. Under each text character T Œi\u0002 appears the state \u0007.Ti/ that the automa-\nton is in after processing the preﬁx Ti. The automaton ﬁnds one occurrence of the pattern, ending in\nposition 9.\nThe sufﬁx function \t is well deﬁned since the empty string P0 D \" is a suf-\nﬁx of every string. As examples, for the pattern P D ab, we have \t.\"/ D 0,\n\t.ccaca/ D 1, and \t.ccab/ D 2. For a pattern P of length m, we have\n\t.x/ D m if and only if P = x. From the deﬁnition of the sufﬁx function,\nx = y implies \t.x/ \u0002 \t.y/.\nWe deﬁne the string-matching automaton that corresponds to a given pattern\nP Œ1 : : m\u0002 as follows:\n998\nChapter 32\nString Matching\n\u0002\nThe state set Q is f0; 1; : : : ; mg. The start state q0 is state 0, and state m is the\nonly accepting state.\n\u0002\nThe transition function ı is deﬁned by the following equation, for any state q\nand character a:\nı.q; a/ D \t.Pqa/ :\n(32.4)\nWe deﬁne ı.q; a/ D \t.Pqa/ because we want to keep track of the longest pre-\nﬁx of the pattern P that has matched the text string T so far. We consider the\nmost recently read characters of T . In order for a substring of T —let’s say the\nsubstring ending at T Œi\u0002—to match some preﬁx Pj of P , this preﬁx Pj must be a\nsufﬁx of Ti. Suppose that q D \u0007.Ti/, so that after reading Ti, the automaton is in\nstate q. We design the transition function ı so that this state number, q, tells us the\nlength of the longest preﬁx of P that matches a sufﬁx of Ti. That is, in state q,\nPq = Ti and q D \t.Ti/. (Whenever q D m, all m characters of P match a sufﬁx",
    "parent_292d657c-fa3c-4f87-a19f-f79cecaad660": "state q. We design the transition function ı so that this state number, q, tells us the\nlength of the longest preﬁx of P that matches a sufﬁx of Ti. That is, in state q,\nPq = Ti and q D \t.Ti/. (Whenever q D m, all m characters of P match a sufﬁx\nof Ti, and so we have found a match.) Thus, since \u0007.Ti/ and \t.Ti/ both equal q,\nwe shall see (in Theorem 32.4, below) that the automaton maintains the following\ninvariant:\n\u0007.Ti/ D \t.Ti/ :\n(32.5)\nIf the automaton is in state q and reads the next character T Œi C 1\u0002 D a, then we\nwant the transition to lead to the state corresponding to the longest preﬁx of P that\nis a sufﬁx of Tia, and that state is \t.Tia/. Because Pq is the longest preﬁx of P\nthat is a sufﬁx of Ti, the longest preﬁx of P that is a sufﬁx of Tia is not only \t.Tia/,\nbut also \t.Pqa/. (Lemma 32.3, on page 1000, proves that \t.Tia/ D \t.Pqa/.)\nThus, when the automaton is in state q, we want the transition function on charac-\nter a to take the automaton to state \t.Pqa/.\nThere are two cases to consider. In the ﬁrst case, a D P Œq C 1\u0002, so that the\ncharacter a continues to match the pattern; in this case, because ı.q; a/ D qC1, the\ntransition continues to go along the “spine” of the automaton (the heavy edges in\nFigure 32.7). In the second case, a ¤ P ŒqC1\u0002, so that a does not continue to match\nthe pattern. Here, we must ﬁnd a smaller preﬁx of P that is also a sufﬁx of Ti.\nBecause the preprocessing step matches the pattern against itself when creating the\nstring-matching automaton, the transition function quickly identiﬁes the longest\nsuch smaller preﬁx of P .\nLet’s look at an example. The string-matching automaton of Figure 32.7 has\nı.5; c/ D 6, illustrating the ﬁrst case, in which the match continues. To illus-\ntrate the second case, observe that the automaton of Figure 32.7 has ı.5; b/ D 4.\nWe make this transition because if the automaton reads a b in state q D 5, then\nPqb D ababab, and the longest preﬁx of P that is also a sufﬁx of ababab is\nP4 D abab.\n32.3",
    "parent_2babcf3d-b8aa-41a5-bafb-c571a2eb7b7c": "trate the second case, observe that the automaton of Figure 32.7 has ı.5; b/ D 4.\nWe make this transition because if the automaton reads a b in state q D 5, then\nPqb D ababab, and the longest preﬁx of P that is also a sufﬁx of ababab is\nP4 D abab.\n32.3\nString matching with ﬁnite automata\n999\nx\na\nPr\nPr–1\nFigure 32.8\nAn illustration for the proof of Lemma 32.2. The ﬁgure shows that r \u0002 \t.x/ C 1,\nwhere r D \t.xa/.\nTo clarify the operation of a string-matching automaton, we now give a simple,\nefﬁcient program for simulating the behavior of such an automaton (represented\nby its transition function ı) in ﬁnding occurrences of a pattern P of length m in an\ninput text T Œ1 : : n\u0002. As for any string-matching automaton for a pattern of length m,\nthe state set Q is f0; 1; : : : ; mg, the start state is 0, and the only accepting state is\nstate m.\nFINITE-AUTOMATON-MATCHER.T; ı; m/\n1\nn D T:length\n2\nq D 0\n3\nfor i D 1 to n\n4\nq D ı.q; T Œi\u0002/\n5\nif q == m\n6\nprint “Pattern occurs with shift” i \u0005 m\nFrom the simple loop structure of FINITE-AUTOMATON-MATCHER, we can easily\nsee that its matching time on a text string of length n is ‚.n/. This matching\ntime, however, does not include the preprocessing time required to compute the\ntransition function ı. We address this problem later, after ﬁrst proving that the\nprocedure FINITE-AUTOMATON-MATCHER operates correctly.\nConsider how the automaton operates on an input text T Œ1 : : n\u0002. We shall prove\nthat the automaton is in state \t.Ti/ after scanning character T Œi\u0002. Since \t.Ti/ D m\nif and only if P = Ti, the machine is in the accepting state m if and only if it has\njust scanned the pattern P . To prove this result, we make use of the following two\nlemmas about the sufﬁx function \t.\nLemma 32.2 (Sufﬁx-function inequality)\nFor any string x and character a, we have \t.xa/ \u0002 \t.x/ C 1.\nProof\nReferring to Figure 32.8, let r D \t.xa/. If r D 0, then the conclusion\n\t.xa/ D r \u0002 \t.x/ C 1 is trivially satisﬁed, by the nonnegativity of \t.x/. Now",
    "parent_cab43f22-ae31-489a-ae07-b171851a8b55": "lemmas about the sufﬁx function \t.\nLemma 32.2 (Sufﬁx-function inequality)\nFor any string x and character a, we have \t.xa/ \u0002 \t.x/ C 1.\nProof\nReferring to Figure 32.8, let r D \t.xa/. If r D 0, then the conclusion\n\t.xa/ D r \u0002 \t.x/ C 1 is trivially satisﬁed, by the nonnegativity of \t.x/. Now\nassume that r > 0. Then, Pr = xa, by the deﬁnition of \t. Thus, Pr\u00031 = x, by\n1000\nChapter 32\nString Matching\nx\na\na\nPq\nPr\nFigure 32.9\nAn illustration for the proof of Lemma 32.3. The ﬁgure shows that r D \t.Pqa/,\nwhere q D \t.x/ and r D \t.xa/.\ndropping the a from the end of Pr and from the end of xa. Therefore, r\u00051 \u0002 \t.x/,\nsince \t.x/ is the largest k such that Pk = x, and thus \t.xa/ D r \u0002 \t.x/ C 1.\nLemma 32.3 (Sufﬁx-function recursion lemma)\nFor any string x and character a, if q D \t.x/, then \t.xa/ D \t.Pqa/.\nProof\nFrom the deﬁnition of \t, we have Pq = x. As Figure 32.9 shows, we\nalso have Pqa = xa. If we let r D \t.xa/, then Pr = xa and, by Lemma 32.2,\nr \u0002 q C 1. Thus, we have jPrj D r \u0002 q C 1 D jPqaj. Since Pqa = xa, Pr = xa,\nand jPrj \u0002 jPqaj, Lemma 32.1 implies that Pr = Pqa. Therefore, r \u0002 \t.Pqa/,\nthat is, \t.xa/ \u0002 \t.Pqa/. But we also have \t.Pqa/ \u0002 \t.xa/, since Pqa = xa.\nThus, \t.xa/ D \t.Pqa/.\nWe are now ready to prove our main theorem characterizing the behavior of a\nstring-matching automaton on a given input text. As noted above, this theorem\nshows that the automaton is merely keeping track, at each step, of the longest\npreﬁx of the pattern that is a sufﬁx of what has been read so far. In other words,\nthe automaton maintains the invariant (32.5).\nTheorem 32.4\nIf \u0007 is the ﬁnal-state function of a string-matching automaton for a given pattern P\nand T Œ1 : : n\u0002 is an input text for the automaton, then\n\u0007.Ti/ D \t.Ti/\nfor i D 0; 1; : : : ; n.\nProof\nThe proof is by induction on i. For i D 0, the theorem is trivially true,\nsince T0 D \". Thus, \u0007.T0/ D 0 D \t.T0/.\n32.3\nString matching with ﬁnite automata\n1001\nNow, we assume that \u0007.Ti/ D \t.Ti/ and prove that \u0007.TiC1/ D \t.TiC1/. Let q",
    "parent_1633ddfd-f946-4fcc-a394-8cc98e327eb6": "\u0007.Ti/ D \t.Ti/\nfor i D 0; 1; : : : ; n.\nProof\nThe proof is by induction on i. For i D 0, the theorem is trivially true,\nsince T0 D \". Thus, \u0007.T0/ D 0 D \t.T0/.\n32.3\nString matching with ﬁnite automata\n1001\nNow, we assume that \u0007.Ti/ D \t.Ti/ and prove that \u0007.TiC1/ D \t.TiC1/. Let q\ndenote \u0007.Ti/, and let a denote T Œi C 1\u0002. Then,\n\u0007.TiC1/\nD\n\u0007.Tia/\n(by the deﬁnitions of TiC1 and a)\nD\nı.\u0007.Ti/; a/\n(by the deﬁnition of \u0007)\nD\nı.q; a/\n(by the deﬁnition of q)\nD\n\t.Pqa/\n(by the deﬁnition (32.4) of ı)\nD\n\t.Tia/\n(by Lemma 32.3 and induction)\nD\n\t.TiC1/\n(by the deﬁnition of TiC1) .\nBy Theorem 32.4, if the machine enters state q on line 4, then q is the largest\nvalue such that Pq = Ti. Thus, we have q D m on line 5 if and only if the ma-\nchine has just scanned an occurrence of the pattern P . We conclude that FINITE-\nAUTOMATON-MATCHER operates correctly.\nComputing the transition function\nThe following procedure computes the transition function ı from a given pattern\nP Œ1 : : m\u0002.\nCOMPUTE-TRANSITION-FUNCTION.P; †/\n1\nm D P:length\n2\nfor q D 0 to m\n3\nfor each character a 2 †\n4\nk D min.m C 1; q C 2/\n5\nrepeat\n6\nk D k \u0005 1\n7\nuntil Pk = Pqa\n8\nı.q; a/ D k\n9\nreturn ı\nThis procedure computes ı.q; a/ in a straightforward manner according to its def-\ninition in equation (32.4). The nested loops beginning on lines 2 and 3 consider\nall states q and all characters a, and lines 4–8 set ı.q; a/ to be the largest k such\nthat Pk = Pqa. The code starts with the largest conceivable value of k, which is\nmin.m; q C 1/. It then decreases k until Pk = Pqa, which must eventually occur,\nsince P0 D \" is a sufﬁx of every string.\nThe running time of COMPUTE-TRANSITION-FUNCTION is O.m3 j†j/, be-\ncause the outer loops contribute a factor of m j†j, the inner repeat loop can run\nat most m C 1 times, and the test Pk = Pqa on line 7 can require comparing up\n1002\nChapter 32\nString Matching\nto m characters. Much faster procedures exist; by utilizing some cleverly com-",
    "parent_5a9cb9cc-a8a8-410e-8392-e4dd4bc0e50a": "cause the outer loops contribute a factor of m j†j, the inner repeat loop can run\nat most m C 1 times, and the test Pk = Pqa on line 7 can require comparing up\n1002\nChapter 32\nString Matching\nto m characters. Much faster procedures exist; by utilizing some cleverly com-\nputed information about the pattern P (see Exercise 32.4-8), we can improve the\ntime required to compute ı from P to O.m j†j/. With this improved procedure for\ncomputing ı, we can ﬁnd all occurrences of a length-m pattern in a length-n text\nover an alphabet † with O.m j†j/ preprocessing time and ‚.n/ matching time.\nExercises\n32.3-1\nConstruct the string-matching automaton for the pattern P D aabab and illustrate\nits operation on the text string T D aaababaabaababaab.\n32.3-2\nDraw a state-transition diagram for a string-matching automaton for the pattern\nababbabbababbababbabb over the alphabet † D fa; bg.\n32.3-3\nWe call a pattern P nonoverlappable if Pk = Pq implies k D 0 or k D q. De-\nscribe the state-transition diagram of the string-matching automaton for a nonover-\nlappable pattern.\n32.3-4\n?\nGiven two patterns P and P 0, describe how to construct a ﬁnite automaton that\ndetermines all occurrences of either pattern. Try to minimize the number of states\nin your automaton.\n32.3-5\nGiven a pattern P containing gap characters (see Exercise 32.1-4), show how to\nbuild a ﬁnite automaton that can ﬁnd an occurrence of P in a text T in O.n/\nmatching time, where n D jT j.\n?\n32.4\nThe Knuth-Morris-Pratt algorithm\nWe now present a linear-time string-matching algorithm due to Knuth, Morris, and\nPratt. This algorithm avoids computing the transition function ı altogether, and its\nmatching time is ‚.n/ using just an auxiliary function \u0006, which we precompute\nfrom the pattern in time ‚.m/ and store in an array \u0006Œ1 : : m\u0002. The array \u0006 allows\nus to compute the transition function ı efﬁciently (in an amortized sense) “on the\nﬂy” as needed. Loosely speaking, for any state q D 0; 1; : : : ; m and any character\n32.4",
    "parent_d930d9a6-3e90-47f6-97ff-8abb4d9b197e": "from the pattern in time ‚.m/ and store in an array \u0006Œ1 : : m\u0002. The array \u0006 allows\nus to compute the transition function ı efﬁciently (in an amortized sense) “on the\nﬂy” as needed. Loosely speaking, for any state q D 0; 1; : : : ; m and any character\n32.4\nThe Knuth-Morris-Pratt algorithm\n1003\na 2 †, the value \u0006Œq\u0002 contains the information we need to compute ı.q; a/ but\nthat does not depend on a. Since the array \u0006 has only m entries, whereas ı has\n‚.m j†j/ entries, we save a factor of j†j in the preprocessing time by computing \u0006\nrather than ı.\nThe preﬁx function for a pattern\nThe preﬁx function \u0006 for a pattern encapsulates knowledge about how the pat-\ntern matches against shifts of itself. We can take advantage of this information to\navoid testing useless shifts in the naive pattern-matching algorithm and to avoid\nprecomputing the full transition function ı for a string-matching automaton.\nConsider the operation of the naive string matcher. Figure 32.10(a) shows a\nparticular shift s of a template containing the pattern P D ababaca against a\ntext T . For this example, q D 5 of the characters have matched successfully, but\nthe 6th pattern character fails to match the corresponding text character. The infor-\nmation that q characters have matched successfully determines the corresponding\ntext characters. Knowing these q text characters allows us to determine immedi-\nately that certain shifts are invalid. In the example of the ﬁgure, the shift s C 1 is\nnecessarily invalid, since the ﬁrst pattern character (a) would be aligned with a text\ncharacter that we know does not match the ﬁrst pattern character, but does match\nthe second pattern character (b). The shift s0 D s C 2 shown in part (b) of the ﬁg-\nure, however, aligns the ﬁrst three pattern characters with three text characters that\nmust necessarily match. In general, it is useful to know the answer to the following\nquestion:\nGiven that pattern characters P Œ1 : : q\u0002 match text characters T ŒsC1 : : sCq\u0002,",
    "parent_f675096a-036f-498f-91f3-e1bc381a7b67": "ure, however, aligns the ﬁrst three pattern characters with three text characters that\nmust necessarily match. In general, it is useful to know the answer to the following\nquestion:\nGiven that pattern characters P Œ1 : : q\u0002 match text characters T ŒsC1 : : sCq\u0002,\nwhat is the least shift s0 > s such that for some k < q,\nP Œ1 : : k\u0002 D T Œs0 C 1 : : s0 C k\u0002 ;\n(32.6)\nwhere s0 C k D s C q?\nIn other words, knowing that Pq = TsCq, we want the longest proper preﬁx Pk\nof Pq that is also a sufﬁx of TsCq. (Since s0 C k D s C q, if we are given s\nand q, then ﬁnding the smallest shift s0 is tantamount to ﬁnding the longest preﬁx\nlength k.) We add the difference q \u0005 k in the lengths of these preﬁxes of P to the\nshift s to arrive at our new shift s0, so that s0 D s C.q \u0005k/. In the best case, k D 0,\nso that s0 D s C q, and we immediately rule out shifts s C 1; s C 2; : : : ; s C q \u0005 1.\nIn any case, at the new shift s0 we don’t need to compare the ﬁrst k characters of P\nwith the corresponding characters of T , since equation (32.6) guarantees that they\nmatch.\nWe can precompute the necessary information by comparing the pattern against\nitself, as Figure 32.10(c) demonstrates. Since T Œs0 C 1 : : s0 C k\u0002 is part of the\n1004\nChapter 32\nString Matching\nb\na\nc\nb\na\nb\na\nb\na\n(a)\na\nb\na\na\nb\nc\nb\na\nb\nb\na\nc\na\ns\nT\nP\nq\nb\na\nc\nb\na\nb\na\nb\na\n(b)\na\nb\na\na\nb\nc\nb\na\nb\nb\na\nc\na\ns′ = s + 2\nT\nP\nk\na\nb\na\nb\na\na\nb\na\n(c)\nPq\nPk\nFigure 32.10\nThe preﬁx function \u0006. (a) The pattern P D ababaca aligns with a text T so that\nthe ﬁrst q D 5 characters match. Matching characters, shown shaded, are connected by vertical lines.\n(b) Using only our knowledge of the 5 matched characters, we can deduce that a shift of s C 1 is\ninvalid, but that a shift of s0 D sC2 is consistent with everything we know about the text and therefore\nis potentially valid. (c) We can precompute useful information for such deductions by comparing the\npattern with itself. Here, we see that the longest preﬁx of P that is also a proper sufﬁx of P5 is P3.",
    "parent_55b7f6ec-a946-4ffe-87c2-e09223216960": "is potentially valid. (c) We can precompute useful information for such deductions by comparing the\npattern with itself. Here, we see that the longest preﬁx of P that is also a proper sufﬁx of P5 is P3.\nWe represent this precomputed information in the array \u0006, so that \u0006Œ5\u0002 D 3. Given that q characters\nhave matched successfully at shift s, the next potentially valid shift is at s0 D sC.q\u0005\u0006Œq\u0002/ as shown\nin part (b).\nknown portion of the text, it is a sufﬁx of the string Pq. Therefore, we can interpret\nequation (32.6) as asking for the greatest k < q such that Pk = Pq. Then, the new\nshift s0 D sC.q\u0005k/ is the next potentially valid shift. We will ﬁnd it convenient to\nstore, for each value of q, the number k of matching characters at the new shift s0,\nrather than storing, say, s0 \u0005 s.\nWe formalize the information that we precompute as follows. Given a pattern\nP Œ1 : : m\u0002, the preﬁx function for the pattern P is the function \u0006 W f1; 2; : : : ; mg !\nf0; 1; : : : ; m \u0005 1g such that\n\u0006Œq\u0002 D max fk W k < q and Pk = Pqg :\nThat is, \u0006Œq\u0002 is the length of the longest preﬁx of P that is a proper sufﬁx of Pq.\nFigure 32.11(a) gives the complete preﬁx function \u0006 for the pattern ababaca.\n32.4\nThe Knuth-Morris-Pratt algorithm\n1005\n1\n2\n3\n4\n5\n6\n7\n0\n0\n1\n2\n3\n0\n1\na\nb\na\nb\na\nc\na\n(a)\na\nb\na\nb\na\nc\na\na\nb\na\nb\na\nc\na\na\nb\na\nb\na\nc\na\na\nb\na\nb\na\nc\na\n(b)\n\"\ni\nP Œi\u0002\n\u0006Œi\u0002\nP5\nP3\nP1\nP0\n\u0006Œ5\u0002 D 3\n\u0006Œ3\u0002 D 1\n\u0006Œ1\u0002 D 0\nFigure 32.11\nAn illustration of Lemma 32.5 for the pattern P D ababaca and q D 5. (a) The \u0006\nfunction for the given pattern. Since \u0006Œ5\u0002 D 3, \u0006Œ3\u0002 D 1, and \u0006Œ1\u0002 D 0, by iterating \u0006 we obtain\n\u0006\u0004Œ5\u0002 D f3; 1; 0g. (b) We slide the template containing the pattern P to the right and note when some\npreﬁx Pk of P matches up with some proper sufﬁx of P5; we get matches when k D 3, 1, and 0. In\nthe ﬁgure, the ﬁrst row gives P , and the dotted vertical line is drawn just after P5. Successive rows\nshow all the shifts of P that cause some preﬁx Pk of P to match some sufﬁx of P5. Successfully",
    "parent_dd8b3b1f-3df9-47c0-97a2-1079bf1f3535": "preﬁx Pk of P matches up with some proper sufﬁx of P5; we get matches when k D 3, 1, and 0. In\nthe ﬁgure, the ﬁrst row gives P , and the dotted vertical line is drawn just after P5. Successive rows\nshow all the shifts of P that cause some preﬁx Pk of P to match some sufﬁx of P5. Successfully\nmatched characters are shown shaded. Vertical lines connect aligned matching characters. Thus,\nfk W k < 5 and Pk = P5g D f3; 1; 0g. Lemma 32.5 claims that \u0006\u0004Œq\u0002 D fk W k < q and Pk = Pqg\nfor all q.\nThe pseudocode below gives the Knuth-Morris-Pratt matching algorithm as\nthe procedure KMP-MATCHER. For the most part, the procedure follows from\nFINITE-AUTOMATON-MATCHER, as we shall see. KMP-MATCHER calls the aux-\niliary procedure COMPUTE-PREFIX-FUNCTION to compute \u0006.\nKMP-MATCHER.T; P /\n1\nn D T:length\n2\nm D P:length\n3\n\u0006 D COMPUTE-PREFIX-FUNCTION.P /\n4\nq D 0\n// number of characters matched\n5\nfor i D 1 to n\n// scan the text from left to right\n6\nwhile q > 0 and P Œq C 1\u0002 ¤ T Œi\u0002\n7\nq D \u0006Œq\u0002\n// next character does not match\n8\nif P Œq C 1\u0002 == T Œi\u0002\n9\nq D q C 1\n// next character matches\n10\nif q == m\n// is all of P matched?\n11\nprint “Pattern occurs with shift” i \u0005 m\n12\nq D \u0006Œq\u0002\n// look for the next match\n1006\nChapter 32\nString Matching\nCOMPUTE-PREFIX-FUNCTION.P /\n1\nm D P:length\n2\nlet \u0006Œ1 : : m\u0002 be a new array\n3\n\u0006Œ1\u0002 D 0\n4\nk D 0\n5\nfor q D 2 to m\n6\nwhile k > 0 and P Œk C 1\u0002 ¤ P Œq\u0002\n7\nk D \u0006Œk\u0002\n8\nif P Œk C 1\u0002 == P Œq\u0002\n9\nk D k C 1\n10\n\u0006Œq\u0002 D k\n11\nreturn \u0006\nThese two procedures have much in common, because both match a string against\nthe pattern P : KMP-MATCHER matches the text T against P , and COMPUTE-\nPREFIX-FUNCTION matches P against itself.\nWe begin with an analysis of the running times of these procedures. Proving\nthese procedures correct will be more complicated.\nRunning-time analysis\nThe running time of COMPUTE-PREFIX-FUNCTION is ‚.m/, which we show by\nusing the aggregate method of amortized analysis (see Section 17.1). The only",
    "parent_102c8a64-3604-4b24-9b81-1c571d0b1f77": "We begin with an analysis of the running times of these procedures. Proving\nthese procedures correct will be more complicated.\nRunning-time analysis\nThe running time of COMPUTE-PREFIX-FUNCTION is ‚.m/, which we show by\nusing the aggregate method of amortized analysis (see Section 17.1). The only\ntricky part is showing that the while loop of lines 6–7 executes O.m/ times alto-\ngether. We shall show that it makes at most m \u0005 1 iterations. We start by making\nsome observations about k. First, line 4 starts k at 0, and the only way that k\nincreases is by the increment operation in line 9, which executes at most once per\niteration of the for loop of lines 5–10. Thus, the total increase in k is at most m\u00051.\nSecond, since k < q upon entering the for loop and each iteration of the loop in-\ncrements q, we always have k < q. Therefore, the assignments in lines 3 and 10\nensure that \u0006Œq\u0002 < q for all q D 1; 2; : : : ; m, which means that each iteration of\nthe while loop decreases k. Third, k never becomes negative. Putting these facts\ntogether, we see that the total decrease in k from the while loop is bounded from\nabove by the total increase in k over all iterations of the for loop, which is m \u0005 1.\nThus, the while loop iterates at most m \u0005 1 times in all, and COMPUTE-PREFIX-\nFUNCTION runs in time ‚.m/.\nExercise 32.4-4 asks you to show, by a similar aggregate analysis, that the match-\ning time of KMP-MATCHER is ‚.n/.\nCompared with FINITE-AUTOMATON-MATCHER, by using \u0006 rather than ı, we\nhave reduced the time for preprocessing the pattern from O.m j†j/ to ‚.m/, while\nkeeping the actual matching time bounded by ‚.n/.\n32.4\nThe Knuth-Morris-Pratt algorithm\n1007\nCorrectness of the preﬁx-function computation\nWe shall see a little later that the preﬁx function \u0006 helps us simulate the transition\nfunction ı in a string-matching automaton. But ﬁrst, we need to prove that the\nprocedure COMPUTE-PREFIX-FUNCTION does indeed compute the preﬁx func-",
    "parent_8e8b2069-d7d7-4ee5-9e34-c761fad5e25f": "1007\nCorrectness of the preﬁx-function computation\nWe shall see a little later that the preﬁx function \u0006 helps us simulate the transition\nfunction ı in a string-matching automaton. But ﬁrst, we need to prove that the\nprocedure COMPUTE-PREFIX-FUNCTION does indeed compute the preﬁx func-\ntion correctly. In order to do so, we will need to ﬁnd all preﬁxes Pk that are proper\nsufﬁxes of a given preﬁx Pq. The value of \u0006Œq\u0002 gives us the longest such preﬁx, but\nthe following lemma, illustrated in Figure 32.11, shows that by iterating the preﬁx\nfunction \u0006, we can indeed enumerate all the preﬁxes Pk that are proper sufﬁxes\nof Pq. Let\n\u0006\u0004Œq\u0002 D f\u0006Œq\u0002; \u0006.2/Œq\u0002; \u0006.3/Œq\u0002; : : : ; \u0006.t/Œq\u0002g ;\nwhere \u0006.i/Œq\u0002 is deﬁned in terms of functional iteration, so that \u0006.0/Œq\u0002 D q and\n\u0006.i/Œq\u0002 D \u0006Œ\u0006.i\u00031/Œq\u0002\u0002 for i \u0006 1, and where the sequence in \u0006\u0004Œq\u0002 stops upon\nreaching \u0006.t/Œq\u0002 D 0.\nLemma 32.5 (Preﬁx-function iteration lemma)\nLet P be a pattern of length m with preﬁx function \u0006. Then, for q D 1; 2; : : : ; m,\nwe have \u0006\u0004Œq\u0002 D fk W k < q and Pk = Pqg.\nProof\nWe ﬁrst prove that \u0006\u0004Œq\u0002 \u0007 fk W k < q and Pk = Pqg or, equivalently,\ni 2 \u0006\u0004Œq\u0002 implies Pi = Pq :\n(32.7)\nIf i 2 \u0006\u0004Œq\u0002, then i D \u0006.u/Œq\u0002 for some u > 0. We prove equation (32.7) by\ninduction on u. For u D 1, we have i D \u0006Œq\u0002, and the claim follows since i < q\nand P\u0003Œq\u0004 = Pq by the deﬁnition of \u0006. Using the relations \u0006Œi\u0002 < i and P\u0003Œi\u0004 = Pi\nand the transitivity of < and = establishes the claim for all i in \u0006\u0004Œq\u0002. Therefore,\n\u0006\u0004Œq\u0002 \u0007 fk W k < q and Pk = Pqg.\nWe now prove that fk W k < q and Pk = Pqg \u0007 \u0006\u0004Œq\u0002 by contradiction. Sup-\npose to the contrary that the set fk W k < q and Pk = Pqg \u0005 \u0006\u0004Œq\u0002 is nonempty,\nand let j be the largest number in the set. Because \u0006Œq\u0002 is the largest value in\nfk W k < q and Pk = Pqg and \u0006Œq\u0002 2 \u0006\u0004Œq\u0002, we must have j < \u0006Œq\u0002, and so we\nlet j 0 denote the smallest integer in \u0006\u0004Œq\u0002 that is greater than j . (We can choose\nj 0 D \u0006Œq\u0002 if no other number in \u0006\u0004Œq\u0002 is greater than j .) We have Pj = Pq because",
    "parent_d1cc6e35-9448-4995-aedf-15f7ecd41eae": "fk W k < q and Pk = Pqg and \u0006Œq\u0002 2 \u0006\u0004Œq\u0002, we must have j < \u0006Œq\u0002, and so we\nlet j 0 denote the smallest integer in \u0006\u0004Œq\u0002 that is greater than j . (We can choose\nj 0 D \u0006Œq\u0002 if no other number in \u0006\u0004Œq\u0002 is greater than j .) We have Pj = Pq because\nj 2 fk W k < q and Pk = Pqg, and from j 0 2 \u0006\u0004Œq\u0002 and equation (32.7), we have\nPj 0 = Pq. Thus, Pj = Pj 0 by Lemma 32.1, and j is the largest value less than j 0\nwith this property. Therefore, we must have \u0006Œj 0\u0002 D j and, since j 0 2 \u0006\u0004Œq\u0002, we\nmust have j 2 \u0006\u0004Œq\u0002 as well. This contradiction proves the lemma.\nThe algorithm COMPUTE-PREFIX-FUNCTION computes \u0006Œq\u0002, in order, for q D\n1; 2; : : : ; m. Setting \u0006Œ1\u0002 to 0 in line 3 of COMPUTE-PREFIX-FUNCTION is cer-\ntainly correct, since \u0006Œq\u0002 < q for all q. We shall use the following lemma and\n1008\nChapter 32\nString Matching\nits corollary to prove that COMPUTE-PREFIX-FUNCTION computes \u0006Œq\u0002 correctly\nfor q > 1.\nLemma 32.6\nLet P be a pattern of length m, and let \u0006 be the preﬁx function for P . For q D\n1; 2; : : : ; m, if \u0006Œq\u0002 > 0, then \u0006Œq\u0002 \u0005 1 2 \u0006\u0004Œq \u0005 1\u0002.\nProof\nLet r D \u0006Œq\u0002 > 0, so that r < q and Pr = Pq; thus, r \u0005 1 < q \u0005 1 and\nPr\u00031 = Pq\u00031 (by dropping the last character from Pr and Pq, which we can do\nbecause r > 0). By Lemma 32.5, therefore, r \u0005 1 2 \u0006\u0004Œq \u0005 1\u0002. Thus, we have\n\u0006Œq\u0002 \u0005 1 D r \u0005 1 2 \u0006\u0004Œq \u0005 1\u0002.\nFor q D 2; 3; : : : ; m, deﬁne the subset Eq\u00031 \u0007 \u0006\u0004Œq \u0005 1\u0002 by\nEq\u00031 D fk 2 \u0006\u0004Œq \u0005 1\u0002 W P Œk C 1\u0002 D P Œq\u0002g\nD fk W k < q \u0005 1 and Pk = Pq\u00031 and P Œk C 1\u0002 D P Œq\u0002g (by Lemma 32.5)\nD fk W k < q \u0005 1 and PkC1 = Pqg :\nThe set Eq\u00031 consists of the values k < q \u0005 1 for which Pk = Pq\u00031 and for which,\nbecause P Œk C 1\u0002 D P Œq\u0002, we have PkC1 = Pq. Thus, Eq\u00031 consists of those\nvalues k 2 \u0006\u0004Œq \u0005 1\u0002 such that we can extend Pk to PkC1 and get a proper sufﬁx\nof Pq.\nCorollary 32.7\nLet P be a pattern of length m, and let \u0006 be the preﬁx function for P . For q D\n2; 3; : : : ; m,\n\u0006Œq\u0002 D\n(\n0\nif Eq\u00031 D ; ;\n1 C max fk 2 Eq\u00031g\nif Eq\u00031 ¤ ; :\nProof",
    "parent_2859cf5c-aa62-45ea-8237-bf5929795686": "values k 2 \u0006\u0004Œq \u0005 1\u0002 such that we can extend Pk to PkC1 and get a proper sufﬁx\nof Pq.\nCorollary 32.7\nLet P be a pattern of length m, and let \u0006 be the preﬁx function for P . For q D\n2; 3; : : : ; m,\n\u0006Œq\u0002 D\n(\n0\nif Eq\u00031 D ; ;\n1 C max fk 2 Eq\u00031g\nif Eq\u00031 ¤ ; :\nProof\nIf Eq\u00031 is empty, there is no k 2 \u0006\u0004Œq \u0005 1\u0002 (including k D 0) for which\nwe can extend Pk to PkC1 and get a proper sufﬁx of Pq. Therefore \u0006Œq\u0002 D 0.\nIf Eq\u00031 is nonempty, then for each k 2 Eq\u00031 we have kC1 < q and PkC1 = Pq.\nTherefore, from the deﬁnition of \u0006Œq\u0002, we have\n\u0006Œq\u0002 \u0006 1 C max fk 2 Eq\u00031g :\n(32.8)\nNote that \u0006Œq\u0002 > 0.\nLet r D \u0006Œq\u0002 \u0005 1, so that r C 1 D \u0006Œq\u0002 and there-\nfore PrC1 = Pq. Since r C 1 > 0, we have P Œr C 1\u0002 D P Œq\u0002. Furthermore,\nby Lemma 32.6, we have r 2 \u0006\u0004Œq \u0005 1\u0002. Therefore, r 2 Eq\u00031, and so r \u0002\nmax fk 2 Eq\u00031g or, equivalently,\n\u0006Œq\u0002 \u0002 1 C max fk 2 Eq\u00031g :\n(32.9)\nCombining equations (32.8) and (32.9) completes the proof.\n32.4\nThe Knuth-Morris-Pratt algorithm\n1009\nWe now ﬁnish the proof that COMPUTE-PREFIX-FUNCTION computes \u0006 cor-\nrectly. In the procedure COMPUTE-PREFIX-FUNCTION, at the start of each iter-\nation of the for loop of lines 5–10, we have that k D \u0006Œq \u0005 1\u0002. This condition\nis enforced by lines 3 and 4 when the loop is ﬁrst entered, and it remains true in\neach successive iteration because of line 10. Lines 6–9 adjust k so that it becomes\nthe correct value of \u0006Œq\u0002. The while loop of lines 6–7 searches through all values\nk 2 \u0006\u0004Œq \u0005 1\u0002 until it ﬁnds a value of k for which P Œk C 1\u0002 D P Œq\u0002; at that point,\nk is the largest value in the set Eq\u00031, so that, by Corollary 32.7, we can set \u0006Œq\u0002\nto k C 1. If the while loop cannot ﬁnd a k 2 \u0006\u0004Œq \u0005 1\u0002 such that P Œk C 1\u0002 D P Œq\u0002,\nthen k equals 0 at line 8. If P Œ1\u0002 D P Œq\u0002, then we should set both k and \u0006Œq\u0002 to 1;\notherwise we should leave k alone and set \u0006Œq\u0002 to 0. Lines 8–10 set k and \u0006Œq\u0002\ncorrectly in either case. This completes our proof of the correctness of COMPUTE-\nPREFIX-FUNCTION.\nCorrectness of the Knuth-Morris-Pratt algorithm",
    "parent_81385783-9483-46a5-a8d3-64fd9927cc27": "otherwise we should leave k alone and set \u0006Œq\u0002 to 0. Lines 8–10 set k and \u0006Œq\u0002\ncorrectly in either case. This completes our proof of the correctness of COMPUTE-\nPREFIX-FUNCTION.\nCorrectness of the Knuth-Morris-Pratt algorithm\nWe can think of the procedure KMP-MATCHER as a reimplemented version of\nthe procedure FINITE-AUTOMATON-MATCHER, but using the preﬁx function \u0006\nto compute state transitions. Speciﬁcally, we shall prove that in the ith iteration of\nthe for loops of both KMP-MATCHER and FINITE-AUTOMATON-MATCHER, the\nstate q has the same value when we test for equality with m (at line 10 in KMP-\nMATCHER and at line 5 in FINITE-AUTOMATON-MATCHER).\nOnce we have\nargued that KMP-MATCHER simulates the behavior of FINITE-AUTOMATON-\nMATCHER, the correctness of KMP-MATCHER follows from the correctness of\nFINITE-AUTOMATON-MATCHER (though we shall see a little later why line 12 in\nKMP-MATCHER is necessary).\nBefore we formally prove that KMP-MATCHER correctly simulates FINITE-\nAUTOMATON-MATCHER, let’s take a moment to understand how the preﬁx func-\ntion \u0006 replaces the ı transition function.\nRecall that when a string-matching\nautomaton is in state q and it scans a character a D T Œi\u0002, it moves to a new\nstate ı.q; a/. If a D P Œq C 1\u0002, so that a continues to match the pattern, then\nı.q; a/ D q C 1. Otherwise, a ¤ P Œq C 1\u0002, so that a does not continue to match\nthe pattern, and 0 \u0002 ı.q; a/ \u0002 q. In the ﬁrst case, when a continues to match,\nKMP-MATCHER moves to state q C 1 without referring to the \u0006 function: the\nwhile loop test in line 6 comes up false the ﬁrst time, the test in line 8 comes up\ntrue, and line 9 increments q.\nThe \u0006 function comes into play when the character a does not continue to match\nthe pattern, so that the new state ı.q; a/ is either q or to the left of q along the spine\nof the automaton. The while loop of lines 6–7 in KMP-MATCHER iterates through\nthe states in \u0006\u0004Œq\u0002, stopping either when it arrives in a state, say q0, such that a",
    "parent_f440e88d-0c7b-47dd-9938-4616d4b60f50": "the pattern, so that the new state ı.q; a/ is either q or to the left of q along the spine\nof the automaton. The while loop of lines 6–7 in KMP-MATCHER iterates through\nthe states in \u0006\u0004Œq\u0002, stopping either when it arrives in a state, say q0, such that a\nmatches P Œq0 C 1\u0002 or q0 has gone all the way down to 0. If a matches P Œq0 C 1\u0002,\n1010\nChapter 32\nString Matching\nthen line 9 sets the new state to q0C1, which should equal ı.q; a/ for the simulation\nto work correctly. In other words, the new state ı.q; a/ should be either state 0 or\none greater than some state in \u0006\u0004Œq\u0002.\nLet’s look at the example in Figures 32.7 and 32.11, which are for the pattern\nP D ababaca. Suppose that the automaton is in state q D 5; the states in\n\u0006\u0004Œ5\u0002 are, in descending order, 3, 1, and 0. If the next character scanned is c, then\nwe can easily see that the automaton moves to state ı.5; c/ D 6 in both FINITE-\nAUTOMATON-MATCHER and KMP-MATCHER. Now suppose that the next char-\nacter scanned is instead b, so that the automaton should move to state ı.5; b/ D 4.\nThe while loop in KMP-MATCHER exits having executed line 7 once, and it ar-\nrives in state q0 D \u0006Œ5\u0002 D 3. Since P Œq0 C 1\u0002 D P Œ4\u0002 D b, the test in line 8\ncomes up true, and KMP-MATCHER moves to the new state q0 C1 D 4 D ı.5; b/.\nFinally, suppose that the next character scanned is instead a, so that the automa-\nton should move to state ı.5; a/ D 1. The ﬁrst three times that the test in line 6\nexecutes, the test comes up true. The ﬁrst time, we ﬁnd that P Œ6\u0002 D c ¤ a, and\nKMP-MATCHER moves to state \u0006Œ5\u0002 D 3 (the ﬁrst state in \u0006\u0004Œ5\u0002). The second\ntime, we ﬁnd that P Œ4\u0002 D b ¤ a and move to state \u0006Œ3\u0002 D 1 (the second state\nin \u0006\u0004Œ5\u0002). The third time, we ﬁnd that P Œ2\u0002 D b ¤ a and move to state \u0006Œ1\u0002 D 0\n(the last state in \u0006\u0004Œ5\u0002). The while loop exits once it arrives in state q0 D 0. Now,\nline 8 ﬁnds that P Œq0 C1\u0002 D P Œ1\u0002 D a, and line 9 moves the automaton to the new\nstate q0 C 1 D 1 D ı.5; a/.",
    "parent_3f9ec150-c11e-43d2-a81f-c5a6465c23b9": "in \u0006\u0004Œ5\u0002). The third time, we ﬁnd that P Œ2\u0002 D b ¤ a and move to state \u0006Œ1\u0002 D 0\n(the last state in \u0006\u0004Œ5\u0002). The while loop exits once it arrives in state q0 D 0. Now,\nline 8 ﬁnds that P Œq0 C1\u0002 D P Œ1\u0002 D a, and line 9 moves the automaton to the new\nstate q0 C 1 D 1 D ı.5; a/.\nThus, our intuition is that KMP-MATCHER iterates through the states in \u0006\u0004Œq\u0002 in\ndecreasing order, stopping at some state q0 and then possibly moving to state q0C1.\nAlthough that might seem like a lot of work just to simulate computing ı.q; a/,\nbear in mind that asymptotically, KMP-MATCHER is no slower than FINITE-\nAUTOMATON-MATCHER.\nWe are now ready to formally prove the correctness of the Knuth-Morris-Pratt\nalgorithm. By Theorem 32.4, we have that q D \t.Ti/ after each time we execute\nline 4 of FINITE-AUTOMATON-MATCHER. Therefore, it sufﬁces to show that the\nsame property holds with regard to the for loop in KMP-MATCHER. The proof\nproceeds by induction on the number of loop iterations. Initially, both procedures\nset q to 0 as they enter their respective for loops for the ﬁrst time. Consider itera-\ntion i of the for loop in KMP-MATCHER, and let q0 be state at the start of this loop\niteration. By the inductive hypothesis, we have q0 D \t.Ti\u00031/. We need to show\nthat q D \t.Ti/ at line 10. (Again, we shall handle line 12 separately.)\nWhen we consider the character T Œi\u0002, the longest preﬁx of P that is a sufﬁx of Ti\nis either Pq0C1 (if P Œq0 C 1\u0002 D T Œi\u0002) or some preﬁx (not necessarily proper, and\npossibly empty) of Pq0. We consider separately the three cases in which \t.Ti/ D 0,\n\t.Ti/ D q0 C 1, and 0 < \t.Ti/ \u0002 q0.\n32.4\nThe Knuth-Morris-Pratt algorithm\n1011\n\u0002\nIf \t.Ti/ D 0, then P0 D \" is the only preﬁx of P that is a sufﬁx of Ti. The while\nloop of lines 6–7 iterates through the values in \u0006\u0004Œq0\u0002, but although Pq = Ti for\nevery q 2 \u0006\u0004Œq0\u0002, the loop never ﬁnds a q such that P Œq C 1\u0002 D T Œi\u0002. The loop\nterminates when q reaches 0, and of course line 9 does not execute. Therefore,",
    "parent_cbb51272-f099-4332-a387-af3e8a8425bb": "loop of lines 6–7 iterates through the values in \u0006\u0004Œq0\u0002, but although Pq = Ti for\nevery q 2 \u0006\u0004Œq0\u0002, the loop never ﬁnds a q such that P Œq C 1\u0002 D T Œi\u0002. The loop\nterminates when q reaches 0, and of course line 9 does not execute. Therefore,\nq D 0 at line 10, so that q D \t.Ti/.\n\u0002\nIf \t.Ti/ D q0 C 1, then P Œq0 C 1\u0002 D T Œi\u0002, and the while loop test in line 6\nfails the ﬁrst time through. Line 9 executes, incrementing q so that afterward\nwe have q D q0 C 1 D \t.Ti/.\n\u0002\nIf 0 < \t.Ti/ \u0002 q0, then the while loop of lines 6–7 iterates at least once,\nchecking in decreasing order each value q 2 \u0006\u0004Œq0\u0002 until it stops at some q < q0.\nThus, Pq is the longest preﬁx of Pq0 for which P ŒqC1\u0002 D T Œi\u0002, so that when the\nwhile loop terminates, q C 1 D \t.Pq0T Œi\u0002/. Since q0 D \t.Ti\u00031/, Lemma 32.3\nimplies that \t.Ti\u00031T Œi\u0002/ D \t.Pq0T Œi\u0002/. Thus, we have\nq C 1\nD\n\t.Pq0T Œi\u0002/\nD\n\t.Ti\u00031T Œi\u0002/\nD\n\t.Ti/\nwhen the while loop terminates. After line 9 increments q, we have q D \t.Ti/.\nLine 12 is necessary in KMP-MATCHER, because otherwise, we might refer-\nence P Œm C 1\u0002 on line 6 after ﬁnding an occurrence of P . (The argument that\nq D \t.Ti\u00031/ upon the next execution of line 6 remains valid by the hint given in\nExercise 32.4-8: ı.m; a/ D ı.\u0006Œm\u0002; a/ or, equivalently, \t.Pa/ D \t.P\u0003Œm\u0004a/ for\nany a 2 †.) The remaining argument for the correctness of the Knuth-Morris-\nPratt algorithm follows from the correctness of FINITE-AUTOMATON-MATCHER,\nsince we have shown that KMP-MATCHER simulates the behavior of FINITE-\nAUTOMATON-MATCHER.\nExercises\n32.4-1\nCompute the preﬁx function \u0006 for the pattern ababbabbabbababbabb.\n32.4-2\nGive an upper bound on the size of \u0006\u0004Œq\u0002 as a function of q. Give an example to\nshow that your bound is tight.\n32.4-3\nExplain how to determine the occurrences of pattern P in the text T by examining\nthe \u0006 function for the string P T (the string of length mCn that is the concatenation\nof P and T ).\n1012\nChapter 32\nString Matching\n32.4-4",
    "parent_b474fe05-9f15-4035-8acf-1576f0de0d6c": "show that your bound is tight.\n32.4-3\nExplain how to determine the occurrences of pattern P in the text T by examining\nthe \u0006 function for the string P T (the string of length mCn that is the concatenation\nof P and T ).\n1012\nChapter 32\nString Matching\n32.4-4\nUse an aggregate analysis to show that the running time of KMP-MATCHER\nis ‚.n/.\n32.4-5\nUse a potential function to show that the running time of KMP-MATCHER is ‚.n/.\n32.4-6\nShow how to improve KMP-MATCHER by replacing the occurrence of \u0006 in line 7\n(but not line 12) by \u00060, where \u00060 is deﬁned recursively for q D 1; 2; : : : ; m \u0005 1 by\nthe equation\n\u00060Œq\u0002 D\n\u0002\n0\nif \u0006Œq\u0002 D 0 ;\n\u00060Œ\u0006Œq\u0002\u0002\nif \u0006Œq\u0002 ¤ 0 and P Œ\u0006Œq\u0002 C 1\u0002 D P Œq C 1\u0002 ;\n\u0006Œq\u0002\nif \u0006Œq\u0002 ¤ 0 and P Œ\u0006Œq\u0002 C 1\u0002 ¤ P Œq C 1\u0002 :\nExplain why the modiﬁed algorithm is correct, and explain in what sense this\nchange constitutes an improvement.\n32.4-7\nGive a linear-time algorithm to determine whether a text T is a cyclic rotation of\nanother string T 0. For example, arc and car are cyclic rotations of each other.\n32.4-8\n?\nGive an O.m j†j/-time algorithm for computing the transition function ı for the\nstring-matching automaton corresponding to a given pattern P . (Hint: Prove that\nı.q; a/ D ı.\u0006Œq\u0002; a/ if q D m or P Œq C 1\u0002 ¤ a.)\nProblems\n32-1\nString matching based on repetition factors\nLet yi denote the concatenation of string y with itself i times.\nFor example,\n.ab/3 D ababab. We say that a string x 2 †\u0004 has repetition factor r if x D yr\nfor some string y 2 †\u0004 and some r > 0. Let \u000f.x/ denote the largest r such that x\nhas repetition factor r.\na. Give an efﬁcient algorithm that takes as input a pattern P Œ1 : : m\u0002 and computes\nthe value \u000f.Pi/ for i D 1; 2; : : : ; m. What is the running time of your algo-\nrithm?\nNotes for Chapter 32\n1013\nb. For any pattern P Œ1 : : m\u0002, let \u000f\u0004.P / be deﬁned as max1\u0005i\u0005m \u000f.Pi/. Prove that if\nthe pattern P is chosen randomly from the set of all binary strings of length m,\nthen the expected value of \u000f\u0004.P / is O.1/.",
    "parent_b610aff3-471e-43c1-a3de-bce29cc8dc16": "rithm?\nNotes for Chapter 32\n1013\nb. For any pattern P Œ1 : : m\u0002, let \u000f\u0004.P / be deﬁned as max1\u0005i\u0005m \u000f.Pi/. Prove that if\nthe pattern P is chosen randomly from the set of all binary strings of length m,\nthen the expected value of \u000f\u0004.P / is O.1/.\nc. Argue that the following string-matching algorithm correctly ﬁnds all occur-\nrences of pattern P in a text T Œ1 : : n\u0002 in time O.\u000f\u0004.P /n C m/:\nREPETITION-MATCHER.P; T /\n1\nm D P:length\n2\nn D T:length\n3\nk D 1 C \u000f\u0004.P /\n4\nq D 0\n5\ns D 0\n6\nwhile s \u0002 n \u0005 m\n7\nif T Œs C q C 1\u0002 == P Œq C 1\u0002\n8\nq D q C 1\n9\nif q == m\n10\nprint “Pattern occurs with shift” s\n11\nif q == m or T Œs C q C 1\u0002 ¤ P Œq C 1\u0002\n12\ns D s C max.1; dq=ke/\n13\nq D 0\nThis algorithm is due to Galil and Seiferas. By extending these ideas greatly,\nthey obtained a linear-time string-matching algorithm that uses only O.1/ stor-\nage beyond what is required for P and T .\nChapter notes\nThe relation of string matching to the theory of ﬁnite automata is discussed by\nAho, Hopcroft, and Ullman [5].\nThe Knuth-Morris-Pratt algorithm [214] was\ninvented independently by Knuth and Pratt and by Morris; they published their\nwork jointly. Reingold, Urban, and Gries [294] give an alternative treatment of the\nKnuth-Morris-Pratt algorithm. The Rabin-Karp algorithm was proposed by Karp\nand Rabin [201]. Galil and Seiferas [126] give an interesting deterministic linear-\ntime string-matching algorithm that uses only O.1/ space beyond that required to\nstore the pattern and text.\n33\nComputational Geometry\nComputational geometry is the branch of computer science that studies algorithms\nfor solving geometric problems. In modern engineering and mathematics, com-\nputational geometry has applications in such diverse ﬁelds as computer graphics,\nrobotics, VLSI design, computer-aided design, molecular modeling, metallurgy,\nmanufacturing, textile layout, forestry, and statistics. The input to a computational-\ngeometry problem is typically a description of a set of geometric objects, such as",
    "parent_ec1e60b1-b7c9-4766-9ee0-c2f154d02723": "robotics, VLSI design, computer-aided design, molecular modeling, metallurgy,\nmanufacturing, textile layout, forestry, and statistics. The input to a computational-\ngeometry problem is typically a description of a set of geometric objects, such as\na set of points, a set of line segments, or the vertices of a polygon in counterclock-\nwise order. The output is often a response to a query about the objects, such as\nwhether any of the lines intersect, or perhaps a new geometric object, such as the\nconvex hull (smallest enclosing convex polygon) of the set of points.\nIn this chapter, we look at a few computational-geometry algorithms in two\ndimensions, that is, in the plane.\nWe represent each input object by a set of\npoints fp1; p2; p3; : : :g, where each pi D .xi; yi/ and xi; yi 2 R. For exam-\nple, we represent an n-vertex polygon P by a sequence hp0; p1; p2; : : : ; pn\u00031i\nof its vertices in order of their appearance on the boundary of P . Computational\ngeometry can also apply to three dimensions, and even higher-dimensional spaces,\nbut such problems and their solutions can be very difﬁcult to visualize. Even in\ntwo dimensions, however, we can see a good sample of computational-geometry\ntechniques.\nSection 33.1 shows how to answer basic questions about line segments efﬁ-\nciently and accurately: whether one segment is clockwise or counterclockwise\nfrom another that shares an endpoint, which way we turn when traversing two\nadjoining line segments, and whether two line segments intersect. Section 33.2\npresents a technique called “sweeping” that we use to develop an O.n lg n/-time\nalgorithm for determining whether a set of n line segments contains any inter-\nsections. Section 33.3 gives two “rotational-sweep” algorithms that compute the\nconvex hull (smallest enclosing convex polygon) of a set of n points: Graham’s\nscan, which runs in time O.n lg n/, and Jarvis’s march, which takes O.nh/ time,\nwhere h is the number of vertices of the convex hull. Finally, Section 33.4 gives",
    "parent_04d104bf-8130-4039-9b5d-7b7cb69825fa": "convex hull (smallest enclosing convex polygon) of a set of n points: Graham’s\nscan, which runs in time O.n lg n/, and Jarvis’s march, which takes O.nh/ time,\nwhere h is the number of vertices of the convex hull. Finally, Section 33.4 gives\n33.1\nLine-segment properties\n1015\nan O.n lg n/-time divide-and-conquer algorithm for ﬁnding the closest pair of\npoints in a set of n points in the plane.\n33.1\nLine-segment properties\nSeveral of the computational-geometry algorithms in this chapter require answers\nto questions about the properties of line segments. A convex combination of two\ndistinct points p1 D .x1; y1/ and p2 D .x2; y2/ is any point p3 D .x3; y3/ such\nthat for some ˛ in the range 0 \u0002 ˛ \u0002 1, we have x3 D ˛x1 C .1 \u0005 ˛/x2 and\ny3 D ˛y1 C .1 \u0005 ˛/y2. We also write that p3 D ˛p1 C .1 \u0005 ˛/p2. Intuitively, p3\nis any point that is on the line passing through p1 and p2 and is on or between p1\nand p2 on the line. Given two distinct points p1 and p2, the line segment p1p2\nis the set of convex combinations of p1 and p2. We call p1 and p2 the endpoints\nof segment p1p2. Sometimes the ordering of p1 and p2 matters, and we speak of\nthe directed segment \u0005\u0005\u0005!\np1p2. If p1 is the origin .0; 0/, then we can treat the directed\nsegment \u0005\u0005\u0005!\np1p2 as the vector p2.\nIn this section, we shall explore the following questions:\n1. Given two directed segments \u0005\u0005\u0005!\np0p1 and \u0005\u0005\u0005!\np0p2, is \u0005\u0005\u0005!\np0p1 clockwise from \u0005\u0005\u0005!\np0p2\nwith respect to their common endpoint p0?\n2. Given two line segments p0p1 and p1p2, if we traverse p0p1 and then p1p2,\ndo we make a left turn at point p1?\n3. Do line segments p1p2 and p3p4 intersect?\nThere are no restrictions on the given points.\nWe can answer each question in O.1/ time, which should come as no surprise\nsince the input size of each question is O.1/. Moreover, our methods use only ad-\nditions, subtractions, multiplications, and comparisons. We need neither division\nnor trigonometric functions, both of which can be computationally expensive and",
    "parent_3a6aaafb-5b33-414e-ae84-a50ad73c68a9": "since the input size of each question is O.1/. Moreover, our methods use only ad-\nditions, subtractions, multiplications, and comparisons. We need neither division\nnor trigonometric functions, both of which can be computationally expensive and\nprone to problems with round-off error. For example, the “straightforward” method\nof determining whether two segments intersect—compute the line equation of the\nform y D mx C b for each segment (m is the slope and b is the y-intercept),\nﬁnd the point of intersection of the lines, and check whether this point is on both\nsegments—uses division to ﬁnd the point of intersection. When the segments are\nnearly parallel, this method is very sensitive to the precision of the division opera-\ntion on real computers. The method in this section, which avoids division, is much\nmore accurate.\n1016\nChapter 33\nComputational Geometry\np2\nx\ny\n(0,0)\np1\np1 + p2\n(a)\n(b)\ny\nx\n(0,0)\np\nFigure 33.1\n(a) The cross product of vectors p1 and p2 is the signed area of the parallelogram.\n(b) The lightly shaded region contains vectors that are clockwise from p. The darkly shaded region\ncontains vectors that are counterclockwise from p.\nCross products\nComputing cross products lies at the heart of our line-segment methods. Consider\nvectors p1 and p2, shown in Figure 33.1(a). We can interpret the cross product\np1 \t p2 as the signed area of the parallelogram formed by the points .0; 0/, p1, p2,\nand p1 Cp2 D .x1 Cx2; y1 Cy2/. An equivalent, but more useful, deﬁnition gives\nthe cross product as the determinant of a matrix:1\np1 \t p2\nD\ndet\n\u0002 x1\nx2\ny1\ny2\n\u0003\nD\nx1y2 \u0005 x2y1\nD\n\u0005p2 \t p1 :\nIf p1\tp2 is positive, then p1 is clockwise from p2 with respect to the origin .0; 0/;\nif this cross product is negative, then p1 is counterclockwise from p2. (See Exer-\ncise 33.1-1.) Figure 33.1(b) shows the clockwise and counterclockwise regions\nrelative to a vector p. A boundary condition arises if the cross product is 0; in this",
    "parent_29a15f43-45df-4085-9090-9494def83168": "if this cross product is negative, then p1 is counterclockwise from p2. (See Exer-\ncise 33.1-1.) Figure 33.1(b) shows the clockwise and counterclockwise regions\nrelative to a vector p. A boundary condition arises if the cross product is 0; in this\ncase, the vectors are colinear, pointing in either the same or opposite directions.\nTo determine whether a directed segment \u0005\u0005\u0005!\np0p1 is closer to a directed seg-\nment \u0005\u0005\u0005!\np0p2 in a clockwise direction or in a counterclockwise direction with respect\nto their common endpoint p0, we simply translate to use p0 as the origin. That\nis, we let p1 \u0005 p0 denote the vector p0\n1 D .x0\n1; y0\n1/, where x0\n1 D x1 \u0005 x0 and\ny0\n1 D y1 \u0005y0, and we deﬁne p2 \u0005p0 similarly. We then compute the cross product\n1Actually, the cross product is a three-dimensional concept. It is a vector that is perpendicular to\nboth p1 and p2 according to the “right-hand rule” and whose magnitude is jx1y2 \u0005 x2y1j. In this\nchapter, however, we ﬁnd it convenient to treat the cross product simply as the value x1y2 \u0005 x2y1.\n33.1\nLine-segment properties\n1017\np0\np1\np2\np0\np1\np2\ncounterclockwise\n(a)\n(b)\nclockwise\nFigure 33.2\nUsing the cross product to determine how consecutive line segments p0p1 and p1p2\nturn at point p1. We check whether the directed segment \u0005\u0005\u0005!\np0p2 is clockwise or counterclockwise\nrelative to the directed segment \u0005\u0005\u0005!\np0p1. (a) If counterclockwise, the points make a left turn. (b) If\nclockwise, they make a right turn.\n.p1 \u0005 p0/ \t .p2 \u0005 p0/ D .x1 \u0005 x0/.y2 \u0005 y0/ \u0005 .x2 \u0005 x0/.y1 \u0005 y0/ :\nIf this cross product is positive, then \u0005\u0005\u0005!\np0p1 is clockwise from \u0005\u0005\u0005!\np0p2; if negative, it\nis counterclockwise.\nDetermining whether consecutive segments turn left or right\nOur next question is whether two consecutive line segments p0p1 and p1p2 turn\nleft or right at point p1. Equivalently, we want a method to determine which way a\ngiven angle †p0p1p2 turns. Cross products allow us to answer this question with-",
    "parent_6c82b313-19f0-4e52-9697-bb2fc69dfd51": "Our next question is whether two consecutive line segments p0p1 and p1p2 turn\nleft or right at point p1. Equivalently, we want a method to determine which way a\ngiven angle †p0p1p2 turns. Cross products allow us to answer this question with-\nout computing the angle. As Figure 33.2 shows, we simply check whether directed\nsegment \u0005\u0005\u0005!\np0p2 is clockwise or counterclockwise relative to directed segment \u0005\u0005\u0005!\np0p1.\nTo do so, we compute the cross product .p2 \u0005 p0/ \t .p1 \u0005 p0/. If the sign of\nthis cross product is negative, then \u0005\u0005\u0005!\np0p2 is counterclockwise with respect to \u0005\u0005\u0005!\np0p1,\nand thus we make a left turn at p1. A positive cross product indicates a clockwise\norientation and a right turn. A cross product of 0 means that points p0, p1, and p2\nare colinear.\nDetermining whether two line segments intersect\nTo determine whether two line segments intersect, we check whether each segment\nstraddles the line containing the other. A segment p1p2 straddles a line if point p1\nlies on one side of the line and point p2 lies on the other side. A boundary case\narises if p1 or p2 lies directly on the line. Two line segments intersect if and only\nif either (or both) of the following conditions holds:\n1. Each segment straddles the line containing the other.\n2. An endpoint of one segment lies on the other segment. (This condition comes\nfrom the boundary case.)\n1018\nChapter 33\nComputational Geometry\nThe following procedures implement this idea. SEGMENTS-INTERSECT returns\nTRUE if segments p1p2 and p3p4 intersect and FALSE if they do not. It calls\nthe subroutines DIRECTION, which computes relative orientations using the cross-\nproduct method above, and ON-SEGMENT, which determines whether a point\nknown to be colinear with a segment lies on that segment.\nSEGMENTS-INTERSECT.p1; p2; p3; p4/\n1\nd1 D DIRECTION.p3; p4; p1/\n2\nd2 D DIRECTION.p3; p4; p2/\n3\nd3 D DIRECTION.p1; p2; p3/\n4\nd4 D DIRECTION.p1; p2; p4/\n5\nif ..d1 > 0 and d2 < 0/ or .d1 < 0 and d2 > 0// and",
    "parent_3520ce0b-4aea-4d55-b3db-e39bd065c9c1": "known to be colinear with a segment lies on that segment.\nSEGMENTS-INTERSECT.p1; p2; p3; p4/\n1\nd1 D DIRECTION.p3; p4; p1/\n2\nd2 D DIRECTION.p3; p4; p2/\n3\nd3 D DIRECTION.p1; p2; p3/\n4\nd4 D DIRECTION.p1; p2; p4/\n5\nif ..d1 > 0 and d2 < 0/ or .d1 < 0 and d2 > 0// and\n..d3 > 0 and d4 < 0/ or .d3 < 0 and d4 > 0//\n6\nreturn TRUE\n7\nelseif d1 == 0 and ON-SEGMENT.p3; p4; p1/\n8\nreturn TRUE\n9\nelseif d2 == 0 and ON-SEGMENT.p3; p4; p2/\n10\nreturn TRUE\n11\nelseif d3 == 0 and ON-SEGMENT.p1; p2; p3/\n12\nreturn TRUE\n13\nelseif d4 == 0 and ON-SEGMENT.p1; p2; p4/\n14\nreturn TRUE\n15\nelse return FALSE\nDIRECTION.pi; pj; pk/\n1\nreturn .pk \u0005 pi/ \t .pj \u0005 pi/\nON-SEGMENT.pi; pj; pk/\n1\nif min.xi; xj/ \u0002 xk \u0002 max.xi; xj/ and min.yi; yj/ \u0002 yk \u0002 max.yi; yj/\n2\nreturn TRUE\n3\nelse return FALSE\nSEGMENTS-INTERSECT works as follows. Lines 1–4 compute the relative ori-\nentation di of each endpoint pi with respect to the other segment. If all the relative\norientations are nonzero, then we can easily determine whether segments p1p2\nand p3p4 intersect, as follows. Segment p1p2 straddles the line containing seg-\nment p3p4 if directed segments \u0005\u0005\u0005!\np3p1 and \u0005\u0005\u0005!\np3p2 have opposite orientations relative\nto \u0005\u0005\u0005!\np3p4. In this case, the signs of d1 and d2 differ. Similarly, p3p4 straddles\nthe line containing p1p2 if the signs of d3 and d4 differ. If the test of line 5 is\ntrue, then the segments straddle each other, and SEGMENTS-INTERSECT returns\nTRUE. Figure 33.3(a) shows this case. Otherwise, the segments do not straddle\n33.1\nLine-segment properties\n1019\np1\np2\np3\np4\n(p1–p3) × (p4–p3) < 0\n(p4–p1) × (p2–p1) < 0\n(p2–p3) × (p4–p3) > 0\n(p3–p1) × (p2–p1) > 0\n(a)\np1\np2\np3\np4\n(p1–p3) × (p4–p3) < 0\n(p4–p1) × (p2–p1) < 0\n(p2–p3) × (p4–p3) < 0\n(p3–p1) × (p2–p1) > 0\n(b)\np1\np2\np3\np4\n(c)\np1\np2\np3\np4\n(d)\nFigure 33.3\nCases in the procedure SEGMENTS-INTERSECT. (a) The segments p1p2 and p3p4\nstraddle each other’s lines. Because p3p4 straddles the line containing p1p2, the signs of the cross",
    "parent_6f0d5fec-2e52-499a-8ed0-f521d317ffc1": "(p4–p1) × (p2–p1) < 0\n(p2–p3) × (p4–p3) < 0\n(p3–p1) × (p2–p1) > 0\n(b)\np1\np2\np3\np4\n(c)\np1\np2\np3\np4\n(d)\nFigure 33.3\nCases in the procedure SEGMENTS-INTERSECT. (a) The segments p1p2 and p3p4\nstraddle each other’s lines. Because p3p4 straddles the line containing p1p2, the signs of the cross\nproducts .p3 \u0005 p1/ \t .p2 \u0005 p1/ and .p4 \u0005 p1/ \t .p2 \u0005 p1/ differ. Because p1p2 straddles the line\ncontaining p3p4, the signs of the cross products .p1 \u0005 p3/ \t .p4 \u0005 p3/ and .p2 \u0005 p3/ \t .p4 \u0005 p3/\ndiffer. (b) Segment p3p4 straddles the line containing p1p2, but p1p2 does not straddle the line\ncontaining p3p4. The signs of the cross products .p1 \u0005 p3/ \t .p4 \u0005 p3/ and .p2 \u0005 p3/ \t .p4 \u0005 p3/\nare the same. (c) Point p3 is colinear with p1p2 and is between p1 and p2. (d) Point p3 is colinear\nwith p1p2, but it is not between p1 and p2. The segments do not intersect.\neach other’s lines, although a boundary case may apply. If all the relative orienta-\ntions are nonzero, no boundary case applies. All the tests against 0 in lines 7–13\nthen fail, and SEGMENTS-INTERSECT returns FALSE in line 15. Figure 33.3(b)\nshows this case.\nA boundary case occurs if any relative orientation dk is 0. Here, we know that pk\nis colinear with the other segment. It is directly on the other segment if and only\nif it is between the endpoints of the other segment. The procedure ON-SEGMENT\nreturns whether pk is between the endpoints of segment pipj, which will be the\nother segment when called in lines 7–13; the procedure assumes that pk is colinear\nwith segment pipj. Figures 33.3(c) and (d) show cases with colinear points. In\nFigure 33.3(c), p3 is on p1p2, and so SEGMENTS-INTERSECT returns TRUE in\nline 12. No endpoints are on other segments in Figure 33.3(d), and so SEGMENTS-\nINTERSECT returns FALSE in line 15.\n1020\nChapter 33\nComputational Geometry\nOther applications of cross products\nLater sections of this chapter introduce additional uses for cross products. In Sec-",
    "parent_b7dba08f-ab68-4cd6-99b2-2dd0ad8ed807": "line 12. No endpoints are on other segments in Figure 33.3(d), and so SEGMENTS-\nINTERSECT returns FALSE in line 15.\n1020\nChapter 33\nComputational Geometry\nOther applications of cross products\nLater sections of this chapter introduce additional uses for cross products. In Sec-\ntion 33.3, we shall need to sort a set of points according to their polar angles with\nrespect to a given origin. As Exercise 33.1-3 asks you to show, we can use cross\nproducts to perform the comparisons in the sorting procedure. In Section 33.2, we\nshall use red-black trees to maintain the vertical ordering of a set of line segments.\nRather than keeping explicit key values which we compare to each other in the\nred-black tree code, we shall compute a cross-product to determine which of two\nsegments that intersect a given vertical line is above the other.\nExercises\n33.1-1\nProve that if p1 \t p2 is positive, then vector p1 is clockwise from vector p2 with\nrespect to the origin .0; 0/ and that if this cross product is negative, then p1 is\ncounterclockwise from p2.\n33.1-2\nProfessor van Pelt proposes that only the x-dimension needs to be tested in line 1\nof ON-SEGMENT. Show why the professor is wrong.\n33.1-3\nThe polar angle of a point p1 with respect to an origin point p0 is the angle of the\nvector p1 \u0005 p0 in the usual polar coordinate system. For example, the polar angle\nof .3; 5/ with respect to .2; 4/ is the angle of the vector .1; 1/, which is 45 degrees\nor \u0006=4 radians. The polar angle of .3; 3/ with respect to .2; 4/ is the angle of the\nvector .1; \u00051/, which is 315 degrees or 7\u0006=4 radians. Write pseudocode to sort a\nsequence hp1; p2; : : : ; pni of n points according to their polar angles with respect\nto a given origin point p0. Your procedure should take O.n lg n/ time and use cross\nproducts to compare angles.\n33.1-4\nShow how to determine in O.n2 lg n/ time whether any three points in a set of n\npoints are colinear.\n33.1-5",
    "parent_9486e95d-c9aa-4644-ad53-30900655303d": "to a given origin point p0. Your procedure should take O.n lg n/ time and use cross\nproducts to compare angles.\n33.1-4\nShow how to determine in O.n2 lg n/ time whether any three points in a set of n\npoints are colinear.\n33.1-5\nA polygon is a piecewise-linear, closed curve in the plane. That is, it is a curve\nending on itself that is formed by a sequence of straight-line segments, called the\nsides of the polygon. A point joining two consecutive sides is a vertex of the poly-\ngon. If the polygon is simple, as we shall generally assume, it does not cross itself.\nThe set of points in the plane enclosed by a simple polygon forms the interior of\n33.2\nDetermining whether any pair of segments intersects\n1021\nthe polygon, the set of points on the polygon itself forms its boundary, and the set\nof points surrounding the polygon forms its exterior. A simple polygon is convex\nif, given any two points on its boundary or in its interior, all points on the line\nsegment drawn between them are contained in the polygon’s boundary or interior.\nA vertex of a convex polygon cannot be expressed as a convex combination of any\ntwo distinct points on the boundary or in the interior of the polygon.\nProfessor Amundsen proposes the following method to determine whether a se-\nquence hp0; p1; : : : ; pn\u00031i of n points forms the consecutive vertices of a convex\npolygon. Output “yes” if the set f†pipiC1piC2 W i D 0; 1; : : : ; n \u0005 1g, where sub-\nscript addition is performed modulo n, does not contain both left turns and right\nturns; otherwise, output “no.” Show that although this method runs in linear time,\nit does not always produce the correct answer. Modify the professor’s method so\nthat it always produces the correct answer in linear time.\n33.1-6\nGiven a point p0 D .x0; y0/, the right horizontal ray from p0 is the set of points\nfpi D .xi; yi/ W xi \u0006 x0 and yi D y0g, that is, it is the set of points due right of p0\nalong with p0 itself. Show how to determine whether a given right horizontal ray",
    "parent_072a699c-c0f2-445d-ac5a-05149d87662e": "33.1-6\nGiven a point p0 D .x0; y0/, the right horizontal ray from p0 is the set of points\nfpi D .xi; yi/ W xi \u0006 x0 and yi D y0g, that is, it is the set of points due right of p0\nalong with p0 itself. Show how to determine whether a given right horizontal ray\nfrom p0 intersects a line segment p1p2 in O.1/ time by reducing the problem to\nthat of determining whether two line segments intersect.\n33.1-7\nOne way to determine whether a point p0 is in the interior of a simple, but not\nnecessarily convex, polygon P is to look at any ray from p0 and check that the ray\nintersects the boundary of P an odd number of times but that p0 itself is not on\nthe boundary of P . Show how to compute in ‚.n/ time whether a point p0 is in\nthe interior of an n-vertex polygon P . (Hint: Use Exercise 33.1-6. Make sure your\nalgorithm is correct when the ray intersects the polygon boundary at a vertex and\nwhen the ray overlaps a side of the polygon.)\n33.1-8\nShow how to compute the area of an n-vertex simple, but not necessarily convex,\npolygon in ‚.n/ time. (See Exercise 33.1-5 for deﬁnitions pertaining to polygons.)\n33.2\nDetermining whether any pair of segments intersects\nThis section presents an algorithm for determining whether any two line segments\nin a set of segments intersect. The algorithm uses a technique known as “sweep-\ning,” which is common to many computational-geometry algorithms. Moreover, as\n1022\nChapter 33\nComputational Geometry\nthe exercises at the end of this section show, this algorithm, or simple variations of\nit, can help solve other computational-geometry problems.\nThe algorithm runs in O.n lg n/ time, where n is the number of segments we are\ngiven. It determines only whether or not any intersection exists; it does not print\nall the intersections. (By Exercise 33.2-1, it takes \u0004.n2/ time in the worst case to\nﬁnd all the intersections in a set of n line segments.)\nIn sweeping, an imaginary vertical sweep line passes through the given set of",
    "parent_119b6073-dc25-48aa-a23a-8fccfad16630": "all the intersections. (By Exercise 33.2-1, it takes \u0004.n2/ time in the worst case to\nﬁnd all the intersections in a set of n line segments.)\nIn sweeping, an imaginary vertical sweep line passes through the given set of\ngeometric objects, usually from left to right. We treat the spatial dimension that\nthe sweep line moves across, in this case the x-dimension, as a dimension of\ntime. Sweeping provides a method for ordering geometric objects, usually by plac-\ning them into a dynamic data structure, and for taking advantage of relationships\namong them. The line-segment-intersection algorithm in this section considers all\nthe line-segment endpoints in left-to-right order and checks for an intersection each\ntime it encounters an endpoint.\nTo describe and prove correct our algorithm for determining whether any two\nof n line segments intersect, we shall make two simplifying assumptions. First, we\nassume that no input segment is vertical. Second, we assume that no three input\nsegments intersect at a single point. Exercises 33.2-8 and 33.2-9 ask you to show\nthat the algorithm is robust enough that it needs only a slight modiﬁcation to work\neven when these assumptions do not hold. Indeed, removing such simplifying\nassumptions and dealing with boundary conditions often present the most difﬁcult\nchallenges when programming computational-geometry algorithms and proving\ntheir correctness.\nOrdering segments\nBecause we assume that there are no vertical segments, we know that any input\nsegment intersecting a given vertical sweep line intersects it at a single point. Thus,\nwe can order the segments that intersect a vertical sweep line according to the y-\ncoordinates of the points of intersection.\nTo be more precise, consider two segments s1 and s2. We say that these segments\nare comparable at x if the vertical sweep line with x-coordinate x intersects both of\nthem. We say that s1 is above s2 at x, written s1 <x s2, if s1 and s2 are comparable",
    "parent_5696dbaf-5dec-4588-a25b-7bcf519b0953": "coordinates of the points of intersection.\nTo be more precise, consider two segments s1 and s2. We say that these segments\nare comparable at x if the vertical sweep line with x-coordinate x intersects both of\nthem. We say that s1 is above s2 at x, written s1 <x s2, if s1 and s2 are comparable\nat x and the intersection of s1 with the sweep line at x is higher than the intersection\nof s2 with the same sweep line, or if s1 and s2 intersect at the sweep line. In\nFigure 33.4(a), for example, we have the relationships a <r c, a <t b, b <t c,\na <t c, and b <u c. Segment d is not comparable with any other segment.\nFor any given x, the relation “<x” is a total preorder (see Section B.2) for all\nsegments that intersect the sweep line at x. That is, the relation is transitive, and\nif segments s1 and s2 each intersect the sweep line at x, then either s1 <x s2\nor s2 <x s1, or both (if s1 and s2 intersect at the sweep line). (The relation <x is\n33.2\nDetermining whether any pair of segments intersects\n1023\nr\nt\nu\na\nc\nb\nd\n(a)\n(b)\nv\nw\ne\nf\ng\nh\ni\nz\nFigure 33.4\nThe ordering among line segments at various vertical sweep lines. (a) We have a <r c,\na <t b, b <t c, a <t c, and b <u c. Segment d is comparable with no other segment shown.\n(b) When segments e and f intersect, they reverse their orders: we have e <\u0005 f but f <w e. Any\nsweep line (such as ´) that passes through the shaded region has e and f consecutive in the ordering\ngiven by the relation <´.\nalso reﬂexive, but neither symmetric nor antisymmetric.) The total preorder may\ndiffer for differing values of x, however, as segments enter and leave the ordering.\nA segment enters the ordering when its left endpoint is encountered by the sweep,\nand it leaves the ordering when its right endpoint is encountered.\nWhat happens when the sweep line passes through the intersection of two seg-\nments? As Figure 33.4(b) shows, the segments reverse their positions in the total",
    "parent_a5469c66-4b75-46c9-b4f4-28c4f8fd0537": "and it leaves the ordering when its right endpoint is encountered.\nWhat happens when the sweep line passes through the intersection of two seg-\nments? As Figure 33.4(b) shows, the segments reverse their positions in the total\npreorder. Sweep lines \u0003 and w are to the left and right, respectively, of the point\nof intersection of segments e and f , and we have e <\u0005 f and f <w e. Note\nthat because we assume that no three segments intersect at the same point, there\nmust be some vertical sweep line x for which intersecting segments e and f are\nconsecutive in the total preorder <x. Any sweep line that passes through the shaded\nregion of Figure 33.4(b), such as ´, has e and f consecutive in its total preorder.\nMoving the sweep line\nSweeping algorithms typically manage two sets of data:\n1. The sweep-line status gives the relationships among the objects that the sweep\nline intersects.\n2. The event-point schedule is a sequence of points, called event points, which\nwe order from left to right according to their x-coordinates. As the sweep\nprogresses from left to right, whenever the sweep line reaches the x-coordinate\nof an event point, the sweep halts, processes the event point, and then resumes.\nChanges to the sweep-line status occur only at event points.\nFor some algorithms (the algorithm asked for in Exercise 33.2-7, for example),\nthe event-point schedule develops dynamically as the algorithm progresses. The al-\ngorithm at hand, however, determines all the event points before the sweep, based\n1024\nChapter 33\nComputational Geometry\nsolely on simple properties of the input data. In particular, each segment endpoint\nis an event point. We sort the segment endpoints by increasing x-coordinate and\nproceed from left to right. (If two or more endpoints are covertical, i.e., they have\nthe same x-coordinate, we break the tie by putting all the covertical left endpoints\nbefore the covertical right endpoints. Within a set of covertical left endpoints, we",
    "parent_f6624678-8831-48bd-ab2c-ec95be0d977a": "proceed from left to right. (If two or more endpoints are covertical, i.e., they have\nthe same x-coordinate, we break the tie by putting all the covertical left endpoints\nbefore the covertical right endpoints. Within a set of covertical left endpoints, we\nput those with lower y-coordinates ﬁrst, and we do the same within a set of cover-\ntical right endpoints.) When we encounter a segment’s left endpoint, we insert the\nsegment into the sweep-line status, and we delete the segment from the sweep-line\nstatus upon encountering its right endpoint. Whenever two segments ﬁrst become\nconsecutive in the total preorder, we check whether they intersect.\nThe sweep-line status is a total preorder T , for which we require the following\noperations:\n\u0002\nINSERT.T; s/: insert segment s into T .\n\u0002\nDELETE.T; s/: delete segment s from T .\n\u0002\nABOVE.T; s/: return the segment immediately above segment s in T .\n\u0002\nBELOW.T; s/: return the segment immediately below segment s in T .\nIt is possible for segments s1 and s2 to be mutually above each other in the total\npreorder T ; this situation can occur if s1 and s2 intersect at the sweep line whose\ntotal preorder is given by T . In this case, the two segments may appear in either\norder in T .\nIf the input contains n segments, we can perform each of the operations INSERT,\nDELETE, ABOVE, and BELOW in O.lg n/ time using red-black trees. Recall that\nthe red-black-tree operations in Chapter 13 involve comparing keys. We can re-\nplace the key comparisons by comparisons that use cross products to determine the\nrelative ordering of two segments (see Exercise 33.2-2).\nSegment-intersection pseudocode\nThe following algorithm takes as input a set S of n line segments, returning the\nboolean value TRUE if any pair of segments in S intersects, and FALSE otherwise.\nA red-black tree maintains the total preorder T .\n33.2\nDetermining whether any pair of segments intersects\n1025\nANY-SEGMENTS-INTERSECT.S/\n1\nT D ;\n2",
    "parent_6076f43d-9ed9-416a-b5fe-20d1bc65492d": "boolean value TRUE if any pair of segments in S intersects, and FALSE otherwise.\nA red-black tree maintains the total preorder T .\n33.2\nDetermining whether any pair of segments intersects\n1025\nANY-SEGMENTS-INTERSECT.S/\n1\nT D ;\n2\nsort the endpoints of the segments in S from left to right,\nbreaking ties by putting left endpoints before right endpoints\nand breaking further ties by putting points with lower\ny-coordinates ﬁrst\n3\nfor each point p in the sorted list of endpoints\n4\nif p is the left endpoint of a segment s\n5\nINSERT.T; s/\n6\nif (ABOVE.T; s/ exists and intersects s)\nor (BELOW.T; s/ exists and intersects s)\n7\nreturn TRUE\n8\nif p is the right endpoint of a segment s\n9\nif both ABOVE.T; s/ and BELOW.T; s/ exist\nand ABOVE.T; s/ intersects BELOW.T; s/\n10\nreturn TRUE\n11\nDELETE.T; s/\n12\nreturn FALSE\nFigure 33.5 illustrates how the algorithm works. Line 1 initializes the total preorder\nto be empty. Line 2 determines the event-point schedule by sorting the 2n segment\nendpoints from left to right, breaking ties as described above. One way to perform\nline 2 is by lexicographically sorting the endpoints on .x; e; y/, where x and y are\nthe usual coordinates, e D 0 for a left endpoint, and e D 1 for a right endpoint.\nEach iteration of the for loop of lines 3–11 processes one event point p. If p is\nthe left endpoint of a segment s, line 5 adds s to the total preorder, and lines 6–7\nreturn TRUE if s intersects either of the segments it is consecutive with in the total\npreorder deﬁned by the sweep line passing through p. (A boundary condition\noccurs if p lies on another segment s0. In this case, we require only that s and s0\nbe placed consecutively into T .) If p is the right endpoint of a segment s, then\nwe need to delete s from the total preorder. But ﬁrst, lines 9–10 return TRUE if\nthere is an intersection between the segments surrounding s in the total preorder\ndeﬁned by the sweep line passing through p. If these segments do not intersect,",
    "parent_6d838cbb-9e55-4dee-a4fa-9ce61e32fbba": "we need to delete s from the total preorder. But ﬁrst, lines 9–10 return TRUE if\nthere is an intersection between the segments surrounding s in the total preorder\ndeﬁned by the sweep line passing through p. If these segments do not intersect,\nline 11 deletes segment s from the total preorder. If the segments surrounding\nsegment s intersect, they would have become consecutive after deleting s had the\nreturn statement in line 10 not prevented line 11 from executing. The correctness\nargument, which follows, will make it clear why it sufﬁces to check the segments\nsurrounding s. Finally, if we never ﬁnd any intersections after having processed\nall 2n event points, line 12 returns FALSE.\n1026\nChapter 33\nComputational Geometry\na\na\nb\na\nc\nb\nd\na\nc\nb\nd\nc\nb\ne\nd\nc\nb\na\nb\nc\nd\ne\nf\ntime\nFigure 33.5\nThe execution of ANY-SEGMENTS-INTERSECT. Each dashed line is the sweep line at\nan event point. Except for the rightmost sweep line, the ordering of segment names below each sweep\nline corresponds to the total preorder T at the end of the for loop processing the corresponding event\npoint. The rightmost sweep line occurs when processing the right endpoint of segment c; because\nsegments d and b surround c and intersect each other, the procedure returns TRUE.\nCorrectness\nTo show that ANY-SEGMENTS-INTERSECT is correct, we will prove that the call\nANY-SEGMENTS-INTERSECT.S/ returns TRUE if and only if there is an intersec-\ntion among the segments in S.\nIt is easy to see that ANY-SEGMENTS-INTERSECT returns TRUE (on lines 7\nand 10) only if it ﬁnds an intersection between two of the input segments. Hence,\nif it returns TRUE, there is an intersection.\nWe also need to show the converse: that if there is an intersection, then ANY-\nSEGMENTS-INTERSECT returns TRUE. Let us suppose that there is at least one\nintersection. Let p be the leftmost intersection point, breaking ties by choosing the\npoint with the lowest y-coordinate, and let a and b be the segments that intersect",
    "parent_11219b7a-17d3-4a83-a232-8992b42fd955": "SEGMENTS-INTERSECT returns TRUE. Let us suppose that there is at least one\nintersection. Let p be the leftmost intersection point, breaking ties by choosing the\npoint with the lowest y-coordinate, and let a and b be the segments that intersect\nat p. Since no intersections occur to the left of p, the order given by T is correct at\nall points to the left of p. Because no three segments intersect at the same point, a\nand b become consecutive in the total preorder at some sweep line ´.2 Moreover,\n´ is to the left of p or goes through p. Some segment endpoint q on sweep line ´\n2If we allow three segments to intersect at the same point, there may be an intervening segment c that\nintersects both a and b at point p. That is, we may have a <w c and c <w b for all sweep lines w to\nthe left of p for which a <w b. Exercise 33.2-8 asks you to show that ANY-SEGMENTS-INTERSECT\nis correct even if three segments do intersect at the same point.\n33.2\nDetermining whether any pair of segments intersects\n1027\nis the event point at which a and b become consecutive in the total preorder. If p\nis on sweep line ´, then q D p. If p is not on sweep line ´, then q is to the left\nof p. In either case, the order given by T is correct just before encountering q.\n(Here is where we use the lexicographic order in which the algorithm processes\nevent points. Because p is the lowest of the leftmost intersection points, even if p\nis on sweep line ´ and some other intersection point p0 is on ´, event point q D p\nis processed before the other intersection p0 can interfere with the total preorder T .\nMoreover, even if p is the left endpoint of one segment, say a, and the right end-\npoint of the other segment, say b, because left endpoint events occur before right\nendpoint events, segment b is in T upon ﬁrst encountering segment a.) Either event\npoint q is processed by ANY-SEGMENTS-INTERSECT or it is not processed.\nIf q is processed by ANY-SEGMENTS-INTERSECT, only two possible actions\nmay occur:",
    "parent_c7dcf096-6d1d-41c8-9fc6-c2405e5b93a1": "endpoint events, segment b is in T upon ﬁrst encountering segment a.) Either event\npoint q is processed by ANY-SEGMENTS-INTERSECT or it is not processed.\nIf q is processed by ANY-SEGMENTS-INTERSECT, only two possible actions\nmay occur:\n1. Either a or b is inserted into T , and the other segment is above or below it in\nthe total preorder. Lines 4–7 detect this case.\n2. Segments a and b are already in T , and a segment between them in the total\npreorder is deleted, making a and b become consecutive. Lines 8–11 detect this\ncase.\nIn either case, we ﬁnd the intersection p and ANY-SEGMENTS-INTERSECT returns\nTRUE.\nIf event point q is not processed by ANY-SEGMENTS-INTERSECT, the proce-\ndure must have returned before processing all event points. This situation could\nhave occurred only if ANY-SEGMENTS-INTERSECT had already found an inter-\nsection and returned TRUE.\nThus, if there is an intersection, ANY-SEGMENTS-INTERSECT returns TRUE.\nAs we have already seen, if ANY-SEGMENTS-INTERSECT returns TRUE, there is\nan intersection. Therefore, ANY-SEGMENTS-INTERSECT always returns a correct\nanswer.\nRunning time\nIf set S contains n segments, then ANY-SEGMENTS-INTERSECT runs in time\nO.n lg n/. Line 1 takes O.1/ time. Line 2 takes O.n lg n/ time, using merge\nsort or heapsort. The for loop of lines 3–11 iterates at most once per event point,\nand so with 2n event points, the loop iterates at most 2n times. Each iteration takes\nO.lg n/ time, since each red-black-tree operation takes O.lg n/ time and, using the\nmethod of Section 33.1, each intersection test takes O.1/ time. The total time is\nthus O.n lg n/.\n1028\nChapter 33\nComputational Geometry\nExercises\n33.2-1\nShow that a set of n line segments may contain ‚.n2/ intersections.\n33.2-2\nGiven two segments a and b that are comparable at x, show how to determine\nin O.1/ time which of a <x b or b <x a holds. Assume that neither segment\nis vertical. (Hint: If a and b do not intersect, you can just use cross products.",
    "parent_665a7464-1927-4fb4-b651-d674093fb78d": "33.2-2\nGiven two segments a and b that are comparable at x, show how to determine\nin O.1/ time which of a <x b or b <x a holds. Assume that neither segment\nis vertical. (Hint: If a and b do not intersect, you can just use cross products.\nIf a and b intersect—which you can of course determine using only cross prod-\nucts—you can still use only addition, subtraction, and multiplication, avoiding\ndivision. Of course, in the application of the <x relation used here, if a and b\nintersect, we can just stop and declare that we have found an intersection.)\n33.2-3\nProfessor Mason suggests that we modify ANY-SEGMENTS-INTERSECT so that\ninstead of returning upon ﬁnding an intersection, it prints the segments that inter-\nsect and continues on to the next iteration of the for loop. The professor calls the\nresulting procedure PRINT-INTERSECTING-SEGMENTS and claims that it prints\nall intersections, from left to right, as they occur in the set of line segments. Pro-\nfessor Dixon disagrees, claiming that Professor Mason’s idea is incorrect. Which\nprofessor is right? Will PRINT-INTERSECTING-SEGMENTS always ﬁnd the left-\nmost intersection ﬁrst? Will it always ﬁnd all the intersections?\n33.2-4\nGive an O.n lg n/-time algorithm to determine whether an n-vertex polygon is\nsimple.\n33.2-5\nGive an O.n lg n/-time algorithm to determine whether two simple polygons with\na total of n vertices intersect.\n33.2-6\nA disk consists of a circle plus its interior and is represented by its center point and\nradius. Two disks intersect if they have any point in common. Give an O.n lg n/-\ntime algorithm to determine whether any two disks in a set of n intersect.\n33.2-7\nGiven a set of n line segments containing a total of k intersections, show how to\noutput all k intersections in O..n C k/ lg n/ time.\n33.3\nFinding the convex hull\n1029\n33.2-8\nArgue that ANY-SEGMENTS-INTERSECT works correctly even if three or more\nsegments intersect at the same point.\n33.2-9",
    "parent_ce21a5ef-c804-443e-bd46-b99b13fd22e1": "33.2-7\nGiven a set of n line segments containing a total of k intersections, show how to\noutput all k intersections in O..n C k/ lg n/ time.\n33.3\nFinding the convex hull\n1029\n33.2-8\nArgue that ANY-SEGMENTS-INTERSECT works correctly even if three or more\nsegments intersect at the same point.\n33.2-9\nShow that ANY-SEGMENTS-INTERSECT works correctly in the presence of verti-\ncal segments if we treat the bottom endpoint of a vertical segment as if it were a\nleft endpoint and the top endpoint as if it were a right endpoint. How does your\nanswer to Exercise 33.2-2 change if we allow vertical segments?\n33.3\nFinding the convex hull\nThe convex hull of a set Q of points, denoted by CH.Q/, is the smallest convex\npolygon P for which each point in Q is either on the boundary of P or in its\ninterior. (See Exercise 33.1-5 for a precise deﬁnition of a convex polygon.) We\nimplicitly assume that all points in the set Q are unique and that Q contains at\nleast three points which are not colinear. Intuitively, we can think of each point\nin Q as being a nail sticking out from a board. The convex hull is then the shape\nformed by a tight rubber band that surrounds all the nails. Figure 33.6 shows a set\nof points and its convex hull.\nIn this section, we shall present two algorithms that compute the convex hull\nof a set of n points. Both algorithms output the vertices of the convex hull in\ncounterclockwise order. The ﬁrst, known as Graham’s scan, runs in O.n lg n/ time.\nThe second, called Jarvis’s march, runs in O.nh/ time, where h is the number of\nvertices of the convex hull. As Figure 33.6 illustrates, every vertex of CH.Q/ is a\np0\np1\np2\np3\np4\np5\np6\np7\np8\np9\np10\np11\np12\nFigure 33.6\nA set of points Q D fp0; p1; : : : ; p12g with its convex hull CH.Q/ in gray.\n1030\nChapter 33\nComputational Geometry\npoint in Q. Both algorithms exploit this property, deciding which vertices in Q to\nkeep as vertices of the convex hull and which vertices in Q to reject.",
    "parent_0ab082d2-7580-477f-aef1-6c1db54ce8b3": "p9\np10\np11\np12\nFigure 33.6\nA set of points Q D fp0; p1; : : : ; p12g with its convex hull CH.Q/ in gray.\n1030\nChapter 33\nComputational Geometry\npoint in Q. Both algorithms exploit this property, deciding which vertices in Q to\nkeep as vertices of the convex hull and which vertices in Q to reject.\nWe can compute convex hulls in O.n lg n/ time by any one of several methods.\nBoth Graham’s scan and Jarvis’s march use a technique called “rotational sweep,”\nprocessing vertices in the order of the polar angles they form with a reference\nvertex. Other methods include the following:\n\u0002\nIn the incremental method, we ﬁrst sort the points from left to right, yielding a\nsequence hp1; p2; : : : ; pni. At the ith stage, we update the convex hull of the\ni \u0005 1 leftmost points, CH.fp1; p2; : : : ; pi\u00031g/, according to the ith point from\nthe left, thus forming CH.fp1; p2; : : : ; pig/. Exercise 33.3-6 asks you how to\nimplement this method to take a total of O.n lg n/ time.\n\u0002\nIn the divide-and-conquer method, we divide the set of n points in ‚.n/ time\ninto two subsets, one containing the leftmost dn=2e points and one containing\nthe rightmost bn=2c points, recursively compute the convex hulls of the subsets,\nand then, by means of a clever method, combine the hulls in O.n/ time. The\nrunning time is described by the familiar recurrence T .n/ D 2T .n=2/ C O.n/,\nand so the divide-and-conquer method runs in O.n lg n/ time.\n\u0002\nThe prune-and-search method is similar to the worst-case linear-time median\nalgorithm of Section 9.3. With this method, we ﬁnd the upper portion (or “upper\nchain”) of the convex hull by repeatedly throwing out a constant fraction of the\nremaining points until only the upper chain of the convex hull remains. We then\ndo the same for the lower chain. This method is asymptotically the fastest: if\nthe convex hull contains h vertices, it runs in only O.n lg h/ time.\nComputing the convex hull of a set of points is an interesting problem in its own",
    "parent_be19e3bd-b749-4644-90b4-8c13044dbefd": "do the same for the lower chain. This method is asymptotically the fastest: if\nthe convex hull contains h vertices, it runs in only O.n lg h/ time.\nComputing the convex hull of a set of points is an interesting problem in its own\nright. Moreover, algorithms for some other computational-geometry problems start\nby computing a convex hull. Consider, for example, the two-dimensional farthest-\npair problem: we are given a set of n points in the plane and wish to ﬁnd the\ntwo points whose distance from each other is maximum. As Exercise 33.3-3 asks\nyou to prove, these two points must be vertices of the convex hull. Although we\nwon’t prove it here, we can ﬁnd the farthest pair of vertices of an n-vertex convex\npolygon in O.n/ time. Thus, by computing the convex hull of the n input points\nin O.n lg n/ time and then ﬁnding the farthest pair of the resulting convex-polygon\nvertices, we can ﬁnd the farthest pair of points in any set of n points in O.n lg n/\ntime.\nGraham’s scan\nGraham’s scan solves the convex-hull problem by maintaining a stack S of can-\ndidate points. It pushes each point of the input set Q onto the stack one time,\n33.3\nFinding the convex hull\n1031\nand it eventually pops from the stack each point that is not a vertex of CH.Q/.\nWhen the algorithm terminates, stack S contains exactly the vertices of CH.Q/, in\ncounterclockwise order of their appearance on the boundary.\nThe procedure GRAHAM-SCAN takes as input a set Q of points, where jQj \u0006 3.\nIt calls the functions TOP.S/, which returns the point on top of stack S without\nchanging S, and NEXT-TO-TOP.S/, which returns the point one entry below the\ntop of stack S without changing S. As we shall prove in a moment, the stack S\nreturned by GRAHAM-SCAN contains, from bottom to top, exactly the vertices\nof CH.Q/ in counterclockwise order.\nGRAHAM-SCAN.Q/\n1\nlet p0 be the point in Q with the minimum y-coordinate,\nor the leftmost such point in case of a tie\n2\nlet hp1; p2; : : : ; pmi be the remaining points in Q,",
    "parent_1efd7364-b7ce-4972-b9bc-913472a3cb61": "returned by GRAHAM-SCAN contains, from bottom to top, exactly the vertices\nof CH.Q/ in counterclockwise order.\nGRAHAM-SCAN.Q/\n1\nlet p0 be the point in Q with the minimum y-coordinate,\nor the leftmost such point in case of a tie\n2\nlet hp1; p2; : : : ; pmi be the remaining points in Q,\nsorted by polar angle in counterclockwise order around p0\n(if more than one point has the same angle, remove all but\nthe one that is farthest from p0)\n3\nlet S be an empty stack\n4\nPUSH.p0; S/\n5\nPUSH.p1; S/\n6\nPUSH.p2; S/\n7\nfor i D 3 to m\n8\nwhile the angle formed by points NEXT-TO-TOP.S/, TOP.S/,\nand pi makes a nonleft turn\n9\nPOP.S/\n10\nPUSH.pi; S/\n11\nreturn S\nFigure 33.7 illustrates the progress of GRAHAM-SCAN. Line 1 chooses point p0\nas the point with the lowest y-coordinate, picking the leftmost such point in case\nof a tie. Since there is no point in Q that is below p0 and any other points with\nthe same y-coordinate are to its right, p0 must be a vertex of CH.Q/. Line 2\nsorts the remaining points of Q by polar angle relative to p0, using the same\nmethod—comparing cross products—as in Exercise 33.1-3. If two or more points\nhave the same polar angle relative to p0, all but the farthest such point are convex\ncombinations of p0 and the farthest point, and so we remove them entirely from\nconsideration. We let m denote the number of points other than p0 that remain.\nThe polar angle, measured in radians, of each point in Q relative to p0 is in the\nhalf-open interval Œ0; \u0006/. Since the points are sorted according to polar angles,\nthey are sorted in counterclockwise order relative to p0. We designate this sorted\nsequence of points by hp1; p2; : : : ; pmi. Note that points p1 and pm are vertices\n1032\nChapter 33\nComputational Geometry\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(a)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(b)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(c)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(d)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(e)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1",
    "parent_e85c70d3-28cd-4326-be22-1bc8aa8c5d29": "Computational Geometry\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(a)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(b)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(c)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(d)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(e)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(f)\nFigure 33.7\nThe execution of GRAHAM-SCAN on the set Q of Figure 33.6. The current convex\nhull contained in stack S is shown in gray at each step. (a) The sequence hp1;p2;: : : ;p12i of points\nnumbered in order of increasing polar angle relative to p0, and the initial stack S containing p0, p1,\nand p2. (b)–(k) Stack S after each iteration of the for loop of lines 7–10. Dashed lines show nonleft\nturns, which cause points to be popped from the stack. In part (h), for example, the right turn at\nangle †p7p8p9 causes p8 to be popped, and then the right turn at angle †p6p7p9 causes p7 to be\npopped.\n33.3\nFinding the convex hull\n1033\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(g)\np12\np11\np10\np9\np8\np6\np5\np4\np3\np2\np1\np0\n(h)\np12\np11\np10\np9\np8\np7\np6\np5\np3\np2\np1\np0\n(i)\np12\np11\np10\np9\np8\np7\np6\np3\np2\np1\np0\n(j)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(k)\np12\np11\np10\np9\np8\np7\np6\np5\np4\np3\np2\np1\np0\n(l)\np4\np4\np5\np7\nFigure 33.7, continued\n(l) The convex hull returned by the procedure, which matches that of\nFigure 33.6.\n1034\nChapter 33\nComputational Geometry\nof CH.Q/ (see Exercise 33.3-1). Figure 33.7(a) shows the points of Figure 33.6\nsequentially numbered in order of increasing polar angle relative to p0.\nThe remainder of the procedure uses the stack S. Lines 3–6 initialize the stack\nto contain, from bottom to top, the ﬁrst three points p0, p1, and p2. Figure 33.7(a)\nshows the initial stack S. The for loop of lines 7–10 iterates once for each point\nin the subsequence hp3; p4; : : : ; pmi. We shall see that after processing point pi,\nstack S contains, from bottom to top, the vertices of CH.fp0; p1; : : : ; pig/ in coun-",
    "parent_0c1b1d16-1756-481a-bcf8-6623048675d1": "shows the initial stack S. The for loop of lines 7–10 iterates once for each point\nin the subsequence hp3; p4; : : : ; pmi. We shall see that after processing point pi,\nstack S contains, from bottom to top, the vertices of CH.fp0; p1; : : : ; pig/ in coun-\nterclockwise order. The while loop of lines 8–9 removes points from the stack if\nwe ﬁnd them not to be vertices of the convex hull. When we traverse the convex\nhull counterclockwise, we should make a left turn at each vertex. Thus, each time\nthe while loop ﬁnds a vertex at which we make a nonleft turn, we pop the vertex\nfrom the stack. (By checking for a nonleft turn, rather than just a right turn, this\ntest precludes the possibility of a straight angle at a vertex of the resulting convex\nhull. We want no straight angles, since no vertex of a convex polygon may be a\nconvex combination of other vertices of the polygon.) After we pop all vertices\nthat have nonleft turns when heading toward point pi, we push pi onto the stack.\nFigures 33.7(b)–(k) show the state of the stack S after each iteration of the for\nloop. Finally, GRAHAM-SCAN returns the stack S in line 11. Figure 33.7(l) shows\nthe corresponding convex hull.\nThe following theorem formally proves the correctness of GRAHAM-SCAN.\nTheorem 33.1 (Correctness of Graham’s scan)\nIf GRAHAM-SCAN executes on a set Q of points, where jQj \u0006 3, then at termina-\ntion, the stack S consists of, from bottom to top, exactly the vertices of CH.Q/ in\ncounterclockwise order.\nProof\nAfter line 2, we have the sequence of points hp1; p2; : : : ; pmi. Let us\ndeﬁne, for i D 2; 3; : : : ; m, the subset of points Qi D fp0; p1; : : : ; pig. The\npoints in Q \u0005 Qm are those that were removed because they had the same polar\nangle relative to p0 as some point in Qm; these points are not in CH.Q/, and\nso CH.Qm/ D CH.Q/. Thus, it sufﬁces to show that when GRAHAM-SCAN\nterminates, the stack S consists of the vertices of CH.Qm/ in counterclockwise",
    "parent_44ddab19-2bdb-4c53-a2c8-4e039fc41c35": "points in Q \u0005 Qm are those that were removed because they had the same polar\nangle relative to p0 as some point in Qm; these points are not in CH.Q/, and\nso CH.Qm/ D CH.Q/. Thus, it sufﬁces to show that when GRAHAM-SCAN\nterminates, the stack S consists of the vertices of CH.Qm/ in counterclockwise\norder, when listed from bottom to top. Note that just as p0, p1, and pm are vertices\nof CH.Q/, the points p0, p1, and pi are all vertices of CH.Qi/.\nThe proof uses the following loop invariant:\nAt the start of each iteration of the for loop of lines 7–10, stack S consists of,\nfrom bottom to top, exactly the vertices of CH.Qi\u00031/ in counterclockwise\norder.\nInitialization: The invariant holds the ﬁrst time we execute line 7, since at that\ntime, stack S consists of exactly the vertices of Q2 D Qi\u00031, and this set of three\n33.3\nFinding the convex hull\n1035\np0\np1\np2\npk\npj\npi\nQj\n(a)\np0\np1\npj\npi\n(b)\npt\npr\nFigure 33.8\nThe proof of correctness of GRAHAM-SCAN. (a) Because pi’s polar angle relative\nto p0 is greater than pj ’s polar angle, and because the angle †pkpj pi makes a left turn, adding pi\nto CH.Qj / gives exactly the vertices of CH.Qj [ fpig/. (b) If the angle †prptpi makes a nonleft\nturn, then pt is either in the interior of the triangle formed by p0, pr, and pi or on a side of the\ntriangle, which means that it cannot be a vertex of CH.Qi/.\nvertices forms its own convex hull. Moreover, they appear in counterclockwise\norder from bottom to top.\nMaintenance: Entering an iteration of the for loop, the top point on stack S\nis pi\u00031, which was pushed at the end of the previous iteration (or before the\nﬁrst iteration, when i D 3). Let pj be the top point on S after executing the\nwhile loop of lines 8–9 but before line 10 pushes pi, and let pk be the point\njust below pj on S. At the moment that pj is the top point on S and we have\nnot yet pushed pi, stack S contains exactly the same points it contained after",
    "parent_afda3ed4-a4e1-4e4f-8579-938b31f88c9a": "while loop of lines 8–9 but before line 10 pushes pi, and let pk be the point\njust below pj on S. At the moment that pj is the top point on S and we have\nnot yet pushed pi, stack S contains exactly the same points it contained after\niteration j of the for loop. By the loop invariant, therefore, S contains exactly\nthe vertices of CH.Qj/ at that moment, and they appear in counterclockwise\norder from bottom to top.\nLet us continue to focus on this moment just before pushing pi. We know\nthat pi’s polar angle relative to p0 is greater than pj’s polar angle and that\nthe angle †pkpjpi makes a left turn (otherwise we would have popped pj).\nTherefore, because S contains exactly the vertices of CH.Qj/, we see from\nFigure 33.8(a) that once we push pi, stack S will contain exactly the vertices\nof CH.Qj [ fpig/, still in counterclockwise order from bottom to top.\nWe now show that CH.Qj [fpig/ is the same set of points as CH.Qi/. Consider\nany point pt that was popped during iteration i of the for loop, and let pr be\nthe point just below pt on stack S at the time pt was popped (pr might be pj).\nThe angle †prptpi makes a nonleft turn, and the polar angle of pt relative\nto p0 is greater than the polar angle of pr. As Figure 33.8(b) shows, pt must\n1036\nChapter 33\nComputational Geometry\nbe either in the interior of the triangle formed by p0, pr, and pi or on a side of\nthis triangle (but it is not a vertex of the triangle). Clearly, since pt is within a\ntriangle formed by three other points of Qi, it cannot be a vertex of CH.Qi/.\nSince pt is not a vertex of CH.Qi/, we have that\nCH.Qi \u0005 fptg/ D CH.Qi/ :\n(33.1)\nLet Pi be the set of points that were popped during iteration i of the for loop.\nSince the equality (33.1) applies for all points in Pi, we can apply it repeatedly\nto show that CH.Qi \u0005 Pi/ D CH.Qi/. But Qi \u0005 Pi D Qj [ fpig, and so we\nconclude that CH.Qj [ fpig/ D CH.Qi \u0005 Pi/ D CH.Qi/.\nWe have shown that once we push pi, stack S contains exactly the vertices",
    "parent_131c7adb-ad02-46ef-90f9-2be3eb23795d": "Since the equality (33.1) applies for all points in Pi, we can apply it repeatedly\nto show that CH.Qi \u0005 Pi/ D CH.Qi/. But Qi \u0005 Pi D Qj [ fpig, and so we\nconclude that CH.Qj [ fpig/ D CH.Qi \u0005 Pi/ D CH.Qi/.\nWe have shown that once we push pi, stack S contains exactly the vertices\nof CH.Qi/ in counterclockwise order from bottom to top. Incrementing i will\nthen cause the loop invariant to hold for the next iteration.\nTermination: When the loop terminates, we have i D m C 1, and so the loop\ninvariant implies that stack S consists of exactly the vertices of CH.Qm/, which\nis CH.Q/, in counterclockwise order from bottom to top. This completes the\nproof.\nWe now show that the running time of GRAHAM-SCAN is O.n lg n/, where\nn D jQj. Line 1 takes ‚.n/ time. Line 2 takes O.n lg n/ time, using merge sort\nor heapsort to sort the polar angles and the cross-product method of Section 33.1\nto compare angles. (We can remove all but the farthest point with the same polar\nangle in total of O.n/ time over all n points.) Lines 3–6 take O.1/ time. Because\nm \u0002 n \u0005 1, the for loop of lines 7–10 executes at most n \u0005 3 times. Since PUSH\ntakes O.1/ time, each iteration takes O.1/ time exclusive of the time spent in the\nwhile loop of lines 8–9, and thus overall the for loop takes O.n/ time exclusive of\nthe nested while loop.\nWe use aggregate analysis to show that the while loop takes O.n/ time overall.\nFor i D 0; 1; : : : ; m, we push each point pi onto stack S exactly once. As in the\nanalysis of the MULTIPOP procedure of Section 17.1, we observe that we can pop at\nmost the number of items that we push. At least three points—p0, p1, and pm—are\nnever popped from the stack, so that in fact at most m \u0005 2 POP operations are\nperformed in total. Each iteration of the while loop performs one POP, and so\nthere are at most m \u0005 2 iterations of the while loop altogether. Since the test in\nline 8 takes O.1/ time, each call of POP takes O.1/ time, and m \u0002 n \u0005 1, the total",
    "parent_f389b066-9058-49ad-a290-88e315c48db0": "performed in total. Each iteration of the while loop performs one POP, and so\nthere are at most m \u0005 2 iterations of the while loop altogether. Since the test in\nline 8 takes O.1/ time, each call of POP takes O.1/ time, and m \u0002 n \u0005 1, the total\ntime taken by the while loop is O.n/. Thus, the running time of GRAHAM-SCAN\nis O.n lg n/.\n33.3\nFinding the convex hull\n1037\np4\np2\np0\np1\nright chain\nleft chain\nright chain\nleft chain\np3\nFigure 33.9\nThe operation of Jarvis’s march. We choose the ﬁrst vertex as the lowest point p0.\nThe next vertex, p1, has the smallest polar angle of any point with respect to p0. Then, p2 has the\nsmallest polar angle with respect to p1. The right chain goes as high as the highest point p3. Then,\nwe construct the left chain by ﬁnding smallest polar angles with respect to the negative x-axis.\nJarvis’s march\nJarvis’s march computes the convex hull of a set Q of points by a technique known\nas package wrapping (or gift wrapping).\nThe algorithm runs in time O.nh/,\nwhere h is the number of vertices of CH.Q/. When h is o.lg n/, Jarvis’s march is\nasymptotically faster than Graham’s scan.\nIntuitively, Jarvis’s march simulates wrapping a taut piece of paper around the\nset Q. We start by taping the end of the paper to the lowest point in the set, that is,\nto the same point p0 with which we start Graham’s scan. We know that this point\nmust be a vertex of the convex hull. We pull the paper to the right to make it taut,\nand then we pull it higher until it touches a point. This point must also be a vertex\nof the convex hull. Keeping the paper taut, we continue in this way around the set\nof vertices until we come back to our original point p0.\nMore formally, Jarvis’s march builds a sequence H D hp0; p1; : : : ; ph\u00031i of the\nvertices of CH.Q/. We start with p0. As Figure 33.9 shows, the next vertex p1\nin the convex hull has the smallest polar angle with respect to p0. (In case of ties,",
    "parent_066fd0e4-ab07-4f55-8136-8588243d986f": "More formally, Jarvis’s march builds a sequence H D hp0; p1; : : : ; ph\u00031i of the\nvertices of CH.Q/. We start with p0. As Figure 33.9 shows, the next vertex p1\nin the convex hull has the smallest polar angle with respect to p0. (In case of ties,\nwe choose the point farthest from p0.) Similarly, p2 has the smallest polar angle\n1038\nChapter 33\nComputational Geometry\nwith respect to p1, and so on. When we reach the highest vertex, say pk (breaking\nties by choosing the farthest such vertex), we have constructed, as Figure 33.9\nshows, the right chain of CH.Q/. To construct the left chain, we start at pk and\nchoose pkC1 as the point with the smallest polar angle with respect to pk, but from\nthe negative x-axis. We continue on, forming the left chain by taking polar angles\nfrom the negative x-axis, until we come back to our original vertex p0.\nWe could implement Jarvis’s march in one conceptual sweep around the convex\nhull, that is, without separately constructing the right and left chains. Such imple-\nmentations typically keep track of the angle of the last convex-hull side chosen and\nrequire the sequence of angles of hull sides to be strictly increasing (in the range\nof 0 to 2\u0006 radians). The advantage of constructing separate chains is that we need\nnot explicitly compute angles; the techniques of Section 33.1 sufﬁce to compare\nangles.\nIf implemented properly, Jarvis’s march has a running time of O.nh/. For each\nof the h vertices of CH.Q/, we ﬁnd the vertex with the minimum polar angle. Each\ncomparison between polar angles takes O.1/ time, using the techniques of Sec-\ntion 33.1. As Section 9.1 shows, we can compute the minimum of n values in O.n/\ntime if each comparison takes O.1/ time. Thus, Jarvis’s march takes O.nh/ time.\nExercises\n33.3-1\nProve that in the procedure GRAHAM-SCAN, points p1 and pm must be vertices\nof CH.Q/.\n33.3-2\nConsider a model of computation that supports addition, comparison, and multipli-",
    "parent_903c3a63-3ba5-49fc-bfca-a1664b9cf4eb": "time if each comparison takes O.1/ time. Thus, Jarvis’s march takes O.nh/ time.\nExercises\n33.3-1\nProve that in the procedure GRAHAM-SCAN, points p1 and pm must be vertices\nof CH.Q/.\n33.3-2\nConsider a model of computation that supports addition, comparison, and multipli-\ncation and for which there is a lower bound of \u0004.n lg n/ to sort n numbers. Prove\nthat \u0004.n lg n/ is a lower bound for computing, in order, the vertices of the convex\nhull of a set of n points in such a model.\n33.3-3\nGiven a set of points Q, prove that the pair of points farthest from each other must\nbe vertices of CH.Q/.\n33.3-4\nFor a given polygon P and a point q on its boundary, the shadow of q is the set\nof points r such that the segment qr is entirely on the boundary or in the interior\nof P . As Figure 33.10 illustrates, a polygon P is star-shaped if there exists a\npoint p in the interior of P that is in the shadow of every point on the boundary\nof P . The set of all such points p is called the kernel of P . Given an n-vertex,\n33.4\nFinding the closest pair of points\n1039\np\n(a)\n(b)\nq\nq′\nFigure 33.10\nThe deﬁnition of a star-shaped polygon, for use in Exercise 33.3-4. (a) A star-shaped\npolygon. The segment from point p to any point q on the boundary intersects the boundary only at q.\n(b) A non-star-shaped polygon. The shaded region on the left is the shadow of q, and the shaded\nregion on the right is the shadow of q0. Since these regions are disjoint, the kernel is empty.\nstar-shaped polygon P speciﬁed by its vertices in counterclockwise order, show\nhow to compute CH.P / in O.n/ time.\n33.3-5\nIn the on-line convex-hull problem, we are given the set Q of n points one point at\na time. After receiving each point, we compute the convex hull of the points seen\nso far. Obviously, we could run Graham’s scan once for each point, with a total\nrunning time of O.n2 lg n/. Show how to solve the on-line convex-hull problem in\na total of O.n2/ time.\n33.3-6\n?",
    "parent_396bf5b2-3b2f-44f8-a45d-6b385653003d": "a time. After receiving each point, we compute the convex hull of the points seen\nso far. Obviously, we could run Graham’s scan once for each point, with a total\nrunning time of O.n2 lg n/. Show how to solve the on-line convex-hull problem in\na total of O.n2/ time.\n33.3-6\n?\nShow how to implement the incremental method for computing the convex hull\nof n points so that it runs in O.n lg n/ time.\n33.4\nFinding the closest pair of points\nWe now consider the problem of ﬁnding the closest pair of points in a set Q of\nn \u0006 2 points. “Closest” refers to the usual euclidean distance: the distance between\npoints p1 D .x1; y1/ and p2 D .x2; y2/ is\np\n.x1 \u0005 x2/2 C .y1 \u0005 y2/2. Two points\nin set Q may be coincident, in which case the distance between them is zero. This\nproblem has applications in, for example, trafﬁc-control systems. A system for\ncontrolling air or sea trafﬁc might need to identify the two closest vehicles in order\nto detect potential collisions.\nA brute-force closest-pair algorithm simply looks at all the\n\u000bn\n2\n\f\nD ‚.n2/ pairs\nof points. In this section, we shall describe a divide-and-conquer algorithm for\n1040\nChapter 33\nComputational Geometry\nthis problem, whose running time is described by the familiar recurrence T .n/ D\n2T .n=2/ C O.n/. Thus, this algorithm uses only O.n lg n/ time.\nThe divide-and-conquer algorithm\nEach recursive invocation of the algorithm takes as input a subset P \u0007 Q and\narrays X and Y , each of which contains all the points of the input subset P .\nThe points in array X are sorted so that their x-coordinates are monotonically\nincreasing. Similarly, array Y is sorted by monotonically increasing y-coordinate.\nNote that in order to attain the O.n lg n/ time bound, we cannot afford to sort\nin each recursive call; if we did, the recurrence for the running time would be\nT .n/ D 2T .n=2/ C O.n lg n/, whose solution is T .n/ D O.n lg2 n/. (Use the\nversion of the master method given in Exercise 4.6-2.) We shall see a little later",
    "parent_f2e06958-32c1-48ad-8446-a141547bd2a5": "in each recursive call; if we did, the recurrence for the running time would be\nT .n/ D 2T .n=2/ C O.n lg n/, whose solution is T .n/ D O.n lg2 n/. (Use the\nversion of the master method given in Exercise 4.6-2.) We shall see a little later\nhow to use “presorting” to maintain this sorted property without actually sorting in\neach recursive call.\nA given recursive invocation with inputs P , X, and Y ﬁrst checks whether\njP j \u0002 3. If so, the invocation simply performs the brute-force method described\nabove: try all\n\u000bjP j\n2\n\f\npairs of points and return the closest pair. If jP j > 3, the\nrecursive invocation carries out the divide-and-conquer paradigm as follows.\nDivide: Find a vertical line l that bisects the point set P into two sets PL and PR\nsuch that jPLj D djP j =2e, jPRj D bjP j =2c, all points in PL are on or to the\nleft of line l, and all points in PR are on or to the right of l. Divide the array X\ninto arrays XL and XR, which contain the points of PL and PR respectively,\nsorted by monotonically increasing x-coordinate. Similarly, divide the array Y\ninto arrays YL and YR, which contain the points of PL and PR respectively,\nsorted by monotonically increasing y-coordinate.\nConquer: Having divided P into PL and PR, make two recursive calls, one to ﬁnd\nthe closest pair of points in PL and the other to ﬁnd the closest pair of points\nin PR. The inputs to the ﬁrst call are the subset PL and arrays XL and YL; the\nsecond call receives the inputs PR, XR, and YR. Let the closest-pair distances\nreturned for PL and PR be ıL and ıR, respectively, and let ı D min.ıL; ıR/.\nCombine: The closest pair is either the pair with distance ı found by one of the\nrecursive calls, or it is a pair of points with one point in PL and the other in PR.\nThe algorithm determines whether there is a pair with one point in PL and the\nother point in PR and whose distance is less than ı. Observe that if a pair of\npoints has distance less than ı, both points of the pair must be within ı units",
    "parent_f61c40ed-6bbf-4697-bdf1-5d5b1f51abc0": "The algorithm determines whether there is a pair with one point in PL and the\nother point in PR and whose distance is less than ı. Observe that if a pair of\npoints has distance less than ı, both points of the pair must be within ı units\nof line l. Thus, as Figure 33.11(a) shows, they both must reside in the 2ı-wide\nvertical strip centered at line l. To ﬁnd such a pair, if one exists, we do the\nfollowing:\n33.4\nFinding the closest pair of points\n1041\n1. Create an array Y 0, which is the array Y with all points not in the 2ı-wide\nvertical strip removed. The array Y 0 is sorted by y-coordinate, just as Y is.\n2. For each point p in the array Y 0, try to ﬁnd points in Y 0 that are within ı\nunits of p. As we shall see shortly, only the 7 points in Y 0 that follow p need\nbe considered. Compute the distance from p to each of these 7 points, and\nkeep track of the closest-pair distance ı0 found over all pairs of points in Y 0.\n3. If ı0 < ı, then the vertical strip does indeed contain a closer pair than the\nrecursive calls found. Return this pair and its distance ı0. Otherwise, return\nthe closest pair and its distance ı found by the recursive calls.\nThe above description omits some implementation details that are necessary to\nachieve the O.n lg n/ running time. After proving the correctness of the algorithm,\nwe shall show how to implement the algorithm to achieve the desired time bound.\nCorrectness\nThe correctness of this closest-pair algorithm is obvious, except for two aspects.\nFirst, by bottoming out the recursion when jP j \u0002 3, we ensure that we never try to\nsolve a subproblem consisting of only one point. The second aspect is that we need\nonly check the 7 points following each point p in array Y 0; we shall now prove this\nproperty.\nSuppose that at some level of the recursion, the closest pair of points is pL 2 PL\nand pR 2 PR. Thus, the distance ı0 between pL and pR is strictly less than ı.",
    "parent_6b6c3a1f-9f83-4683-9b1a-47b3717d7e3c": "only check the 7 points following each point p in array Y 0; we shall now prove this\nproperty.\nSuppose that at some level of the recursion, the closest pair of points is pL 2 PL\nand pR 2 PR. Thus, the distance ı0 between pL and pR is strictly less than ı.\nPoint pL must be on or to the left of line l and less than ı units away. Similarly, pR\nis on or to the right of l and less than ı units away. Moreover, pL and pR are\nwithin ı units of each other vertically. Thus, as Figure 33.11(a) shows, pL and pR\nare within a ı \t 2ı rectangle centered at line l. (There may be other points within\nthis rectangle as well.)\nWe next show that at most 8 points of P can reside within this ı \t 2ı rectangle.\nConsider the ı \t ı square forming the left half of this rectangle. Since all points\nwithin PL are at least ı units apart, at most 4 points can reside within this square;\nFigure 33.11(b) shows how. Similarly, at most 4 points in PR can reside within\nthe ı \tı square forming the right half of the rectangle. Thus, at most 8 points of P\ncan reside within the ı \t 2ı rectangle. (Note that since points on line l may be in\neither PL or PR, there may be up to 4 points on l. This limit is achieved if there are\ntwo pairs of coincident points such that each pair consists of one point from PL and\none point from PR, one pair is at the intersection of l and the top of the rectangle,\nand the other pair is where l intersects the bottom of the rectangle.)\nHaving shown that at most 8 points of P can reside within the rectangle, we\ncan easily see why we need to check only the 7 points following each point in the\narray Y 0. Still assuming that the closest pair is pL and pR, let us assume without\n1042\nChapter 33\nComputational Geometry\nl\npL\npR\nPL\nPR\nδ\n2δ\n(a)\nPR\nPL\n(b)\nl\ncoincident points,\n  one in PL,\n  one in PR\ncoincident points,\n  one in PL,\n  one in PR\nδ\nδ\nδ\nFigure 33.11\nKey concepts in the proof that the closest-pair algorithm needs to check only 7 points",
    "parent_0f8ba06a-f6ef-4e51-96e7-aeb71743dd53": "1042\nChapter 33\nComputational Geometry\nl\npL\npR\nPL\nPR\nδ\n2δ\n(a)\nPR\nPL\n(b)\nl\ncoincident points,\n  one in PL,\n  one in PR\ncoincident points,\n  one in PL,\n  one in PR\nδ\nδ\nδ\nFigure 33.11\nKey concepts in the proof that the closest-pair algorithm needs to check only 7 points\nfollowing each point in the array Y 0. (a) If pL 2 PL and pR 2 PR are less than ı units apart, they\nmust reside within a ı \t 2ı rectangle centered at line l. (b) How 4 points that are pairwise at least ı\nunits apart can all reside within a ı \t ı square. On the left are 4 points in PL, and on the right are 4\npoints in PR. The ı \t 2ı rectangle can contain 8 points if the points shown on line l are actually\npairs of coincident points with one point in PL and one in PR.\nloss of generality that pL precedes pR in array Y 0. Then, even if pL occurs as early\nas possible in Y 0 and pR occurs as late as possible, pR is in one of the 7 positions\nfollowing pL. Thus, we have shown the correctness of the closest-pair algorithm.\nImplementation and running time\nAs we have noted, our goal is to have the recurrence for the running time be T .n/ D\n2T .n=2/ C O.n/, where T .n/ is the running time for a set of n points. The main\ndifﬁculty comes from ensuring that the arrays XL, XR, YL, and YR, which are\npassed to recursive calls, are sorted by the proper coordinate and also that the\narray Y 0 is sorted by y-coordinate. (Note that if the array X that is received by a\nrecursive call is already sorted, then we can easily divide set P into PL and PR in\nlinear time.)\nThe key observation is that in each call, we wish to form a sorted subset of a\nsorted array. For example, a particular invocation receives the subset P and the\narray Y , sorted by y-coordinate. Having partitioned P into PL and PR, it needs to\nform the arrays YL and YR, which are sorted by y-coordinate, in linear time. We\ncan view the method as the opposite of the MERGE procedure from merge sort in\n33.4\nFinding the closest pair of points\n1043",
    "parent_f4a94b15-160f-49ed-84f2-7f2c7c21fe07": "array Y , sorted by y-coordinate. Having partitioned P into PL and PR, it needs to\nform the arrays YL and YR, which are sorted by y-coordinate, in linear time. We\ncan view the method as the opposite of the MERGE procedure from merge sort in\n33.4\nFinding the closest pair of points\n1043\nSection 2.3.1: we are splitting a sorted array into two sorted arrays. The following\npseudocode gives the idea.\n1\nlet YLŒ1 : : Y:length\u0002 and YRŒ1 : : Y:length\u0002 be new arrays\n2\nYL:length D YR:length D 0\n3\nfor i D 1 to Y:length\n4\nif Y Œi\u0002 2 PL\n5\nYL:length D YL:length C 1\n6\nYLŒYL:length\u0002 D Y Œi\u0002\n7\nelse YR:length D YR:length C 1\n8\nYRŒYR:length\u0002 D Y Œi\u0002\nWe simply examine the points in array Y in order. If a point Y Œi\u0002 is in PL, we\nappend it to the end of array YL; otherwise, we append it to the end of array YR.\nSimilar pseudocode works for forming arrays XL, XR, and Y 0.\nThe only remaining question is how to get the points sorted in the ﬁrst place. We\npresort them; that is, we sort them once and for all before the ﬁrst recursive call.\nWe pass these sorted arrays into the ﬁrst recursive call, and from there we whittle\nthem down through the recursive calls as necessary. Presorting adds an additional\nO.n lg n/ term to the running time, but now each step of the recursion takes linear\ntime exclusive of the recursive calls. Thus, if we let T .n/ be the running time of\neach recursive step and T 0.n/ be the running time of the entire algorithm, we get\nT 0.n/ D T .n/ C O.n lg n/ and\nT .n/ D\n(\n2T .n=2/ C O.n/\nif n > 3 ;\nO.1/\nif n \u0002 3 :\nThus, T .n/ D O.n lg n/ and T 0.n/ D O.n lg n/.\nExercises\n33.4-1\nProfessor Williams comes up with a scheme that allows the closest-pair algorithm\nto check only 5 points following each point in array Y 0. The idea is always to place\npoints on line l into set PL. Then, there cannot be pairs of coincident points on\nline l with one point in PL and one in PR. Thus, at most 6 points can reside in\nthe ı \t 2ı rectangle. What is the ﬂaw in the professor’s scheme?\n33.4-2",
    "parent_49e72800-f76a-4ac7-a7de-8fb2af76c919": "points on line l into set PL. Then, there cannot be pairs of coincident points on\nline l with one point in PL and one in PR. Thus, at most 6 points can reside in\nthe ı \t 2ı rectangle. What is the ﬂaw in the professor’s scheme?\n33.4-2\nShow that it actually sufﬁces to check only the points in the 5 array positions fol-\nlowing each point in the array Y 0.\n1044\nChapter 33\nComputational Geometry\n33.4-3\nWe can deﬁne the distance between two points in ways other than euclidean. In\nthe plane, the Lm-distance between points p1 and p2 is given by the expres-\nsion .jx1 \u0005 x2jm C jy1 \u0005 y2jm/\n1=m. Euclidean distance, therefore, is L2-distance.\nModify the closest-pair algorithm to use the L1-distance, which is also known as\nthe Manhattan distance.\n33.4-4\nGiven two points p1 and p2 in the plane, the L1-distance between them is\ngiven by max.jx1 \u0005 x2j ; jy1 \u0005 y2j/. Modify the closest-pair algorithm to use the\nL1-distance.\n33.4-5\nSuppose that \u0004.n/ of the points given to the closest-pair algorithm are covertical.\nShow how to determine the sets PL and PR and how to determine whether each\npoint of Y is in PL or PR so that the running time for the closest-pair algorithm\nremains O.n lg n/.\n33.4-6\nSuggest a change to the closest-pair algorithm that avoids presorting the Y array\nbut leaves the running time as O.n lg n/. (Hint: Merge sorted arrays YL and YR to\nform the sorted array Y .)\nProblems\n33-1\nConvex layers\nGiven a set Q of points in the plane, we deﬁne the convex layers of Q inductively.\nThe ﬁrst convex layer of Q consists of those points in Q that are vertices of CH.Q/.\nFor i > 1, deﬁne Qi to consist of the points of Q with all points in convex layers\n1; 2; : : : ; i \u00051 removed. Then, the ith convex layer of Q is CH.Qi/ if Qi ¤ ; and\nis undeﬁned otherwise.\na. Give an O.n2/-time algorithm to ﬁnd the convex layers of a set of n points.\nb. Prove that \u0004.n lg n/ time is required to compute the convex layers of a set of n",
    "parent_6e1e6c2e-cf79-43c1-98af-87b8b9625e04": "1; 2; : : : ; i \u00051 removed. Then, the ith convex layer of Q is CH.Qi/ if Qi ¤ ; and\nis undeﬁned otherwise.\na. Give an O.n2/-time algorithm to ﬁnd the convex layers of a set of n points.\nb. Prove that \u0004.n lg n/ time is required to compute the convex layers of a set of n\npoints with any model of computation that requires \u0004.n lg n/ time to sort n real\nnumbers.\nProblems for Chapter 33\n1045\n33-2\nMaximal layers\nLet Q be a set of n points in the plane.\nWe say that point .x; y/ dominates\npoint .x0; y0/ if x \u0006 x0 and y \u0006 y0. A point in Q that is dominated by no other\npoints in Q is said to be maximal. Note that Q may contain many maximal points,\nwhich can be organized into maximal layers as follows. The ﬁrst maximal layer L1\nis the set of maximal points of Q. For i > 1, the ith maximal layer Li is the set of\nmaximal points in Q \u0005 Si\u00031\njD1 Lj.\nSuppose that Q has k nonempty maximal layers, and let yi be the y-coordinate\nof the leftmost point in Li for i D 1; 2; : : : ; k. For now, assume that no two points\nin Q have the same x- or y-coordinate.\na. Show that y1 > y2 > \u0003 \u0003 \u0003 > yk.\nConsider a point .x; y/ that is to the left of any point in Q and for which y is\ndistinct from the y-coordinate of any point in Q. Let Q0 D Q [ f.x; y/g.\nb. Let j be the minimum index such that yj < y, unless y < yk, in which case\nwe let j D k C 1. Show that the maximal layers of Q0 are as follows:\n\u0002 If j \u0002 k, then the maximal layers of Q0 are the same as the maximal layers\nof Q, except that Lj also includes .x; y/ as its new leftmost point.\n\u0002 If j D k C1, then the ﬁrst k maximal layers of Q0 are the same as for Q, but\nin addition, Q0 has a nonempty .k C 1/st maximal layer: LkC1 D f.x; y/g.\nc. Describe an O.n lg n/-time algorithm to compute the maximal layers of a set Q\nof n points. (Hint: Move a sweep line from right to left.)\nd. Do any difﬁculties arise if we now allow input points to have the same x- or\ny-coordinate? Suggest a way to resolve such problems.\n33-3\nGhostbusters and ghosts",
    "parent_00c3848a-358b-40b0-86ba-d97aaf810d46": "of n points. (Hint: Move a sweep line from right to left.)\nd. Do any difﬁculties arise if we now allow input points to have the same x- or\ny-coordinate? Suggest a way to resolve such problems.\n33-3\nGhostbusters and ghosts\nA group of n Ghostbusters is battling n ghosts. Each Ghostbuster carries a proton\npack, which shoots a stream at a ghost, eradicating it. A stream goes in a straight\nline and terminates when it hits the ghost. The Ghostbusters decide upon the fol-\nlowing strategy. They will pair off with the ghosts, forming n Ghostbuster-ghost\npairs, and then simultaneously each Ghostbuster will shoot a stream at his cho-\nsen ghost. As we all know, it is very dangerous to let streams cross, and so the\nGhostbusters must choose pairings for which no streams will cross.\nAssume that the position of each Ghostbuster and each ghost is a ﬁxed point in\nthe plane and that no three positions are colinear.\na. Argue that there exists a line passing through one Ghostbuster and one ghost\nsuch that the number of Ghostbusters on one side of the line equals the number\nof ghosts on the same side. Describe how to ﬁnd such a line in O.n lg n/ time.\n1046\nChapter 33\nComputational Geometry\nb. Give an O.n2 lg n/-time algorithm to pair Ghostbusters with ghosts in such a\nway that no streams cross.\n33-4\nPicking up sticks\nProfessor Charon has a set of n sticks, which are piled up in some conﬁguration.\nEach stick is speciﬁed by its endpoints, and each endpoint is an ordered triple\ngiving its .x; y; ´/ coordinates. No stick is vertical. He wishes to pick up all the\nsticks, one at a time, subject to the condition that he may pick up a stick only if\nthere is no other stick on top of it.\na. Give a procedure that takes two sticks a and b and reports whether a is above,\nbelow, or unrelated to b.\nb. Describe an efﬁcient algorithm that determines whether it is possible to pick up\nall the sticks, and if so, provides a legal order in which to pick them up.\n33-5\nSparse-hulled distributions",
    "parent_67d180fa-747e-4d87-b908-22245b21f17c": "below, or unrelated to b.\nb. Describe an efﬁcient algorithm that determines whether it is possible to pick up\nall the sticks, and if so, provides a legal order in which to pick them up.\n33-5\nSparse-hulled distributions\nConsider the problem of computing the convex hull of a set of points in the plane\nthat have been drawn according to some known random distribution. Sometimes,\nthe number of points, or size, of the convex hull of n points drawn from such a\ndistribution has expectation O.n1\u0003\u0002/ for some constant \b > 0. We call such a\ndistribution sparse-hulled. Sparse-hulled distributions include the following:\n\u0002\nPoints drawn uniformly from a unit-radius disk. The convex hull has expected\nsize ‚.n1=3/.\n\u0002\nPoints drawn uniformly from the interior of a convex polygon with k sides, for\nany constant k. The convex hull has expected size ‚.lg n/.\n\u0002\nPoints drawn according to a two-dimensional normal distribution. The convex\nhull has expected size ‚.\np\nlg n/.\na. Given two convex polygons with n1 and n2 vertices respectively, show how to\ncompute the convex hull of all n1Cn2 points in O.n1Cn2/ time. (The polygons\nmay overlap.)\nb. Show how to compute the convex hull of a set of n points drawn independently\naccording to a sparse-hulled distribution in O.n/ average-case time. (Hint:\nRecursively ﬁnd the convex hulls of the ﬁrst n=2 points and the second n=2\npoints, and then combine the results.)\nNotes for Chapter 33\n1047\nChapter notes\nThis chapter barely scratches the surface of computational-geometry algorithms\nand techniques. Books on computational geometry include those by Preparata and\nShamos [282], Edelsbrunner [99], and O’Rourke [269].\nAlthough geometry has been studied since antiquity, the development of algo-\nrithms for geometric problems is relatively new. Preparata and Shamos note that\nthe earliest notion of the complexity of a problem was given by E. Lemoine in 1902.\nHe was studying euclidean constructions—those using a compass and a ruler—and",
    "parent_012721b2-92df-4e51-bbdd-0377000cf201": "rithms for geometric problems is relatively new. Preparata and Shamos note that\nthe earliest notion of the complexity of a problem was given by E. Lemoine in 1902.\nHe was studying euclidean constructions—those using a compass and a ruler—and\ndevised a set of ﬁve primitives: placing one leg of the compass on a given point,\nplacing one leg of the compass on a given line, drawing a circle, passing the ruler’s\nedge through a given point, and drawing a line. Lemoine was interested in the\nnumber of primitives needed to effect a given construction; he called this amount\nthe “simplicity” of the construction.\nThe algorithm of Section 33.2, which determines whether any segments inter-\nsect, is due to Shamos and Hoey [313].\nThe original version of Graham’s scan is given by Graham [150]. The package-\nwrapping algorithm is due to Jarvis [189]. Using a decision-tree model of com-\nputation, Yao [359] proved a worst-case lower bound of \u0004.n lg n/ for the running\ntime of any convex-hull algorithm. When the number of vertices h of the con-\nvex hull is taken into account, the prune-and-search algorithm of Kirkpatrick and\nSeidel [206], which takes O.n lg h/ time, is asymptotically optimal.\nThe O.n lg n/-time divide-and-conquer algorithm for ﬁnding the closest pair of\npoints is by Shamos and appears in Preparata and Shamos [282]. Preparata and\nShamos also show that the algorithm is asymptotically optimal in a decision-tree\nmodel.\n34\nNP-Completeness\nAlmost all the algorithms we have studied thus far have been polynomial-time al-\ngorithms: on inputs of size n, their worst-case running time is O.nk/ for some con-\nstant k. You might wonder whether all problems can be solved in polynomial time.\nThe answer is no. For example, there are problems, such as Turing’s famous “Halt-\ning Problem,” that cannot be solved by any computer, no matter how much time we\nallow. There are also problems that can be solved, but not in time O.nk/ for any",
    "parent_d21a0a55-0fc9-445e-901c-a1e87c1f64b7": "The answer is no. For example, there are problems, such as Turing’s famous “Halt-\ning Problem,” that cannot be solved by any computer, no matter how much time we\nallow. There are also problems that can be solved, but not in time O.nk/ for any\nconstant k. Generally, we think of problems that are solvable by polynomial-time\nalgorithms as being tractable, or easy, and problems that require superpolynomial\ntime as being intractable, or hard.\nThe subject of this chapter, however, is an interesting class of problems, called\nthe “NP-complete” problems, whose status is unknown. No polynomial-time al-\ngorithm has yet been discovered for an NP-complete problem, nor has anyone yet\nbeen able to prove that no polynomial-time algorithm can exist for any one of them.\nThis so-called P ¤ NP question has been one of the deepest, most perplexing open\nresearch problems in theoretical computer science since it was ﬁrst posed in 1971.\nSeveral NP-complete problems are particularly tantalizing because they seem\non the surface to be similar to problems that we know how to solve in polynomial\ntime. In each of the following pairs of problems, one is solvable in polynomial\ntime and the other is NP-complete, but the difference between problems appears to\nbe slight:\nShortest vs. longest simple paths: In Chapter 24, we saw that even with negative\nedge weights, we can ﬁnd shortest paths from a single source in a directed\ngraph G D .V; E/ in O.VE/ time. Finding a longest simple path between two\nvertices is difﬁcult, however. Merely determining whether a graph contains a\nsimple path with at least a given number of edges is NP-complete.\nEuler tour vs. hamiltonian cycle: An Euler tour of a connected, directed graph\nG D .V; E/ is a cycle that traverses each edge of G exactly once, although\nit is allowed to visit each vertex more than once. By Problem 22-3, we can\ndetermine whether a graph has an Euler tour in only O.E/ time and, in fact,\nChapter 34\nNP-Completeness\n1049",
    "parent_0317ee06-21eb-4a7c-a433-183ef588c992": "G D .V; E/ is a cycle that traverses each edge of G exactly once, although\nit is allowed to visit each vertex more than once. By Problem 22-3, we can\ndetermine whether a graph has an Euler tour in only O.E/ time and, in fact,\nChapter 34\nNP-Completeness\n1049\nwe can ﬁnd the edges of the Euler tour in O.E/ time. A hamiltonian cycle of\na directed graph G D .V; E/ is a simple cycle that contains each vertex in V .\nDetermining whether a directed graph has a hamiltonian cycle is NP-complete.\n(Later in this chapter, we shall prove that determining whether an undirected\ngraph has a hamiltonian cycle is NP-complete.)\n2-CNF satisﬁability vs. 3-CNF satisﬁability: A boolean formula contains vari-\nables whose values are 0 or 1; boolean connectives such as ^ (AND), _ (OR),\nand : (NOT); and parentheses. A boolean formula is satisﬁable if there exists\nsome assignment of the values 0 and 1 to its variables that causes it to evaluate\nto 1. We shall deﬁne terms more formally later in this chapter, but informally, a\nboolean formula is in k-conjunctive normal form, or k-CNF, if it is the AND\nof clauses of ORs of exactly k variables or their negations. For example, the\nboolean formula .x1 _ :x2/ ^ .:x1 _ x3/ ^ .:x2 _ :x3/ is in 2-CNF. (It has\nthe satisfying assignment x1 D 1; x2 D 0; x3 D 1.) Although we can deter-\nmine in polynomial time whether a 2-CNF formula is satisﬁable, we shall see\nlater in this chapter that determining whether a 3-CNF formula is satisﬁable is\nNP-complete.\nNP-completeness and the classes P and NP\nThroughout this chapter, we shall refer to three classes of problems: P, NP, and\nNPC, the latter class being the NP-complete problems. We describe them infor-\nmally here, and we shall deﬁne them more formally later on.\nThe class P consists of those problems that are solvable in polynomial time.\nMore speciﬁcally, they are problems that can be solved in time O.nk/ for some\nconstant k, where n is the size of the input to the problem. Most of the problems",
    "parent_0c24b4d7-6efd-4506-9820-252ecf99e15f": "mally here, and we shall deﬁne them more formally later on.\nThe class P consists of those problems that are solvable in polynomial time.\nMore speciﬁcally, they are problems that can be solved in time O.nk/ for some\nconstant k, where n is the size of the input to the problem. Most of the problems\nexamined in previous chapters are in P.\nThe class NP consists of those problems that are “veriﬁable” in polynomial time.\nWhat do we mean by a problem being veriﬁable? If we were somehow given a\n“certiﬁcate” of a solution, then we could verify that the certiﬁcate is correct in time\npolynomial in the size of the input to the problem. For example, in the hamiltonian-\ncycle problem, given a directed graph G D .V; E/, a certiﬁcate would be a se-\nquence h\u00031; \u00032; \u00033; : : : ; \u0003jV ji of jV j vertices. We could easily check in polynomial\ntime that .\u0003i; \u0003iC1/ 2 E for i D 1; 2; 3; : : : ; jV j\u00051 and that .\u0003jV j; \u00031/ 2 E as well.\nAs another example, for 3-CNF satisﬁability, a certiﬁcate would be an assignment\nof values to variables. We could check in polynomial time that this assignment\nsatisﬁes the boolean formula.\nAny problem in P is also in NP, since if a problem is in P then we can solve it\nin polynomial time without even being supplied a certiﬁcate. We shall formalize\nthis notion later in this chapter, but for now we can believe that P \u0007 NP. The open\nquestion is whether or not P is a proper subset of NP.\n1050\nChapter 34\nNP-Completeness\nInformally, a problem is in the class NPC—and we refer to it as being NP-\ncomplete—if it is in NP and is as “hard” as any problem in NP. We shall formally\ndeﬁne what it means to be as hard as any problem in NP later in this chapter.\nIn the meantime, we will state without proof that if any NP-complete problem\ncan be solved in polynomial time, then every problem in NP has a polynomial-\ntime algorithm. Most theoretical computer scientists believe that the NP-complete\nproblems are intractable, since given the wide range of NP-complete problems",
    "parent_f027685c-0484-45c5-b79e-5ecdb1450021": "can be solved in polynomial time, then every problem in NP has a polynomial-\ntime algorithm. Most theoretical computer scientists believe that the NP-complete\nproblems are intractable, since given the wide range of NP-complete problems\nthat have been studied to date—without anyone having discovered a polynomial-\ntime solution to any of them—it would be truly astounding if all of them could\nbe solved in polynomial time. Yet, given the effort devoted thus far to proving\nthat NP-complete problems are intractable—without a conclusive outcome—we\ncannot rule out the possibility that the NP-complete problems are in fact solvable\nin polynomial time.\nTo become a good algorithm designer, you must understand the rudiments of the\ntheory of NP-completeness. If you can establish a problem as NP-complete, you\nprovide good evidence for its intractability. As an engineer, you would then do\nbetter to spend your time developing an approximation algorithm (see Chapter 35)\nor solving a tractable special case, rather than searching for a fast algorithm that\nsolves the problem exactly. Moreover, many natural and interesting problems that\non the surface seem no harder than sorting, graph searching, or network ﬂow are\nin fact NP-complete. Therefore, you should become familiar with this remarkable\nclass of problems.\nOverview of showing problems to be NP-complete\nThe techniques we use to show that a particular problem is NP-complete differ\nfundamentally from the techniques used throughout most of this book to design\nand analyze algorithms. When we demonstrate that a problem is NP-complete,\nwe are making a statement about how hard it is (or at least how hard we think it\nis), rather than about how easy it is. We are not trying to prove the existence of\nan efﬁcient algorithm, but instead that no efﬁcient algorithm is likely to exist. In\nthis way, NP-completeness proofs bear some similarity to the proof in Section 8.1",
    "parent_ce4fb5ad-802d-4a61-9883-fb751e32c094": "is), rather than about how easy it is. We are not trying to prove the existence of\nan efﬁcient algorithm, but instead that no efﬁcient algorithm is likely to exist. In\nthis way, NP-completeness proofs bear some similarity to the proof in Section 8.1\nof an \u0004.n lg n/-time lower bound for any comparison sort algorithm; the speciﬁc\ntechniques used for showing NP-completeness differ from the decision-tree method\nused in Section 8.1, however.\nWe rely on three key concepts in showing a problem to be NP-complete:\nDecision problems vs. optimization problems\nMany problems of interest are optimization problems, in which each feasible (i.e.,\n“legal”) solution has an associated value, and we wish to ﬁnd a feasible solution\nwith the best value. For example, in a problem that we call SHORTEST-PATH,\nChapter 34\nNP-Completeness\n1051\nwe are given an undirected graph G and vertices u and \u0003, and we wish to ﬁnd a\npath from u to \u0003 that uses the fewest edges. In other words, SHORTEST-PATH\nis the single-pair shortest-path problem in an unweighted, undirected graph. NP-\ncompleteness applies directly not to optimization problems, however, but to deci-\nsion problems, in which the answer is simply “yes” or “no” (or, more formally, “1”\nor “0”).\nAlthough NP-complete problems are conﬁned to the realm of decision problems,\nwe can take advantage of a convenient relationship between optimization problems\nand decision problems. We usually can cast a given optimization problem as a re-\nlated decision problem by imposing a bound on the value to be optimized. For\nexample, a decision problem related to SHORTEST-PATH is PATH: given a di-\nrected graph G, vertices u and \u0003, and an integer k, does a path exist from u to \u0003\nconsisting of at most k edges?\nThe relationship between an optimization problem and its related decision prob-\nlem works in our favor when we try to show that the optimization problem is\n“hard.” That is because the decision problem is in a sense “easier,” or at least “no",
    "parent_2c73d289-ad68-48f4-b6f6-d9636aeab10b": "consisting of at most k edges?\nThe relationship between an optimization problem and its related decision prob-\nlem works in our favor when we try to show that the optimization problem is\n“hard.” That is because the decision problem is in a sense “easier,” or at least “no\nharder.” As a speciﬁc example, we can solve PATH by solving SHORTEST-PATH\nand then comparing the number of edges in the shortest path found to the value\nof the decision-problem parameter k. In other words, if an optimization prob-\nlem is easy, its related decision problem is easy as well. Stated in a way that has\nmore relevance to NP-completeness, if we can provide evidence that a decision\nproblem is hard, we also provide evidence that its related optimization problem is\nhard. Thus, even though it restricts attention to decision problems, the theory of\nNP-completeness often has implications for optimization problems as well.\nReductions\nThe above notion of showing that one problem is no harder or no easier than an-\nother applies even when both problems are decision problems. We take advantage\nof this idea in almost every NP-completeness proof, as follows. Let us consider a\ndecision problem A, which we would like to solve in polynomial time. We call the\ninput to a particular problem an instance of that problem; for example, in PATH,\nan instance would be a particular graph G, particular vertices u and \u0003 of G, and a\nparticular integer k. Now suppose that we already know how to solve a different\ndecision problem B in polynomial time. Finally, suppose that we have a procedure\nthat transforms any instance ˛ of A into some instance ˇ of B with the following\ncharacteristics:\n\u0002\nThe transformation takes polynomial time.\n\u0002\nThe answers are the same. That is, the answer for ˛ is “yes” if and only if the\nanswer for ˇ is also “yes.”\n1052\nChapter 34\nNP-Completeness\npolynomial-time\nreduction algorithm\ninstance β\npolynomial-time\nalgorithm to decide B\nyes\nyes\npolynomial-time algorithm to decide A\nno\nno\nof B\ninstance α",
    "parent_c6d3d8c2-bc7d-4f70-98ce-a55a4aa5346a": "\u0002\nThe answers are the same. That is, the answer for ˛ is “yes” if and only if the\nanswer for ˇ is also “yes.”\n1052\nChapter 34\nNP-Completeness\npolynomial-time\nreduction algorithm\ninstance β\npolynomial-time\nalgorithm to decide B\nyes\nyes\npolynomial-time algorithm to decide A\nno\nno\nof B\ninstance α\nof A\nFigure 34.1\nHow to use a polynomial-time reduction algorithm to solve a decision problem A in\npolynomial time, given a polynomial-time decision algorithm for another problem B. In polynomial\ntime, we transform an instance ˛ of A into an instance ˇ of B, we solve B in polynomial time, and\nwe use the answer for ˇ as the answer for ˛.\nWe call such a procedure a polynomial-time reduction algorithm and, as Fig-\nure 34.1 shows, it provides us a way to solve problem A in polynomial time:\n1. Given an instance ˛ of problem A, use a polynomial-time reduction algorithm\nto transform it to an instance ˇ of problem B.\n2. Run the polynomial-time decision algorithm for B on the instance ˇ.\n3. Use the answer for ˇ as the answer for ˛.\nAs long as each of these steps takes polynomial time, all three together do also, and\nso we have a way to decide on ˛ in polynomial time. In other words, by “reducing”\nsolving problem A to solving problem B, we use the “easiness” of B to prove the\n“easiness” of A.\nRecalling that NP-completeness is about showing how hard a problem is rather\nthan how easy it is, we use polynomial-time reductions in the opposite way to show\nthat a problem is NP-complete. Let us take the idea a step further, and show how we\ncould use polynomial-time reductions to show that no polynomial-time algorithm\ncan exist for a particular problem B. Suppose we have a decision problem A for\nwhich we already know that no polynomial-time algorithm can exist. (Let us not\nconcern ourselves for now with how to ﬁnd such a problem A.) Suppose further\nthat we have a polynomial-time reduction transforming instances of A to instances",
    "parent_481d9579-3557-4388-b503-ce72778de270": "which we already know that no polynomial-time algorithm can exist. (Let us not\nconcern ourselves for now with how to ﬁnd such a problem A.) Suppose further\nthat we have a polynomial-time reduction transforming instances of A to instances\nof B. Now we can use a simple proof by contradiction to show that no polynomial-\ntime algorithm can exist for B. Suppose otherwise; i.e., suppose that B has a\npolynomial-time algorithm. Then, using the method shown in Figure 34.1, we\nwould have a way to solve problem A in polynomial time, which contradicts our\nassumption that there is no polynomial-time algorithm for A.\nFor NP-completeness, we cannot assume that there is absolutely no polynomial-\ntime algorithm for problem A. The proof methodology is similar, however, in that\nwe prove that problem B is NP-complete on the assumption that problem A is also\nNP-complete.\n34.1\nPolynomial time\n1053\nA ﬁrst NP-complete problem\nBecause the technique of reduction relies on having a problem already known to\nbe NP-complete in order to prove a different problem NP-complete, we need a\n“ﬁrst” NP-complete problem. The problem we shall use is the circuit-satisﬁability\nproblem, in which we are given a boolean combinational circuit composed of AND,\nOR, and NOT gates, and we wish to know whether there exists some set of boolean\ninputs to this circuit that causes its output to be 1. We shall prove that this ﬁrst\nproblem is NP-complete in Section 34.3.\nChapter outline\nThis chapter studies the aspects of NP-completeness that bear most directly on the\nanalysis of algorithms. In Section 34.1, we formalize our notion of “problem” and\ndeﬁne the complexity class P of polynomial-time solvable decision problems. We\nalso see how these notions ﬁt into the framework of formal-language theory. Sec-\ntion 34.2 deﬁnes the class NP of decision problems whose solutions are veriﬁable\nin polynomial time. It also formally poses the P ¤ NP question.\nSection 34.3 shows we can relate problems via polynomial-time “reductions.”",
    "parent_b903e6aa-a7bd-423a-b85b-06a18b5f2956": "tion 34.2 deﬁnes the class NP of decision problems whose solutions are veriﬁable\nin polynomial time. It also formally poses the P ¤ NP question.\nSection 34.3 shows we can relate problems via polynomial-time “reductions.”\nIt deﬁnes NP-completeness and sketches a proof that one problem, called “circuit\nsatisﬁability,” is NP-complete. Having found one NP-complete problem, we show\nin Section 34.4 how to prove other problems to be NP-complete much more simply\nby the methodology of reductions. We illustrate this methodology by showing that\ntwo formula-satisﬁability problems are NP-complete. With additional reductions,\nwe show in Section 34.5 a variety of other problems to be NP-complete.\n34.1\nPolynomial time\nWe begin our study of NP-completeness by formalizing our notion of polynomial-\ntime solvable problems. We generally regard these problems as tractable, but for\nphilosophical, not mathematical, reasons.\nWe can offer three supporting argu-\nments.\nFirst, although we may reasonably regard a problem that requires time ‚.n100/\nto be intractable, very few practical problems require time on the order of such a\nhigh-degree polynomial. The polynomial-time computable problems encountered\nin practice typically require much less time. Experience has shown that once the\nﬁrst polynomial-time algorithm for a problem has been discovered, more efﬁcient\nalgorithms often follow. Even if the current best algorithm for a problem has a\nrunning time of ‚.n100/, an algorithm with a much better running time will likely\nsoon be discovered.\n1054\nChapter 34\nNP-Completeness\nSecond, for many reasonable models of computation, a problem that can be\nsolved in polynomial time in one model can be solved in polynomial time in an-\nother. For example, the class of problems solvable in polynomial time by the serial\nrandom-access machine used throughout most of this book is the same as the class\nof problems solvable in polynomial time on abstract Turing machines.1 It is also",
    "parent_db3591bb-9110-44ac-8fcb-a346f78fcc59": "other. For example, the class of problems solvable in polynomial time by the serial\nrandom-access machine used throughout most of this book is the same as the class\nof problems solvable in polynomial time on abstract Turing machines.1 It is also\nthe same as the class of problems solvable in polynomial time on a parallel com-\nputer when the number of processors grows polynomially with the input size.\nThird, the class of polynomial-time solvable problems has nice closure proper-\nties, since polynomials are closed under addition, multiplication, and composition.\nFor example, if the output of one polynomial-time algorithm is fed into the input of\nanother, the composite algorithm is polynomial. Exercise 34.1-5 asks you to show\nthat if an algorithm makes a constant number of calls to polynomial-time subrou-\ntines and performs an additional amount of work that also takes polynomial time,\nthen the running time of the composite algorithm is polynomial.\nAbstract problems\nTo understand the class of polynomial-time solvable problems, we must ﬁrst have\na formal notion of what a “problem” is. We deﬁne an abstract problem Q to be a\nbinary relation on a set I of problem instances and a set S of problem solutions.\nFor example, an instance for SHORTEST-PATH is a triple consisting of a graph\nand two vertices. A solution is a sequence of vertices in the graph, with perhaps\nthe empty sequence denoting that no path exists. The problem SHORTEST-PATH\nitself is the relation that associates each instance of a graph and two vertices with\na shortest path in the graph that connects the two vertices. Since shortest paths are\nnot necessarily unique, a given problem instance may have more than one solution.\nThis formulation of an abstract problem is more general than we need for our\npurposes. As we saw above, the theory of NP-completeness restricts attention to\ndecision problems: those having a yes/no solution. In this case, we can view an",
    "parent_62a25e7d-d5f6-4f86-9177-313eb7a2a8d4": "This formulation of an abstract problem is more general than we need for our\npurposes. As we saw above, the theory of NP-completeness restricts attention to\ndecision problems: those having a yes/no solution. In this case, we can view an\nabstract decision problem as a function that maps the instance set I to the solution\nset f0; 1g. For example, a decision problem related to SHORTEST-PATH is the\nproblem PATH that we saw earlier. If i D hG;u;\u0003;ki is an instance of the decision\nproblem PATH, then PATH.i/ D 1 (yes) if a shortest path from u to \u0003 has at\nmost k edges, and PATH.i/ D 0 (no) otherwise. Many abstract problems are not\ndecision problems, but rather optimization problems, which require some value to\nbe minimized or maximized. As we saw above, however, we can usually recast an\noptimization problem as a decision problem that is no harder.\n1See Hopcroft and Ullman [180] or Lewis and Papadimitriou [236] for a thorough treatment of the\nTuring-machine model.\n34.1\nPolynomial time\n1055\nEncodings\nIn order for a computer program to solve an abstract problem, we must represent\nproblem instances in a way that the program understands. An encoding of a set S\nof abstract objects is a mapping e from S to the set of binary strings.2 For example,\nwe are all familiar with encoding the natural numbers N D f0; 1; 2; 3; 4; : : :g as\nthe strings f0; 1; 10; 11; 100; : : :g. Using this encoding, e.17/ D 10001. If you\nhave looked at computer representations of keyboard characters, you probably have\nseen the ASCII code, where, for example, the encoding of A is 1000001. We can\nencode a compound object as a binary string by combining the representations of\nits constituent parts. Polygons, graphs, functions, ordered pairs, programs—all can\nbe encoded as binary strings.\nThus, a computer algorithm that “solves” some abstract decision problem actu-\nally takes an encoding of a problem instance as input. We call a problem whose",
    "parent_ab91e6ec-aa2b-4973-8750-75e2ba57f62a": "its constituent parts. Polygons, graphs, functions, ordered pairs, programs—all can\nbe encoded as binary strings.\nThus, a computer algorithm that “solves” some abstract decision problem actu-\nally takes an encoding of a problem instance as input. We call a problem whose\ninstance set is the set of binary strings a concrete problem. We say that an algo-\nrithm solves a concrete problem in time O.T .n// if, when it is provided a problem\ninstance i of length n D jij, the algorithm can produce the solution in O.T .n//\ntime.3 A concrete problem is polynomial-time solvable, therefore, if there exists\nan algorithm to solve it in time O.nk/ for some constant k.\nWe can now formally deﬁne the complexity class P as the set of concrete deci-\nsion problems that are polynomial-time solvable.\nWe can use encodings to map abstract problems to concrete problems. Given\nan abstract decision problem Q mapping an instance set I to f0; 1g, an encoding\ne W I ! f0; 1g\u0004 can induce a related concrete decision problem, which we denote\nby e.Q/.4 If the solution to an abstract-problem instance i 2 I is Q.i/ 2 f0; 1g,\nthen the solution to the concrete-problem instance e.i/ 2 f0; 1g\u0004 is also Q.i/. As a\ntechnicality, some binary strings might represent no meaningful abstract-problem\ninstance. For convenience, we shall assume that any such string maps arbitrarily\nto 0. Thus, the concrete problem produces the same solutions as the abstract prob-\nlem on binary-string instances that represent the encodings of abstract-problem\ninstances.\nWe would like to extend the deﬁnition of polynomial-time solvability from con-\ncrete problems to abstract problems by using encodings as the bridge, but we would\n2The codomain of e need not be binary strings; any set of strings over a ﬁnite alphabet having at\nleast 2 symbols will do.\n3We assume that the algorithm’s output is separate from its input. Because it takes at least one time",
    "parent_fe5ad36e-ad12-4d03-b340-0c533d5ca8d2": "2The codomain of e need not be binary strings; any set of strings over a ﬁnite alphabet having at\nleast 2 symbols will do.\n3We assume that the algorithm’s output is separate from its input. Because it takes at least one time\nstep to produce each bit of the output and the algorithm takes O.T .n// time steps, the size of the\noutput is O.T .n//.\n4We denote by f0; 1g\u0004 the set of all strings composed of symbols from the set f0; 1g.\n1056\nChapter 34\nNP-Completeness\nlike the deﬁnition to be independent of any particular encoding. That is, the ef-\nﬁciency of solving a problem should not depend on how the problem is encoded.\nUnfortunately, it depends quite heavily on the encoding. For example, suppose that\nan integer k is to be provided as the sole input to an algorithm, and suppose that\nthe running time of the algorithm is ‚.k/. If the integer k is provided in unary—a\nstring of k 1s—then the running time of the algorithm is O.n/ on length-n inputs,\nwhich is polynomial time. If we use the more natural binary representation of the\ninteger k, however, then the input length is n D blg kc C 1. In this case, the run-\nning time of the algorithm is ‚.k/ D ‚.2n/, which is exponential in the size of the\ninput. Thus, depending on the encoding, the algorithm runs in either polynomial\nor superpolynomial time.\nHow we encode an abstract problem matters quite a bit to how we understand\npolynomial time. We cannot really talk about solving an abstract problem without\nﬁrst specifying an encoding. Nevertheless, in practice, if we rule out “expensive”\nencodings such as unary ones, the actual encoding of a problem makes little dif-\nference to whether the problem can be solved in polynomial time. For example,\nrepresenting integers in base 3 instead of binary has no effect on whether a prob-\nlem is solvable in polynomial time, since we can convert an integer represented in\nbase 3 to an integer represented in base 2 in polynomial time.",
    "parent_122b1259-3cd8-4053-990b-acf45dd3e4df": "representing integers in base 3 instead of binary has no effect on whether a prob-\nlem is solvable in polynomial time, since we can convert an integer represented in\nbase 3 to an integer represented in base 2 in polynomial time.\nWe say that a function f W f0; 1g\u0004 ! f0; 1g\u0004 is polynomial-time computable\nif there exists a polynomial-time algorithm A that, given any input x 2 f0; 1g\u0004,\nproduces as output f .x/. For some set I of problem instances, we say that two en-\ncodings e1 and e2 are polynomially related if there exist two polynomial-time com-\nputable functions f12 and f21 such that for any i 2 I, we have f12.e1.i// D e2.i/\nand f21.e2.i// D e1.i/.5 That is, a polynomial-time algorithm can compute the en-\ncoding e2.i/ from the encoding e1.i/, and vice versa. If two encodings e1 and e2 of\nan abstract problem are polynomially related, whether the problem is polynomial-\ntime solvable or not is independent of which encoding we use, as the following\nlemma shows.\nLemma 34.1\nLet Q be an abstract decision problem on an instance set I, and let e1 and e2 be\npolynomially related encodings on I. Then, e1.Q/ 2 P if and only if e2.Q/ 2 P.\n5Technically, we also require the functions f12 and f21 to “map noninstances to noninstances.”\nA noninstance of an encoding e is a string x 2 f0; 1g\u0004 such that there is no instance i for which\ne.i/ D x. We require that f12.x/ D y for every noninstance x of encoding e1, where y is some non-\ninstance of e2, and that f21.x0/ D y0 for every noninstance x0 of e2, where y0 is some noninstance\nof e1.\n34.1\nPolynomial time\n1057\nProof\nWe need only prove the forward direction, since the backward direction is\nsymmetric. Suppose, therefore, that e1.Q/ can be solved in time O.nk/ for some\nconstant k. Further, suppose that for any problem instance i, the encoding e1.i/\ncan be computed from the encoding e2.i/ in time O.nc/ for some constant c, where\nn D je2.i/j. To solve problem e2.Q/, on input e2.i/, we ﬁrst compute e1.i/ and",
    "parent_46dd28a3-6e5a-43c9-a584-d1efdf2b0a72": "constant k. Further, suppose that for any problem instance i, the encoding e1.i/\ncan be computed from the encoding e2.i/ in time O.nc/ for some constant c, where\nn D je2.i/j. To solve problem e2.Q/, on input e2.i/, we ﬁrst compute e1.i/ and\nthen run the algorithm for e1.Q/ on e1.i/. How long does this take? Converting\nencodings takes time O.nc/, and therefore je1.i/j D O.nc/, since the output of\na serial computer cannot be longer than its running time. Solving the problem\non e1.i/ takes time O.je1.i/jk/ D O.nck/, which is polynomial since both c and k\nare constants.\nThus, whether an abstract problem has its instances encoded in binary or base 3\ndoes not affect its “complexity,” that is, whether it is polynomial-time solvable or\nnot; but if instances are encoded in unary, its complexity may change. In order to\nbe able to converse in an encoding-independent fashion, we shall generally assume\nthat problem instances are encoded in any reasonable, concise fashion, unless we\nspeciﬁcally say otherwise. To be precise, we shall assume that the encoding of an\ninteger is polynomially related to its binary representation, and that the encoding of\na ﬁnite set is polynomially related to its encoding as a list of its elements, enclosed\nin braces and separated by commas. (ASCII is one such encoding scheme.) With\nsuch a “standard” encoding in hand, we can derive reasonable encodings of other\nmathematical objects, such as tuples, graphs, and formulas. To denote the standard\nencoding of an object, we shall enclose the object in angle braces. Thus, hGi\ndenotes the standard encoding of a graph G.\nAs long as we implicitly use an encoding that is polynomially related to this\nstandard encoding, we can talk directly about abstract problems without reference\nto any particular encoding, knowing that the choice of encoding has no effect on\nwhether the abstract problem is polynomial-time solvable. Henceforth, we shall",
    "parent_ca79674a-6ef1-4bc9-9798-f0de4d78f920": "standard encoding, we can talk directly about abstract problems without reference\nto any particular encoding, knowing that the choice of encoding has no effect on\nwhether the abstract problem is polynomial-time solvable. Henceforth, we shall\ngenerally assume that all problem instances are binary strings encoded using the\nstandard encoding, unless we explicitly specify the contrary. We shall also typically\nneglect the distinction between abstract and concrete problems. You should watch\nout for problems that arise in practice, however, in which a standard encoding is\nnot obvious and the encoding does make a difference.\nA formal-language framework\nBy focusing on decision problems, we can take advantage of the machinery of\nformal-language theory.\nLet’s review some deﬁnitions from that theory.\nAn\nalphabet † is a ﬁnite set of symbols.\nA language L over † is any set of\nstrings made up of symbols from †.\nFor example, if † D f0; 1g, the set\nL D f10; 11; 101; 111; 1011; 1101; 10001; : : :g is the language of binary represen-\n1058\nChapter 34\nNP-Completeness\ntations of prime numbers. We denote the empty string by \", the empty language\nby ;, and the language of all strings over † by †\u0004. For example, if † D f0; 1g,\nthen †\u0004 D f\"; 0; 1; 00; 01; 10; 11; 000; : : :g is the set of all binary strings. Every\nlanguage L over † is a subset of †\u0004.\nWe can perform a variety of operations on languages. Set-theoretic operations,\nsuch as union and intersection, follow directly from the set-theoretic deﬁnitions.\nWe deﬁne the complement of L by L D †\u0004 \u0005 L. The concatenation L1L2 of two\nlanguages L1 and L2 is the language\nL D fx1x2 W x1 2 L1 and x2 2 L2g :\nThe closure or Kleene star of a language L is the language\nL\u0004 D f\"g [ L [ L2 [ L3 [ \u0003 \u0003 \u0003 ;\nwhere Lk is the language obtained by concatenating L to itself k times.\nFrom the point of view of language theory, the set of instances for any decision\nproblem Q is simply the set †\u0004, where † D f0; 1g. Since Q is entirely character-",
    "parent_7be780b1-05cf-41a2-93bf-0441d7648461": "L\u0004 D f\"g [ L [ L2 [ L3 [ \u0003 \u0003 \u0003 ;\nwhere Lk is the language obtained by concatenating L to itself k times.\nFrom the point of view of language theory, the set of instances for any decision\nproblem Q is simply the set †\u0004, where † D f0; 1g. Since Q is entirely character-\nized by those problem instances that produce a 1 (yes) answer, we can view Q as\na language L over † D f0; 1g, where\nL D fx 2 †\u0004 W Q.x/ D 1g :\nFor example, the decision problem PATH has the corresponding language\nPATH D fhG; u; \u0003; ki W G D .V; E/ is an undirected graph,\nu; \u0003 2 V;\nk \u0006 0 is an integer, and\nthere exists a path from u to \u0003 in G\nconsisting of at most k edgesg :\n(Where convenient, we shall sometimes use the same name—PATH in this case—\nto refer to both a decision problem and its corresponding language.)\nThe formal-language framework allows us to express concisely the relation be-\ntween decision problems and algorithms that solve them.\nWe say that an al-\ngorithm A accepts a string x 2 f0; 1g\u0004 if, given input x, the algorithm’s out-\nput A.x/ is 1. The language accepted by an algorithm A is the set of strings\nL D fx 2 f0; 1g\u0004 W A.x/ D 1g, that is, the set of strings that the algorithm accepts.\nAn algorithm A rejects a string x if A.x/ D 0.\nEven if language L is accepted by an algorithm A, the algorithm will not neces-\nsarily reject a string x 62 L provided as input to it. For example, the algorithm may\nloop forever. A language L is decided by an algorithm A if every binary string\nin L is accepted by A and every binary string not in L is rejected by A. A lan-\nguage L is accepted in polynomial time by an algorithm A if it is accepted by A\nand if in addition there exists a constant k such that for any length-n string x 2 L,\n34.1\nPolynomial time\n1059\nalgorithm A accepts x in time O.nk/. A language L is decided in polynomial\ntime by an algorithm A if there exists a constant k such that for any length-n string\nx 2 f0; 1g\u0004, the algorithm correctly decides whether x 2 L in time O.nk/. Thus,",
    "parent_b0d5ffde-5a40-40a0-bca1-43bd65254e96": "34.1\nPolynomial time\n1059\nalgorithm A accepts x in time O.nk/. A language L is decided in polynomial\ntime by an algorithm A if there exists a constant k such that for any length-n string\nx 2 f0; 1g\u0004, the algorithm correctly decides whether x 2 L in time O.nk/. Thus,\nto accept a language, an algorithm need only produce an answer when provided a\nstring in L, but to decide a language, it must correctly accept or reject every string\nin f0; 1g\u0004.\nAs an example, the language PATH can be accepted in polynomial time. One\npolynomial-time accepting algorithm veriﬁes that G encodes an undirected graph,\nveriﬁes that u and \u0003 are vertices in G, uses breadth-ﬁrst search to compute a short-\nest path from u to \u0003 in G, and then compares the number of edges on the shortest\npath obtained with k. If G encodes an undirected graph and the path found from u\nto \u0003 has at most k edges, the algorithm outputs 1 and halts. Otherwise, the algo-\nrithm runs forever. This algorithm does not decide PATH, however, since it does\nnot explicitly output 0 for instances in which a shortest path has more than k edges.\nA decision algorithm for PATH must explicitly reject binary strings that do not be-\nlong to PATH. For a decision problem such as PATH, such a decision algorithm is\neasy to design: instead of running forever when there is not a path from u to \u0003 with\nat most k edges, it outputs 0 and halts. (It must also output 0 and halt if the input\nencoding is faulty.) For other problems, such as Turing’s Halting Problem, there\nexists an accepting algorithm, but no decision algorithm exists.\nWe can informally deﬁne a complexity class as a set of languages, membership\nin which is determined by a complexity measure, such as running time, of an\nalgorithm that determines whether a given string x belongs to language L. The\nactual deﬁnition of a complexity class is somewhat more technical.6\nUsing this language-theoretic framework, we can provide an alternative deﬁni-\ntion of the complexity class P:",
    "parent_cb0e37de-0062-4a74-9045-eeefa036f87f": "algorithm that determines whether a given string x belongs to language L. The\nactual deﬁnition of a complexity class is somewhat more technical.6\nUsing this language-theoretic framework, we can provide an alternative deﬁni-\ntion of the complexity class P:\nP D fL \u0007 f0; 1g\u0004 W there exists an algorithm A that decides L\nin polynomial timeg :\nIn fact, P is also the class of languages that can be accepted in polynomial time.\nTheorem 34.2\nP D fL W L is accepted by a polynomial-time algorithmg :\nProof\nBecause the class of languages decided by polynomial-time algorithms is\na subset of the class of languages accepted by polynomial-time algorithms, we\nneed only show that if L is accepted by a polynomial-time algorithm, it is de-\ncided by a polynomial-time algorithm. Let L be the language accepted by some\n6For more on complexity classes, see the seminal paper by Hartmanis and Stearns [162].\n1060\nChapter 34\nNP-Completeness\npolynomial-time algorithm A. We shall use a classic “simulation” argument to\nconstruct another polynomial-time algorithm A0 that decides L. Because A ac-\ncepts L in time O.nk/ for some constant k, there also exists a constant c such\nthat A accepts L in at most cnk steps. For any input string x, the algorithm A0\nsimulates cnk steps of A. After simulating cnk steps, algorithm A0 inspects the be-\nhavior of A. If A has accepted x, then A0 accepts x by outputting a 1. If A has not\naccepted x, then A0 rejects x by outputting a 0. The overhead of A0 simulating A\ndoes not increase the running time by more than a polynomial factor, and thus A0\nis a polynomial-time algorithm that decides L.\nNote that the proof of Theorem 34.2 is nonconstructive. For a given language\nL 2 P, we may not actually know a bound on the running time for the algorithm A\nthat accepts L. Nevertheless, we know that such a bound exists, and therefore, that\nan algorithm A0 exists that can check the bound, even though we may not be able\nto ﬁnd the algorithm A0 easily.\nExercises\n34.1-1",
    "parent_02443e00-31db-4b1b-83ea-a00d19d113f2": "L 2 P, we may not actually know a bound on the running time for the algorithm A\nthat accepts L. Nevertheless, we know that such a bound exists, and therefore, that\nan algorithm A0 exists that can check the bound, even though we may not be able\nto ﬁnd the algorithm A0 easily.\nExercises\n34.1-1\nDeﬁne the optimization problem LONGEST-PATH-LENGTH as the relation that\nassociates each instance of an undirected graph and two vertices with the num-\nber of edges in a longest simple path between the two vertices. Deﬁne the de-\ncision problem LONGEST-PATH D fhG; u; \u0003; ki W G D .V; E/ is an undi-\nrected graph, u; \u0003 2 V , k \u0006 0 is an integer, and there exists a simple path\nfrom u to \u0003 in G consisting of at least k edgesg. Show that the optimization prob-\nlem LONGEST-PATH-LENGTH can be solved in polynomial time if and only if\nLONGEST-PATH 2 P.\n34.1-2\nGive a formal deﬁnition for the problem of ﬁnding the longest simple cycle in an\nundirected graph. Give a related decision problem. Give the language correspond-\ning to the decision problem.\n34.1-3\nGive a formal encoding of directed graphs as binary strings using an adjacency-\nmatrix representation. Do the same using an adjacency-list representation. Argue\nthat the two representations are polynomially related.\n34.1-4\nIs the dynamic-programming algorithm for the 0-1 knapsack problem that is asked\nfor in Exercise 16.2-2 a polynomial-time algorithm? Explain your answer.\n34.2\nPolynomial-time veriﬁcation\n1061\n34.1-5\nShow that if an algorithm makes at most a constant number of calls to polynomial-\ntime subroutines and performs an additional amount of work that also takes polyno-\nmial time, then it runs in polynomial time. Also show that a polynomial number of\ncalls to polynomial-time subroutines may result in an exponential-time algorithm.\n34.1-6\nShow that the class P, viewed as a set of languages, is closed under union, inter-\nsection, concatenation, complement, and Kleene star. That is, if L1; L2 2 P, then",
    "parent_3d659227-a3f3-4445-aabc-1d9977614495": "calls to polynomial-time subroutines may result in an exponential-time algorithm.\n34.1-6\nShow that the class P, viewed as a set of languages, is closed under union, inter-\nsection, concatenation, complement, and Kleene star. That is, if L1; L2 2 P, then\nL1 [ L2 2 P, L1 \\ L2 2 P, L1L2 2 P, L1 2 P, and L\u0004\n1 2 P.\n34.2\nPolynomial-time veriﬁcation\nWe now look at algorithms that verify membership in languages. For example,\nsuppose that for a given instance hG; u; \u0003; ki of the decision problem PATH, we\nare also given a path p from u to \u0003. We can easily check whether p is a path in G\nand whether the length of p is at most k, and if so, we can view p as a “certiﬁcate”\nthat the instance indeed belongs to PATH. For the decision problem PATH, this\ncertiﬁcate doesn’t seem to buy us much. After all, PATH belongs to P—in fact,\nwe can solve PATH in linear time—and so verifying membership from a given\ncertiﬁcate takes as long as solving the problem from scratch. We shall now examine\na problem for which we know of no polynomial-time decision algorithm and yet,\ngiven a certiﬁcate, veriﬁcation is easy.\nHamiltonian cycles\nThe problem of ﬁnding a hamiltonian cycle in an undirected graph has been stud-\nied for over a hundred years. Formally, a hamiltonian cycle of an undirected graph\nG D .V; E/ is a simple cycle that contains each vertex in V . A graph that con-\ntains a hamiltonian cycle is said to be hamiltonian; otherwise, it is nonhamilto-\nnian. The name honors W. R. Hamilton, who described a mathematical game on\nthe dodecahedron (Figure 34.2(a)) in which one player sticks ﬁve pins in any ﬁve\nconsecutive vertices and the other player must complete the path to form a cycle\n1062\nChapter 34\nNP-Completeness\n(a)\n(b)\nFigure 34.2\n(a) A graph representing the vertices, edges, and faces of a dodecahedron, with a\nhamiltonian cycle shown by shaded edges. (b) A bipartite graph with an odd number of vertices.\nAny such graph is nonhamiltonian.",
    "parent_298a4136-3603-491a-8bda-ca28344f0eef": "1062\nChapter 34\nNP-Completeness\n(a)\n(b)\nFigure 34.2\n(a) A graph representing the vertices, edges, and faces of a dodecahedron, with a\nhamiltonian cycle shown by shaded edges. (b) A bipartite graph with an odd number of vertices.\nAny such graph is nonhamiltonian.\ncontaining all the vertices.7 The dodecahedron is hamiltonian, and Figure 34.2(a)\nshows one hamiltonian cycle. Not all graphs are hamiltonian, however. For ex-\nample, Figure 34.2(b) shows a bipartite graph with an odd number of vertices.\nExercise 34.2-2 asks you to show that all such graphs are nonhamiltonian.\nWe can deﬁne the hamiltonian-cycle problem, “Does a graph G have a hamil-\ntonian cycle?” as a formal language:\nHAM-CYCLE D fhGi W G is a hamiltonian graphg :\nHow might an algorithm decide the language HAM-CYCLE? Given a problem\ninstance hGi, one possible decision algorithm lists all permutations of the vertices\nof G and then checks each permutation to see if it is a hamiltonian path. What is\nthe running time of this algorithm? If we use the “reasonable” encoding of a graph\nas its adjacency matrix, the number m of vertices in the graph is \u0004.pn/, where\nn D jhGij is the length of the encoding of G. There are mŠ possible permutations\n7In a letter dated 17 October 1856 to his friend John T. Graves, Hamilton [157, p. 624] wrote, “I\nhave found that some young persons have been much amused by trying a new mathematical game\nwhich the Icosion furnishes, one person sticking ﬁve pins in any ﬁve consecutive points . . . and the\nother player then aiming to insert, which by the theory in this letter can always be done, ﬁfteen other\npins, in cyclical succession, so as to cover all the other points, and to end in immediate proximity to\nthe pin wherewith his antagonist had begun.”\n34.2\nPolynomial-time veriﬁcation\n1063\nof the vertices, and therefore the running time is \u0004.mŠ/ D \u0004.pn Š/ D \u0004.2\npn/,\nwhich is not O.nk/ for any constant k. Thus, this naive algorithm does not run",
    "parent_31a35c43-d86c-4913-93d2-fb20c8b7b3e3": "the pin wherewith his antagonist had begun.”\n34.2\nPolynomial-time veriﬁcation\n1063\nof the vertices, and therefore the running time is \u0004.mŠ/ D \u0004.pn Š/ D \u0004.2\npn/,\nwhich is not O.nk/ for any constant k. Thus, this naive algorithm does not run\nin polynomial time. In fact, the hamiltonian-cycle problem is NP-complete, as we\nshall prove in Section 34.5.\nVeriﬁcation algorithms\nConsider a slightly easier problem. Suppose that a friend tells you that a given\ngraph G is hamiltonian, and then offers to prove it by giving you the vertices in\norder along the hamiltonian cycle. It would certainly be easy enough to verify the\nproof: simply verify that the provided cycle is hamiltonian by checking whether\nit is a permutation of the vertices of V and whether each of the consecutive edges\nalong the cycle actually exists in the graph. You could certainly implement this\nveriﬁcation algorithm to run in O.n2/ time, where n is the length of the encoding\nof G. Thus, a proof that a hamiltonian cycle exists in a graph can be veriﬁed in\npolynomial time.\nWe deﬁne a veriﬁcation algorithm as being a two-argument algorithm A, where\none argument is an ordinary input string x and the other is a binary string y called\na certiﬁcate. A two-argument algorithm A veriﬁes an input string x if there exists\na certiﬁcate y such that A.x; y/ D 1. The language veriﬁed by a veriﬁcation\nalgorithm A is\nL D fx 2 f0; 1g\u0004 W there exists y 2 f0; 1g\u0004 such that A.x; y/ D 1g :\nIntuitively, an algorithm A veriﬁes a language L if for any string x 2 L, there\nexists a certiﬁcate y that A can use to prove that x 2 L. Moreover, for any string\nx 62 L, there must be no certiﬁcate proving that x 2 L. For example, in the\nhamiltonian-cycle problem, the certiﬁcate is the list of vertices in some hamilto-\nnian cycle. If a graph is hamiltonian, the hamiltonian cycle itself offers enough\ninformation to verify this fact. Conversely, if a graph is not hamiltonian, there",
    "parent_11e7ecb9-e168-4222-827e-5354b11290bf": "hamiltonian-cycle problem, the certiﬁcate is the list of vertices in some hamilto-\nnian cycle. If a graph is hamiltonian, the hamiltonian cycle itself offers enough\ninformation to verify this fact. Conversely, if a graph is not hamiltonian, there\ncan be no list of vertices that fools the veriﬁcation algorithm into believing that the\ngraph is hamiltonian, since the veriﬁcation algorithm carefully checks the proposed\n“cycle” to be sure.\n1064\nChapter 34\nNP-Completeness\nThe complexity class NP\nThe complexity class NP is the class of languages that can be veriﬁed by a poly-\nnomial-time algorithm.8 More precisely, a language L belongs to NP if and only if\nthere exist a two-input polynomial-time algorithm A and a constant c such that\nL D fx 2 f0; 1g\u0004 W there exists a certiﬁcate y with jyj D O.jxjc/\nsuch that A.x; y/ D 1g :\nWe say that algorithm A veriﬁes language L in polynomial time.\nFrom our earlier discussion on the hamiltonian-cycle problem, we now see that\nHAM-CYCLE 2 NP. (It is always nice to know that an important set is nonempty.)\nMoreover, if L 2 P, then L 2 NP, since if there is a polynomial-time algorithm\nto decide L, the algorithm can be easily converted to a two-argument veriﬁcation\nalgorithm that simply ignores any certiﬁcate and accepts exactly those input strings\nit determines to be in L. Thus, P \u0007 NP.\nIt is unknown whether P D NP, but most researchers believe that P and NP are\nnot the same class. Intuitively, the class P consists of problems that can be solved\nquickly. The class NP consists of problems for which a solution can be veriﬁed\nquickly. You may have learned from experience that it is often more difﬁcult to\nsolve a problem from scratch than to verify a clearly presented solution, especially\nwhen working under time constraints. Theoretical computer scientists generally\nbelieve that this analogy extends to the classes P and NP, and thus that NP includes\nlanguages that are not in P.",
    "parent_0f7c1683-5af2-4d5b-a6f3-2f26c7985987": "solve a problem from scratch than to verify a clearly presented solution, especially\nwhen working under time constraints. Theoretical computer scientists generally\nbelieve that this analogy extends to the classes P and NP, and thus that NP includes\nlanguages that are not in P.\nThere is more compelling, though not conclusive, evidence that P ¤ NP—the\nexistence of languages that are “NP-complete.” We shall study this class in Sec-\ntion 34.3.\nMany other fundamental questions beyond the P ¤ NP question remain unre-\nsolved. Figure 34.3 shows some possible scenarios. Despite much work by many\nresearchers, no one even knows whether the class NP is closed under comple-\nment. That is, does L 2 NP imply L 2 NP? We can deﬁne the complexity class\nco-NP as the set of languages L such that L 2 NP. We can restate the question\nof whether NP is closed under complement as whether NP D co-NP. Since P is\nclosed under complement (Exercise 34.1-6), it follows from Exercise 34.2-9 that\nP \u0007 NP \\ co-NP. Once again, however, no one knows whether P D NP \\ co-NP\nor whether there is some language in NP \\ co-NP \u0005 P.\n8The name “NP” stands for “nondeterministic polynomial time.” The class NP was originally studied\nin the context of nondeterminism, but this book uses the somewhat simpler yet equivalent notion of\nveriﬁcation. Hopcroft and Ullman [180] give a good presentation of NP-completeness in terms of\nnondeterministic models of computation.\n34.2\nPolynomial-time veriﬁcation\n1065\nco-NP\nNP\n(c)\nP = NP ∩ co-NP\nco-NP\nNP\n(d)\nP\nP = NP = co-NP\n(a)\nNP = co-NP\n(b)\nP\nNP ∩ co-NP\nFigure 34.3\nFour possibilities for relationships among complexity classes. In each diagram, one\nregion enclosing another indicates a proper-subset relation. (a) P D NP D co-NP. Most researchers\nregard this possibility as the most unlikely. (b) If NP is closed under complement, then NP D co-NP,\nbut it need not be the case that P D NP. (c) P D NP\\co-NP, but NP is not closed under complement.",
    "parent_177d7399-136c-45c3-84be-34a02e55f91b": "region enclosing another indicates a proper-subset relation. (a) P D NP D co-NP. Most researchers\nregard this possibility as the most unlikely. (b) If NP is closed under complement, then NP D co-NP,\nbut it need not be the case that P D NP. (c) P D NP\\co-NP, but NP is not closed under complement.\n(d) NP ¤ co-NP and P ¤ NP \\ co-NP. Most researchers regard this possibility as the most likely.\nThus, our understanding of the precise relationship between P and NP is woe-\nfully incomplete. Nevertheless, even though we might not be able to prove that a\nparticular problem is intractable, if we can prove that it is NP-complete, then we\nhave gained valuable information about it.\nExercises\n34.2-1\nConsider the language GRAPH-ISOMORPHISM D fhG1; G2i W G1 and G2 are\nisomorphic graphsg. Prove that GRAPH-ISOMORPHISM 2 NP by describing a\npolynomial-time algorithm to verify the language.\n34.2-2\nProve that if G is an undirected bipartite graph with an odd number of vertices,\nthen G is nonhamiltonian.\n34.2-3\nShow that if HAM-CYCLE 2 P, then the problem of listing the vertices of a\nhamiltonian cycle, in order, is polynomial-time solvable.\n1066\nChapter 34\nNP-Completeness\n34.2-4\nProve that the class NP of languages is closed under union, intersection, concate-\nnation, and Kleene star. Discuss the closure of NP under complement.\n34.2-5\nShow that any language in NP can be decided by an algorithm running in\ntime 2O.nk/ for some constant k.\n34.2-6\nA hamiltonian path in a graph is a simple path that visits every vertex exactly\nonce. Show that the language HAM-PATH D fhG; u; \u0003i W there is a hamiltonian\npath from u to \u0003 in graph Gg belongs to NP.\n34.2-7\nShow that the hamiltonian-path problem from Exercise 34.2-6 can be solved in\npolynomial time on directed acyclic graphs. Give an efﬁcient algorithm for the\nproblem.\n34.2-8\nLet \u0007 be a boolean formula constructed from the boolean input variables x1; x2;\n: : : ; xk, negations (:), ANDs (^), ORs (_), and parentheses. The formula \u0007 is a",
    "parent_f1b4600f-35d3-4929-9930-c937b9e4c3e4": "polynomial time on directed acyclic graphs. Give an efﬁcient algorithm for the\nproblem.\n34.2-8\nLet \u0007 be a boolean formula constructed from the boolean input variables x1; x2;\n: : : ; xk, negations (:), ANDs (^), ORs (_), and parentheses. The formula \u0007 is a\ntautology if it evaluates to 1 for every assignment of 1 and 0 to the input variables.\nDeﬁne TAUTOLOGY as the language of boolean formulas that are tautologies.\nShow that TAUTOLOGY 2 co-NP.\n34.2-9\nProve that P \u0007 co-NP.\n34.2-10\nProve that if NP ¤ co-NP, then P ¤ NP.\n34.2-11\nLet G be a connected, undirected graph with at least 3 vertices, and let G3 be the\ngraph obtained by connecting all pairs of vertices that are connected by a path in G\nof length at most 3. Prove that G3 is hamiltonian. (Hint: Construct a spanning tree\nfor G, and use an inductive argument.)\n34.3\nNP-completeness and reducibility\n1067\n34.3\nNP-completeness and reducibility\nPerhaps the most compelling reason why theoretical computer scientists believe\nthat P ¤ NP comes from the existence of the class of “NP-complete” problems.\nThis class has the intriguing property that if any NP-complete problem can be\nsolved in polynomial time, then every problem in NP has a polynomial-time solu-\ntion, that is, P D NP. Despite years of study, though, no polynomial-time algorithm\nhas ever been discovered for any NP-complete problem.\nThe language HAM-CYCLE is one NP-complete problem. If we could decide\nHAM-CYCLE in polynomial time, then we could solve every problem in NP in\npolynomial time. In fact, if NP \u0005 P should turn out to be nonempty, we could say\nwith certainty that HAM-CYCLE 2 NP \u0005 P.\nThe NP-complete languages are, in a sense, the “hardest” languages in NP. In\nthis section, we shall show how to compare the relative “hardness” of languages\nusing a precise notion called “polynomial-time reducibility.” Then we formally\ndeﬁne the NP-complete languages, and we ﬁnish by sketching a proof that one",
    "parent_83cb7b45-2428-4fa6-8f1c-fbb808472ecf": "this section, we shall show how to compare the relative “hardness” of languages\nusing a precise notion called “polynomial-time reducibility.” Then we formally\ndeﬁne the NP-complete languages, and we ﬁnish by sketching a proof that one\nsuch language, called CIRCUIT-SAT, is NP-complete. In Sections 34.4 and 34.5,\nwe shall use the notion of reducibility to show that many other problems are NP-\ncomplete.\nReducibility\nIntuitively, a problem Q can be reduced to another problem Q0 if any instance of Q\ncan be “easily rephrased” as an instance of Q0, the solution to which provides a\nsolution to the instance of Q. For example, the problem of solving linear equations\nin an indeterminate x reduces to the problem of solving quadratic equations. Given\nan instance ax C b D 0, we transform it to 0x2 C ax C b D 0, whose solution\nprovides a solution to ax C b D 0. Thus, if a problem Q reduces to another\nproblem Q0, then Q is, in a sense, “no harder to solve” than Q0.\nReturning to our formal-language framework for decision problems, we say that\na language L1 is polynomial-time reducible to a language L2, written L1 \u0002P L2,\nif there exists a polynomial-time computable function f W f0; 1g\u0004 ! f0; 1g\u0004 such\nthat for all x 2 f0; 1g\u0004,\nx 2 L1 if and only if f .x/ 2 L2 :\n(34.1)\nWe call the function f the reduction function, and a polynomial-time algorithm F\nthat computes f is a reduction algorithm.\nFigure 34.4 illustrates the idea of a polynomial-time reduction from a lan-\nguage L1 to another language L2. Each language is a subset of f0; 1g\u0004. The\nreduction function f provides a polynomial-time mapping such that if x 2 L1,\n1068\nChapter 34\nNP-Completeness\nL2\nL1\n{0,1}*\n{0,1}*\nf\nFigure 34.4\nAn illustration of a polynomial-time reduction from a language L1 to a language L2\nvia a reduction function f . For any input x 2 f0; 1g\u0004, the question of whether x 2 L1 has the same\nanswer as the question of whether f .x/ 2 L2.\nthen f .x/ 2 L2. Moreover, if x 62 L1, then f .x/ 62 L2. Thus, the reduction func-",
    "parent_d5f088d1-728c-4771-94d2-02f86aa5e5d4": "via a reduction function f . For any input x 2 f0; 1g\u0004, the question of whether x 2 L1 has the same\nanswer as the question of whether f .x/ 2 L2.\nthen f .x/ 2 L2. Moreover, if x 62 L1, then f .x/ 62 L2. Thus, the reduction func-\ntion maps any instance x of the decision problem represented by the language L1\nto an instance f .x/ of the problem represented by L2. Providing an answer to\nwhether f .x/ 2 L2 directly provides the answer to whether x 2 L1.\nPolynomial-time reductions give us a powerful tool for proving that various lan-\nguages belong to P.\nLemma 34.3\nIf L1; L2 \u0007 f0; 1g\u0004 are languages such that L1 \u0002P L2, then L2 2 P implies\nL1 2 P.\nProof\nLet A2 be a polynomial-time algorithm that decides L2, and let F be a\npolynomial-time reduction algorithm that computes the reduction function f . We\nshall construct a polynomial-time algorithm A1 that decides L1.\nFigure 34.5 illustrates how we construct A1. For a given input x 2 f0; 1g\u0004,\nalgorithm A1 uses F to transform x into f .x/, and then it uses A2 to test whether\nf .x/ 2 L2. Algorithm A1 takes the output from algorithm A2 and produces that\nanswer as its own output.\nThe correctness of A1 follows from condition (34.1). The algorithm runs in poly-\nnomial time, since both F and A2 run in polynomial time (see Exercise 34.1-5).\nNP-completeness\nPolynomial-time reductions provide a formal means for showing that one prob-\nlem is at least as hard as another, to within a polynomial-time factor. That is, if\nL1 \u0002P L2, then L1 is not more than a polynomial factor harder than L2, which is\n34.3\nNP-completeness and reducibility\n1069\nx\nF\nf .x/\nA1\nA2\nyes, f .x/ 2 L2\nno, f .x/ 62 L2\nyes, x 2 L1\nno, x 62 L1\nFigure 34.5\nThe proof of Lemma 34.3. The algorithm F is a reduction algorithm that computes the\nreduction function f from L1 to L2 in polynomial time, and A2 is a polynomial-time algorithm that\ndecides L2. Algorithm A1 decides whether x 2 L1 by using F to transform any input x into f .x/\nand then using A2 to decide whether f .x/ 2 L2.",
    "parent_fb1455d0-dc13-461d-ae96-ab72fbda3eff": "reduction function f from L1 to L2 in polynomial time, and A2 is a polynomial-time algorithm that\ndecides L2. Algorithm A1 decides whether x 2 L1 by using F to transform any input x into f .x/\nand then using A2 to decide whether f .x/ 2 L2.\nwhy the “less than or equal to” notation for reduction is mnemonic. We can now\ndeﬁne the set of NP-complete languages, which are the hardest problems in NP.\nA language L \u0007 f0; 1g\u0004 is NP-complete if\n1. L 2 NP, and\n2. L0 \u0002P L for every L0 2 NP.\nIf a language L satisﬁes property 2, but not necessarily property 1, we say that L\nis NP-hard. We also deﬁne NPC to be the class of NP-complete languages.\nAs the following theorem shows, NP-completeness is at the crux of deciding\nwhether P is in fact equal to NP.\nTheorem 34.4\nIf any NP-complete problem is polynomial-time solvable, then P D NP. Equiva-\nlently, if any problem in NP is not polynomial-time solvable, then no NP-complete\nproblem is polynomial-time solvable.\nProof\nSuppose that L 2 P and also that L 2 NPC. For any L0 2 NP, we\nhave L0 \u0002P L by property 2 of the deﬁnition of NP-completeness.\nThus, by\nLemma 34.3, we also have that L0 2 P, which proves the ﬁrst statement of the\ntheorem.\nTo prove the second statement, note that it is the contrapositive of the ﬁrst state-\nment.\nIt is for this reason that research into the P ¤ NP question centers around the\nNP-complete problems. Most theoretical computer scientists believe that P ¤ NP,\nwhich leads to the relationships among P, NP, and NPC shown in Figure 34.6.\nBut, for all we know, someone may yet come up with a polynomial-time algo-\nrithm for an NP-complete problem, thus proving that P D NP. Nevertheless, since\nno polynomial-time algorithm for any NP-complete problem has yet been discov-\n1070\nChapter 34\nNP-Completeness\nNPC\nP\nNP\nFigure 34.6\nHow most theoretical computer scientists view the relationships among P, NP,\nand NPC. Both P and NPC are wholly contained within NP, and P \\ NPC D ;.",
    "parent_30f2415a-7500-4ed3-84d6-ac796f4f9b3d": "no polynomial-time algorithm for any NP-complete problem has yet been discov-\n1070\nChapter 34\nNP-Completeness\nNPC\nP\nNP\nFigure 34.6\nHow most theoretical computer scientists view the relationships among P, NP,\nand NPC. Both P and NPC are wholly contained within NP, and P \\ NPC D ;.\nered, a proof that a problem is NP-complete provides excellent evidence that it is\nintractable.\nCircuit satisﬁability\nWe have deﬁned the notion of an NP-complete problem, but up to this point, we\nhave not actually proved that any problem is NP-complete. Once we prove that at\nleast one problem is NP-complete, we can use polynomial-time reducibility as a\ntool to prove other problems to be NP-complete. Thus, we now focus on demon-\nstrating the existence of an NP-complete problem: the circuit-satisﬁability prob-\nlem.\nUnfortunately, the formal proof that the circuit-satisﬁability problem is NP-\ncomplete requires technical detail beyond the scope of this text. Instead, we shall\ninformally describe a proof that relies on a basic understanding of boolean combi-\nnational circuits.\nBoolean combinational circuits are built from boolean combinational elements\nthat are interconnected by wires. A boolean combinational element is any circuit\nelement that has a constant number of boolean inputs and outputs and that performs\na well-deﬁned function. Boolean values are drawn from the set f0; 1g, where 0\nrepresents FALSE and 1 represents TRUE.\nThe boolean combinational elements that we use in the circuit-satisﬁability prob-\nlem compute simple boolean functions, and they are known as logic gates. Fig-\nure 34.7 shows the three basic logic gates that we use in the circuit-satisﬁability\nproblem: the NOT gate (or inverter), the AND gate, and the OR gate. The NOT\ngate takes a single binary input x, whose value is either 0 or 1, and produces a\nbinary output ´ whose value is opposite that of the input value. Each of the other\ntwo gates takes two binary inputs x and y and produces a single binary output ´.",
    "parent_bc15d3fe-7914-483b-a8c1-9f6447e4a767": "gate takes a single binary input x, whose value is either 0 or 1, and produces a\nbinary output ´ whose value is opposite that of the input value. Each of the other\ntwo gates takes two binary inputs x and y and produces a single binary output ´.\nWe can describe the operation of each gate, and of any boolean combinational\nelement, by a truth table, shown under each gate in Figure 34.7. A truth table gives\nthe outputs of the combinational element for each possible setting of the inputs. For\n34.3\nNP-completeness and reducibility\n1071\nx\ny\nz\nx\ny\nz\n0\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n1\n0\n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n1\n(b)\n(c)\nx\nz\n0\n1\n1\n0\n(a)\nx\nx\nx\ny\ny\n:x\nx ^ y\nx _ y\nFigure 34.7\nThree basic logic gates, with binary inputs and outputs. Under each gate is the truth\ntable that describes the gate’s operation. (a) The NOT gate. (b) The AND gate. (c) The OR gate.\nexample, the truth table for the OR gate tells us that when the inputs are x D 0\nand y D 1, the output value is ´ D 1. We use the symbols : to denote the NOT\nfunction, ^ to denote the AND function, and _ to denote the OR function. Thus,\nfor example, 0 _ 1 D 1.\nWe can generalize AND and OR gates to take more than two inputs. An AND\ngate’s output is 1 if all of its inputs are 1, and its output is 0 otherwise. An OR gate’s\noutput is 1 if any of its inputs are 1, and its output is 0 otherwise.\nA boolean combinational circuit consists of one or more boolean combinational\nelements interconnected by wires. A wire can connect the output of one element\nto the input of another, thereby providing the output value of the ﬁrst element as an\ninput value of the second. Figure 34.8 shows two similar boolean combinational\ncircuits, differing in only one gate. Part (a) of the ﬁgure also shows the values on\nthe individual wires, given the input hx1 D 1; x2 D 1; x3 D 0i. Although a single\nwire may have no more than one combinational-element output connected to it, it\ncan feed several element inputs. The number of element inputs fed by a wire is",
    "parent_215a5335-b4a0-4058-afb4-09fd4933c62a": "the individual wires, given the input hx1 D 1; x2 D 1; x3 D 0i. Although a single\nwire may have no more than one combinational-element output connected to it, it\ncan feed several element inputs. The number of element inputs fed by a wire is\ncalled the fan-out of the wire. If no element output is connected to a wire, the wire\nis a circuit input, accepting input values from an external source. If no element\ninput is connected to a wire, the wire is a circuit output, providing the results of\nthe circuit’s computation to the outside world. (An internal wire can also fan out\nto a circuit output.) For the purpose of deﬁning the circuit-satisﬁability problem,\nwe limit the number of circuit outputs to 1, though in actual hardware design, a\nboolean combinational circuit may have multiple outputs.\nBoolean combinational circuits contain no cycles. In other words, suppose we\ncreate a directed graph G D .V; E/ with one vertex for each combinational element\nand with k directed edges for each wire whose fan-out is k; the graph contains\na directed edge .u; \u0003/ if a wire connects the output of element u to an input of\nelement \u0003. Then G must be acyclic.\n1072\nChapter 34\nNP-Completeness\nx3\nx2\nx1\n(a)\n1\n1\n0\n1\n1\n1\n1\n1\n1\n1\n1\n0\n0\n1\n1\n1\n1\nx3\nx2\nx1\n(b)\nFigure 34.8\nTwo instances of the circuit-satisﬁability problem.\n(a) The assignment hx1 D 1;\nx2 D 1; x3 D 0i to the inputs of this circuit causes the output of the circuit to be 1. The circuit\nis therefore satisﬁable. (b) No assignment to the inputs of this circuit can cause the output of the\ncircuit to be 1. The circuit is therefore unsatisﬁable.\nA truth assignment for a boolean combinational circuit is a set of boolean input\nvalues. We say that a one-output boolean combinational circuit is satisﬁable if it\nhas a satisfying assignment: a truth assignment that causes the output of the circuit\nto be 1. For example, the circuit in Figure 34.8(a) has the satisfying assignment",
    "parent_7de2b9d2-fa69-42d5-a32a-a3f6225ddec2": "values. We say that a one-output boolean combinational circuit is satisﬁable if it\nhas a satisfying assignment: a truth assignment that causes the output of the circuit\nto be 1. For example, the circuit in Figure 34.8(a) has the satisfying assignment\nhx1 D 1; x2 D 1; x3 D 0i, and so it is satisﬁable. As Exercise 34.3-1 asks you to\nshow, no assignment of values to x1, x2, and x3 causes the circuit in Figure 34.8(b)\nto produce a 1 output; it always produces 0, and so it is unsatisﬁable.\nThe circuit-satisﬁability problem is, “Given a boolean combinational circuit\ncomposed of AND, OR, and NOT gates, is it satisﬁable?” In order to pose this\nquestion formally, however, we must agree on a standard encoding for circuits.\nThe size of a boolean combinational circuit is the number of boolean combina-\ntional elements plus the number of wires in the circuit. We could devise a graphlike\nencoding that maps any given circuit C into a binary string hCi whose length is\npolynomial in the size of the circuit itself. As a formal language, we can therefore\ndeﬁne\nCIRCUIT-SAT D fhCi W C is a satisﬁable boolean combinational circuitg :\nThe circuit-satisﬁability problem arises in the area of computer-aided hardware\noptimization. If a subcircuit always produces 0, that subcircuit is unnecessary;\nthe designer can replace it by a simpler subcircuit that omits all logic gates and\nprovides the constant 0 value as its output. You can see why we would like to have\na polynomial-time algorithm for this problem.\nGiven a circuit C, we might attempt to determine whether it is satisﬁable by\nsimply checking all possible assignments to the inputs. Unfortunately, if the circuit\nhas k inputs, then we would have to check up to 2k possible assignments. When\n34.3\nNP-completeness and reducibility\n1073\nthe size of C is polynomial in k, checking each one takes \u0004.2k/ time, which is\nsuperpolynomial in the size of the circuit.9 In fact, as we have claimed, there is",
    "parent_06b926b6-9d52-46ea-9614-dced120cfe16": "has k inputs, then we would have to check up to 2k possible assignments. When\n34.3\nNP-completeness and reducibility\n1073\nthe size of C is polynomial in k, checking each one takes \u0004.2k/ time, which is\nsuperpolynomial in the size of the circuit.9 In fact, as we have claimed, there is\nstrong evidence that no polynomial-time algorithm exists that solves the circuit-\nsatisﬁability problem because circuit satisﬁability is NP-complete. We break the\nproof of this fact into two parts, based on the two parts of the deﬁnition of NP-\ncompleteness.\nLemma 34.5\nThe circuit-satisﬁability problem belongs to the class NP.\nProof\nWe shall provide a two-input, polynomial-time algorithm A that can verify\nCIRCUIT-SAT. One of the inputs to A is (a standard encoding of) a boolean com-\nbinational circuit C. The other input is a certiﬁcate corresponding to an assignment\nof boolean values to the wires in C. (See Exercise 34.3-4 for a smaller certiﬁcate.)\nWe construct the algorithm A as follows. For each logic gate in the circuit, it\nchecks that the value provided by the certiﬁcate on the output wire is correctly\ncomputed as a function of the values on the input wires. Then, if the output of the\nentire circuit is 1, the algorithm outputs 1, since the values assigned to the inputs\nof C provide a satisfying assignment. Otherwise, A outputs 0.\nWhenever a satisﬁable circuit C is input to algorithm A, there exists a certiﬁcate\nwhose length is polynomial in the size of C and that causes A to output a 1. When-\never an unsatisﬁable circuit is input, no certiﬁcate can fool A into believing that\nthe circuit is satisﬁable. Algorithm A runs in polynomial time: with a good imple-\nmentation, linear time sufﬁces. Thus, we can verify CIRCUIT-SAT in polynomial\ntime, and CIRCUIT-SAT 2 NP.\nThe second part of proving that CIRCUIT-SAT is NP-complete is to show that\nthe language is NP-hard. That is, we must show that every language in NP is",
    "parent_8d6f2ea8-9c8d-4de0-8c3c-3b86ab5b0da9": "mentation, linear time sufﬁces. Thus, we can verify CIRCUIT-SAT in polynomial\ntime, and CIRCUIT-SAT 2 NP.\nThe second part of proving that CIRCUIT-SAT is NP-complete is to show that\nthe language is NP-hard. That is, we must show that every language in NP is\npolynomial-time reducible to CIRCUIT-SAT. The actual proof of this fact is full\nof technical intricacies, and so we shall settle for a sketch of the proof based on\nsome understanding of the workings of computer hardware.\nA computer program is stored in the computer memory as a sequence of in-\nstructions. A typical instruction encodes an operation to be performed, addresses\nof operands in memory, and an address where the result is to be stored. A spe-\ncial memory location, called the program counter, keeps track of which instruc-\n9On the other hand, if the size of the circuit C is ‚.2k/, then an algorithm whose running time\nis O.2k/ has a running time that is polynomial in the circuit size. Even if P ¤ NP, this situa-\ntion would not contradict the NP-completeness of the problem; the existence of a polynomial-time\nalgorithm for a special case does not imply that there is a polynomial-time algorithm for all cases.\n1074\nChapter 34\nNP-Completeness\ntion is to be executed next. The program counter automatically increments upon\nfetching each instruction, thereby causing the computer to execute instructions se-\nquentially. The execution of an instruction can cause a value to be written to the\nprogram counter, however, which alters the normal sequential execution and allows\nthe computer to loop and perform conditional branches.\nAt any point during the execution of a program, the computer’s memory holds\nthe entire state of the computation. (We take the memory to include the program\nitself, the program counter, working storage, and any of the various bits of state\nthat a computer maintains for bookkeeping.) We call any particular state of com-\nputer memory a conﬁguration. We can view the execution of an instruction as",
    "parent_ef6b4190-da2b-4d5c-8ace-6185b719aee3": "itself, the program counter, working storage, and any of the various bits of state\nthat a computer maintains for bookkeeping.) We call any particular state of com-\nputer memory a conﬁguration. We can view the execution of an instruction as\nmapping one conﬁguration to another. The computer hardware that accomplishes\nthis mapping can be implemented as a boolean combinational circuit, which we\ndenote by M in the proof of the following lemma.\nLemma 34.6\nThe circuit-satisﬁability problem is NP-hard.\nProof\nLet L be any language in NP. We shall describe a polynomial-time algo-\nrithm F computing a reduction function f that maps every binary string x to a\ncircuit C D f .x/ such that x 2 L if and only if C 2 CIRCUIT-SAT.\nSince L 2 NP, there must exist an algorithm A that veriﬁes L in polynomial\ntime. The algorithm F that we shall construct uses the two-input algorithm A to\ncompute the reduction function f .\nLet T .n/ denote the worst-case running time of algorithm A on length-n input\nstrings, and let k \u0006 1 be a constant such that T .n/ D O.nk/ and the length of the\ncertiﬁcate is O.nk/. (The running time of A is actually a polynomial in the total\ninput size, which includes both an input string and a certiﬁcate, but since the length\nof the certiﬁcate is polynomial in the length n of the input string, the running time\nis polynomial in n.)\nThe basic idea of the proof is to represent the computation of A as a sequence\nof conﬁgurations. As Figure 34.9 illustrates, we can break each conﬁguration into\nparts consisting of the program for A, the program counter and auxiliary machine\nstate, the input x, the certiﬁcate y, and working storage. The combinational cir-\ncuit M, which implements the computer hardware, maps each conﬁguration ci to\nthe next conﬁguration ciC1, starting from the initial conﬁguration c0. Algorithm A\nwrites its output—0 or 1—to some designated location by the time it ﬁnishes ex-\necuting, and if we assume that thereafter A halts, the value never changes. Thus,",
    "parent_8df5fb1d-cd32-439c-bb74-816874bf3828": "the next conﬁguration ciC1, starting from the initial conﬁguration c0. Algorithm A\nwrites its output—0 or 1—to some designated location by the time it ﬁnishes ex-\necuting, and if we assume that thereafter A halts, the value never changes. Thus,\nif the algorithm runs for at most T .n/ steps, the output appears as one of the bits\nin cT .n/.\nThe reduction algorithm F constructs a single combinational circuit that com-\nputes all conﬁgurations produced by a given initial conﬁguration. The idea is to\n34.3\nNP-completeness and reducibility\n1075\nM\nA\nPC\naux machine state\nx\ny\nworking storage\nA\nPC\naux machine state\nx\ny\nworking storage\nM\nA\nPC\naux machine state\nx\ny\nworking storage\nM\nA\nPC\naux machine state\nx\ny\n…\nworking storage\n0/1 output\nM\nc0\nc1\nc2\ncT(n)\nFigure 34.9\nThe sequence of conﬁgurations produced by an algorithm A running on an input x and\ncertiﬁcate y. Each conﬁguration represents the state of the computer for one step of the computation\nand, besides A, x, and y, includes the program counter (PC), auxiliary machine state, and working\nstorage. Except for the certiﬁcate y, the initial conﬁguration c0 is constant. A boolean combinational\ncircuit M maps each conﬁguration to the next conﬁguration. The output is a distinguished bit in the\nworking storage.\n1076\nChapter 34\nNP-Completeness\npaste together T .n/ copies of the circuit M. The output of the ith circuit, which\nproduces conﬁguration ci, feeds directly into the input of the .i C1/st circuit. Thus,\nthe conﬁgurations, rather than being stored in the computer’s memory, simply re-\nside as values on the wires connecting copies of M.\nRecall what the polynomial-time reduction algorithm F must do. Given an in-\nput x, it must compute a circuit C D f .x/ that is satisﬁable if and only if there\nexists a certiﬁcate y such that A.x; y/ D 1. When F obtains an input x, it ﬁrst\ncomputes n D jxj and constructs a combinational circuit C 0 consisting of T .n/",
    "parent_857cd5cd-53df-4f13-a75e-3b7386c4d322": "put x, it must compute a circuit C D f .x/ that is satisﬁable if and only if there\nexists a certiﬁcate y such that A.x; y/ D 1. When F obtains an input x, it ﬁrst\ncomputes n D jxj and constructs a combinational circuit C 0 consisting of T .n/\ncopies of M. The input to C 0 is an initial conﬁguration corresponding to a compu-\ntation on A.x; y/, and the output is the conﬁguration cT .n/.\nAlgorithm F modiﬁes circuit C 0 slightly to construct the circuit C D f .x/.\nFirst, it wires the inputs to C 0 corresponding to the program for A, the initial pro-\ngram counter, the input x, and the initial state of memory directly to these known\nvalues. Thus, the only remaining inputs to the circuit correspond to the certiﬁ-\ncate y. Second, it ignores all outputs from C 0, except for the one bit of cT .n/\ncorresponding to the output of A.\nThis circuit C, so constructed, computes\nC.y/ D A.x; y/ for any input y of length O.nk/. The reduction algorithm F ,\nwhen provided an input string x, computes such a circuit C and outputs it.\nWe need to prove two properties. First, we must show that F correctly computes\na reduction function f . That is, we must show that C is satisﬁable if and only if\nthere exists a certiﬁcate y such that A.x; y/ D 1. Second, we must show that F\nruns in polynomial time.\nTo show that F correctly computes a reduction function, let us suppose that there\nexists a certiﬁcate y of length O.nk/ such that A.x; y/ D 1. Then, if we apply the\nbits of y to the inputs of C, the output of C is C.y/ D A.x; y/ D 1. Thus, if a\ncertiﬁcate exists, then C is satisﬁable. For the other direction, suppose that C is\nsatisﬁable. Hence, there exists an input y to C such that C.y/ D 1, from which\nwe conclude that A.x; y/ D 1. Thus, F correctly computes a reduction function.\nTo complete the proof sketch, we need only show that F runs in time polynomial\nin n D jxj. The ﬁrst observation we make is that the number of bits required to",
    "parent_feb9d9bd-48d9-41ba-9201-ca8838ea3402": "we conclude that A.x; y/ D 1. Thus, F correctly computes a reduction function.\nTo complete the proof sketch, we need only show that F runs in time polynomial\nin n D jxj. The ﬁrst observation we make is that the number of bits required to\nrepresent a conﬁguration is polynomial in n. The program for A itself has constant\nsize, independent of the length of its input x. The length of the input x is n, and\nthe length of the certiﬁcate y is O.nk/. Since the algorithm runs for at most O.nk/\nsteps, the amount of working storage required by A is polynomial in n as well.\n(We assume that this memory is contiguous; Exercise 34.3-5 asks you to extend\nthe argument to the situation in which the locations accessed by A are scattered\nacross a much larger region of memory and the particular pattern of scattering can\ndiffer for each input x.)\nThe combinational circuit M implementing the computer hardware has size\npolynomial in the length of a conﬁguration, which is O.nk/; hence, the size of M\nis polynomial in n. (Most of this circuitry implements the logic of the memory\n34.3\nNP-completeness and reducibility\n1077\nsystem.) The circuit C consists of at most t D O.nk/ copies of M, and hence it\nhas size polynomial in n. The reduction algorithm F can construct C from x in\npolynomial time, since each step of the construction takes polynomial time.\nThe language CIRCUIT-SAT is therefore at least as hard as any language in NP,\nand since it belongs to NP, it is NP-complete.\nTheorem 34.7\nThe circuit-satisﬁability problem is NP-complete.\nProof\nImmediate from Lemmas 34.5 and 34.6 and from the deﬁnition of NP-\ncompleteness.\nExercises\n34.3-1\nVerify that the circuit in Figure 34.8(b) is unsatisﬁable.\n34.3-2\nShow that the \u0002P relation is a transitive relation on languages. That is, show that if\nL1 \u0002P L2 and L2 \u0002P L3, then L1 \u0002P L3.\n34.3-3\nProve that L \u0002P L if and only if L \u0002P L.\n34.3-4\nShow that we could have used a satisfying assignment as a certiﬁcate in an alter-",
    "parent_19e64d6f-dcf2-4ae6-8cfe-cca74aca0b39": "34.3-2\nShow that the \u0002P relation is a transitive relation on languages. That is, show that if\nL1 \u0002P L2 and L2 \u0002P L3, then L1 \u0002P L3.\n34.3-3\nProve that L \u0002P L if and only if L \u0002P L.\n34.3-4\nShow that we could have used a satisfying assignment as a certiﬁcate in an alter-\nnative proof of Lemma 34.5. Which certiﬁcate makes for an easier proof?\n34.3-5\nThe proof of Lemma 34.6 assumes that the working storage for algorithm A occu-\npies a contiguous region of polynomial size. Where in the proof do we exploit this\nassumption? Argue that this assumption does not involve any loss of generality.\n34.3-6\nA language L is complete for a language class C with respect to polynomial-time\nreductions if L 2 C and L0 \u0002P L for all L0 2 C. Show that ; and f0; 1g\u0004 are the\nonly languages in P that are not complete for P with respect to polynomial-time\nreductions.\n1078\nChapter 34\nNP-Completeness\n34.3-7\nShow that, with respect to polynomial-time reductions (see Exercise 34.3-6), L is\ncomplete for NP if and only if L is complete for co-NP.\n34.3-8\nThe reduction algorithm F in the proof of Lemma 34.6 constructs the circuit\nC D f .x/ based on knowledge of x, A, and k. Professor Sartre observes that\nthe string x is input to F , but only the existence of A, k, and the constant factor\nimplicit in the O.nk/ running time is known to F (since the language L belongs\nto NP), not their actual values. Thus, the professor concludes that F can’t possi-\nbly construct the circuit C and that the language CIRCUIT-SAT is not necessarily\nNP-hard. Explain the ﬂaw in the professor’s reasoning.\n34.4\nNP-completeness proofs\nWe proved that the circuit-satisﬁability problem is NP-complete by a direct proof\nthat L \u0002P CIRCUIT-SAT for every language L 2 NP. In this section, we shall\nshow how to prove that languages are NP-complete without directly reducing every\nlanguage in NP to the given language. We shall illustrate this methodology by\nproving that various formula-satisﬁability problems are NP-complete. Section 34.5",
    "parent_3c700a62-0d80-43bb-9aba-b20027b71150": "show how to prove that languages are NP-complete without directly reducing every\nlanguage in NP to the given language. We shall illustrate this methodology by\nproving that various formula-satisﬁability problems are NP-complete. Section 34.5\nprovides many more examples of the methodology.\nThe following lemma is the basis of our method for showing that a language is\nNP-complete.\nLemma 34.8\nIf L is a language such that L0 \u0002P L for some L0 2 NPC, then L is NP-hard. If, in\naddition, L 2 NP, then L 2 NPC.\nProof\nSince L0 is NP-complete, for all L00 2 NP, we have L00 \u0002P L0. By sup-\nposition, L0 \u0002P L, and thus by transitivity (Exercise 34.3-2), we have L00 \u0002P L,\nwhich shows that L is NP-hard. If L 2 NP, we also have L 2 NPC.\nIn other words, by reducing a known NP-complete language L0 to L, we implic-\nitly reduce every language in NP to L. Thus, Lemma 34.8 gives us a method for\nproving that a language L is NP-complete:\n1. Prove L 2 NP.\n2. Select a known NP-complete language L0.\n34.4\nNP-completeness proofs\n1079\n3. Describe an algorithm that computes a function f mapping every instance\nx 2 f0; 1g\u0004 of L0 to an instance f .x/ of L.\n4. Prove that the function f satisﬁes x 2 L0 if and only if f .x/ 2 L for all\nx 2 f0; 1g\u0004.\n5. Prove that the algorithm computing f runs in polynomial time.\n(Steps 2–5 show that L is NP-hard.) This methodology of reducing from a sin-\ngle known NP-complete language is far simpler than the more complicated pro-\ncess of showing directly how to reduce from every language in NP.\nProving\nCIRCUIT-SAT 2 NPC has given us a “foot in the door.” Because we know that the\ncircuit-satisﬁability problem is NP-complete, we now can prove much more easily\nthat other problems are NP-complete. Moreover, as we develop a catalog of known\nNP-complete problems, we will have more and more choices for languages from\nwhich to reduce.\nFormula satisﬁability\nWe illustrate the reduction methodology by giving an NP-completeness proof for",
    "parent_1821ea24-d56b-4bea-b16c-39c9d5259cb6": "that other problems are NP-complete. Moreover, as we develop a catalog of known\nNP-complete problems, we will have more and more choices for languages from\nwhich to reduce.\nFormula satisﬁability\nWe illustrate the reduction methodology by giving an NP-completeness proof for\nthe problem of determining whether a boolean formula, not a circuit, is satisﬁable.\nThis problem has the historical honor of being the ﬁrst problem ever shown to be\nNP-complete.\nWe formulate the (formula) satisﬁability problem in terms of the language SAT\nas follows. An instance of SAT is a boolean formula \u0007 composed of\n1. n boolean variables: x1; x2; : : : ; xn;\n2. m boolean connectives: any boolean function with one or two inputs and one\noutput, such as ^ (AND), _ (OR), : (NOT), ! (implication), $ (if and only\nif); and\n3. parentheses. (Without loss of generality, we assume that there are no redundant\nparentheses, i.e., a formula contains at most one pair of parentheses per boolean\nconnective.)\nWe can easily encode a boolean formula \u0007 in a length that is polynomial in n C m.\nAs in boolean combinational circuits, a truth assignment for a boolean formula \u0007\nis a set of values for the variables of \u0007, and a satisfying assignment is a truth\nassignment that causes it to evaluate to 1. A formula with a satisfying assignment\nis a satisﬁable formula. The satisﬁability problem asks whether a given boolean\nformula is satisﬁable; in formal-language terms,\nSAT D fh\u0007i W \u0007 is a satisﬁable boolean formulag :\nAs an example, the formula\n1080\nChapter 34\nNP-Completeness\n\u0007 D ..x1 ! x2/ _ :..:x1 $ x3/ _ x4// ^ :x2\nhas the satisfying assignment hx1 D 0; x2 D 0; x3 D 1; x4 D 1i, since\n\u0007\nD\n..0 ! 0/ _ :..:0 $ 1/ _ 1// ^ :0\n(34.2)\nD\n.1 _ :.1 _ 1// ^ 1\nD\n.1 _ 0/ ^ 1\nD\n1 ;\nand thus this formula \u0007 belongs to SAT.\nThe naive algorithm to determine whether an arbitrary boolean formula is satis-\nﬁable does not run in polynomial time. A formula with n variables has 2n possible",
    "parent_b5d53ed3-2edd-40a9-86a6-e2cc64242e1d": "\u0007\nD\n..0 ! 0/ _ :..:0 $ 1/ _ 1// ^ :0\n(34.2)\nD\n.1 _ :.1 _ 1// ^ 1\nD\n.1 _ 0/ ^ 1\nD\n1 ;\nand thus this formula \u0007 belongs to SAT.\nThe naive algorithm to determine whether an arbitrary boolean formula is satis-\nﬁable does not run in polynomial time. A formula with n variables has 2n possible\nassignments. If the length of h\u0007i is polynomial in n, then checking every assign-\nment requires \u0004.2n/ time, which is superpolynomial in the length of h\u0007i. As the\nfollowing theorem shows, a polynomial-time algorithm is unlikely to exist.\nTheorem 34.9\nSatisﬁability of boolean formulas is NP-complete.\nProof\nWe start by arguing that SAT 2 NP. Then we prove that SAT is NP-hard by\nshowing that CIRCUIT-SAT \u0002P SAT; by Lemma 34.8, this will prove the theorem.\nTo show that SAT belongs to NP, we show that a certiﬁcate consisting of a\nsatisfying assignment for an input formula \u0007 can be veriﬁed in polynomial time.\nThe verifying algorithm simply replaces each variable in the formula with its cor-\nresponding value and then evaluates the expression, much as we did in equa-\ntion (34.2) above. This task is easy to do in polynomial time. If the expression\nevaluates to 1, then the algorithm has veriﬁed that the formula is satisﬁable. Thus,\nthe ﬁrst condition of Lemma 34.8 for NP-completeness holds.\nTo prove that SAT is NP-hard, we show that CIRCUIT-SAT \u0002P SAT. In other\nwords, we need to show how to reduce any instance of circuit satisﬁability to an\ninstance of formula satisﬁability in polynomial time. We can use induction to\nexpress any boolean combinational circuit as a boolean formula. We simply look\nat the gate that produces the circuit output and inductively express each of the\ngate’s inputs as formulas. We then obtain the formula for the circuit by writing an\nexpression that applies the gate’s function to its inputs’ formulas.\nUnfortunately, this straightforward method does not amount to a polynomial-\ntime reduction. As Exercise 34.4-1 asks you to show, shared subformulas—which",
    "parent_77253dae-3aed-4722-9421-3f7c71ae578c": "expression that applies the gate’s function to its inputs’ formulas.\nUnfortunately, this straightforward method does not amount to a polynomial-\ntime reduction. As Exercise 34.4-1 asks you to show, shared subformulas—which\narise from gates whose output wires have fan-out of 2 or more—can cause the\nsize of the generated formula to grow exponentially. Thus, the reduction algorithm\nmust be somewhat more clever.\nFigure 34.10 illustrates how we overcome this problem, using as an example\nthe circuit from Figure 34.8(a). For each wire xi in the circuit C, the formula \u0007\n34.4\nNP-completeness proofs\n1081\nx6\nx3\nx4\nx7\nx10\nx9\nx8\nx5\nx2\nx1\nFigure 34.10\nReducing circuit satisﬁability to formula satisﬁability. The formula produced by the\nreduction algorithm has a variable for each wire in the circuit.\nhas a variable xi. We can now express how each gate operates as a small formula\ninvolving the variables of its incident wires. For example, the operation of the\noutput AND gate is x10 $ .x7 ^ x8 ^ x9/. We call each of these small formulas a\nclause.\nThe formula \u0007 produced by the reduction algorithm is the AND of the circuit-\noutput variable with the conjunction of clauses describing the operation of each\ngate. For the circuit in the ﬁgure, the formula is\n\u0007 D x10 ^ .x4 $ :x3/\n^ .x5 $ .x1 _ x2//\n^ .x6 $ :x4/\n^ .x7 $ .x1 ^ x2 ^ x4//\n^ .x8 $ .x5 _ x6//\n^ .x9 $ .x6 _ x7//\n^ .x10 $ .x7 ^ x8 ^ x9// :\nGiven a circuit C, it is straightforward to produce such a formula \u0007 in polynomial\ntime.\nWhy is the circuit C satisﬁable exactly when the formula \u0007 is satisﬁable? If C\nhas a satisfying assignment, then each wire of the circuit has a well-deﬁned value,\nand the output of the circuit is 1.\nTherefore, when we assign wire values to\nvariables in \u0007, each clause of \u0007 evaluates to 1, and thus the conjunction of all\nevaluates to 1. Conversely, if some assignment causes \u0007 to evaluate to 1, the\ncircuit C is satisﬁable by an analogous argument.\nThus, we have shown that",
    "parent_3e911ec5-6cd2-4580-afc1-6bc00e29f1ac": "Therefore, when we assign wire values to\nvariables in \u0007, each clause of \u0007 evaluates to 1, and thus the conjunction of all\nevaluates to 1. Conversely, if some assignment causes \u0007 to evaluate to 1, the\ncircuit C is satisﬁable by an analogous argument.\nThus, we have shown that\nCIRCUIT-SAT \u0002P SAT, which completes the proof.\n1082\nChapter 34\nNP-Completeness\n3-CNF satisﬁability\nWe can prove many problems NP-complete by reducing from formula satisﬁability.\nThe reduction algorithm must handle any input formula, though, and this require-\nment can lead to a huge number of cases that we must consider. We often prefer\nto reduce from a restricted language of boolean formulas, so that we need to con-\nsider fewer cases. Of course, we must not restrict the language so much that it\nbecomes polynomial-time solvable. One convenient language is 3-CNF satisﬁabil-\nity, or 3-CNF-SAT.\nWe deﬁne 3-CNF satisﬁability using the following terms. A literal in a boolean\nformula is an occurrence of a variable or its negation. A boolean formula is in\nconjunctive normal form, or CNF, if it is expressed as an AND of clauses, each\nof which is the OR of one or more literals. A boolean formula is in 3-conjunctive\nnormal form, or 3-CNF, if each clause has exactly three distinct literals.\nFor example, the boolean formula\n.x1 _ :x1 _ :x2/ ^ .x3 _ x2 _ x4/ ^ .:x1 _ :x3 _ :x4/\nis in 3-CNF. The ﬁrst of its three clauses is .x1 _ :x1 _ :x2/, which contains the\nthree literals x1, :x1, and :x2.\nIn 3-CNF-SAT, we are asked whether a given boolean formula \u0007 in 3-CNF is\nsatisﬁable. The following theorem shows that a polynomial-time algorithm that\ncan determine the satisﬁability of boolean formulas is unlikely to exist, even when\nthey are expressed in this simple normal form.\nTheorem 34.10\nSatisﬁability of boolean formulas in 3-conjunctive normal form is NP-complete.\nProof\nThe argument we used in the proof of Theorem 34.9 to show that SAT 2\nNP applies equally well here to show that 3-CNF-SAT 2 NP. By Lemma 34.8,",
    "parent_7d60befb-3e09-4de5-acd0-f2a6eb137825": "they are expressed in this simple normal form.\nTheorem 34.10\nSatisﬁability of boolean formulas in 3-conjunctive normal form is NP-complete.\nProof\nThe argument we used in the proof of Theorem 34.9 to show that SAT 2\nNP applies equally well here to show that 3-CNF-SAT 2 NP. By Lemma 34.8,\ntherefore, we need only show that SAT \u0002P 3-CNF-SAT.\nWe break the reduction algorithm into three basic steps. Each step progressively\ntransforms the input formula \u0007 closer to the desired 3-conjunctive normal form.\nThe ﬁrst step is similar to the one used to prove CIRCUIT-SAT \u0002P SAT in\nTheorem 34.9. First, we construct a binary “parse” tree for the input formula \u0007,\nwith literals as leaves and connectives as internal nodes. Figure 34.11 shows such\na parse tree for the formula\n\u0007 D ..x1 ! x2/ _ :..:x1 $ x3/ _ x4// ^ :x2 :\n(34.3)\nShould the input formula contain a clause such as the OR of several literals, we use\nassociativity to parenthesize the expression fully so that every internal node in the\nresulting tree has 1 or 2 children. We can now think of the binary parse tree as a\ncircuit for computing the function.\n34.4\nNP-completeness proofs\n1083\n:x1\nx1\n:x2\nx2\nx3\nx4\ny1\ny2\ny3\ny4\ny5\ny6\n^\n$\n_\n_\n:\n!\nFigure 34.11\nThe tree corresponding to the formula \u0007 D ..x1 !x2/_:..:x1 $x3/_x4//^:x2:\nMimicking the reduction in the proof of Theorem 34.9, we introduce a vari-\nable yi for the output of each internal node. Then, we rewrite the original for-\nmula \u0007 as the AND of the root variable and a conjunction of clauses describing the\noperation of each node. For the formula (34.3), the resulting expression is\n\u00070 D y1 ^ .y1 $ .y2 ^ :x2//\n^ .y2 $ .y3 _ y4//\n^ .y3 $ .x1 ! x2//\n^ .y4 $ :y5/\n^ .y5 $ .y6 _ x4//\n^ .y6 $ .:x1 $ x3// :\nObserve that the formula \u00070 thus obtained is a conjunction of clauses \u00070\ni, each of\nwhich has at most 3 literals. The only requirement that we might fail to meet is\nthat each clause has to be an OR of 3 literals.\nThe second step of the reduction converts each clause \u00070",
    "parent_9417a4cb-2c5c-4814-8fbf-a05e3c8c0b09": "^ .y6 $ .:x1 $ x3// :\nObserve that the formula \u00070 thus obtained is a conjunction of clauses \u00070\ni, each of\nwhich has at most 3 literals. The only requirement that we might fail to meet is\nthat each clause has to be an OR of 3 literals.\nThe second step of the reduction converts each clause \u00070\ni into conjunctive normal\nform. We construct a truth table for \u00070\ni by evaluating all possible assignments to\nits variables. Each row of the truth table consists of a possible assignment of the\nvariables of the clause, together with the value of the clause under that assignment.\nUsing the truth-table entries that evaluate to 0, we build a formula in disjunctive\nnormal form (or DNF)—an OR of ANDs—that is equivalent to :\u00070\ni. We then\nnegate this formula and convert it into a CNF formula \u000700\ni by using DeMorgan’s\n1084\nChapter 34\nNP-Completeness\ny1\ny2\nx2\n.y1 $ .y2 ^ :x2//\n1\n1\n1\n0\n1\n1\n0\n1\n1\n0\n1\n0\n1\n0\n0\n0\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n1\n0\n0\n0\n1\nFigure 34.12\nThe truth table for the clause .y1 $ .y2 ^ :x2//.\nlaws for propositional logic,\n:.a ^ b/\nD\n:a _ :b ;\n:.a _ b/\nD\n:a ^ :b ;\nto complement all literals, change ORs into ANDs, and change ANDs into ORs.\nIn our example, we convert the clause \u00070\n1 D .y1 $ .y2 ^ :x2// into CNF\nas follows. The truth table for \u00070\n1 appears in Figure 34.12. The DNF formula\nequivalent to :\u00070\n1 is\n.y1 ^ y2 ^ x2/ _ .y1 ^ :y2 ^ x2/ _ .y1 ^ :y2 ^ :x2/ _ .:y1 ^ y2 ^ :x2/ :\nNegating and applying DeMorgan’s laws, we get the CNF formula\n\u000700\n1\nD\n.:y1 _ :y2 _ :x2/ ^ .:y1 _ y2 _ :x2/\n^ .:y1 _ y2 _ x2/ ^ .y1 _ :y2 _ x2/ ;\nwhich is equivalent to the original clause \u00070\n1.\nAt this point, we have converted each clause \u00070\ni of the formula \u00070 into a CNF\nformula \u000700\ni , and thus \u00070 is equivalent to the CNF formula \u000700 consisting of the\nconjunction of the \u000700\ni . Moreover, each clause of \u000700 has at most 3 literals.\nThe third and ﬁnal step of the reduction further transforms the formula so that\neach clause has exactly 3 distinct literals. We construct the ﬁnal 3-CNF formula \u0007000",
    "parent_17063ceb-83a4-4e4b-8b72-1c79f3979fb7": "conjunction of the \u000700\ni . Moreover, each clause of \u000700 has at most 3 literals.\nThe third and ﬁnal step of the reduction further transforms the formula so that\neach clause has exactly 3 distinct literals. We construct the ﬁnal 3-CNF formula \u0007000\nfrom the clauses of the CNF formula \u000700. The formula \u0007000 also uses two auxiliary\nvariables that we shall call p and q. For each clause Ci of \u000700, we include the\nfollowing clauses in \u0007000:\n\u0002\nIf Ci has 3 distinct literals, then simply include Ci as a clause of \u0007000.\n\u0002\nIf Ci has 2 distinct literals, that is, if Ci D .l1 _ l2/, where l1 and l2 are literals,\nthen include .l1 _ l2 _ p/ ^ .l1 _ l2 _ :p/ as clauses of \u0007000. The literals\np and :p merely fulﬁll the syntactic requirement that each clause of \u0007000 has\n34.4\nNP-completeness proofs\n1085\nexactly 3 distinct literals. Whether p D 0 or p D 1, one of the clauses is\nequivalent to l1 _l2, and the other evaluates to 1, which is the identity for AND.\n\u0002\nIf Ci has just 1 distinct literal l, then include .l _ p _ q/ ^ .l _ p _ :q/ ^\n.l _ :p _ q/ ^ .l _ :p _ :q/ as clauses of \u0007000. Regardless of the values of p\nand q, one of the four clauses is equivalent to l, and the other 3 evaluate to 1.\nWe can see that the 3-CNF formula \u0007000 is satisﬁable if and only if \u0007 is satisﬁable\nby inspecting each of the three steps. Like the reduction from CIRCUIT-SAT to\nSAT, the construction of \u00070 from \u0007 in the ﬁrst step preserves satisﬁability. The\nsecond step produces a CNF formula \u000700 that is algebraically equivalent to \u00070. The\nthird step produces a 3-CNF formula \u0007000 that is effectively equivalent to \u000700, since\nany assignment to the variables p and q produces a formula that is algebraically\nequivalent to \u000700.\nWe must also show that the reduction can be computed in polynomial time. Con-\nstructing \u00070 from \u0007 introduces at most 1 variable and 1 clause per connective in \u0007.\nConstructing \u000700 from \u00070 can introduce at most 8 clauses into \u000700 for each clause",
    "parent_aa7aac65-a410-4b61-8ba1-9c2f1814f09c": "equivalent to \u000700.\nWe must also show that the reduction can be computed in polynomial time. Con-\nstructing \u00070 from \u0007 introduces at most 1 variable and 1 clause per connective in \u0007.\nConstructing \u000700 from \u00070 can introduce at most 8 clauses into \u000700 for each clause\nfrom \u00070, since each clause of \u00070 has at most 3 variables, and the truth table for\neach clause has at most 23 D 8 rows. The construction of \u0007000 from \u000700 introduces\nat most 4 clauses into \u0007000 for each clause of \u000700. Thus, the size of the resulting\nformula \u0007000 is polynomial in the length of the original formula. Each of the con-\nstructions can easily be accomplished in polynomial time.\nExercises\n34.4-1\nConsider the straightforward (nonpolynomial-time) reduction in the proof of The-\norem 34.9. Describe a circuit of size n that, when converted to a formula by this\nmethod, yields a formula whose size is exponential in n.\n34.4-2\nShow the 3-CNF formula that results when we use the method of Theorem 34.10\non the formula (34.3).\n34.4-3\nProfessor Jagger proposes to show that SAT \u0002P 3-CNF-SAT by using only the\ntruth-table technique in the proof of Theorem 34.10, and not the other steps. That\nis, the professor proposes to take the boolean formula \u0007, form a truth table for\nits variables, derive from the truth table a formula in 3-DNF that is equivalent\nto :\u0007, and then negate and apply DeMorgan’s laws to produce a 3-CNF formula\nequivalent to \u0007. Show that this strategy does not yield a polynomial-time reduction.\n1086\nChapter 34\nNP-Completeness\n34.4-4\nShow that the problem of determining whether a boolean formula is a tautology is\ncomplete for co-NP. (Hint: See Exercise 34.3-7.)\n34.4-5\nShow that the problem of determining the satisﬁability of boolean formulas in dis-\njunctive normal form is polynomial-time solvable.\n34.4-6\nSuppose that someone gives you a polynomial-time algorithm to decide formula\nsatisﬁability. Describe how to use this algorithm to ﬁnd satisfying assignments in\npolynomial time.\n34.4-7",
    "parent_5c3c348a-0860-4740-bf68-94961c20a09a": "junctive normal form is polynomial-time solvable.\n34.4-6\nSuppose that someone gives you a polynomial-time algorithm to decide formula\nsatisﬁability. Describe how to use this algorithm to ﬁnd satisfying assignments in\npolynomial time.\n34.4-7\nLet 2-CNF-SAT be the set of satisﬁable boolean formulas in CNF with exactly 2\nliterals per clause. Show that 2-CNF-SAT 2 P. Make your algorithm as efﬁcient as\npossible. (Hint: Observe that x _ y is equivalent to :x ! y. Reduce 2-CNF-SAT\nto an efﬁciently solvable problem on a directed graph.)\n34.5\nNP-complete problems\nNP-complete problems arise in diverse domains: boolean logic, graphs, arithmetic,\nnetwork design, sets and partitions, storage and retrieval, sequencing and schedul-\ning, mathematical programming, algebra and number theory, games and puzzles,\nautomata and language theory, program optimization, biology, chemistry, physics,\nand more. In this section, we shall use the reduction methodology to provide NP-\ncompleteness proofs for a variety of problems drawn from graph theory and set\npartitioning.\nFigure 34.13 outlines the structure of the NP-completeness proofs in this section\nand Section 34.4. We prove each language in the ﬁgure to be NP-complete by\nreduction from the language that points to it. At the root is CIRCUIT-SAT, which\nwe proved NP-complete in Theorem 34.7.\n34.5.1\nThe clique problem\nA clique in an undirected graph G D .V; E/ is a subset V 0 \u0007 V of vertices, each\npair of which is connected by an edge in E. In other words, a clique is a complete\nsubgraph of G. The size of a clique is the number of vertices it contains. The\nclique problem is the optimization problem of ﬁnding a clique of maximum size in\n34.5\nNP-complete problems\n1087\nCIRCUIT-SAT\nSAT\n3-CNF-SAT\nCLIQUE\nVERTEX-COVER\nSUBSET-SUM\nHAM-CYCLE\nTSP\nFigure 34.13\nThe structure of NP-completeness proofs in Sections 34.4 and 34.5. All proofs ulti-\nmately follow by reduction from the NP-completeness of CIRCUIT-SAT.",
    "parent_c50f2189-5d75-44ba-b96b-cd4156ae02a9": "34.5\nNP-complete problems\n1087\nCIRCUIT-SAT\nSAT\n3-CNF-SAT\nCLIQUE\nVERTEX-COVER\nSUBSET-SUM\nHAM-CYCLE\nTSP\nFigure 34.13\nThe structure of NP-completeness proofs in Sections 34.4 and 34.5. All proofs ulti-\nmately follow by reduction from the NP-completeness of CIRCUIT-SAT.\na graph. As a decision problem, we ask simply whether a clique of a given size k\nexists in the graph. The formal deﬁnition is\nCLIQUE D fhG; ki W G is a graph containing a clique of size kg :\nA naive algorithm for determining whether a graph G D .V; E/ with jV j ver-\ntices has a clique of size k is to list all k-subsets of V , and check each one to\nsee whether it forms a clique. The running time of this algorithm is \u0004.k2\u000bjV j\nk\n\f\n/,\nwhich is polynomial if k is a constant. In general, however, k could be near jV j =2,\nin which case the algorithm runs in superpolynomial time. Indeed, an efﬁcient\nalgorithm for the clique problem is unlikely to exist.\nTheorem 34.11\nThe clique problem is NP-complete.\nProof\nTo show that CLIQUE 2 NP, for a given graph G D .V; E/, we use the\nset V 0 \u0007 V of vertices in the clique as a certiﬁcate for G. We can check whether V 0\nis a clique in polynomial time by checking whether, for each pair u; \u0003 2 V 0, the\nedge .u; \u0003/ belongs to E.\nWe next prove that 3-CNF-SAT \u0002P CLIQUE, which shows that the clique prob-\nlem is NP-hard. You might be surprised that we should be able to prove such a\nresult, since on the surface logical formulas seem to have little to do with graphs.\nThe reduction algorithm begins with an instance of 3-CNF-SAT.\nLet \u0007 D\nC1 ^ C2 ^ \u0003 \u0003 \u0003 ^ Ck be a boolean formula in 3-CNF with k clauses. For r D\n1088\nChapter 34\nNP-Completeness\nx1\nx1\nx2\nx2\nx3\nx3\n:x1\n:x2\n:x3\nC1 D x1 _ :x2 _ :x3\nC2 D :x1 _ x2 _ x3\nC3 D x1 _ x2 _ x3\nFigure 34.14\nThe graph G derived from the 3-CNF formula \u0007 D C1 ^ C2 ^ C3, where C1 D\n.x1 _ :x2 _ :x3/, C2 D .:x1 _ x2 _ x3/, and C3 D .x1 _ x2 _ x3/, in reducing 3-CNF-SAT to",
    "parent_d5594811-a2bc-4349-bc9a-01611b44bc40": "1088\nChapter 34\nNP-Completeness\nx1\nx1\nx2\nx2\nx3\nx3\n:x1\n:x2\n:x3\nC1 D x1 _ :x2 _ :x3\nC2 D :x1 _ x2 _ x3\nC3 D x1 _ x2 _ x3\nFigure 34.14\nThe graph G derived from the 3-CNF formula \u0007 D C1 ^ C2 ^ C3, where C1 D\n.x1 _ :x2 _ :x3/, C2 D .:x1 _ x2 _ x3/, and C3 D .x1 _ x2 _ x3/, in reducing 3-CNF-SAT to\nCLIQUE. A satisfying assignment of the formula has x2 D 0, x3 D 1, and x1 either 0 or 1. This\nassignment satisﬁes C1 with :x2, and it satisﬁes C2 and C3 with x3, corresponding to the clique\nwith lightly shaded vertices.\n1; 2; : : : ; k, each clause Cr has exactly three distinct literals lr\n1, lr\n2, and lr\n3. We shall\nconstruct a graph G such that \u0007 is satisﬁable if and only if G has a clique of size k.\nWe construct the graph G D .V; E/ as follows.\nFor each clause Cr\nD\n.lr\n1 _ lr\n2 _ lr\n3/ in \u0007, we place a triple of vertices \u0003r\n1, \u0003r\n2, and \u0003r\n3 into V . We put\nan edge between two vertices \u0003r\ni and \u0003s\nj if both of the following hold:\n\u0002\n\u0003r\ni and \u0003s\nj are in different triples, that is, r ¤ s, and\n\u0002\ntheir corresponding literals are consistent, that is, lr\ni is not the negation of ls\nj .\nWe can easily build this graph from \u0007 in polynomial time. As an example of this\nconstruction, if we have\n\u0007 D .x1 _ :x2 _ :x3/ ^ .:x1 _ x2 _ x3/ ^ .x1 _ x2 _ x3/ ;\nthen G is the graph shown in Figure 34.14.\nWe must show that this transformation of \u0007 into G is a reduction. First, suppose\nthat \u0007 has a satisfying assignment. Then each clause Cr contains at least one\nliteral lr\ni that is assigned 1, and each such literal corresponds to a vertex \u0003r\ni . Picking\none such “true” literal from each clause yields a set V 0 of k vertices. We claim that\nV 0 is a clique. For any two vertices \u0003r\ni ; \u0003s\nj 2 V 0, where r ¤ s, both corresponding\nliterals lr\ni and ls\nj map to 1 by the given satisfying assignment, and thus the literals\n34.5\nNP-complete problems\n1089\ncannot be complements. Thus, by the construction of G, the edge .\u0003r\ni ; \u0003s\nj / belongs\nto E.",
    "parent_808af054-335f-47f4-9a70-414c8dd8212c": "i ; \u0003s\nj 2 V 0, where r ¤ s, both corresponding\nliterals lr\ni and ls\nj map to 1 by the given satisfying assignment, and thus the literals\n34.5\nNP-complete problems\n1089\ncannot be complements. Thus, by the construction of G, the edge .\u0003r\ni ; \u0003s\nj / belongs\nto E.\nConversely, suppose that G has a clique V 0 of size k. No edges in G connect\nvertices in the same triple, and so V 0 contains exactly one vertex per triple. We can\nassign 1 to each literal lr\ni such that \u0003r\ni 2 V 0 without fear of assigning 1 to both a\nliteral and its complement, since G contains no edges between inconsistent literals.\nEach clause is satisﬁed, and so \u0007 is satisﬁed. (Any variables that do not correspond\nto a vertex in the clique may be set arbitrarily.)\nIn the example of Figure 34.14, a satisfying assignment of \u0007 has x2 D 0 and\nx3 D 1. A corresponding clique of size k D 3 consists of the vertices correspond-\ning to :x2 from the ﬁrst clause, x3 from the second clause, and x3 from the third\nclause. Because the clique contains no vertices corresponding to either x1 or :x1,\nwe can set x1 to either 0 or 1 in this satisfying assignment.\nObserve that in the proof of Theorem 34.11, we reduced an arbitrary instance\nof 3-CNF-SAT to an instance of CLIQUE with a particular structure. You might\nthink that we have shown only that CLIQUE is NP-hard in graphs in which the\nvertices are restricted to occur in triples and in which there are no edges between\nvertices in the same triple. Indeed, we have shown that CLIQUE is NP-hard only\nin this restricted case, but this proof sufﬁces to show that CLIQUE is NP-hard in\ngeneral graphs. Why? If we had a polynomial-time algorithm that solved CLIQUE\non general graphs, it would also solve CLIQUE on restricted graphs.\nThe opposite approach—reducing instances of 3-CNF-SAT with a special struc-\nture to general instances of CLIQUE—would not have sufﬁced, however. Why\nnot? Perhaps the instances of 3-CNF-SAT that we chose to reduce from were",
    "parent_9fe53220-00c2-4be8-b714-850296997cf9": "on general graphs, it would also solve CLIQUE on restricted graphs.\nThe opposite approach—reducing instances of 3-CNF-SAT with a special struc-\nture to general instances of CLIQUE—would not have sufﬁced, however. Why\nnot? Perhaps the instances of 3-CNF-SAT that we chose to reduce from were\n“easy,” and so we would not have reduced an NP-hard problem to CLIQUE.\nObserve also that the reduction used the instance of 3-CNF-SAT, but not the\nsolution. We would have erred if the polynomial-time reduction had relied on\nknowing whether the formula \u0007 is satisﬁable, since we do not know how to decide\nwhether \u0007 is satisﬁable in polynomial time.\n34.5.2\nThe vertex-cover problem\nA vertex cover of an undirected graph G D .V; E/ is a subset V 0 \u0007 V such that\nif .u; \u0003/ 2 E, then u 2 V 0 or \u0003 2 V 0 (or both). That is, each vertex “covers” its\nincident edges, and a vertex cover for G is a set of vertices that covers all the edges\nin E. The size of a vertex cover is the number of vertices in it. For example, the\ngraph in Figure 34.15(b) has a vertex cover fw; ´g of size 2.\nThe vertex-cover problem is to ﬁnd a vertex cover of minimum size in a given\ngraph. Restating this optimization problem as a decision problem, we wish to\n1090\nChapter 34\nNP-Completeness\nu\nv\ny\nx\nz\nw\n(a)\nu\nv\ny\nx\nz\nw\n(b)\nFigure 34.15\nReducing CLIQUE to VERTEX-COVER. (a) An undirected graph G D .V; E/ with\nclique V 0 D fu; \u0003; x; yg. (b) The graph G produced by the reduction algorithm that has vertex cover\nV \u0005 V 0 D fw; ´g.\ndetermine whether a graph has a vertex cover of a given size k. As a language, we\ndeﬁne\nVERTEX-COVER D fhG; ki W graph G has a vertex cover of size kg :\nThe following theorem shows that this problem is NP-complete.\nTheorem 34.12\nThe vertex-cover problem is NP-complete.\nProof\nWe ﬁrst show that VERTEX-COVER 2 NP. Suppose we are given a graph\nG D .V; E/ and an integer k. The certiﬁcate we choose is the vertex cover V 0 \u0007 V\nitself. The veriﬁcation algorithm afﬁrms that jV 0j D k, and then it checks, for each",
    "parent_15a50ed3-f762-46be-9530-0f6b5f925c7a": "Theorem 34.12\nThe vertex-cover problem is NP-complete.\nProof\nWe ﬁrst show that VERTEX-COVER 2 NP. Suppose we are given a graph\nG D .V; E/ and an integer k. The certiﬁcate we choose is the vertex cover V 0 \u0007 V\nitself. The veriﬁcation algorithm afﬁrms that jV 0j D k, and then it checks, for each\nedge .u; \u0003/ 2 E, that u 2 V 0 or \u0003 2 V 0. We can easily verify the certiﬁcate in\npolynomial time.\nWe prove that the vertex-cover problem is NP-hard by showing that CLIQUE \u0002P\nVERTEX-COVER. This reduction relies on the notion of the “complement” of a\ngraph. Given an undirected graph G D .V; E/, we deﬁne the complement of G\nas G D .V; E/, where E D f.u; \u0003/ W u; \u0003 2 V; u ¤ \u0003; and .u; \u0003/ 62 Eg. In other\nwords, G is the graph containing exactly those edges that are not in G. Figure 34.15\nshows a graph and its complement and illustrates the reduction from CLIQUE to\nVERTEX-COVER.\nThe reduction algorithm takes as input an instance hG;ki of the clique problem.\nIt computes the complement G, which we can easily do in polynomial time. The\noutput of the reduction algorithm is the instance hG; jV j \u0005 ki of the vertex-cover\nproblem. To complete the proof, we show that this transformation is indeed a\n34.5\nNP-complete problems\n1091\nreduction: the graph G has a clique of size k if and only if the graph G has a vertex\ncover of size jV j \u0005 k.\nSuppose that G has a clique V 0 \u0007 V with jV 0j D k. We claim that V \u0005 V 0 is a\nvertex cover in G. Let .u; \u0003/ be any edge in E. Then, .u; \u0003/ 62 E, which implies\nthat at least one of u or \u0003 does not belong to V 0, since every pair of vertices in V 0 is\nconnected by an edge of E. Equivalently, at least one of u or \u0003 is in V \u0005 V 0, which\nmeans that edge .u; \u0003/ is covered by V \u0005 V 0. Since .u; \u0003/ was chosen arbitrarily\nfrom E, every edge of E is covered by a vertex in V \u0005 V 0. Hence, the set V \u0005 V 0,\nwhich has size jV j \u0005 k, forms a vertex cover for G.\nConversely, suppose that G has a vertex cover V 0 \u0007 V , where jV 0j D jV j \u0005 k.",
    "parent_0675b86d-50c3-42a1-afc5-303e5b8dd84f": "means that edge .u; \u0003/ is covered by V \u0005 V 0. Since .u; \u0003/ was chosen arbitrarily\nfrom E, every edge of E is covered by a vertex in V \u0005 V 0. Hence, the set V \u0005 V 0,\nwhich has size jV j \u0005 k, forms a vertex cover for G.\nConversely, suppose that G has a vertex cover V 0 \u0007 V , where jV 0j D jV j \u0005 k.\nThen, for all u; \u0003 2 V , if .u; \u0003/ 2 E, then u 2 V 0 or \u0003 2 V 0 or both. The\ncontrapositive of this implication is that for all u; \u0003 2 V , if u 62 V 0 and \u0003 62 V 0,\nthen .u; \u0003/ 2 E. In other words, V \u0005V 0 is a clique, and it has size jV j\u0005jV 0j D k.\nSince VERTEX-COVER is NP-complete, we don’t expect to ﬁnd a polynomial-\ntime algorithm for ﬁnding a minimum-size vertex cover. Section 35.1 presents a\npolynomial-time “approximation algorithm,” however, which produces “approxi-\nmate” solutions for the vertex-cover problem. The size of a vertex cover produced\nby the algorithm is at most twice the minimum size of a vertex cover.\nThus, we shouldn’t give up hope just because a problem is NP-complete. We\nmay be able to design a polynomial-time approximation algorithm that obtains\nnear-optimal solutions, even though ﬁnding an optimal solution is NP-complete.\nChapter 35 gives several approximation algorithms for NP-complete problems.\n34.5.3\nThe hamiltonian-cycle problem\nWe now return to the hamiltonian-cycle problem deﬁned in Section 34.2.\nTheorem 34.13\nThe hamiltonian cycle problem is NP-complete.\nProof\nWe ﬁrst show that HAM-CYCLE belongs to NP. Given a graph G D\n.V; E/, our certiﬁcate is the sequence of jV j vertices that makes up the hamiltonian\ncycle. The veriﬁcation algorithm checks that this sequence contains each vertex\nin V exactly once and that with the ﬁrst vertex repeated at the end, it forms a cycle\nin G. That is, it checks that there is an edge between each pair of consecutive\nvertices and between the ﬁrst and last vertices. We can verify the certiﬁcate in\npolynomial time.\nWe now prove that VERTEX-COVER \u0002P HAM-CYCLE, which shows that",
    "parent_aa0d232d-28bc-40ae-adf8-3caa46ae2d7a": "in G. That is, it checks that there is an edge between each pair of consecutive\nvertices and between the ﬁrst and last vertices. We can verify the certiﬁcate in\npolynomial time.\nWe now prove that VERTEX-COVER \u0002P HAM-CYCLE, which shows that\nHAM-CYCLE is NP-complete. Given an undirected graph G D .V; E/ and an\n1092\nChapter 34\nNP-Completeness\n[u,v,1]\n[u,v,2]\n[u,v,3]\n[u,v,4]\n[u,v,5]\n[u,v,6]\n[v,u,1]\n[v,u,2]\n[v,u,3]\n[v,u,4]\n[v,u,5]\n[v,u,6]\nWuv\n(a)\nWuv\n(b)\n[u,v,1]\n[u,v,6]\n[v,u,1]\n[v,u,6]\nWuv\n(c)\n[u,v,1]\n[u,v,6]\n[v,u,1]\n[v,u,6]\nWuv\n(d)\n[u,v,1]\n[u,v,6]\n[v,u,1]\n[v,u,6]\nFigure 34.16\nThe widget used in reducing the vertex-cover problem to the hamiltonian-cycle prob-\nlem. An edge .u; \u0003/ of graph G corresponds to widget Wu\u0005 in the graph G0 created in the reduction.\n(a) The widget, with individual vertices labeled. (b)–(d) The shaded paths are the only possible ones\nthrough the widget that include all vertices, assuming that the only connections from the widget to\nthe remainder of G0 are through vertices Œu; \u0003; 1\u0002, Œu; \u0003; 6\u0002, Œ\u0003; u; 1\u0002, and Œ\u0003; u; 6\u0002.\ninteger k, we construct an undirected graph G0 D .V 0; E0/ that has a hamiltonian\ncycle if and only if G has a vertex cover of size k.\nOur construction uses a widget, which is a piece of a graph that enforces certain\nproperties. Figure 34.16(a) shows the widget we use. For each edge .u; \u0003/ 2 E, the\ngraph G0 that we construct will contain one copy of this widget, which we denote\nby Wu\u0005. We denote each vertex in Wu\u0005 by Œu; \u0003; i\u0002 or Œ\u0003; u; i\u0002, where 1 \u0002 i \u0002 6, so\nthat each widget Wu\u0005 contains 12 vertices. Widget Wu\u0005 also contains the 14 edges\nshown in Figure 34.16(a).\nAlong with the internal structure of the widget, we enforce the properties we\nwant by limiting the connections between the widget and the remainder of the\ngraph G0 that we construct. In particular, only vertices Œu; \u0003; 1\u0002, Œu; \u0003; 6\u0002, Œ\u0003; u; 1\u0002,\nand Œ\u0003; u; 6\u0002 will have edges incident from outside Wu\u0005. Any hamiltonian cycle",
    "parent_b63884ca-b95f-4fd0-890b-57186d83f67d": "want by limiting the connections between the widget and the remainder of the\ngraph G0 that we construct. In particular, only vertices Œu; \u0003; 1\u0002, Œu; \u0003; 6\u0002, Œ\u0003; u; 1\u0002,\nand Œ\u0003; u; 6\u0002 will have edges incident from outside Wu\u0005. Any hamiltonian cycle\nof G0 must traverse the edges of Wu\u0005 in one of the three ways shown in Fig-\nures 34.16(b)–(d). If the cycle enters through vertex Œu; \u0003; 1\u0002, it must exit through\nvertex Œu; \u0003; 6\u0002, and it either visits all 12 of the widget’s vertices (Figure 34.16(b))\nor the six vertices Œu; \u0003; 1\u0002 through Œu; \u0003; 6\u0002 (Figure 34.16(c)). In the latter case,\nthe cycle will have to reenter the widget to visit vertices Œ\u0003; u; 1\u0002 through Œ\u0003; u; 6\u0002.\nSimilarly, if the cycle enters through vertex Œ\u0003; u; 1\u0002, it must exit through ver-\ntex Œ\u0003; u; 6\u0002, and it either visits all 12 of the widget’s vertices (Figure 34.16(d)) or\nthe six vertices Œ\u0003; u; 1\u0002 through Œ\u0003; u; 6\u0002 (Figure 34.16(c)). No other paths through\nthe widget that visit all 12 vertices are possible. In particular, it is impossible to\nconstruct two vertex-disjoint paths, one of which connects Œu; \u0003; 1\u0002 to Œ\u0003; u; 6\u0002 and\nthe other of which connects Œ\u0003; u; 1\u0002 to Œu; \u0003; 6\u0002, such that the union of the two paths\ncontains all of the widget’s vertices.\n34.5\nNP-complete problems\n1093\n[w,x,1]\n[w,x,6]\n[x,w,1]\n[x,w,6]\nWwx\n(b)\n[x,y,1]\n[x,y,6]\n[y,x,1]\n[y,x,6]\nWxy\n[w,y,1]\n[w,y,6]\n[y,w,1]\n[y,w,6]\nWwy\n[w,z,1]\n[w,z,6]\n[z,w,1]\n[z,w,6]\nWwz\ns1\ns2\nw\nx\nz\ny\n(a)\nFigure 34.17\nReducing an instance of the vertex-cover problem to an instance of the hamiltonian-\ncycle problem. (a) An undirected graph G with a vertex cover of size 2, consisting of the lightly\nshaded vertices w and y. (b) The undirected graph G0 produced by the reduction, with the hamilto-\nnian path corresponding to the vertex cover shaded. The vertex cover fw; yg corresponds to edges\n.s1; Œw; x; 1\u0002/ and .s2; Œy; x; 1\u0002/ appearing in the hamiltonian cycle.\nThe only other vertices in V 0 other than those of widgets are selector vertices",
    "parent_8c177665-721a-4639-8447-4f0de060b5bd": "nian path corresponding to the vertex cover shaded. The vertex cover fw; yg corresponds to edges\n.s1; Œw; x; 1\u0002/ and .s2; Œy; x; 1\u0002/ appearing in the hamiltonian cycle.\nThe only other vertices in V 0 other than those of widgets are selector vertices\ns1; s2; : : : ; sk. We use edges incident on selector vertices in G0 to select the k\nvertices of the cover in G.\nIn addition to the edges in widgets, E0 contains two other types of edges, which\nFigure 34.17 shows. First, for each vertex u 2 V , we add edges to join pairs\nof widgets in order to form a path containing all widgets corresponding to edges\nincident on u in G.\nWe arbitrarily order the vertices adjacent to each vertex\nu 2 V as u.1/; u.2/; : : : ; u.degree.u//, where degree.u/ is the number of vertices\nadjacent to u.\nWe create a path in G0 through all the widgets corresponding\nto edges incident on u by adding to E0 the edges f.Œu; u.i/; 6\u0002; Œu; u.iC1/; 1\u0002/ W\n1 \u0002 i \u0002 degree.u/ \u0005 1g. In Figure 34.17, for example, we order the vertices ad-\njacent to w as x; y; ´, and so graph G0 in part (b) of the ﬁgure includes the edges\n1094\nChapter 34\nNP-Completeness\n.Œw; x; 6\u0002; Œw; y; 1\u0002/ and .Œw; y; 6\u0002; Œw; ´; 1\u0002/. For each vertex u 2 V , these edges\nin G0 ﬁll in a path containing all widgets corresponding to edges incident on u\nin G.\nThe intuition behind these edges is that if we choose a vertex u 2 V in the vertex\ncover of G, we can construct a path from Œu; u.1/; 1\u0002 to Œu; u.degree.u//; 6\u0002 in G0 that\n“covers” all widgets corresponding to edges incident on u. That is, for each of these\nwidgets, say Wu;u.i/, the path either includes all 12 vertices (if u is in the vertex\ncover but u.i/ is not) or just the six vertices Œu; u.i/; 1\u0002; Œu; u.i/; 2\u0002; : : : ; Œu; u.i/; 6\u0002 (if\nboth u and u.i/ are in the vertex cover).\nThe ﬁnal type of edge in E0 joins the ﬁrst vertex Œu; u.1/; 1\u0002 and the last vertex\nŒu; u.degree.u//; 6\u0002 of each of these paths to each of the selector vertices. That is, we\ninclude the edges",
    "parent_f725b590-edd6-49c0-8463-4b9d130d9a29": "both u and u.i/ are in the vertex cover).\nThe ﬁnal type of edge in E0 joins the ﬁrst vertex Œu; u.1/; 1\u0002 and the last vertex\nŒu; u.degree.u//; 6\u0002 of each of these paths to each of the selector vertices. That is, we\ninclude the edges\nf.sj; Œu; u.1/; 1\u0002/ W u 2 V and 1 \u0002 j \u0002 kg\n[ f.sj; Œu; u.degree.u//; 6\u0002/ W u 2 V and 1 \u0002 j \u0002 kg :\nNext, we show that the size of G0 is polynomial in the size of G, and hence we\ncan construct G0 in time polynomial in the size of G. The vertices of G0 are those\nin the widgets, plus the selector vertices. With 12 vertices per widget, plus k \u0002 jV j\nselector vertices, we have a total of\njV 0j\nD\n12 jEj C k\n\u0002\n12 jEj C jV j\nvertices. The edges of G0 are those in the widgets, those that go between widgets,\nand those connecting selector vertices to widgets. Each widget contains 14 edges,\ntotaling 14 jEj in all widgets. For each vertex u 2 V , graph G0 has degree.u/ \u0005 1\nedges going between widgets, so that summed over all vertices in V ,\nX\nu2V\n.degree.u/ \u0005 1/ D 2 jEj \u0005 jV j\nedges go between widgets. Finally, G0 has two edges for each pair consisting of a\nselector vertex and a vertex of V , totaling 2k jV j such edges. The total number of\nedges of G0 is therefore\njE0j\nD\n.14 jEj/ C .2 jEj \u0005 jV j/ C .2k jV j/\nD\n16 jEj C .2k \u0005 1/ jV j\n\u0002\n16 jEj C .2 jV j \u0005 1/ jV j :\nNow we show that the transformation from graph G to G0 is a reduction. That is,\nwe must show that G has a vertex cover of size k if and only if G0 has a hamiltonian\ncycle.\n34.5\nNP-complete problems\n1095\nSuppose that G D .V; E/ has a vertex cover V \u0004 \u0007 V of size k.\nLet\nV \u0004 D fu1; u2; : : : ; ukg.\nAs Figure 34.17 shows, we form a hamiltonian cy-\ncle in G0 by including the following edges10 for each vertex uj 2 V \u0004. Include\nedges\n˚\n.Œuj; u.i/\nj ; 6\u0002; Œuj ; u.iC1/\nj\n; 1\u0002/ W 1 \u0002 i \u0002 degree.uj/ \u0005 1",
    "parent_0731beb0-293c-4f94-98ca-519d0e3a8c5f": ", which connect all\nwidgets corresponding to edges incident on uj. We also include the edges within\nthese widgets as Figures 34.16(b)–(d) show, depending on whether the edge is cov-\nered by one or two vertices in V \u0004. The hamiltonian cycle also includes the edges\nf.sj; Œuj; u.1/\nj ; 1\u0002/ W 1 \u0002 j \u0002 kg\n[ f.sjC1; Œuj; u\n.degree.uj //\nj\n; 6\u0002/ W 1 \u0002 j \u0002 k \u0005 1g\n[ f.s1; Œuk; u.degree.uk//\nk\n; 6\u0002/g :\nBy inspecting Figure 34.17, you can verify that these edges form a cycle. The cycle\nstarts at s1, visits all widgets corresponding to edges incident on u1, then visits s2,\nvisits all widgets corresponding to edges incident on u2, and so on, until it returns\nto s1. The cycle visits each widget either once or twice, depending on whether one\nor two vertices of V \u0004 cover its corresponding edge. Because V \u0004 is a vertex cover\nfor G, each edge in E is incident on some vertex in V \u0004, and so the cycle visits each\nvertex in each widget of G0. Because the cycle also visits every selector vertex, it\nis hamiltonian.\nConversely, suppose that G0 D .V 0; E0/ has a hamiltonian cycle C \u0007 E0. We\nclaim that the set\nV \u0004 D fu 2 V W .sj; Œu; u.1/; 1\u0002/ 2 C for some 1 \u0002 j \u0002 kg\n(34.4)\nis a vertex cover for G. To see why, partition C into maximal paths that start at\nsome selector vertex si, traverse an edge .si; Œu; u.1/; 1\u0002/ for some u 2 V , and end\nat a selector vertex sj without passing through any other selector vertex. Let us call\neach such path a “cover path.” From how G0 is constructed, each cover path must\nstart at some si, take the edge .si; Œu; u.1/; 1\u0002/ for some vertex u 2 V , pass through\nall the widgets corresponding to edges in E incident on u, and then end at some\nselector vertex sj. We refer to this cover path as pu, and by equation (34.4), we\nput u into V \u0004. Each widget visited by pu must be Wu\u0005 or W\u0005u for some \u0003 2 V .\nFor each widget visited by pu, its vertices are visited by either one or two cover\npaths. If they are visited by one cover path, then edge .u; \u0003/ 2 E is covered in G",
    "parent_dac0e22d-c0a5-4532-a036-e862d2fb306d": "put u into V \u0004. Each widget visited by pu must be Wu\u0005 or W\u0005u for some \u0003 2 V .\nFor each widget visited by pu, its vertices are visited by either one or two cover\npaths. If they are visited by one cover path, then edge .u; \u0003/ 2 E is covered in G\nby vertex u. If two cover paths visit the widget, then the other cover path must\nbe p\u0005, which implies that \u0003 2 V \u0004, and edge .u; \u0003/ 2 E is covered by both u and \u0003.\n10Technically, we deﬁne a cycle in terms of vertices rather than edges (see Section B.4). In the\ninterest of clarity, we abuse notation here and deﬁne the hamiltonian cycle in terms of edges.\n1096\nChapter 34\nNP-Completeness\nu\nv\nx\nw\n4\n2\n3\n5\n1\n1\nFigure 34.18\nAn instance of the traveling-salesman problem. Shaded edges represent a minimum-\ncost tour, with cost 7.\nBecause each vertex in each widget is visited by some cover path, we see that each\nedge in E is covered by some vertex in V \u0004.\n34.5.4\nThe traveling-salesman problem\nIn the traveling-salesman problem, which is closely related to the hamiltonian-\ncycle problem, a salesman must visit n cities. Modeling the problem as a complete\ngraph with n vertices, we can say that the salesman wishes to make a tour, or\nhamiltonian cycle, visiting each city exactly once and ﬁnishing at the city he starts\nfrom. The salesman incurs a nonnegative integer cost c.i; j / to travel from city i\nto city j , and the salesman wishes to make the tour whose total cost is minimum,\nwhere the total cost is the sum of the individual costs along the edges of the tour.\nFor example, in Figure 34.18, a minimum-cost tour is hu; w; \u0003; x; ui, with cost 7.\nThe formal language for the corresponding decision problem is\nTSP D fhG; c; ki W G D .V; E/ is a complete graph;\nc is a function from V \t V ! Z;\nk 2 Z, and\nG has a traveling-salesman tour with cost at most kg :\nThe following theorem shows that a fast algorithm for the traveling-salesman\nproblem is unlikely to exist.\nTheorem 34.14\nThe traveling-salesman problem is NP-complete.\nProof",
    "parent_bcddc2be-b229-41ab-9283-66ea12beb338": "c is a function from V \t V ! Z;\nk 2 Z, and\nG has a traveling-salesman tour with cost at most kg :\nThe following theorem shows that a fast algorithm for the traveling-salesman\nproblem is unlikely to exist.\nTheorem 34.14\nThe traveling-salesman problem is NP-complete.\nProof\nWe ﬁrst show that TSP belongs to NP. Given an instance of the problem,\nwe use as a certiﬁcate the sequence of n vertices in the tour. The veriﬁcation\nalgorithm checks that this sequence contains each vertex exactly once, sums up the\nedge costs, and checks whether the sum is at most k. This process can certainly be\ndone in polynomial time.\n34.5\nNP-complete problems\n1097\nTo prove that TSP is NP-hard, we show that HAM-CYCLE \u0002P TSP.\nLet\nG D .V; E/ be an instance of HAM-CYCLE. We construct an instance of TSP as\nfollows. We form the complete graph G0 D .V; E0/, where E0 D f.i; j / W i; j 2 V\nand i ¤ j g, and we deﬁne the cost function c by\nc.i; j / D\n(\n0\nif .i; j / 2 E ;\n1\nif .i; j / 62 E :\n(Note that because G is undirected, it has no self-loops, and so c.\u0003; \u0003/ D 1 for all\nvertices \u0003 2 V .) The instance of TSP is then hG0; c; 0i, which we can easily create\nin polynomial time.\nWe now show that graph G has a hamiltonian cycle if and only if graph G0 has a\ntour of cost at most 0. Suppose that graph G has a hamiltonian cycle h. Each edge\nin h belongs to E and thus has cost 0 in G0. Thus, h is a tour in G0 with cost 0.\nConversely, suppose that graph G0 has a tour h0 of cost at most 0. Since the costs\nof the edges in E0 are 0 and 1, the cost of tour h0 is exactly 0 and each edge on the\ntour must have cost 0. Therefore, h0 contains only edges in E. We conclude that h0\nis a hamiltonian cycle in graph G.\n34.5.5\nThe subset-sum problem\nWe next consider an arithmetic NP-complete problem. In the subset-sum problem,\nwe are given a ﬁnite set S of positive integers and an integer target t > 0. We ask\nwhether there exists a subset S 0 \u0007 S whose elements sum to t. For example,",
    "parent_4cf1a0cd-8a04-41a5-aed6-c3354a65db00": "34.5.5\nThe subset-sum problem\nWe next consider an arithmetic NP-complete problem. In the subset-sum problem,\nwe are given a ﬁnite set S of positive integers and an integer target t > 0. We ask\nwhether there exists a subset S 0 \u0007 S whose elements sum to t. For example,\nif S D f1; 2; 7; 14; 49; 98; 343; 686; 2409; 2793; 16808; 17206; 117705; 117993g\nand t D 138457, then the subset S 0 D f1; 2; 7; 98; 343; 686; 2409; 17206; 117705g\nis a solution.\nAs usual, we deﬁne the problem as a language:\nSUBSET-SUM D fhS; ti W there exists a subset S 0 \u0007 S such that t D P\ns2S0 sg :\nAs with any arithmetic problem, it is important to recall that our standard encoding\nassumes that the input integers are coded in binary. With this assumption in mind,\nwe can show that the subset-sum problem is unlikely to have a fast algorithm.\nTheorem 34.15\nThe subset-sum problem is NP-complete.\nProof\nTo show that SUBSET-SUM is in NP, for an instance hS;ti of the problem,\nwe let the subset S 0 be the certiﬁcate. A veriﬁcation algorithm can check whether\nt D P\ns2S0 s in polynomial time.\nWe now show that 3-CNF-SAT \u0002P SUBSET-SUM. Given a 3-CNF formula \u0007\nover variables x1; x2; : : : ; xn with clauses C1; C2; : : : ; Ck, each containing exactly\n1098\nChapter 34\nNP-Completeness\nthree distinct literals, the reduction algorithm constructs an instance hS; ti of the\nsubset-sum problem such that \u0007 is satisﬁable if and only if there exists a subset\nof S whose sum is exactly t. Without loss of generality, we make two simplifying\nassumptions about the formula \u0007. First, no clause contains both a variable and its\nnegation, for such a clause is automatically satisﬁed by any assignment of values\nto the variables. Second, each variable appears in at least one clause, because it\ndoes not matter what value is assigned to a variable that appears in no clauses.\nThe reduction creates two numbers in set S for each variable xi and two numbers\nin S for each clause Cj. We shall create numbers in base 10, where each number",
    "parent_9fe396ea-3a72-43fb-a261-1dc053cb1092": "does not matter what value is assigned to a variable that appears in no clauses.\nThe reduction creates two numbers in set S for each variable xi and two numbers\nin S for each clause Cj. We shall create numbers in base 10, where each number\ncontains nCk digits and each digit corresponds to either one variable or one clause.\nBase 10 (and other bases, as we shall see) has the property we need of preventing\ncarries from lower digits to higher digits.\nAs Figure 34.19 shows, we construct set S and target t as follows. We label\neach digit position by either a variable or a clause. The least signiﬁcant k digits are\nlabeled by the clauses, and the most signiﬁcant n digits are labeled by variables.\n\u0002\nThe target t has a 1 in each digit labeled by a variable and a 4 in each digit\nlabeled by a clause.\n\u0002\nFor each variable xi, set S contains two integers \u0003i and \u00030\ni. Each of \u0003i and \u00030\ni\nhas a 1 in the digit labeled by xi and 0s in the other variable digits. If literal xi\nappears in clause Cj, then the digit labeled by Cj in \u0003i contains a 1. If lit-\neral :xi appears in clause Cj, then the digit labeled by Cj in \u00030\ni contains a 1.\nAll other digits labeled by clauses in \u0003i and \u00030\ni are 0.\nAll \u0003i and \u00030\ni values in set S are unique. Why? For l ¤ i, no \u0003l or \u00030\nl values can\nequal \u0003i and \u00030\ni in the most signiﬁcant n digits. Furthermore, by our simplifying\nassumptions above, no \u0003i and \u00030\ni can be equal in all k least signiﬁcant digits.\nIf \u0003i and \u00030\ni were equal, then xi and :xi would have to appear in exactly the\nsame set of clauses. But we assume that no clause contains both xi and :xi\nand that either xi or :xi appears in some clause, and so there must be some\nclause Cj for which \u0003i and \u00030\ni differ.\n\u0002\nFor each clause Cj, set S contains two integers sj and s0\nj. Each of sj and s0\nj has\n0s in all digits other than the one labeled by Cj. For sj, there is a 1 in the Cj\ndigit, and s0\nj has a 2 in this digit. These integers are “slack variables,” which we",
    "parent_1cca90f4-e245-431c-a908-93542d1f936e": "clause Cj for which \u0003i and \u00030\ni differ.\n\u0002\nFor each clause Cj, set S contains two integers sj and s0\nj. Each of sj and s0\nj has\n0s in all digits other than the one labeled by Cj. For sj, there is a 1 in the Cj\ndigit, and s0\nj has a 2 in this digit. These integers are “slack variables,” which we\nuse to get each clause-labeled digit position to add to the target value of 4.\nSimple inspection of Figure 34.19 demonstrates that all sj and s0\nj values in S\nare unique in set S.\nNote that the greatest sum of digits in any one digit position is 6, which occurs in\nthe digits labeled by clauses (three 1s from the \u0003i and \u00030\ni values, plus 1 and 2 from\n34.5\nNP-complete problems\n1099\n=\n1\n0\n0\n1\n0\n0\n1\n=\n1\n0\n0\n0\n1\n1\n0\n=\n0\n1\n0\n0\n0\n0\n1\n=\n0\n1\n0\n1\n1\n1\n0\n=\n0\n0\n1\n0\n0\n1\n1\n=\n0\n0\n1\n1\n1\n0\n0\n=\n0\n0\n0\n1\n0\n0\n0\n=\n0\n0\n0\n2\n0\n0\n0\n=\n0\n0\n0\n0\n1\n0\n0\n=\n0\n0\n0\n0\n2\n0\n0\n=\n0\n0\n0\n0\n0\n1\n0\n=\n0\n0\n0\n0\n0\n2\n0\n=\n0\n0\n0\n0\n0\n0\n1\n=\n0\n0\n0\n0\n0\n0\n2\n=\n1\n1\n1\n4\n4\n4\n4\nx1\nx2\nx3\nC1\nC2\nC3\nC4\n\u00031\n\u00030\n1\n\u00032\n\u00030\n2\n\u00033\n\u00030\n3\ns1\ns0\n1\ns2\ns0\n2\ns3\ns0\n3\ns4\ns0\n4\nt\nFigure 34.19\nThe reduction of 3-CNF-SAT to SUBSET-SUM. The formula in 3-CNF is \u0007 D\nC1^C2^C3^C4, where C1 D .x1_:x2_:x3/, C2 D .:x1_:x2_:x3/, C3 D .:x1_:x2_x3/,\nand C4 D .x1 _ x2 _ x3/. A satisfying assignment of \u0007 is hx1 D 0; x2 D 0; x3 D 1i. The set S\nproduced by the reduction consists of the base-10 numbers shown; reading from top to bottom, S D\nf1001001; 1000110; 100001; 101110; 10011; 11100; 1000; 2000; 100; 200; 10; 20; 1; 2g. The target t\nis 1114444. The subset S0 \u0007 S is lightly shaded, and it contains \u00030\n1, \u00030\n2, and \u00033, corresponding to the\nsatisfying assignment. It also contains slack variables s1, s0\n1, s0\n2, s3, s4, and s0\n4 to achieve the target\nvalue of 4 in the digits labeled by C1 through C4.\nthe sj and s0\nj values). Interpreting these numbers in base 10, therefore, no carries\ncan occur from lower digits to higher digits.11\nWe can perform the reduction in polynomial time. The set S contains 2n C 2k",
    "parent_14744f32-ab9c-4e8f-89af-1ed6a6c8017c": "4 to achieve the target\nvalue of 4 in the digits labeled by C1 through C4.\nthe sj and s0\nj values). Interpreting these numbers in base 10, therefore, no carries\ncan occur from lower digits to higher digits.11\nWe can perform the reduction in polynomial time. The set S contains 2n C 2k\nvalues, each of which has n C k digits, and the time to produce each digit is poly-\nnomial in n C k. The target t has n C k digits, and the reduction produces each in\nconstant time.\nWe now show that the 3-CNF formula \u0007 is satisﬁable if and only if there exists\na subset S 0 \u0007 S whose sum is t. First, suppose that \u0007 has a satisfying assignment.\nFor i D 1; 2; : : : ; n, if xi D 1 in this assignment, then include \u0003i in S 0. Otherwise,\ninclude \u00030\ni. In other words, we include in S 0 exactly the \u0003i and \u00030\ni values that cor-\n11In fact, any base b, where b \u0006 7, would work. The instance at the beginning of this subsection is\nthe set S and target t in Figure 34.19 interpreted in base 7, with S listed in sorted order.\n1100\nChapter 34\nNP-Completeness\nrespond to literals with the value 1 in the satisfying assignment. Having included\neither \u0003i or \u00030\ni, but not both, for all i, and having put 0 in the digits labeled by\nvariables in all sj and s0\nj , we see that for each variable-labeled digit, the sum of the\nvalues of S 0 must be 1, which matches those digits of the target t. Because each\nclause is satisﬁed, the clause contains some literal with the value 1. Therefore,\neach digit labeled by a clause has at least one 1 contributed to its sum by a \u0003i or \u00030\ni\nvalue in S 0. In fact, 1, 2, or 3 literals may be 1 in each clause, and so each clause-\nlabeled digit has a sum of 1, 2, or 3 from the \u0003i and \u00030\ni values in S 0. In Figure 34.19\nfor example, literals :x1, :x2, and x3 have the value 1 in a satisfying assignment.\nEach of clauses C1 and C4 contains exactly one of these literals, and so together \u00030\n1,\n\u00030\n2, and \u00033 contribute 1 to the sum in the digits for C1 and C4. Clause C2 contains",
    "parent_c6544a11-e363-45ad-b550-bff336408eea": "i values in S 0. In Figure 34.19\nfor example, literals :x1, :x2, and x3 have the value 1 in a satisfying assignment.\nEach of clauses C1 and C4 contains exactly one of these literals, and so together \u00030\n1,\n\u00030\n2, and \u00033 contribute 1 to the sum in the digits for C1 and C4. Clause C2 contains\ntwo of these literals, and \u00030\n1, \u00030\n2, and \u00033 contribute 2 to the sum in the digit for C2.\nClause C3 contains all three of these literals, and \u00030\n1, \u00030\n2, and \u00033 contribute 3 to the\nsum in the digit for C3. We achieve the target of 4 in each digit labeled by clause Cj\nby including in S 0 the appropriate nonempty subset of slack variables fsj; s0\nj g. In\nFigure 34.19, S 0 includes s1, s0\n1, s0\n2, s3, s4, and s0\n4. Since we have matched the target\nin all digits of the sum, and no carries can occur, the values of S 0 sum to t.\nNow, suppose that there is a subset S 0 \u0007 S that sums to t. The subset S 0 must\ninclude exactly one of \u0003i and \u00030\ni for each i D 1; 2; : : : ; n, for otherwise the digits\nlabeled by variables would not sum to 1. If \u0003i 2 S 0, we set xi D 1. Otherwise,\n\u00030\ni 2 S 0, and we set xi D 0. We claim that every clause Cj, for j D 1; 2; : : : ; k, is\nsatisﬁed by this assignment. To prove this claim, note that to achieve a sum of 4 in\nthe digit labeled by Cj, the subset S 0 must include at least one \u0003i or \u00030\ni value that\nhas a 1 in the digit labeled by Cj, since the contributions of the slack variables sj\nand s0\nj together sum to at most 3. If S 0 includes a \u0003i that has a 1 in Cj’s position,\nthen the literal xi appears in clause Cj. Since we have set xi D 1 when \u0003i 2 S 0,\nclause Cj is satisﬁed. If S 0 includes a \u00030\ni that has a 1 in that position, then the\nliteral :xi appears in Cj. Since we have set xi D 0 when \u00030\ni 2 S 0, clause Cj is\nagain satisﬁed. Thus, all clauses of \u0007 are satisﬁed, which completes the proof.\nExercises\n34.5-1\nThe subgraph-isomorphism problem takes two undirected graphs G1 and G2, and",
    "parent_446f6d4b-9b8a-4034-a373-c05024c5efee": "i that has a 1 in that position, then the\nliteral :xi appears in Cj. Since we have set xi D 0 when \u00030\ni 2 S 0, clause Cj is\nagain satisﬁed. Thus, all clauses of \u0007 are satisﬁed, which completes the proof.\nExercises\n34.5-1\nThe subgraph-isomorphism problem takes two undirected graphs G1 and G2, and\nit asks whether G1 is isomorphic to a subgraph of G2. Show that the subgraph-\nisomorphism problem is NP-complete.\n34.5-2\nGiven an integer m \t n matrix A and an integer m-vector b, the 0-1 integer-\nprogramming problem asks whether there exists an integer n-vector x with ele-\nProblems for Chapter 34\n1101\nments in the set f0; 1g such that Ax \u0002 b. Prove that 0-1 integer programming is\nNP-complete. (Hint: Reduce from 3-CNF-SAT.)\n34.5-3\nThe integer linear-programming problem is like the 0-1 integer-programming\nproblem given in Exercise 34.5-2, except that the values of the vector x may be\nany integers rather than just 0 or 1. Assuming that the 0-1 integer-programming\nproblem is NP-hard, show that the integer linear-programming problem is NP-\ncomplete.\n34.5-4\nShow how to solve the subset-sum problem in polynomial time if the target value t\nis expressed in unary.\n34.5-5\nThe set-partition problem takes as input a set S of numbers. The question is\nwhether the numbers can be partitioned into two sets A and A D S \u0005 A such\nthat P\nx2A x D P\nx2A x. Show that the set-partition problem is NP-complete.\n34.5-6\nShow that the hamiltonian-path problem is NP-complete.\n34.5-7\nThe longest-simple-cycle problem is the problem of determining a simple cycle\n(no repeated vertices) of maximum length in a graph. Formulate a related decision\nproblem, and show that the decision problem is NP-complete.\n34.5-8\nIn the half 3-CNF satisﬁability problem, we are given a 3-CNF formula \u0007 with n\nvariables and m clauses, where m is even. We wish to determine whether there\nexists a truth assignment to the variables of \u0007 such that exactly half the clauses",
    "parent_f3abe28c-8518-400f-9fc2-72004ef1a515": "34.5-8\nIn the half 3-CNF satisﬁability problem, we are given a 3-CNF formula \u0007 with n\nvariables and m clauses, where m is even. We wish to determine whether there\nexists a truth assignment to the variables of \u0007 such that exactly half the clauses\nevaluate to 0 and exactly half the clauses evaluate to 1. Prove that the half 3-CNF\nsatisﬁability problem is NP-complete.\nProblems\n34-1\nIndependent set\nAn independent set of a graph G D .V; E/ is a subset V 0 \u0007 V of vertices such\nthat each edge in E is incident on at most one vertex in V 0. The independent-set\nproblem is to ﬁnd a maximum-size independent set in G.\n1102\nChapter 34\nNP-Completeness\na. Formulate a related decision problem for the independent-set problem, and\nprove that it is NP-complete. (Hint: Reduce from the clique problem.)\nb. Suppose that you are given a “black-box” subroutine to solve the decision prob-\nlem you deﬁned in part (a). Give an algorithm to ﬁnd an independent set of max-\nimum size. The running time of your algorithm should be polynomial in jV j\nand jEj, counting queries to the black box as a single step.\nAlthough the independent-set decision problem is NP-complete, certain special\ncases are polynomial-time solvable.\nc. Give an efﬁcient algorithm to solve the independent-set problem when each ver-\ntex in G has degree 2. Analyze the running time, and prove that your algorithm\nworks correctly.\nd. Give an efﬁcient algorithm to solve the independent-set problem when G is\nbipartite. Analyze the running time, and prove that your algorithm works cor-\nrectly. (Hint: Use the results of Section 26.3.)\n34-2\nBonnie and Clyde\nBonnie and Clyde have just robbed a bank. They have a bag of money and want\nto divide it up. For each of the following scenarios, either give a polynomial-time\nalgorithm, or prove that the problem is NP-complete. The input in each case is a\nlist of the n items in the bag, along with the value of each.\na. The bag contains n coins, but only 2 different denominations: some coins are",
    "parent_c735c864-07af-4096-94eb-dc7d297f53f5": "algorithm, or prove that the problem is NP-complete. The input in each case is a\nlist of the n items in the bag, along with the value of each.\na. The bag contains n coins, but only 2 different denominations: some coins are\nworth x dollars, and some are worth y dollars. Bonnie and Clyde wish to divide\nthe money exactly evenly.\nb. The bag contains n coins, with an arbitrary number of different denominations,\nbut each denomination is a nonnegative integer power of 2, i.e., the possible\ndenominations are 1 dollar, 2 dollars, 4 dollars, etc. Bonnie and Clyde wish to\ndivide the money exactly evenly.\nc. The bag contains n checks, which are, in an amazing coincidence, made out to\n“Bonnie or Clyde.” They wish to divide the checks so that they each get the\nexact same amount of money.\nd. The bag contains n checks as in part (c), but this time Bonnie and Clyde are\nwilling to accept a split in which the difference is no larger than 100 dollars.\nProblems for Chapter 34\n1103\n34-3\nGraph coloring\nMapmakers try to use as few colors as possible when coloring countries on a map,\nas long as no two countries that share a border have the same color. We can model\nthis problem with an undirected graph G D .V; E/ in which each vertex repre-\nsents a country and vertices whose respective countries share a border are adjacent.\nThen, a k-coloring is a function c W V ! f1; 2; : : : ; kg such that c.u/ ¤ c.\u0003/ for\nevery edge .u; \u0003/ 2 E. In other words, the numbers 1; 2; : : : ; k represent the k col-\nors, and adjacent vertices must have different colors. The graph-coloring problem\nis to determine the minimum number of colors needed to color a given graph.\na. Give an efﬁcient algorithm to determine a 2-coloring of a graph, if one exists.\nb. Cast the graph-coloring problem as a decision problem. Show that your deci-\nsion problem is solvable in polynomial time if and only if the graph-coloring\nproblem is solvable in polynomial time.",
    "parent_464911d1-536d-41bb-90ac-689390e2c9b2": "a. Give an efﬁcient algorithm to determine a 2-coloring of a graph, if one exists.\nb. Cast the graph-coloring problem as a decision problem. Show that your deci-\nsion problem is solvable in polynomial time if and only if the graph-coloring\nproblem is solvable in polynomial time.\nc. Let the language 3-COLOR be the set of graphs that can be 3-colored. Show\nthat if 3-COLOR is NP-complete, then your decision problem from part (b) is\nNP-complete.\nTo prove that 3-COLOR is NP-complete, we use a reduction from 3-CNF-SAT.\nGiven a formula \u0007 of m clauses on n variables x1, x2, . . . , xn, we construct a graph\nG D .V; E/ as follows. The set V consists of a vertex for each variable, a vertex\nfor the negation of each variable, 5 vertices for each clause, and 3 special vertices:\nTRUE, FALSE, and RED. The edges of the graph are of two types: “literal” edges\nthat are independent of the clauses and “clause” edges that depend on the clauses.\nThe literal edges form a triangle on the special vertices and also form a triangle on\nxi, :xi, and RED for i D 1; 2; : : : ; n.\nd. Argue that in any 3-coloring c of a graph containing the literal edges, exactly\none of a variable and its negation is colored c.TRUE/ and the other is colored\nc.FALSE/. Argue that for any truth assignment for \u0007, there exists a 3-coloring\nof the graph containing just the literal edges.\nThe widget shown in Figure 34.20 helps to enforce the condition corresponding to\na clause .x _ y _ ´/. Each clause requires a unique copy of the 5 vertices that are\nheavily shaded in the ﬁgure; they connect as shown to the literals of the clause and\nthe special vertex TRUE.\ne. Argue that if each of x, y, and ´ is colored c.TRUE/ or c.FALSE/, then the\nwidget is 3-colorable if and only if at least one of x, y, or ´ is colored c.TRUE/.\nf. Complete the proof that 3-COLOR is NP-complete.\n1104\nChapter 34\nNP-Completeness\nx\ny\nz\nTRUE\nFigure 34.20\nThe widget corresponding to a clause .x _ y _ ´/, used in Problem 34-3.\n34-4",
    "parent_a76e7e8f-202c-4459-ae38-c27df4575e0d": "widget is 3-colorable if and only if at least one of x, y, or ´ is colored c.TRUE/.\nf. Complete the proof that 3-COLOR is NP-complete.\n1104\nChapter 34\nNP-Completeness\nx\ny\nz\nTRUE\nFigure 34.20\nThe widget corresponding to a clause .x _ y _ ´/, used in Problem 34-3.\n34-4\nScheduling with proﬁts and deadlines\nSuppose that we have one machine and a set of n tasks a1; a2; : : : ; an, each of\nwhich requires time on the machine. Each task aj requires tj time units on the\nmachine (its processing time), yields a proﬁt of pj, and has a deadline dj. The\nmachine can process only one task at a time, and task aj must run without inter-\nruption for tj consecutive time units. If we complete task aj by its deadline dj, we\nreceive a proﬁt pj, but if we complete it after its deadline, we receive no proﬁt. As\nan optimization problem, we are given the processing times, proﬁts, and deadlines\nfor a set of n tasks, and we wish to ﬁnd a schedule that completes all the tasks and\nreturns the greatest amount of proﬁt. The processing times, proﬁts, and deadlines\nare all nonnegative numbers.\na. State this problem as a decision problem.\nb. Show that the decision problem is NP-complete.\nc. Give a polynomial-time algorithm for the decision problem, assuming that all\nprocessing times are integers from 1 to n. (Hint: Use dynamic programming.)\nd. Give a polynomial-time algorithm for the optimization problem, assuming that\nall processing times are integers from 1 to n.\nChapter notes\nThe book by Garey and Johnson [129] provides a wonderful guide to NP-complete-\nness, discussing the theory at length and providing a catalogue of many problems\nthat were known to be NP-complete in 1979. The proof of Theorem 34.13 is\nadapted from their book, and the list of NP-complete problem domains at the begin-\nning of Section 34.5 is drawn from their table of contents. Johnson wrote a series\nNotes for Chapter 34\n1105\nof 23 columns in the Journal of Algorithms between 1981 and 1992 reporting new",
    "parent_7685dcdd-43ae-4fd9-9b6e-39cf64d86c41": "adapted from their book, and the list of NP-complete problem domains at the begin-\nning of Section 34.5 is drawn from their table of contents. Johnson wrote a series\nNotes for Chapter 34\n1105\nof 23 columns in the Journal of Algorithms between 1981 and 1992 reporting new\ndevelopments in NP-completeness. Hopcroft, Motwani, and Ullman [177], Lewis\nand Papadimitriou [236], Papadimitriou [270], and Sipser [317] have good treat-\nments of NP-completeness in the context of complexity theory. NP-completeness\nand several reductions also appear in books by Aho, Hopcroft, and Ullman [5];\nDasgupta, Papadimitriou, and Vazirani [82]; Johnsonbaugh and Schaefer [193];\nand Kleinberg and Tardos [208].\nThe class P was introduced in 1964 by Cobham [72] and, independently, in 1965\nby Edmonds [100], who also introduced the class NP and conjectured that P ¤ NP.\nThe notion of NP-completeness was proposed in 1971 by Cook [75], who gave\nthe ﬁrst NP-completeness proofs for formula satisﬁability and 3-CNF satisﬁabil-\nity. Levin [234] independently discovered the notion, giving an NP-completeness\nproof for a tiling problem. Karp [199] introduced the methodology of reductions\nin 1972 and demonstrated the rich variety of NP-complete problems. Karp’s pa-\nper included the original NP-completeness proofs of the clique, vertex-cover, and\nhamiltonian-cycle problems. Since then, thousands of problems have been proven\nto be NP-complete by many researchers. In a talk at a meeting celebrating Karp’s\n60th birthday in 1995, Papadimitriou remarked, “about 6000 papers each year have\nthe term ‘NP-complete’ on their title, abstract, or list of keywords. This is more\nthan each of the terms ‘compiler,’ ‘database,’ ‘expert,’ ‘neural network,’ or ‘oper-\nating system.’ ”\nRecent work in complexity theory has shed light on the complexity of computing\napproximate solutions. This work gives a new deﬁnition of NP using “probabilis-\ntically checkable proofs.” This new deﬁnition implies that for problems such as",
    "parent_5ff6d851-d466-48c2-ab7e-dd649a4ce8a8": "ating system.’ ”\nRecent work in complexity theory has shed light on the complexity of computing\napproximate solutions. This work gives a new deﬁnition of NP using “probabilis-\ntically checkable proofs.” This new deﬁnition implies that for problems such as\nclique, vertex cover, the traveling-salesman problem with the triangle inequality,\nand many others, computing good approximate solutions is NP-hard and hence no\neasier than computing optimal solutions. An introduction to this area can be found\nin Arora’s thesis [20]; a chapter by Arora and Lund in Hochbaum [172]; a survey\narticle by Arora [21]; a book edited by Mayr, Pr¨omel, and Steger [246]; and a\nsurvey article by Johnson [191].\n35\nApproximation Algorithms\nMany problems of practical signiﬁcance are NP-complete, yet they are too impor-\ntant to abandon merely because we don’t know how to ﬁnd an optimal solution in\npolynomial time. Even if a problem is NP-complete, there may be hope. We have at\nleast three ways to get around NP-completeness. First, if the actual inputs are small,\nan algorithm with exponential running time may be perfectly satisfactory. Second,\nwe may be able to isolate important special cases that we can solve in polynomial\ntime. Third, we might come up with approaches to ﬁnd near-optimal solutions in\npolynomial time (either in the worst case or the expected case). In practice, near-\noptimality is often good enough. We call an algorithm that returns near-optimal\nsolutions an approximation algorithm. This chapter presents polynomial-time ap-\nproximation algorithms for several NP-complete problems.\nPerformance ratios for approximation algorithms\nSuppose that we are working on an optimization problem in which each potential\nsolution has a positive cost, and we wish to ﬁnd a near-optimal solution. Depending\non the problem, we may deﬁne an optimal solution as one with maximum possi-\nble cost or one with minimum possible cost; that is, the problem may be either a\nmaximization or a minimization problem.",
    "parent_5131c22c-eae8-4af2-a18f-9a79149dd759": "solution has a positive cost, and we wish to ﬁnd a near-optimal solution. Depending\non the problem, we may deﬁne an optimal solution as one with maximum possi-\nble cost or one with minimum possible cost; that is, the problem may be either a\nmaximization or a minimization problem.\nWe say that an algorithm for a problem has an approximation ratio of \u000f.n/ if,\nfor any input of size n, the cost C of the solution produced by the algorithm is\nwithin a factor of \u000f.n/ of the cost C \u0004 of an optimal solution:\nmax\n\u0002 C\nC \u0004 ; C \u0004\nC\n\u0003\n\u0002 \u000f.n/ :\n(35.1)\nIf an algorithm achieves an approximation ratio of \u000f.n/, we call it a \u0004.n/-approx-\nimation algorithm.\nThe deﬁnitions of the approximation ratio and of a \u000f.n/-\napproximation algorithm apply to both minimization and maximization problems.\nFor a maximization problem, 0 < C \u0002 C \u0004, and the ratio C \u0004=C gives the factor\nby which the cost of an optimal solution is larger than the cost of the approximate\nChapter 35\nApproximation Algorithms\n1107\nsolution. Similarly, for a minimization problem, 0 < C \u0004 \u0002 C, and the ratio C=C \u0004\ngives the factor by which the cost of the approximate solution is larger than the\ncost of an optimal solution. Because we assume that all solutions have positive\ncost, these ratios are always well deﬁned. The approximation ratio of an approx-\nimation algorithm is never less than 1, since C=C \u0004 \u0002 1 implies C \u0004=C \u0006 1.\nTherefore, a 1-approximation algorithm1 produces an optimal solution, and an ap-\nproximation algorithm with a large approximation ratio may return a solution that\nis much worse than optimal.\nFor many problems, we have polynomial-time approximation algorithms with\nsmall constant approximation ratios, although for other problems, the best known\npolynomial-time approximation algorithms have approximation ratios that grow\nas functions of the input size n. An example of such a problem is the set-cover\nproblem presented in Section 35.3.\nSome NP-complete problems allow polynomial-time approximation algorithms",
    "parent_79e5fb20-bf2f-496a-82ed-f52d93ca3b59": "polynomial-time approximation algorithms have approximation ratios that grow\nas functions of the input size n. An example of such a problem is the set-cover\nproblem presented in Section 35.3.\nSome NP-complete problems allow polynomial-time approximation algorithms\nthat can achieve increasingly better approximation ratios by using more and more\ncomputation time. That is, we can trade computation time for the quality of the\napproximation. An example is the subset-sum problem studied in Section 35.5.\nThis situation is important enough to deserve a name of its own.\nAn approximation scheme for an optimization problem is an approximation al-\ngorithm that takes as input not only an instance of the problem, but also a value\n\b > 0 such that for any ﬁxed \b, the scheme is a .1 C \b/-approximation algorithm.\nWe say that an approximation scheme is a polynomial-time approximation scheme\nif for any ﬁxed \b > 0, the scheme runs in time polynomial in the size n of its input\ninstance.\nThe running time of a polynomial-time approximation scheme can increase very\nrapidly as \b decreases. For example, the running time of a polynomial-time ap-\nproximation scheme might be O.n2=\u0002/. Ideally, if \b decreases by a constant factor,\nthe running time to achieve the desired approximation should not increase by more\nthan a constant factor (though not necessarily the same constant factor by which \b\ndecreased).\nWe say that an approximation scheme is a fully polynomial-time approximation\nscheme if it is an approximation scheme and its running time is polynomial in\nboth 1=\b and the size n of the input instance. For example, the scheme might have\na running time of O..1=\b/2n3/. With such a scheme, any constant-factor decrease\nin \b comes with a corresponding constant-factor increase in the running time.\n1When the approximation ratio is independent of n, we use the terms “approximation ratio of \u000f” and\n“\u000f-approximation algorithm,” indicating no dependence on n.\n1108\nChapter 35\nApproximation Algorithms",
    "parent_7fadac62-e2e5-4374-a61f-7cae818fd056": "in \b comes with a corresponding constant-factor increase in the running time.\n1When the approximation ratio is independent of n, we use the terms “approximation ratio of \u000f” and\n“\u000f-approximation algorithm,” indicating no dependence on n.\n1108\nChapter 35\nApproximation Algorithms\nChapter outline\nThe ﬁrst four sections of this chapter present some examples of polynomial-time\napproximation algorithms for NP-complete problems, and the ﬁfth section presents\na fully polynomial-time approximation scheme. Section 35.1 begins with a study\nof the vertex-cover problem, an NP-complete minimization problem that has an\napproximation algorithm with an approximation ratio of 2. Section 35.2 presents\nan approximation algorithm with an approximation ratio of 2 for the case of the\ntraveling-salesman problem in which the cost function satisﬁes the triangle in-\nequality. It also shows that without the triangle inequality, for any constant \u000f \u0006 1,\na \u000f-approximation algorithm cannot exist unless P D NP. In Section 35.3, we\nshow how to use a greedy method as an effective approximation algorithm for the\nset-covering problem, obtaining a covering whose cost is at worst a logarithmic\nfactor larger than the optimal cost. Section 35.4 presents two more approximation\nalgorithms. First we study the optimization version of 3-CNF satisﬁability and\ngive a simple randomized algorithm that produces a solution with an expected ap-\nproximation ratio of 8=7. Then we examine a weighted variant of the vertex-cover\nproblem and show how to use linear programming to develop a 2-approximation\nalgorithm. Finally, Section 35.5 presents a fully polynomial-time approximation\nscheme for the subset-sum problem.\n35.1\nThe vertex-cover problem\nSection 34.5.2 deﬁned the vertex-cover problem and proved it NP-complete. Recall\nthat a vertex cover of an undirected graph G D .V; E/ is a subset V 0 \u0007 V such\nthat if .u; \u0003/ is an edge of G, then either u 2 V 0 or \u0003 2 V 0 (or both). The size of a",
    "parent_8c6d8cf3-7122-4278-a09e-502e316deb24": "35.1\nThe vertex-cover problem\nSection 34.5.2 deﬁned the vertex-cover problem and proved it NP-complete. Recall\nthat a vertex cover of an undirected graph G D .V; E/ is a subset V 0 \u0007 V such\nthat if .u; \u0003/ is an edge of G, then either u 2 V 0 or \u0003 2 V 0 (or both). The size of a\nvertex cover is the number of vertices in it.\nThe vertex-cover problem is to ﬁnd a vertex cover of minimum size in a given\nundirected graph. We call such a vertex cover an optimal vertex cover. This prob-\nlem is the optimization version of an NP-complete decision problem.\nEven though we don’t know how to ﬁnd an optimal vertex cover in a graph G\nin polynomial time, we can efﬁciently ﬁnd a vertex cover that is near-optimal.\nThe following approximation algorithm takes as input an undirected graph G and\nreturns a vertex cover whose size is guaranteed to be no more than twice the size\nof an optimal vertex cover.\n35.1\nThe vertex-cover problem\n1109\nb\nc\nd\na\ne\nf\ng\n(a)\nb\nc\nd\na\ne\nf\ng\n(b)\nb\nc\nd\na\ne\nf\ng\n(c)\nb\nc\nd\na\ne\nf\ng\n(d)\nb\nc\nd\na\ne\nf\ng\n(e)\nb\nc\nd\na\ne\nf\ng\n(f)\nFigure 35.1\nThe operation of APPROX-VERTEX-COVER. (a) The input graph G, which has 7\nvertices and 8 edges. (b) The edge .b;c/, shown heavy, is the ﬁrst edge chosen by APPROX-VERTEX-\nCOVER. Vertices b and c, shown lightly shaded, are added to the set C containing the vertex cover\nbeing created. Edges .a; b/, .c; e/, and .c; d/, shown dashed, are removed since they are now covered\nby some vertex in C. (c) Edge .e; f / is chosen; vertices e and f are added to C. (d) Edge .d; g/\nis chosen; vertices d and g are added to C. (e) The set C, which is the vertex cover produced by\nAPPROX-VERTEX-COVER, contains the six vertices b; c; d; e; f; g. (f) The optimal vertex cover for\nthis problem contains only three vertices: b, d, and e.\nAPPROX-VERTEX-COVER.G/\n1\nC D ;\n2\nE0 D G:E\n3\nwhile E0 ¤ ;\n4\nlet .u; \u0003/ be an arbitrary edge of E0\n5\nC D C [ fu; \u0003g\n6\nremove from E0 every edge incident on either u or \u0003\n7\nreturn C",
    "parent_6bd8df2e-ea27-4b66-9012-0d6661940eaf": "this problem contains only three vertices: b, d, and e.\nAPPROX-VERTEX-COVER.G/\n1\nC D ;\n2\nE0 D G:E\n3\nwhile E0 ¤ ;\n4\nlet .u; \u0003/ be an arbitrary edge of E0\n5\nC D C [ fu; \u0003g\n6\nremove from E0 every edge incident on either u or \u0003\n7\nreturn C\nFigure 35.1 illustrates how APPROX-VERTEX-COVER operates on an example\ngraph. The variable C contains the vertex cover being constructed. Line 1 ini-\ntializes C to the empty set. Line 2 sets E0 to be a copy of the edge set G:E of\nthe graph. The loop of lines 3–6 repeatedly picks an edge .u; \u0003/ from E0, adds its\n1110\nChapter 35\nApproximation Algorithms\nendpoints u and \u0003 to C, and deletes all edges in E0 that are covered by either u\nor \u0003. Finally, line 7 returns the vertex cover C. The running time of this algorithm\nis O.V C E/, using adjacency lists to represent E0.\nTheorem 35.1\nAPPROX-VERTEX-COVER is a polynomial-time 2-approximation algorithm.\nProof\nWe have already shown that APPROX-VERTEX-COVER runs in polyno-\nmial time.\nThe set C of vertices that is returned by APPROX-VERTEX-COVER is a vertex\ncover, since the algorithm loops until every edge in G:E has been covered by some\nvertex in C.\nTo see that APPROX-VERTEX-COVER returns a vertex cover that is at most twice\nthe size of an optimal cover, let A denote the set of edges that line 4 of APPROX-\nVERTEX-COVER picked. In order to cover the edges in A, any vertex cover—in\nparticular, an optimal cover C \u0004—must include at least one endpoint of each edge\nin A. No two edges in A share an endpoint, since once an edge is picked in line 4,\nall other edges that are incident on its endpoints are deleted from E0 in line 6. Thus,\nno two edges in A are covered by the same vertex from C \u0004, and we have the lower\nbound\njC \u0004j \u0006 jAj\n(35.2)\non the size of an optimal vertex cover. Each execution of line 4 picks an edge for\nwhich neither of its endpoints is already in C, yielding an upper bound (an exact\nupper bound, in fact) on the size of the vertex cover returned:\njCj D 2 jAj :\n(35.3)",
    "parent_0f6cc91d-60e6-42ed-9d34-9a6c133dc638": "bound\njC \u0004j \u0006 jAj\n(35.2)\non the size of an optimal vertex cover. Each execution of line 4 picks an edge for\nwhich neither of its endpoints is already in C, yielding an upper bound (an exact\nupper bound, in fact) on the size of the vertex cover returned:\njCj D 2 jAj :\n(35.3)\nCombining equations (35.2) and (35.3), we obtain\njCj\nD\n2 jAj\n\u0002\n2 jC \u0004j ;\nthereby proving the theorem.\nLet us reﬂect on this proof. At ﬁrst, you might wonder how we can possibly\nprove that the size of the vertex cover returned by APPROX-VERTEX-COVER is at\nmost twice the size of an optimal vertex cover, when we do not even know the size\nof an optimal vertex cover. Instead of requiring that we know the exact size of an\noptimal vertex cover, we rely on a lower bound on the size. As Exercise 35.1-2 asks\nyou to show, the set A of edges that line 4 of APPROX-VERTEX-COVER selects is\nactually a maximal matching in the graph G. (A maximal matching is a matching\nthat is not a proper subset of any other matching.) The size of a maximal matching\n35.2\nThe traveling-salesman problem\n1111\nis, as we argued in the proof of Theorem 35.1, a lower bound on the size of an\noptimal vertex cover. The algorithm returns a vertex cover whose size is at most\ntwice the size of the maximal matching A. By relating the size of the solution\nreturned to the lower bound, we obtain our approximation ratio. We will use this\nmethodology in later sections as well.\nExercises\n35.1-1\nGive an example of a graph for which APPROX-VERTEX-COVER always yields a\nsuboptimal solution.\n35.1-2\nProve that the set of edges picked in line 4 of APPROX-VERTEX-COVER forms a\nmaximal matching in the graph G.\n35.1-3\n?\nProfessor B¨undchen proposes the following heuristic to solve the vertex-cover\nproblem. Repeatedly select a vertex of highest degree, and remove all of its in-\ncident edges. Give an example to show that the professor’s heuristic does not have\nan approximation ratio of 2. (Hint: Try a bipartite graph with vertices of uniform",
    "parent_d28e4452-33af-4e32-84a4-7822e4d978ff": "problem. Repeatedly select a vertex of highest degree, and remove all of its in-\ncident edges. Give an example to show that the professor’s heuristic does not have\nan approximation ratio of 2. (Hint: Try a bipartite graph with vertices of uniform\ndegree on the left and vertices of varying degree on the right.)\n35.1-4\nGive an efﬁcient greedy algorithm that ﬁnds an optimal vertex cover for a tree in\nlinear time.\n35.1-5\nFrom the proof of Theorem 34.12, we know that the vertex-cover problem and the\nNP-complete clique problem are complementary in the sense that an optimal vertex\ncover is the complement of a maximum-size clique in the complement graph. Does\nthis relationship imply that there is a polynomial-time approximation algorithm\nwith a constant approximation ratio for the clique problem? Justify your answer.\n35.2\nThe traveling-salesman problem\nIn the traveling-salesman problem introduced in Section 34.5.4, we are given a\ncomplete undirected graph G D .V; E/ that has a nonnegative integer cost c.u; \u0003/\nassociated with each edge .u; \u0003/ 2 E, and we must ﬁnd a hamiltonian cycle (a\ntour) of G with minimum cost. As an extension of our notation, let c.A/ denote\nthe total cost of the edges in the subset A \u0007 E:\n1112\nChapter 35\nApproximation Algorithms\nc.A/ D\nX\n.u;\u0005/2A\nc.u; \u0003/ :\nIn many practical situations, the least costly way to go from a place u to a place w\nis to go directly, with no intermediate steps. Put another way, cutting out an inter-\nmediate stop never increases the cost. We formalize this notion by saying that the\ncost function c satisﬁes the triangle inequality if, for all vertices u; \u0003; w 2 V ,\nc.u; w/ \u0002 c.u; \u0003/ C c.\u0003; w/ :\nThe triangle inequality seems as though it should naturally hold, and it is au-\ntomatically satisﬁed in several applications. For example, if the vertices of the\ngraph are points in the plane and the cost of traveling between two vertices is the\nordinary euclidean distance between them, then the triangle inequality is satisﬁed.",
    "parent_f99e9ea5-66aa-44e8-b6f4-77461a307b9f": "tomatically satisﬁed in several applications. For example, if the vertices of the\ngraph are points in the plane and the cost of traveling between two vertices is the\nordinary euclidean distance between them, then the triangle inequality is satisﬁed.\nFurthermore, many cost functions other than euclidean distance satisfy the triangle\ninequality.\nAs Exercise 35.2-2 shows, the traveling-salesman problem is NP-complete even\nif we require that the cost function satisfy the triangle inequality. Thus, we should\nnot expect to ﬁnd a polynomial-time algorithm for solving this problem exactly.\nInstead, we look for good approximation algorithms.\nIn Section 35.2.1, we examine a 2-approximation algorithm for the traveling-\nsalesman problem with the triangle inequality. In Section 35.2.2, we show that\nwithout the triangle inequality, a polynomial-time approximation algorithm with a\nconstant approximation ratio does not exist unless P D NP.\n35.2.1\nThe traveling-salesman problem with the triangle inequality\nApplying the methodology of the previous section, we shall ﬁrst compute a struc-\nture—a minimum spanning tree—whose weight gives a lower bound on the length\nof an optimal traveling-salesman tour. We shall then use the minimum spanning\ntree to create a tour whose cost is no more than twice that of the minimum spanning\ntree’s weight, as long as the cost function satisﬁes the triangle inequality. The fol-\nlowing algorithm implements this approach, calling the minimum-spanning-tree\nalgorithm MST-PRIM from Section 23.2 as a subroutine. The parameter G is a\ncomplete undirected graph, and the cost function c satisﬁes the triangle inequality.\nAPPROX-TSP-TOUR.G; c/\n1\nselect a vertex r 2 G:V to be a “root” vertex\n2\ncompute a minimum spanning tree T for G from root r\nusing MST-PRIM.G; c; r/\n3\nlet H be a list of vertices, ordered according to when they are ﬁrst visited\nin a preorder tree walk of T\n4\nreturn the hamiltonian cycle H\n35.2\nThe traveling-salesman problem\n1113\n(a)\na\nd\nb\nf\ne\ng\nc\nh",
    "parent_26a84eb5-1b6b-47a8-9425-77f7f32696c7": "2\ncompute a minimum spanning tree T for G from root r\nusing MST-PRIM.G; c; r/\n3\nlet H be a list of vertices, ordered according to when they are ﬁrst visited\nin a preorder tree walk of T\n4\nreturn the hamiltonian cycle H\n35.2\nThe traveling-salesman problem\n1113\n(a)\na\nd\nb\nf\ne\ng\nc\nh\n(b)\na\nd\nb\nf\ne\ng\nc\nh\n(c)\na\nd\ne\nc\nh\n(d)\na\nd\nb\nf\ne\ng\nc\nh\n(e)\nb\nf\ng\ne\nh\nc\na\nb\nf\ng\nd\nFigure 35.2\nThe operation of APPROX-TSP-TOUR. (a) A complete undirected graph. Vertices lie\non intersections of integer grid lines. For example, f is one unit to the right and two units up from h.\nThe cost function between two points is the ordinary euclidean distance. (b) A minimum spanning\ntree T of the complete graph, as computed by MST-PRIM. Vertex a is the root vertex. Only edges\nin the minimum spanning tree are shown. The vertices happen to be labeled in such a way that they\nare added to the main tree by MST-PRIM in alphabetical order. (c) A walk of T , starting at a. A\nfull walk of the tree visits the vertices in the order a; b; c; b; h; b; a; d; e; f; e; g; e; d; a. A preorder\nwalk of T lists a vertex just when it is ﬁrst encountered, as indicated by the dot next to each vertex,\nyielding the ordering a; b; c; h; d; e; f; g. (d) A tour obtained by visiting the vertices in the order\ngiven by the preorder walk, which is the tour H returned by APPROX-TSP-TOUR. Its total cost\nis approximately 19:074. (e) An optimal tour H \u0004 for the original complete graph. Its total cost is\napproximately 14:715.\nRecall from Section 12.1 that a preorder tree walk recursively visits every vertex\nin the tree, listing a vertex when it is ﬁrst encountered, before visiting any of its\nchildren.\nFigure 35.2 illustrates the operation of APPROX-TSP-TOUR. Part (a) of the ﬁg-\nure shows a complete undirected graph, and part (b) shows the minimum spanning\ntree T grown from root vertex a by MST-PRIM. Part (c) shows how a preorder\nwalk of T visits the vertices, and part (d) displays the corresponding tour, which is",
    "parent_903a224e-60cf-4046-830b-0006d2e468a8": "ure shows a complete undirected graph, and part (b) shows the minimum spanning\ntree T grown from root vertex a by MST-PRIM. Part (c) shows how a preorder\nwalk of T visits the vertices, and part (d) displays the corresponding tour, which is\nthe tour returned by APPROX-TSP-TOUR. Part (e) displays an optimal tour, which\nis about 23% shorter.\n1114\nChapter 35\nApproximation Algorithms\nBy Exercise 23.2-2, even with a simple implementation of MST-PRIM, the run-\nning time of APPROX-TSP-TOUR is ‚.V 2/. We now show that if the cost function\nfor an instance of the traveling-salesman problem satisﬁes the triangle inequality,\nthen APPROX-TSP-TOUR returns a tour whose cost is not more than twice the cost\nof an optimal tour.\nTheorem 35.2\nAPPROX-TSP-TOUR is a polynomial-time 2-approximation algorithm for the\ntraveling-salesman problem with the triangle inequality.\nProof\nWe have already seen that APPROX-TSP-TOUR runs in polynomial time.\nLet H \u0004 denote an optimal tour for the given set of vertices. We obtain a spanning\ntree by deleting any edge from a tour, and each edge cost is nonnegative. Therefore,\nthe weight of the minimum spanning tree T computed in line 2 of APPROX-TSP-\nTOUR provides a lower bound on the cost of an optimal tour:\nc.T / \u0002 c.H \u0004/ :\n(35.4)\nA full walk of T lists the vertices when they are ﬁrst visited and also whenever\nthey are returned to after a visit to a subtree. Let us call this full walk W . The full\nwalk of our example gives the order\na; b; c; b; h; b; a; d; e; f; e; g; e; d; a :\nSince the full walk traverses every edge of T exactly twice, we have (extending\nour deﬁnition of the cost c in the natural manner to handle multisets of edges)\nc.W / D 2c.T / :\n(35.5)\nInequality (35.4) and equation (35.5) imply that\nc.W / \u0002 2c.H \u0004/ ;\n(35.6)\nand so the cost of W is within a factor of 2 of the cost of an optimal tour.\nUnfortunately, the full walk W is generally not a tour, since it visits some ver-",
    "parent_c1ad345d-c595-40ce-8786-94824889e3af": "c.W / D 2c.T / :\n(35.5)\nInequality (35.4) and equation (35.5) imply that\nc.W / \u0002 2c.H \u0004/ ;\n(35.6)\nand so the cost of W is within a factor of 2 of the cost of an optimal tour.\nUnfortunately, the full walk W is generally not a tour, since it visits some ver-\ntices more than once. By the triangle inequality, however, we can delete a visit to\nany vertex from W and the cost does not increase. (If we delete a vertex \u0003 from W\nbetween visits to u and w, the resulting ordering speciﬁes going directly from u\nto w.) By repeatedly applying this operation, we can remove from W all but the\nﬁrst visit to each vertex. In our example, this leaves the ordering\na; b; c; h; d; e; f; g :\nThis ordering is the same as that obtained by a preorder walk of the tree T . Let H\nbe the cycle corresponding to this preorder walk. It is a hamiltonian cycle, since ev-\n35.2\nThe traveling-salesman problem\n1115\nery vertex is visited exactly once, and in fact it is the cycle computed by APPROX-\nTSP-TOUR. Since H is obtained by deleting vertices from the full walk W , we\nhave\nc.H/ \u0002 c.W / :\n(35.7)\nCombining inequalities (35.6) and (35.7) gives c.H/ \u0002 2c.H \u0004/, which completes\nthe proof.\nIn spite of the nice approximation ratio provided by Theorem 35.2, APPROX-\nTSP-TOUR is usually not the best practical choice for this problem. There are other\napproximation algorithms that typically perform much better in practice. (See the\nreferences at the end of this chapter.)\n35.2.2\nThe general traveling-salesman problem\nIf we drop the assumption that the cost function c satisﬁes the triangle inequality,\nthen we cannot ﬁnd good approximate tours in polynomial time unless P D NP.\nTheorem 35.3\nIf P ¤ NP, then for any constant \u000f \u0006 1, there is no polynomial-time approximation\nalgorithm with approximation ratio \u000f for the general traveling-salesman problem.\nProof\nThe proof is by contradiction. Suppose to the contrary that for some num-\nber \u000f \u0006 1, there is a polynomial-time approximation algorithm A with approx-",
    "parent_7589a237-7dad-4699-9aac-79debd1eb2fd": "algorithm with approximation ratio \u000f for the general traveling-salesman problem.\nProof\nThe proof is by contradiction. Suppose to the contrary that for some num-\nber \u000f \u0006 1, there is a polynomial-time approximation algorithm A with approx-\nimation ratio \u000f. Without loss of generality, we assume that \u000f is an integer, by\nrounding it up if necessary. We shall then show how to use A to solve instances\nof the hamiltonian-cycle problem (deﬁned in Section 34.2) in polynomial time.\nSince Theorem 34.13 tells us that the hamiltonian-cycle problem is NP-complete,\nTheorem 34.4 implies that if we can solve it in polynomial time, then P D NP.\nLet G D .V; E/ be an instance of the hamiltonian-cycle problem. We wish to\ndetermine efﬁciently whether G contains a hamiltonian cycle by making use of\nthe hypothesized approximation algorithm A. We turn G into an instance of the\ntraveling-salesman problem as follows. Let G0 D .V; E0/ be the complete graph\non V ; that is,\nE0 D f.u; \u0003/ W u; \u0003 2 V and u ¤ \u0003g :\nAssign an integer cost to each edge in E0 as follows:\nc.u; \u0003/ D\n(\n1\nif .u; \u0003/ 2 E ;\n\u000f jV j C 1\notherwise :\nWe can create representations of G0 and c from a representation of G in time poly-\nnomial in jV j and jEj.\n1116\nChapter 35\nApproximation Algorithms\nNow, consider the traveling-salesman problem .G0; c/. If the original graph G\nhas a hamiltonian cycle H, then the cost function c assigns to each edge of H a\ncost of 1, and so .G0; c/ contains a tour of cost jV j. On the other hand, if G does\nnot contain a hamiltonian cycle, then any tour of G0 must use some edge not in E.\nBut any tour that uses an edge not in E has a cost of at least\n.\u000f jV j C 1/ C .jV j \u0005 1/\nD\n\u000f jV j C jV j\n>\n\u000f jV j :\nBecause edges not in G are so costly, there is a gap of at least \u000f jV j between the cost\nof a tour that is a hamiltonian cycle in G (cost jV j) and the cost of any other tour\n(cost at least \u000f jV j C jV j). Therefore, the cost of a tour that is not a hamiltonian",
    "parent_d1e40581-5770-49e1-b898-31e0e41de567": "D\n\u000f jV j C jV j\n>\n\u000f jV j :\nBecause edges not in G are so costly, there is a gap of at least \u000f jV j between the cost\nof a tour that is a hamiltonian cycle in G (cost jV j) and the cost of any other tour\n(cost at least \u000f jV j C jV j). Therefore, the cost of a tour that is not a hamiltonian\ncycle in G is at least a factor of \u000f C 1 greater than the cost of a tour that is a\nhamiltonian cycle in G.\nNow, suppose that we apply the approximation algorithm A to the traveling-\nsalesman problem .G0; c/. Because A is guaranteed to return a tour of cost no\nmore than \u000f times the cost of an optimal tour, if G contains a hamiltonian cycle,\nthen A must return it. If G has no hamiltonian cycle, then A returns a tour of cost\nmore than \u000f jV j. Therefore, we can use A to solve the hamiltonian-cycle problem\nin polynomial time.\nThe proof of Theorem 35.3 serves as an example of a general technique for\nproving that we cannot approximate a problem very well. Suppose that given an\nNP-hard problem X, we can produce in polynomial time a minimization prob-\nlem Y such that “yes” instances of X correspond to instances of Y with value at\nmost k (for some k), but that “no” instances of X correspond to instances of Y\nwith value greater than \u000fk. Then, we have shown that, unless P D NP, there is no\npolynomial-time \u000f-approximation algorithm for problem Y .\nExercises\n35.2-1\nSuppose that a complete undirected graph G D .V; E/ with at least 3 vertices has\na cost function c that satisﬁes the triangle inequality. Prove that c.u; \u0003/ \u0006 0 for all\nu; \u0003 2 V .\n35.2-2\nShow how in polynomial time we can transform one instance of the traveling-\nsalesman problem into another instance whose cost function satisﬁes the triangle\ninequality. The two instances must have the same set of optimal tours. Explain\nwhy such a polynomial-time transformation does not contradict Theorem 35.3, as-\nsuming that P ¤ NP.\n35.3\nThe set-covering problem\n1117\n35.2-3",
    "parent_0bfa615a-ae92-4a98-9562-9fc37a9fe322": "inequality. The two instances must have the same set of optimal tours. Explain\nwhy such a polynomial-time transformation does not contradict Theorem 35.3, as-\nsuming that P ¤ NP.\n35.3\nThe set-covering problem\n1117\n35.2-3\nConsider the following closest-point heuristic for building an approximate trav-\neling-salesman tour whose cost function satisﬁes the triangle inequality. Begin\nwith a trivial cycle consisting of a single arbitrarily chosen vertex. At each step,\nidentify the vertex u that is not on the cycle but whose distance to any vertex on the\ncycle is minimum. Suppose that the vertex on the cycle that is nearest u is vertex \u0003.\nExtend the cycle to include u by inserting u just after \u0003. Repeat until all vertices\nare on the cycle. Prove that this heuristic returns a tour whose total cost is not more\nthan twice the cost of an optimal tour.\n35.2-4\nIn the bottleneck traveling-salesman problem, we wish to ﬁnd the hamiltonian cy-\ncle that minimizes the cost of the most costly edge in the cycle. Assuming that the\ncost function satisﬁes the triangle inequality, show that there exists a polynomial-\ntime approximation algorithm with approximation ratio 3 for this problem. (Hint:\nShow recursively that we can visit all the nodes in a bottleneck spanning tree, as\ndiscussed in Problem 23-3, exactly once by taking a full walk of the tree and skip-\nping nodes, but without skipping more than two consecutive intermediate nodes.\nShow that the costliest edge in a bottleneck spanning tree has a cost that is at most\nthe cost of the costliest edge in a bottleneck hamiltonian cycle.)\n35.2-5\nSuppose that the vertices for an instance of the traveling-salesman problem are\npoints in the plane and that the cost c.u; \u0003/ is the euclidean distance between\npoints u and \u0003. Show that an optimal tour never crosses itself.\n35.3\nThe set-covering problem\nThe set-covering problem is an optimization problem that models many problems",
    "parent_2550bc1f-1509-487a-9241-1df7dafb3f76": "points in the plane and that the cost c.u; \u0003/ is the euclidean distance between\npoints u and \u0003. Show that an optimal tour never crosses itself.\n35.3\nThe set-covering problem\nThe set-covering problem is an optimization problem that models many problems\nthat require resources to be allocated. Its corresponding decision problem general-\nizes the NP-complete vertex-cover problem and is therefore also NP-hard. The ap-\nproximation algorithm developed to handle the vertex-cover problem doesn’t apply\nhere, however, and so we need to try other approaches. We shall examine a simple\ngreedy heuristic with a logarithmic approximation ratio. That is, as the size of the\ninstance gets larger, the size of the approximate solution may grow, relative to the\nsize of an optimal solution. Because the logarithm function grows rather slowly,\nhowever, this approximation algorithm may nonetheless give useful results.\n1118\nChapter 35\nApproximation Algorithms\nS3\nS6\nS4\nS5\nS2\nS1\nFigure 35.3\nAn instance .X; F / of the set-covering problem, where X consists of the 12 black\npoints and F D fS1; S2; S3; S4; S5; S6g. A minimum-size set cover is C D fS3; S4; S5g, with\nsize 3. The greedy algorithm produces a cover of size 4 by selecting either the sets S1, S4, S5,\nand S3 or the sets S1, S4, S5, and S6, in order.\nAn instance .X; F / of the set-covering problem consists of a ﬁnite set X and\na family F of subsets of X, such that every element of X belongs to at least one\nsubset in F :\nX D\n[\nS2F\nS :\nWe say that a subset S 2 F covers its elements. The problem is to ﬁnd a minimum-\nsize subset C \u0007 F whose members cover all of X:\nX D\n[\nS2C\nS :\n(35.8)\nWe say that any C satisfying equation (35.8) covers X. Figure 35.3 illustrates the\nset-covering problem. The size of C is the number of sets it contains, rather than\nthe number of individual elements in these sets, since every subset C that covers X\nmust contain all jXj individual elements. In Figure 35.3, the minimum set cover\nhas size 3.",
    "parent_d1761588-57d0-4b82-998d-1a2751f6bc55": "set-covering problem. The size of C is the number of sets it contains, rather than\nthe number of individual elements in these sets, since every subset C that covers X\nmust contain all jXj individual elements. In Figure 35.3, the minimum set cover\nhas size 3.\nThe set-covering problem abstracts many commonly arising combinatorial prob-\nlems. As a simple example, suppose that X represents a set of skills that are needed\nto solve a problem and that we have a given set of people available to work on the\nproblem. We wish to form a committee, containing as few people as possible,\nsuch that for every requisite skill in X, at least one member of the committee has\nthat skill. In the decision version of the set-covering problem, we ask whether a\ncovering exists with size at most k, where k is an additional parameter speciﬁed\nin the problem instance. The decision version of the problem is NP-complete, as\nExercise 35.3-2 asks you to show.\n35.3\nThe set-covering problem\n1119\nA greedy approximation algorithm\nThe greedy method works by picking, at each stage, the set S that covers the great-\nest number of remaining elements that are uncovered.\nGREEDY-SET-COVER.X; F /\n1\nU D X\n2\nC D ;\n3\nwhile U ¤ ;\n4\nselect an S 2 F that maximizes jS \\ U j\n5\nU D U \u0005 S\n6\nC D C [ fSg\n7\nreturn C\nIn the example of Figure 35.3, GREEDY-SET-COVER adds to C, in order, the sets\nS1, S4, and S5, followed by either S3 or S6.\nThe algorithm works as follows. The set U contains, at each stage, the set of\nremaining uncovered elements. The set C contains the cover being constructed.\nLine 4 is the greedy decision-making step, choosing a subset S that covers as many\nuncovered elements as possible (breaking ties arbitrarily). After S is selected,\nline 5 removes its elements from U , and line 6 places S into C. When the algorithm\nterminates, the set C contains a subfamily of F that covers X.\nWe can easily implement GREEDY-SET-COVER to run in time polynomial in jXj",
    "parent_061bc5f4-14c9-4a03-a908-ed70c3e35e1a": "line 5 removes its elements from U , and line 6 places S into C. When the algorithm\nterminates, the set C contains a subfamily of F that covers X.\nWe can easily implement GREEDY-SET-COVER to run in time polynomial in jXj\nand jF j. Since the number of iterations of the loop on lines 3–6 is bounded from\nabove by min.jXj ; jF j/, and we can implement the loop body to run in time\nO.jXj jF j/, a simple implementation runs in time O.jXj jF j min.jXj ; jF j//. Ex-\nercise 35.3-3 asks for a linear-time algorithm.\nAnalysis\nWe now show that the greedy algorithm returns a set cover that is not too much\nlarger than an optimal set cover. For convenience, in this chapter we denote the dth\nharmonic number Hd D Pd\niD1 1=i (see Section A.1) by H.d/. As a boundary\ncondition, we deﬁne H.0/ D 0.\nTheorem 35.4\nGREEDY-SET-COVER is a polynomial-time \u000f.n/-approximation algorithm, where\n\u000f.n/ D H.max fjSj W S 2 F g/ :\nProof\nWe have already shown that GREEDY-SET-COVER runs in polynomial\ntime.\n1120\nChapter 35\nApproximation Algorithms\nTo show that GREEDY-SET-COVER is a \u000f.n/-approximation algorithm, we as-\nsign a cost of 1 to each set selected by the algorithm, distribute this cost over\nthe elements covered for the ﬁrst time, and then use these costs to derive the de-\nsired relationship between the size of an optimal set cover C \u0004 and the size of the\nset cover C returned by the algorithm. Let Si denote the ith subset selected by\nGREEDY-SET-COVER; the algorithm incurs a cost of 1 when it adds Si to C. We\nspread this cost of selecting Si evenly among the elements covered for the ﬁrst time\nby Si. Let cx denote the cost allocated to element x, for each x 2 X. Each element\nis assigned a cost only once, when it is covered for the ﬁrst time. If x is covered\nfor the ﬁrst time by Si, then\ncx D\n1\njSi \u0005 .S1 [ S2 [ \u0003 \u0003 \u0003 [ Si\u00031/j :\nEach step of the algorithm assigns 1 unit of cost, and so\njCj D\nX\nx2X\ncx :\n(35.9)\nEach element x 2 X is in at least one set in the optimal cover C \u0004, and so we have\nX\nS2C\u0003\nX\nx2S",
    "parent_ebeb7371-34d3-4cbf-bf63-15419f21b706": "for the ﬁrst time by Si, then\ncx D\n1\njSi \u0005 .S1 [ S2 [ \u0003 \u0003 \u0003 [ Si\u00031/j :\nEach step of the algorithm assigns 1 unit of cost, and so\njCj D\nX\nx2X\ncx :\n(35.9)\nEach element x 2 X is in at least one set in the optimal cover C \u0004, and so we have\nX\nS2C\u0003\nX\nx2S\ncx \u0006\nX\nx2X\ncx :\n(35.10)\nCombining equation (35.9) and inequality (35.10), we have that\njCj \u0002\nX\nS2C\u0003\nX\nx2S\ncx :\n(35.11)\nThe remainder of the proof rests on the following key inequality, which we shall\nprove shortly. For any set S belonging to the family F ,\nX\nx2S\ncx \u0002 H.jSj/ :\n(35.12)\nFrom inequalities (35.11) and (35.12), it follows that\njCj\n\u0002\nX\nS2C\u0003\nH.jSj/\n\u0002\njC \u0004j \u0003 H.max fjSj W S 2 F g/ ;\nthus proving the theorem.\nAll that remains is to prove inequality (35.12). Consider any set S 2 F and any\ni D 1; 2; : : : ; jCj, and let\nui D jS \u0005 .S1 [ S2 [ \u0003 \u0003 \u0003 [ Si/j\nbe the number of elements in S that remain uncovered after the algorithm has\nselected sets S1; S2; : : : ; Si. We deﬁne u0 D jSj to be the number of elements\n35.3\nThe set-covering problem\n1121\nof S, which are all initially uncovered. Let k be the least index such that uk D 0,\nso that every element in S is covered by at least one of the sets S1; S2; : : : ; Sk and\nsome element in S is uncovered by S1 [ S2 [ \u0003 \u0003 \u0003 [ Sk\u00031. Then, ui\u00031 \u0006 ui, and\nui\u00031 \u0005 ui elements of S are covered for the ﬁrst time by Si, for i D 1; 2; : : : ; k.\nThus,\nX\nx2S\ncx\nD\nk\nX\niD1\n.ui\u00031 \u0005 ui/ \u0003\n1\njSi \u0005 .S1 [ S2 [ \u0003 \u0003 \u0003 [ Si\u00031/j :\nObserve that\njSi \u0005 .S1 [ S2 [ \u0003 \u0003 \u0003 [ Si\u00031/j\n\u0006\njS \u0005 .S1 [ S2 [ \u0003 \u0003 \u0003 [ Si\u00031/j\nD\nui\u00031 ;\nbecause the greedy choice of Si guarantees that S cannot cover more new ele-\nments than Si does (otherwise, the algorithm would have chosen S instead of Si).\nConsequently, we obtain\nX\nx2S\ncx\n\u0002\nk\nX\niD1\n.ui\u00031 \u0005 ui/ \u0003\n1\nui\u00031\n:\nWe now bound this quantity as follows:\nX\nx2S\ncx\n\u0002\nk\nX\niD1\n.ui\u00031 \u0005 ui/ \u0003\n1\nui\u00031\nD\nk\nX\niD1\nui\u00041\nX\njDuiC1\n1\nui\u00031\n\u0002\nk\nX\niD1\nui\u00041\nX\njDuiC1\n1\nj\n(because j \u0002 ui\u00031)\nD\nk\nX\niD1\n ui\u00041\nX\njD1\n1\nj \u0005\nui\nX\njD1\n1\nj\n!\nD\nk\nX\niD1\n.H.ui\u00031/ \u0005 H.ui//\nD\nH.u0/ \u0005 H.uk/",
    "parent_a1f5d1b4-7c0d-41fe-ab2d-39dd573b4f35": "X\nx2S\ncx\n\u0002\nk\nX\niD1\n.ui\u00031 \u0005 ui/ \u0003\n1\nui\u00031\n:\nWe now bound this quantity as follows:\nX\nx2S\ncx\n\u0002\nk\nX\niD1\n.ui\u00031 \u0005 ui/ \u0003\n1\nui\u00031\nD\nk\nX\niD1\nui\u00041\nX\njDuiC1\n1\nui\u00031\n\u0002\nk\nX\niD1\nui\u00041\nX\njDuiC1\n1\nj\n(because j \u0002 ui\u00031)\nD\nk\nX\niD1\n ui\u00041\nX\njD1\n1\nj \u0005\nui\nX\njD1\n1\nj\n!\nD\nk\nX\niD1\n.H.ui\u00031/ \u0005 H.ui//\nD\nH.u0/ \u0005 H.uk/\n(because the sum telescopes)\nD\nH.u0/ \u0005 H.0/\nD\nH.u0/\n(because H.0/ D 0)\nD\nH.jSj/ ;\nwhich completes the proof of inequality (35.12).\n1122\nChapter 35\nApproximation Algorithms\nCorollary 35.5\nGREEDY-SET-COVER is a polynomial-time .ln jXjC1/-approximation algorithm.\nProof\nUse inequality (A.14) and Theorem 35.4.\nIn some applications, max fjSj W S 2 F g is a small constant, and so the solution\nreturned by GREEDY-SET-COVER is at most a small constant times larger than\noptimal. One such application occurs when this heuristic ﬁnds an approximate\nvertex cover for a graph whose vertices have degree at most 3. In this case, the\nsolution found by GREEDY-SET-COVER is not more than H.3/ D 11=6 times as\nlarge as an optimal solution, a performance guarantee that is slightly better than\nthat of APPROX-VERTEX-COVER.\nExercises\n35.3-1\nConsider each of the following words as a set of letters: farid; dash; drain;\nheard; lost; nose; shun; slate; snare; threadg. Show which set cover\nGREEDY-SET-COVER produces when we break ties in favor of the word that ap-\npears ﬁrst in the dictionary.\n35.3-2\nShow that the decision version of the set-covering problem is NP-complete by\nreducing it from the vertex-cover problem.\n35.3-3\nShow how to implement GREEDY-SET-COVER in such a way that it runs in time\nO\n\u0004P\nS2F jSj\n\u0005\n.\n35.3-4\nShow that the following weaker form of Theorem 35.4 is trivially true:\njCj \u0002 jC \u0004j max fjSj W S 2 F g :\n35.3-5\nGREEDY-SET-COVER can return a number of different solutions, depending on\nhow we break ties in line 4. Give a procedure BAD-SET-COVER-INSTANCE.n/\nthat returns an n-element instance of the set-covering problem for which, depend-",
    "parent_e183b35e-1d49-4fb2-8bd7-3c2212376772": "jCj \u0002 jC \u0004j max fjSj W S 2 F g :\n35.3-5\nGREEDY-SET-COVER can return a number of different solutions, depending on\nhow we break ties in line 4. Give a procedure BAD-SET-COVER-INSTANCE.n/\nthat returns an n-element instance of the set-covering problem for which, depend-\ning on how we break ties in line 4, GREEDY-SET-COVER can return a number of\ndifferent solutions that is exponential in n.\n35.4\nRandomization and linear programming\n1123\n35.4\nRandomization and linear programming\nIn this section, we study two useful techniques for designing approximation algo-\nrithms: randomization and linear programming. We shall give a simple randomized\nalgorithm for an optimization version of 3-CNF satisﬁability, and then we shall use\nlinear programming to help design an approximation algorithm for a weighted ver-\nsion of the vertex-cover problem. This section only scratches the surface of these\ntwo powerful techniques. The chapter notes give references for further study of\nthese areas.\nA randomized approximation algorithm for MAX-3-CNF satisﬁability\nJust as some randomized algorithms compute exact solutions, some randomized\nalgorithms compute approximate solutions. We say that a randomized algorithm\nfor a problem has an approximation ratio of \u000f.n/ if, for any input of size n, the\nexpected cost C of the solution produced by the randomized algorithm is within a\nfactor of \u000f.n/ of the cost C \u0004 of an optimal solution:\nmax\n\u0002 C\nC \u0004 ; C \u0004\nC\n\u0003\n\u0002 \u000f.n/ :\n(35.13)\nWe call a randomized algorithm that achieves an approximation ratio of \u000f.n/ a\nrandomized \u0004.n/-approximation algorithm. In other words, a randomized ap-\nproximation algorithm is like a deterministic approximation algorithm, except that\nthe approximation ratio is for an expected cost.\nA particular instance of 3-CNF satisﬁability, as deﬁned in Section 34.4, may or\nmay not be satisﬁable. In order to be satisﬁable, there must exist an assignment of\nthe variables so that every clause evaluates to 1. If an instance is not satisﬁable, we",
    "parent_57998866-f5a1-4c5f-8b90-4b8d3d6fdd96": "A particular instance of 3-CNF satisﬁability, as deﬁned in Section 34.4, may or\nmay not be satisﬁable. In order to be satisﬁable, there must exist an assignment of\nthe variables so that every clause evaluates to 1. If an instance is not satisﬁable, we\nmay want to compute how “close” to satisﬁable it is, that is, we may wish to ﬁnd an\nassignment of the variables that satisﬁes as many clauses as possible. We call the\nresulting maximization problem MAX-3-CNF satisﬁability. The input to MAX-3-\nCNF satisﬁability is the same as for 3-CNF satisﬁability, and the goal is to return\nan assignment of the variables that maximizes the number of clauses evaluating\nto 1. We now show that randomly setting each variable to 1 with probability 1=2\nand to 0 with probability 1=2 yields a randomized 8=7-approximation algorithm.\nAccording to the deﬁnition of 3-CNF satisﬁability from Section 34.4, we require\neach clause to consist of exactly three distinct literals. We further assume that\nno clause contains both a variable and its negation. (Exercise 35.4-1 asks you to\nremove this last assumption.)\n1124\nChapter 35\nApproximation Algorithms\nTheorem 35.6\nGiven an instance of MAX-3-CNF satisﬁability with n variables x1; x2; : : : ; xn\nand m clauses, the randomized algorithm that independently sets each vari-\nable to 1 with probability 1=2 and to 0 with probability 1=2 is a randomized\n8=7-approximation algorithm.\nProof\nSuppose that we have independently set each variable to 1 with probabil-\nity 1=2 and to 0 with probability 1=2. For i D 1; 2; : : : ; m, we deﬁne the indicator\nrandom variable\nYi D I fclause i is satisﬁedg ;\nso that Yi D 1 as long as we have set at least one of the literals in the ith clause\nto 1. Since no literal appears more than once in the same clause, and since we have\nassumed that no variable and its negation appear in the same clause, the settings of\nthe three literals in each clause are independent. A clause is not satisﬁed only if all",
    "parent_d926a8a1-e287-4efc-830c-ac08ea5a49f8": "to 1. Since no literal appears more than once in the same clause, and since we have\nassumed that no variable and its negation appear in the same clause, the settings of\nthe three literals in each clause are independent. A clause is not satisﬁed only if all\nthree of its literals are set to 0, and so Pr fclause i is not satisﬁedg D .1=2/3 D 1=8.\nThus, we have Pr fclause i is satisﬁedg D 1 \u0005 1=8 D 7=8, and by Lemma 5.1,\nwe have E ŒYi\u0002 D 7=8. Let Y be the number of satisﬁed clauses overall, so that\nY D Y1 C Y2 C \u0003 \u0003 \u0003 C Ym. Then, we have\nE ŒY \u0002\nD\nE\n\" m\nX\niD1\nYi\n#\nD\nm\nX\niD1\nE ŒYi\u0002\n(by linearity of expectation)\nD\nm\nX\niD1\n7=8\nD\n7m=8 :\nClearly, m is an upper bound on the number of satisﬁed clauses, and hence the\napproximation ratio is at most m=.7m=8/ D 8=7.\nApproximating weighted vertex cover using linear programming\nIn the minimum-weight vertex-cover problem, we are given an undirected graph\nG D .V; E/ in which each vertex \u0003 2 V has an associated positive weight w.\u0003/.\nFor any vertex cover V 0 \u0007 V , we deﬁne the weight of the vertex cover w.V 0/ D\nP\n\u00052V 0 w.\u0003/. The goal is to ﬁnd a vertex cover of minimum weight.\nWe cannot apply the algorithm used for unweighted vertex cover, nor can we use\na random solution; both methods may return solutions that are far from optimal.\nWe shall, however, compute a lower bound on the weight of the minimum-weight\n35.4\nRandomization and linear programming\n1125\nvertex cover, by using a linear program. We shall then “round” this solution and\nuse it to obtain a vertex cover.\nSuppose that we associate a variable x.\u0003/ with each vertex \u0003 2 V , and let us\nrequire that x.\u0003/ equals either 0 or 1 for each \u0003 2 V . We put \u0003 into the vertex cover\nif and only if x.\u0003/ D 1. Then, we can write the constraint that for any edge .u; \u0003/,\nat least one of u and \u0003 must be in the vertex cover as x.u/ C x.\u0003/ \u0006 1. This view\ngives rise to the following 0-1 integer program for ﬁnding a minimum-weight\nvertex cover:\nminimize\nX\n\u00052V\nw.\u0003/ x.\u0003/\n(35.14)\nsubject to\nx.u/ C x.\u0003/",
    "parent_ecb465dd-7e41-4a6d-9f24-474c2c2283cc": "at least one of u and \u0003 must be in the vertex cover as x.u/ C x.\u0003/ \u0006 1. This view\ngives rise to the following 0-1 integer program for ﬁnding a minimum-weight\nvertex cover:\nminimize\nX\n\u00052V\nw.\u0003/ x.\u0003/\n(35.14)\nsubject to\nx.u/ C x.\u0003/\n\u0006\n1\nfor each .u; \u0003/ 2 E\n(35.15)\nx.\u0003/\n2\nf0; 1g\nfor each \u0003 2 V :\n(35.16)\nIn the special case in which all the weights w.\u0003/ are equal to 1, this formu-\nlation is the optimization version of the NP-hard vertex-cover problem.\nSup-\npose, however, that we remove the constraint that x.\u0003/ 2 f0; 1g and replace it\nby 0 \u0002 x.\u0003/ \u0002 1. We then obtain the following linear program, which is known as\nthe linear-programming relaxation:\nminimize\nX\n\u00052V\nw.\u0003/ x.\u0003/\n(35.17)\nsubject to\nx.u/ C x.\u0003/\n\u0006\n1\nfor each .u; \u0003/ 2 E\n(35.18)\nx.\u0003/\n\u0002\n1\nfor each \u0003 2 V\n(35.19)\nx.\u0003/\n\u0006\n0\nfor each \u0003 2 V :\n(35.20)\nAny feasible solution to the 0-1 integer program in lines (35.14)–(35.16) is also\na feasible solution to the linear program in lines (35.17)–(35.20). Therefore, the\nvalue of an optimal solution to the linear program gives a lower bound on the value\nof an optimal solution to the 0-1 integer program, and hence a lower bound on the\noptimal weight in the minimum-weight vertex-cover problem.\nThe following procedure uses the solution to the linear-programming relaxation\nto construct an approximate solution to the minimum-weight vertex-cover problem:\n1126\nChapter 35\nApproximation Algorithms\nAPPROX-MIN-WEIGHT-VC.G; w/\n1\nC D ;\n2\ncompute Nx, an optimal solution to the linear program in lines (35.17)–(35.20)\n3\nfor each \u0003 2 V\n4\nif Nx.\u0003/ \u0006 1=2\n5\nC D C [ f\u0003g\n6\nreturn C\nThe APPROX-MIN-WEIGHT-VC procedure works as follows. Line 1 initial-\nizes the vertex cover to be empty.\nLine 2 formulates the linear program in\nlines (35.17)–(35.20) and then solves this linear program. An optimal solution\ngives each vertex \u0003 an associated value Nx.\u0003/, where 0 \u0002 Nx.\u0003/ \u0002 1. We use this\nvalue to guide the choice of which vertices to add to the vertex cover C in lines 3–5.",
    "parent_c59b9fa4-0882-45c8-83da-b796b93db1b4": "Line 2 formulates the linear program in\nlines (35.17)–(35.20) and then solves this linear program. An optimal solution\ngives each vertex \u0003 an associated value Nx.\u0003/, where 0 \u0002 Nx.\u0003/ \u0002 1. We use this\nvalue to guide the choice of which vertices to add to the vertex cover C in lines 3–5.\nIf Nx.\u0003/ \u0006 1=2, we add \u0003 to C; otherwise we do not. In effect, we are “rounding”\neach fractional variable in the solution to the linear program to 0 or 1 in order to\nobtain a solution to the 0-1 integer program in lines (35.14)–(35.16). Finally, line 6\nreturns the vertex cover C.\nTheorem 35.7\nAlgorithm APPROX-MIN-WEIGHT-VC is a polynomial-time 2-approximation al-\ngorithm for the minimum-weight vertex-cover problem.\nProof\nBecause there is a polynomial-time algorithm to solve the linear program\nin line 2, and because the for loop of lines 3–5 runs in polynomial time, APPROX-\nMIN-WEIGHT-VC is a polynomial-time algorithm.\nNow we show that APPROX-MIN-WEIGHT-VC is a 2-approximation algo-\nrithm. Let C \u0004 be an optimal solution to the minimum-weight vertex-cover prob-\nlem, and let ´\u0004 be the value of an optimal solution to the linear program in\nlines (35.17)–(35.20). Since an optimal vertex cover is a feasible solution to the\nlinear program, ´\u0004 must be a lower bound on w.C \u0004/, that is,\n´\u0004 \u0002 w.C \u0004/ :\n(35.21)\nNext, we claim that by rounding the fractional values of the variables Nx.\u0003/, we\nproduce a set C that is a vertex cover and satisﬁes w.C/ \u0002 2´\u0004. To see that C is\na vertex cover, consider any edge .u; \u0003/ 2 E. By constraint (35.18), we know that\nx.u/ C x.\u0003/ \u0006 1, which implies that at least one of Nx.u/ and Nx.\u0003/ is at least 1=2.\nTherefore, at least one of u and \u0003 is included in the vertex cover, and so every edge\nis covered.\nNow, we consider the weight of the cover. We have\n35.4\nRandomization and linear programming\n1127\n´\u0004\nD\nX\n\u00052V\nw.\u0003/ Nx.\u0003/\n\u0006\nX\n\u00052V W Nx.\u0005/\u00061=2\nw.\u0003/ Nx.\u0003/\n\u0006\nX\n\u00052V W Nx.\u0005/\u00061=2\nw.\u0003/ \u0003 1\n2\nD\nX\n\u00052C\nw.\u0003/ \u0003 1\n2\nD\n1\n2\nX\n\u00052C\nw.\u0003/\nD\n1\n2w.C/ :\n(35.22)",
    "parent_b2726855-85e2-48f6-b043-b3203b0eafd7": "is covered.\nNow, we consider the weight of the cover. We have\n35.4\nRandomization and linear programming\n1127\n´\u0004\nD\nX\n\u00052V\nw.\u0003/ Nx.\u0003/\n\u0006\nX\n\u00052V W Nx.\u0005/\u00061=2\nw.\u0003/ Nx.\u0003/\n\u0006\nX\n\u00052V W Nx.\u0005/\u00061=2\nw.\u0003/ \u0003 1\n2\nD\nX\n\u00052C\nw.\u0003/ \u0003 1\n2\nD\n1\n2\nX\n\u00052C\nw.\u0003/\nD\n1\n2w.C/ :\n(35.22)\nCombining inequalities (35.21) and (35.22) gives\nw.C/ \u0002 2´\u0004 \u0002 2w.C \u0004/ ;\nand hence APPROX-MIN-WEIGHT-VC is a 2-approximation algorithm.\nExercises\n35.4-1\nShow that even if we allow a clause to contain both a variable and its negation, ran-\ndomly setting each variable to 1 with probability 1=2 and to 0 with probability 1=2\nstill yields a randomized 8=7-approximation algorithm.\n35.4-2\nThe MAX-CNF satisﬁability problem is like the MAX-3-CNF satisﬁability prob-\nlem, except that it does not restrict each clause to have exactly 3 literals. Give a\nrandomized 2-approximation algorithm for the MAX-CNF satisﬁability problem.\n35.4-3\nIn the MAX-CUT problem, we are given an unweighted undirected graph G D\n.V; E/. We deﬁne a cut .S; V \u0005 S/ as in Chapter 23 and the weight of a cut as the\nnumber of edges crossing the cut. The goal is to ﬁnd a cut of maximum weight.\nSuppose that for each vertex \u0003, we randomly and independently place \u0003 in S with\nprobability 1=2 and in V \u0005 S with probability 1=2. Show that this algorithm is a\nrandomized 2-approximation algorithm.\n1128\nChapter 35\nApproximation Algorithms\n35.4-4\nShow that the constraints in line (35.19) are redundant in the sense that if we re-\nmove them from the linear program in lines (35.17)–(35.20), any optimal solution\nto the resulting linear program must satisfy x.\u0003/ \u0002 1 for each \u0003 2 V .\n35.5\nThe subset-sum problem\nRecall from Section 34.5.5 that an instance of the subset-sum problem is a\npair .S; t/, where S is a set fx1; x2; : : : ; xng of positive integers and t is a posi-\ntive integer. This decision problem asks whether there exists a subset of S that\nadds up exactly to the target value t. As we saw in Section 34.5.5, this problem is\nNP-complete.",
    "parent_9f8df9a3-c625-49e7-aa3e-9212a13e46da": "pair .S; t/, where S is a set fx1; x2; : : : ; xng of positive integers and t is a posi-\ntive integer. This decision problem asks whether there exists a subset of S that\nadds up exactly to the target value t. As we saw in Section 34.5.5, this problem is\nNP-complete.\nThe optimization problem associated with this decision problem arises in prac-\ntical applications.\nIn the optimization problem, we wish to ﬁnd a subset of\nfx1; x2; : : : ; xng whose sum is as large as possible but not larger than t. For ex-\nample, we may have a truck that can carry no more than t pounds, and n different\nboxes to ship, the ith of which weighs xi pounds. We wish to ﬁll the truck with as\nheavy a load as possible without exceeding the given weight limit.\nIn this section, we present an exponential-time algorithm that computes the op-\ntimal value for this optimization problem, and then we show how to modify the\nalgorithm so that it becomes a fully polynomial-time approximation scheme. (Re-\ncall that a fully polynomial-time approximation scheme has a running time that is\npolynomial in 1=\b as well as in the size of the input.)\nAn exponential-time exact algorithm\nSuppose that we computed, for each subset S 0 of S, the sum of the elements\nin S 0, and then we selected, among the subsets whose sum does not exceed t,\nthe one whose sum was closest to t. Clearly this algorithm would return the op-\ntimal solution, but it could take exponential time. To implement this algorithm,\nwe could use an iterative procedure that, in iteration i, computes the sums of\nall subsets of fx1; x2; : : : ; xig, using as a starting point the sums of all subsets\nof fx1; x2; : : : ; xi\u00031g. In doing so, we would realize that once a particular subset S 0\nhad a sum exceeding t, there would be no reason to maintain it, since no super-\nset of S 0 could be the optimal solution. We now give an implementation of this\nstrategy.\nThe procedure EXACT-SUBSET-SUM takes an input set S D fx1; x2; : : : ; xng",
    "parent_be8d8218-669a-4157-a39d-51c8f65aef4c": "had a sum exceeding t, there would be no reason to maintain it, since no super-\nset of S 0 could be the optimal solution. We now give an implementation of this\nstrategy.\nThe procedure EXACT-SUBSET-SUM takes an input set S D fx1; x2; : : : ; xng\nand a target value t; we’ll see its pseudocode in a moment. This procedure it-\n35.5\nThe subset-sum problem\n1129\neratively computes Li, the list of sums of all subsets of fx1; : : : ; xig that do not\nexceed t, and then it returns the maximum value in Ln.\nIf L is a list of positive integers and x is another positive integer, then we let\nL C x denote the list of integers derived from L by increasing each element of L\nby x. For example, if L D h1;2;3;5;9i, then L C 2 D h3;4;5;7;11i. We also use\nthis notation for sets, so that\nS C x D fs C x W s 2 Sg :\nWe also use an auxiliary procedure MERGE-LISTS.L; L0/, which returns the\nsorted list that is the merge of its two sorted input lists L and L0 with duplicate\nvalues removed. Like the MERGE procedure we used in merge sort (Section 2.3.1),\nMERGE-LISTS runs in time O.jLj C jL0j/. We omit the pseudocode for MERGE-\nLISTS.\nEXACT-SUBSET-SUM.S; t/\n1\nn D jSj\n2\nL0 D h0i\n3\nfor i D 1 to n\n4\nLi D MERGE-LISTS.Li\u00031; Li\u00031 C xi/\n5\nremove from Li every element that is greater than t\n6\nreturn the largest element in Ln\nTo see how EXACT-SUBSET-SUM works, let Pi denote the set of all values\nobtained by selecting a (possibly empty) subset of fx1; x2; : : : ; xig and summing\nits members. For example, if S D f1; 4; 5g, then\nP1\nD\nf0; 1g ;\nP2\nD\nf0; 1; 4; 5g ;\nP3\nD\nf0; 1; 4; 5; 6; 9; 10g :\nGiven the identity\nPi D Pi\u00031 [ .Pi\u00031 C xi/ ;\n(35.23)\nwe can prove by induction on i (see Exercise 35.5-1) that the list Li is a sorted list\ncontaining every element of Pi whose value is not more than t. Since the length\nof Li can be as much as 2i, EXACT-SUBSET-SUM is an exponential-time algorithm\nin general, although it is a polynomial-time algorithm in the special cases in which t",
    "parent_85fc9904-25dd-4769-929d-1c9200217f90": "containing every element of Pi whose value is not more than t. Since the length\nof Li can be as much as 2i, EXACT-SUBSET-SUM is an exponential-time algorithm\nin general, although it is a polynomial-time algorithm in the special cases in which t\nis polynomial in jSj or all the numbers in S are bounded by a polynomial in jSj.\nA fully polynomial-time approximation scheme\nWe can derive a fully polynomial-time approximation scheme for the subset-sum\nproblem by “trimming” each list Li after it is created. The idea behind trimming is\n1130\nChapter 35\nApproximation Algorithms\nthat if two values in L are close to each other, then since we want just an approxi-\nmate solution, we do not need to maintain both of them explicitly. More precisely,\nwe use a trimming parameter ı such that 0 < ı < 1. When we trim a list L by ı,\nwe remove as many elements from L as possible, in such a way that if L0 is the\nresult of trimming L, then for every element y that was removed from L, there is\nan element ´ still in L0 that approximates y, that is,\ny\n1 C ı \u0002 ´ \u0002 y :\n(35.24)\nWe can think of such a ´ as “representing” y in the new list L0. Each removed\nelement y is represented by a remaining element ´ satisfying inequality (35.24).\nFor example, if ı D 0:1 and\nL D h10; 11; 12; 15; 20; 21; 22; 23; 24; 29i ;\nthen we can trim L to obtain\nL0 D h10; 12; 15; 20; 23; 29i ;\nwhere the deleted value 11 is represented by 10, the deleted values 21 and 22\nare represented by 20, and the deleted value 24 is represented by 23. Because\nevery element of the trimmed version of the list is also an element of the original\nversion of the list, trimming can dramatically decrease the number of elements kept\nwhile keeping a close (and slightly smaller) representative value in the list for each\ndeleted element.\nThe following procedure trims list L D hy1; y2; : : : ; ymi in time ‚.m/, given L\nand ı, and assuming that L is sorted into monotonically increasing order. The\noutput of the procedure is a trimmed, sorted list.",
    "parent_22029282-06f4-4075-8c05-f9570f84eb7d": "deleted element.\nThe following procedure trims list L D hy1; y2; : : : ; ymi in time ‚.m/, given L\nand ı, and assuming that L is sorted into monotonically increasing order. The\noutput of the procedure is a trimmed, sorted list.\nTRIM.L; ı/\n1\nlet m be the length of L\n2\nL0 D hy1i\n3\nlast D y1\n4\nfor i D 2 to m\n5\nif yi > last \u0003 .1 C ı/\n// yi \u0006 last because L is sorted\n6\nappend yi onto the end of L0\n7\nlast D yi\n8\nreturn L0\nThe procedure scans the elements of L in monotonically increasing order. A num-\nber is appended onto the returned list L0 only if it is the ﬁrst element of L or if it\ncannot be represented by the most recent number placed into L0.\nGiven the procedure TRIM, we can construct our approximation scheme as fol-\nlows. This procedure takes as input a set S D fx1; x2; : : : ; xng of n integers (in\narbitrary order), a target integer t, and an “approximation parameter” \b, where\n35.5\nThe subset-sum problem\n1131\n0 < \b < 1 :\n(35.25)\nIt returns a value ´ whose value is within a 1 C \b factor of the optimal solution.\nAPPROX-SUBSET-SUM.S; t; \b/\n1\nn D jSj\n2\nL0 D h0i\n3\nfor i D 1 to n\n4\nLi D MERGE-LISTS.Li\u00031; Li\u00031 C xi/\n5\nLi D TRIM.Li; \b=2n/\n6\nremove from Li every element that is greater than t\n7\nlet ´\u0004 be the largest value in Ln\n8\nreturn ´\u0004\nLine 2 initializes the list L0 to be the list containing just the element 0. The for\nloop in lines 3–6 computes Li as a sorted list containing a suitably trimmed ver-\nsion of the set Pi, with all elements larger than t removed. Since we create Li\nfrom Li\u00031, we must ensure that the repeated trimming doesn’t introduce too much\ncompounded inaccuracy. In a moment, we shall see that APPROX-SUBSET-SUM\nreturns a correct approximation if one exists.\nAs an example, suppose we have the instance\nS D h104; 102; 201; 101i\nwith t D 308 and \b D 0:40. The trimming parameter ı is \b=8 D 0:05. APPROX-\nSUBSET-SUM computes the following values on the indicated lines:\nline 2:\nL0\nD\nh0i ;\nline 4:\nL1\nD\nh0; 104i ;\nline 5:\nL1\nD\nh0; 104i ;\nline 6:\nL1\nD\nh0; 104i ;",
    "parent_9b900c5a-eb39-4bff-9531-823642420696": "As an example, suppose we have the instance\nS D h104; 102; 201; 101i\nwith t D 308 and \b D 0:40. The trimming parameter ı is \b=8 D 0:05. APPROX-\nSUBSET-SUM computes the following values on the indicated lines:\nline 2:\nL0\nD\nh0i ;\nline 4:\nL1\nD\nh0; 104i ;\nline 5:\nL1\nD\nh0; 104i ;\nline 6:\nL1\nD\nh0; 104i ;\nline 4:\nL2\nD\nh0; 102; 104; 206i ;\nline 5:\nL2\nD\nh0; 102; 206i ;\nline 6:\nL2\nD\nh0; 102; 206i ;\nline 4:\nL3\nD\nh0; 102; 201; 206; 303; 407i ;\nline 5:\nL3\nD\nh0; 102; 201; 303; 407i ;\nline 6:\nL3\nD\nh0; 102; 201; 303i ;\nline 4:\nL4\nD\nh0; 101; 102; 201; 203; 302; 303; 404i ;\nline 5:\nL4\nD\nh0; 101; 201; 302; 404i ;\nline 6:\nL4\nD\nh0; 101; 201; 302i :\n1132\nChapter 35\nApproximation Algorithms\nThe algorithm returns ´\u0004 D 302 as its answer, which is well within \b D 40% of\nthe optimal answer 307 D 104 C 102 C 101; in fact, it is within 2%.\nTheorem 35.8\nAPPROX-SUBSET-SUM is a fully polynomial-time approximation scheme for the\nsubset-sum problem.\nProof\nThe operations of trimming Li in line 5 and removing from Li every ele-\nment that is greater than t maintain the property that every element of Li is also a\nmember of Pi. Therefore, the value ´\u0004 returned in line 8 is indeed the sum of some\nsubset of S. Let y\u0004 2 Pn denote an optimal solution to the subset-sum problem.\nThen, from line 6, we know that ´\u0004 \u0002 y\u0004. By inequality (35.1), we need to show\nthat y\u0004=´\u0004 \u0002 1 C \b. We must also show that the running time of this algorithm is\npolynomial in both 1=\b and the size of the input.\nAs Exercise 35.5-2 asks you to show, for every element y in Pi that is at most t,\nthere exists an element ´ 2 Li such that\ny\n.1 C \b=2n/i \u0002 ´ \u0002 y :\n(35.26)\nInequality (35.26) must hold for y\u0004 2 Pn, and therefore there exists an element\n´ 2 Ln such that\ny\u0004\n.1 C \b=2n/n \u0002 ´ \u0002 y\u0004 ;\nand thus\ny\u0004\n´ \u0002\n\u0004\n1 C \b\n2n\n\u0005n\n:\n(35.27)\nSince there exists an element ´ 2 Ln fulﬁlling inequality (35.27), the inequality\nmust hold for ´\u0004, which is the largest value in Ln; that is,\ny\u0004\n´\u0004 \u0002\n\u0004\n1 C \b\n2n\n\u0005n\n:\n(35.28)",
    "parent_78ac8ae2-b571-405b-8548-4f93bbe9cb46": "´ 2 Ln such that\ny\u0004\n.1 C \b=2n/n \u0002 ´ \u0002 y\u0004 ;\nand thus\ny\u0004\n´ \u0002\n\u0004\n1 C \b\n2n\n\u0005n\n:\n(35.27)\nSince there exists an element ´ 2 Ln fulﬁlling inequality (35.27), the inequality\nmust hold for ´\u0004, which is the largest value in Ln; that is,\ny\u0004\n´\u0004 \u0002\n\u0004\n1 C \b\n2n\n\u0005n\n:\n(35.28)\nNow, we show that y\u0004=´\u0004 \u0002 1 C \b. We do so by showing that .1 C \b=2n/n \u0002\n1 C \b. By equation (3.14), we have limn!1.1 C \b=2n/n D e\u0002=2. Exercise 35.5-3\nasks you to show that\nd\ndn\n\u0004\n1 C \b\n2n\n\u0005n\n> 0 :\n(35.29)\nTherefore, the function .1 C \b=2n/n increases with n as it approaches its limit\nof e\u0002=2, and we have\n35.5\nThe subset-sum problem\n1133\n\u0004\n1 C \b\n2n\n\u0005n\n\u0002\ne\u0002=2\n\u0002\n1 C \b=2 C .\b=2/2\n(by inequality (3.13))\n\u0002\n1 C \b\n(by inequality (35.25)) .\n(35.30)\nCombining inequalities (35.28) and (35.30) completes the analysis of the approxi-\nmation ratio.\nTo show that APPROX-SUBSET-SUM is a fully polynomial-time approximation\nscheme, we derive a bound on the length of Li. After trimming, successive ele-\nments ´ and ´0 of Li must have the relationship ´0=´ > 1C\b=2n. That is, they must\ndiffer by a factor of at least 1 C \b=2n. Each list, therefore, contains the value 0,\npossibly the value 1, and up to\n\r\nlog1C\u0002=2n t\n˘\nadditional values. The number of\nelements in each list Li is at most\nlog1C\u0002=2n t C 2\nD\nln t\nln.1 C \b=2n/ C 2\n\u0002\n2n.1 C \b=2n/ ln t\n\b\nC 2\n(by inequality (3.17))\n<\n3n ln t\n\b\nC 2\n(by inequality (35.25)) .\nThis bound is polynomial in the size of the input—which is the number of bits lg t\nneeded to represent t plus the number of bits needed to represent the set S, which is\nin turn polynomial in n—and in 1=\b. Since the running time of APPROX-SUBSET-\nSUM is polynomial in the lengths of the Li, we conclude that APPROX-SUBSET-\nSUM is a fully polynomial-time approximation scheme.\nExercises\n35.5-1\nProve equation (35.23). Then show that after executing line 5 of EXACT-SUBSET-\nSUM, Li is a sorted list containing every element of Pi whose value is not more\nthan t.\n35.5-2\nUsing induction on i, prove inequality (35.26).\n35.5-3",
    "parent_ed4cd036-57e4-4943-9c3e-426fb9c6f82a": "SUM is a fully polynomial-time approximation scheme.\nExercises\n35.5-1\nProve equation (35.23). Then show that after executing line 5 of EXACT-SUBSET-\nSUM, Li is a sorted list containing every element of Pi whose value is not more\nthan t.\n35.5-2\nUsing induction on i, prove inequality (35.26).\n35.5-3\nProve inequality (35.29).\n1134\nChapter 35\nApproximation Algorithms\n35.5-4\nHow would you modify the approximation scheme presented in this section to ﬁnd\na good approximation to the smallest value not less than t that is a sum of some\nsubset of the given input list?\n35.5-5\nModify the APPROX-SUBSET-SUM procedure to also return the subset of S that\nsums to the value ´\u0004.\nProblems\n35-1\nBin packing\nSuppose that we are given a set of n objects, where the size si of the ith object\nsatisﬁes 0 < si < 1. We wish to pack all the objects into the minimum number of\nunit-size bins. Each bin can hold any subset of the objects whose total size does\nnot exceed 1.\na. Prove that the problem of determining the minimum number of bins required is\nNP-hard. (Hint: Reduce from the subset-sum problem.)\nThe ﬁrst-ﬁt heuristic takes each object in turn and places it into the ﬁrst bin that\ncan accommodate it. Let S D Pn\niD1 si.\nb. Argue that the optimal number of bins required is at least dSe.\nc. Argue that the ﬁrst-ﬁt heuristic leaves at most one bin less than half full.\nd. Prove that the number of bins used by the ﬁrst-ﬁt heuristic is never more\nthan d2Se.\ne. Prove an approximation ratio of 2 for the ﬁrst-ﬁt heuristic.\nf.\nGive an efﬁcient implementation of the ﬁrst-ﬁt heuristic, and analyze its running\ntime.\n35-2\nApproximating the size of a maximum clique\nLet G D .V; E/ be an undirected graph. For any k \u0006 1, deﬁne G.k/ to be the undi-\nrected graph .V .k/; E.k//, where V .k/ is the set of all ordered k-tuples of vertices\nfrom V and E.k/ is deﬁned so that .\u00031; \u00032; : : : ; \u0003k/ is adjacent to .w1; w2; : : : ; wk/\nif and only if for i D 1; 2; : : : ; k, either vertex \u0003i is adjacent to wi in G, or else",
    "parent_a2ba9728-9f88-48c7-a166-e4021871f55b": "rected graph .V .k/; E.k//, where V .k/ is the set of all ordered k-tuples of vertices\nfrom V and E.k/ is deﬁned so that .\u00031; \u00032; : : : ; \u0003k/ is adjacent to .w1; w2; : : : ; wk/\nif and only if for i D 1; 2; : : : ; k, either vertex \u0003i is adjacent to wi in G, or else\n\u0003i D wi.\nProblems for Chapter 35\n1135\na. Prove that the size of the maximum clique in G.k/ is equal to the kth power of\nthe size of the maximum clique in G.\nb. Argue that if there is an approximation algorithm that has a constant approxi-\nmation ratio for ﬁnding a maximum-size clique, then there is a polynomial-time\napproximation scheme for the problem.\n35-3\nWeighted set-covering problem\nSuppose that we generalize the set-covering problem so that each set Si in the\nfamily F has an associated weight wi and the weight of a cover C is P\nSi 2C wi.\nWe wish to determine a minimum-weight cover. (Section 35.3 handles the case in\nwhich wi D 1 for all i.)\nShow how to generalize the greedy set-covering heuristic in a natural manner\nto provide an approximate solution for any instance of the weighted set-covering\nproblem. Show that your heuristic has an approximation ratio of H.d/, where d is\nthe maximum size of any set Si.\n35-4\nMaximum matching\nRecall that for an undirected graph G, a matching is a set of edges such that no\ntwo edges in the set are incident on the same vertex. In Section 26.3, we saw how\nto ﬁnd a maximum matching in a bipartite graph. In this problem, we will look at\nmatchings in undirected graphs in general (i.e., the graphs are not required to be\nbipartite).\na. A maximal matching is a matching that is not a proper subset of any other\nmatching. Show that a maximal matching need not be a maximum matching by\nexhibiting an undirected graph G and a maximal matching M in G that is not a\nmaximum matching. (Hint: You can ﬁnd such a graph with only four vertices.)\nb. Consider an undirected graph G D .V; E/. Give an O.E/-time greedy algo-\nrithm to ﬁnd a maximal matching in G.",
    "parent_d2451e5d-60bc-4462-9344-6e711e3adca7": "exhibiting an undirected graph G and a maximal matching M in G that is not a\nmaximum matching. (Hint: You can ﬁnd such a graph with only four vertices.)\nb. Consider an undirected graph G D .V; E/. Give an O.E/-time greedy algo-\nrithm to ﬁnd a maximal matching in G.\nIn this problem, we shall concentrate on a polynomial-time approximation algo-\nrithm for maximum matching. Whereas the fastest known algorithm for maximum\nmatching takes superlinear (but polynomial) time, the approximation algorithm\nhere will run in linear time. You will show that the linear-time greedy algorithm\nfor maximal matching in part (b) is a 2-approximation algorithm for maximum\nmatching.\nc. Show that the size of a maximum matching in G is a lower bound on the size\nof any vertex cover for G.\n1136\nChapter 35\nApproximation Algorithms\nd. Consider a maximal matching M in G D .V; E/. Let\nT D f\u0003 2 V W some edge in M is incident on \u0003g :\nWhat can you say about the subgraph of G induced by the vertices of G that\nare not in T ?\ne. Conclude from part (d) that 2 jMj is the size of a vertex cover for G.\nf.\nUsing parts (c) and (e), prove that the greedy algorithm in part (b) is a 2-approx-\nimation algorithm for maximum matching.\n35-5\nParallel machine scheduling\nIn the parallel-machine-scheduling problem, we are given n jobs, J1; J2; : : : ; Jn,\nwhere each job Jk has an associated nonnegative processing time of pk. We are\nalso given m identical machines, M1; M2; : : : ; Mm. Any job can run on any ma-\nchine. A schedule speciﬁes, for each job Jk, the machine on which it runs and\nthe time period during which it runs. Each job Jk must run on some machine Mi\nfor pk consecutive time units, and during that time period no other job may run\non Mi. Let Ck denote the completion time of job Jk, that is, the time at which\njob Jk completes processing. Given a schedule, we deﬁne Cmax D max1\u0005j\u0005n Cj to\nbe the makespan of the schedule. The goal is to ﬁnd a schedule whose makespan\nis minimum.",
    "parent_cf66a46e-f16c-4a26-9c4d-452659e28822": "on Mi. Let Ck denote the completion time of job Jk, that is, the time at which\njob Jk completes processing. Given a schedule, we deﬁne Cmax D max1\u0005j\u0005n Cj to\nbe the makespan of the schedule. The goal is to ﬁnd a schedule whose makespan\nis minimum.\nFor example, suppose that we have two machines M1 and M2 and that we have\nfour jobs J1; J2; J3; J4, with p1 D 2, p2 D 12, p3 D 4, and p4 D 5. Then one\npossible schedule runs, on machine M1, job J1 followed by job J2, and on ma-\nchine M2, it runs job J4 followed by job J3. For this schedule, C1 D 2, C2 D 14,\nC3 D 9, C4 D 5, and Cmax D 14. An optimal schedule runs J2 on machine M1, and\nit runs jobs J1, J3, and J4 on machine M2. For this schedule, C1 D 2, C2 D 12,\nC3 D 6, C4 D 11, and Cmax D 12.\nGiven a parallel-machine-scheduling problem, we let C \u0004\nmax denote the makespan\nof an optimal schedule.\na. Show that the optimal makespan is at least as large as the greatest processing\ntime, that is,\nC \u0004\nmax \u0006 max\n1\u0005k\u0005n pk :\nb. Show that the optimal makespan is at least as large as the average machine load,\nthat is,\nC \u0004\nmax \u0006 1\nm\nX\n1\u0005k\u0005n\npk :\nProblems for Chapter 35\n1137\nSuppose that we use the following greedy algorithm for parallel machine schedul-\ning: whenever a machine is idle, schedule any job that has not yet been scheduled.\nc. Write pseudocode to implement this greedy algorithm. What is the running\ntime of your algorithm?\nd. For the schedule returned by the greedy algorithm, show that\nCmax \u0002 1\nm\nX\n1\u0005k\u0005n\npk C max\n1\u0005k\u0005n pk :\nConclude that this algorithm is a polynomial-time 2-approximation algorithm.\n35-6\nApproximating a maximum spanning tree\nLet G D .V; E/ be an undirected graph with distinct edge weights w.u; \u0003/ on each\nedge .u; \u0003/ 2 E. For each vertex \u0003 2 V , let max.\u0003/ D max.u;\u0005/2E fw.u; \u0003/g be\nthe maximum-weight edge incident on that vertex. Let SG D fmax.\u0003/ W \u0003 2 V g\nbe the set of maximum-weight edges incident on each vertex, and let TG be the\nmaximum-weight spanning tree of G, that is, the spanning tree of maximum total",
    "parent_d1972407-80b6-42d8-aaa0-bf6cd6956651": "the maximum-weight edge incident on that vertex. Let SG D fmax.\u0003/ W \u0003 2 V g\nbe the set of maximum-weight edges incident on each vertex, and let TG be the\nmaximum-weight spanning tree of G, that is, the spanning tree of maximum total\nweight. For any subset of edges E0 \u0007 E, deﬁne w.E0/ D P\n.u;\u0005/2E0 w.u; \u0003/.\na. Give an example of a graph with at least 4 vertices for which SG D TG.\nb. Give an example of a graph with at least 4 vertices for which SG ¤ TG.\nc. Prove that SG \u0007 TG for any graph G.\nd. Prove that w.TG/ \u0006 w.SG/=2 for any graph G.\ne. Give an O.V C E/-time algorithm to compute a 2-approximation to the maxi-\nmum spanning tree.\n35-7\nAn approximation algorithm for the 0-1 knapsack problem\nRecall the knapsack problem from Section 16.2. There are n items, where the ith\nitem is worth \u0003i dollars and weighs wi pounds. We are also given a knapsack\nthat can hold at most W pounds. Here, we add the further assumptions that each\nweight wi is at most W and that the items are indexed in monotonically decreasing\norder of their values: \u00031 \u0006 \u00032 \u0006 \u0003 \u0003 \u0003 \u0006 \u0003n.\nIn the 0-1 knapsack problem, we wish to ﬁnd a subset of the items whose total\nweight is at most W and whose total value is maximum. The fractional knapsack\nproblem is like the 0-1 knapsack problem, except that we are allowed to take a\nfraction of each item, rather than being restricted to taking either all or none of\n1138\nChapter 35\nApproximation Algorithms\neach item. If we take a fraction xi of item i, where 0 \u0002 xi \u0002 1, we contribute\nxiwi to the weight of the knapsack and receive value xi\u0003i. Our goal is to develop\na polynomial-time 2-approximation algorithm for the 0-1 knapsack problem.\nIn order to design a polynomial-time algorithm, we consider restricted instances\nof the 0-1 knapsack problem. Given an instance I of the knapsack problem, we\nform restricted instances Ij, for j D 1; 2; : : : ; n, by removing items 1; 2; : : : ; j \u00051\nand requiring the solution to include item j (all of item j in both the fractional",
    "parent_cdadea80-1cd7-4cf6-b80d-4904aecaf50a": "of the 0-1 knapsack problem. Given an instance I of the knapsack problem, we\nform restricted instances Ij, for j D 1; 2; : : : ; n, by removing items 1; 2; : : : ; j \u00051\nand requiring the solution to include item j (all of item j in both the fractional\nand 0-1 knapsack problems). No items are removed in instance I1. For instance Ij,\nlet Pj denote an optimal solution to the 0-1 problem and Qj denote an optimal\nsolution to the fractional problem.\na. Argue that an optimal solution to instance I of the 0-1 knapsack problem is one\nof fP1; P2; : : : ; Png.\nb. Prove that we can ﬁnd an optimal solution Qj to the fractional problem for in-\nstance Ij by including item j and then using the greedy algorithm in which\nat each step, we take as much as possible of the unchosen item in the set\nfj C 1; j C 2; : : : ; ng with maximum value per pound \u0003i=wi.\nc. Prove that we can always construct an optimal solution Qj to the fractional\nproblem for instance Ij that includes at most one item fractionally. That is, for\nall items except possibly one, we either include all of the item or none of the\nitem in the knapsack.\nd. Given an optimal solution Qj to the fractional problem for instance Ij, form\nsolution Rj from Qj by deleting any fractional items from Qj. Let \u0003.S/ denote\nthe total value of items taken in a solution S. Prove that \u0003.Rj/ \u0006 \u0003.Qj/=2 \u0006\n\u0003.Pj/=2.\ne. Give a polynomial-time algorithm that returns a maximum-value solution from\nthe set fR1; R2; : : : ; Rng, and prove that your algorithm is a polynomial-time\n2-approximation algorithm for the 0-1 knapsack problem.\nChapter notes\nAlthough methods that do not necessarily compute exact solutions have been\nknown for thousands of years (for example, methods to approximate the value\nof \u0006), the notion of an approximation algorithm is much more recent. Hochbaum\n[172] credits Garey, Graham, and Ullman [128] and Johnson [190] with formal-\nizing the concept of a polynomial-time approximation algorithm. The ﬁrst such",
    "parent_133de140-dd5f-4b78-9fbf-a578e1e8a28c": "of \u0006), the notion of an approximation algorithm is much more recent. Hochbaum\n[172] credits Garey, Graham, and Ullman [128] and Johnson [190] with formal-\nizing the concept of a polynomial-time approximation algorithm. The ﬁrst such\nalgorithm is often credited to Graham [149].\nNotes for Chapter 35\n1139\nSince this early work, thousands of approximation algorithms have been de-\nsigned for a wide range of problems, and there is a wealth of literature on this\nﬁeld. Recent texts by Ausiello et al. [26], Hochbaum [172], and Vazirani [345]\ndeal exclusively with approximation algorithms, as do surveys by Shmoys [315]\nand Klein and Young [207]. Several other texts, such as Garey and Johnson [129]\nand Papadimitriou and Steiglitz [271], have signiﬁcant coverage of approximation\nalgorithms as well. Lawler, Lenstra, Rinnooy Kan, and Shmoys [225] provide an\nextensive treatment of approximation algorithms for the traveling-salesman prob-\nlem.\nPapadimitriou and Steiglitz attribute the algorithm APPROX-VERTEX-COVER\nto F. Gavril and M. Yannakakis. The vertex-cover problem has been studied exten-\nsively (Hochbaum [172] lists 16 different approximation algorithms for this prob-\nlem), but all the approximation ratios are at least 2 \u0005 o.1/.\nThe algorithm APPROX-TSP-TOUR appears in a paper by Rosenkrantz, Stearns,\nand Lewis [298]. Christoﬁdes improved on this algorithm and gave a 3=2-approx-\nimation algorithm for the traveling-salesman problem with the triangle inequality.\nArora [22] and Mitchell [257] have shown that if the points are in the euclidean\nplane, there is a polynomial-time approximation scheme. Theorem 35.3 is due to\nSahni and Gonzalez [301].\nThe analysis of the greedy heuristic for the set-covering problem is modeled\nafter the proof published by Chv´atal [68] of a more general result; the basic result\nas presented here is due to Johnson [190] and Lov´asz [238].\nThe algorithm APPROX-SUBSET-SUM and its analysis are loosely modeled after",
    "parent_268d8fbe-5b01-4ba9-8603-97482d6aedef": "The analysis of the greedy heuristic for the set-covering problem is modeled\nafter the proof published by Chv´atal [68] of a more general result; the basic result\nas presented here is due to Johnson [190] and Lov´asz [238].\nThe algorithm APPROX-SUBSET-SUM and its analysis are loosely modeled after\nrelated approximation algorithms for the knapsack and subset-sum problems by\nIbarra and Kim [187].\nProblem 35-7 is a combinatorial version of a more general result on approximat-\ning knapsack-type integer programs by Bienstock and McClosky [45].\nThe randomized algorithm for MAX-3-CNF satisﬁability is implicit in the work\nof Johnson [190]. The weighted vertex-cover algorithm is by Hochbaum [171].\nSection 35.4 only touches on the power of randomization and linear program-\nming in the design of approximation algorithms. A combination of these two ideas\nyields a technique called “randomized rounding,” which formulates a problem as\nan integer linear program, solves the linear-programming relaxation, and interprets\nthe variables in the solution as probabilities. These probabilities then help guide\nthe solution of the original problem. This technique was ﬁrst used by Raghavan\nand Thompson [290], and it has had many subsequent uses. (See Motwani, Naor,\nand Raghavan [261] for a survey.) Several other notable recent ideas in the ﬁeld\nof approximation algorithms include the primal-dual method (see Goemans and\nWilliamson [135] for a survey), ﬁnding sparse cuts for use in divide-and-conquer\nalgorithms [229], and the use of semideﬁnite programming [134].\n1140\nChapter 35\nApproximation Algorithms\nAs mentioned in the chapter notes for Chapter 34, recent results in probabilisti-\ncally checkable proofs have led to lower bounds on the approximability of many\nproblems, including several in this chapter. In addition to the references there,\nthe chapter by Arora and Lund [23] contains a good description of the relation-",
    "parent_1bb784b4-1bdd-4ea3-9c39-e475bb22ec54": "cally checkable proofs have led to lower bounds on the approximability of many\nproblems, including several in this chapter. In addition to the references there,\nthe chapter by Arora and Lund [23] contains a good description of the relation-\nship between probabilistically checkable proofs and the hardness of approximating\nvarious problems.\nVIII\nAppendix: Mathematical Background\nIntroduction\nWhen we analyze algorithms, we often need to draw upon a body of mathematical\ntools. Some of these tools are as simple as high-school algebra, but others may be\nnew to you. In Part I, we saw how to manipulate asymptotic notations and solve\nrecurrences. This appendix comprises a compendium of several other concepts and\nmethods we use to analyze algorithms. As noted in the introduction to Part I, you\nmay have seen much of the material in this appendix before having read this book\n(although the speciﬁc notational conventions we use might occasionally differ from\nthose you have seen elsewhere). Hence, you should treat this appendix as reference\nmaterial. As in the rest of this book, however, we have included exercises and\nproblems, in order for you to improve your skills in these areas.\nAppendix A offers methods for evaluating and bounding summations, which\noccur frequently in the analysis of algorithms. Many of the formulas here appear\nin any calculus text, but you will ﬁnd it convenient to have these methods compiled\nin one place.\nAppendix B contains basic deﬁnitions and notations for sets, relations, functions,\ngraphs, and trees. It also gives some basic properties of these mathematical objects.\nAppendix C begins with elementary principles of counting: permutations, com-\nbinations, and the like. The remainder contains deﬁnitions and properties of basic\nprobability. Most of the algorithms in this book require no probability for their\nanalysis, and thus you can easily omit the latter sections of the chapter on a ﬁrst",
    "parent_6b2d0f9c-5400-45fd-8d16-cf8fac6999cd": "binations, and the like. The remainder contains deﬁnitions and properties of basic\nprobability. Most of the algorithms in this book require no probability for their\nanalysis, and thus you can easily omit the latter sections of the chapter on a ﬁrst\nreading, even without skimming them. Later, when you encounter a probabilistic\nanalysis that you want to understand better, you will ﬁnd Appendix C well orga-\nnized for reference purposes.\n1144\nPart VIII\nAppendix: Mathematical Background\nAppendix D deﬁnes matrices, their operations, and some of their basic prop-\nerties. You have probably seen most of this material already if you have taken a\ncourse in linear algebra, but you might ﬁnd it helpful to have one place to look for\nour notation and deﬁnitions.\nA\nSummations\nWhen an algorithm contains an iterative control construct such as a while or for\nloop, we can express its running time as the sum of the times spent on each exe-\ncution of the body of the loop. For example, we found in Section 2.2 that the j th\niteration of insertion sort took time proportional to j in the worst case. By adding\nup the time spent on each iteration, we obtained the summation (or series)\nn\nX\njD2\nj :\nWhen we evaluated this summation, we attained a bound of ‚.n2/ on the worst-\ncase running time of the algorithm. This example illustrates why you should know\nhow to manipulate and bound summations.\nSection A.1 lists several basic formulas involving summations. Section A.2 of-\nfers useful techniques for bounding summations. We present the formulas in Sec-\ntion A.1 without proof, though proofs for some of them appear in Section A.2 to\nillustrate the methods of that section. You can ﬁnd most of the other proofs in any\ncalculus text.\nA.1\nSummation formulas and properties\nGiven a sequence a1; a2; : : : ; an of numbers, where n is a nonnegative integer, we\ncan write the ﬁnite sum a1 C a2 C \u0003 \u0003 \u0003 C an as\nn\nX\nkD1\nak :\nIf n D 0, the value of the summation is deﬁned to be 0. The value of a ﬁnite series",
    "parent_e8fdae6a-f93b-4103-b1e4-46598b3aa388": "calculus text.\nA.1\nSummation formulas and properties\nGiven a sequence a1; a2; : : : ; an of numbers, where n is a nonnegative integer, we\ncan write the ﬁnite sum a1 C a2 C \u0003 \u0003 \u0003 C an as\nn\nX\nkD1\nak :\nIf n D 0, the value of the summation is deﬁned to be 0. The value of a ﬁnite series\nis always well deﬁned, and we can add its terms in any order.\nGiven an inﬁnite sequence a1; a2; : : : of numbers, we can write the inﬁnite sum\na1 C a2 C \u0003 \u0003 \u0003 as\n1146\nAppendix A\nSummations\n1\nX\nkD1\nak ;\nwhich we interpret to mean\nlim\nn!1\nn\nX\nkD1\nak :\nIf the limit does not exist, the series diverges; otherwise, it converges. The terms\nof a convergent series cannot always be added in any order. We can, however,\nrearrange the terms of an absolutely convergent series, that is, a series P1\nkD1 ak\nfor which the series P1\nkD1 jakj also converges.\nLinearity\nFor any real number c and any ﬁnite sequences a1; a2; : : : ; an and b1; b2; : : : ; bn,\nn\nX\nkD1\n.cak C bk/ D c\nn\nX\nkD1\nak C\nn\nX\nkD1\nbk :\nThe linearity property also applies to inﬁnite convergent series.\nWe can exploit the linearity property to manipulate summations incorporating\nasymptotic notation. For example,\nn\nX\nkD1\n‚.f .k// D ‚\n n\nX\nkD1\nf .k/\n!\n:\nIn this equation, the ‚-notation on the left-hand side applies to the variable k, but\non the right-hand side, it applies to n. We can also apply such manipulations to\ninﬁnite convergent series.\nArithmetic series\nThe summation\nn\nX\nkD1\nk D 1 C 2 C \u0003 \u0003 \u0003 C n ;\nis an arithmetic series and has the value\nn\nX\nkD1\nk\nD\n1\n2n.n C 1/\n(A.1)\nD\n‚.n2/ :\n(A.2)\nA.1\nSummation formulas and properties\n1147\nSums of squares and cubes\nWe have the following summations of squares and cubes:\nn\nX\nkD0\nk2\nD\nn.n C 1/.2n C 1/\n6\n;\n(A.3)\nn\nX\nkD0\nk3\nD\nn2.n C 1/2\n4\n:\n(A.4)\nGeometric series\nFor real x ¤ 1, the summation\nn\nX\nkD0\nxk D 1 C x C x2 C \u0003 \u0003 \u0003 C xn\nis a geometric or exponential series and has the value\nn\nX\nkD0\nxk D xnC1 \u0005 1\nx \u0005 1\n:\n(A.5)\nWhen the summation is inﬁnite and jxj < 1, we have the inﬁnite decreasing geo-",
    "parent_dff74249-ea22-449c-9972-d11265aa534d": "6\n;\n(A.3)\nn\nX\nkD0\nk3\nD\nn2.n C 1/2\n4\n:\n(A.4)\nGeometric series\nFor real x ¤ 1, the summation\nn\nX\nkD0\nxk D 1 C x C x2 C \u0003 \u0003 \u0003 C xn\nis a geometric or exponential series and has the value\nn\nX\nkD0\nxk D xnC1 \u0005 1\nx \u0005 1\n:\n(A.5)\nWhen the summation is inﬁnite and jxj < 1, we have the inﬁnite decreasing geo-\nmetric series\n1\nX\nkD0\nxk D\n1\n1 \u0005 x :\n(A.6)\nHarmonic series\nFor positive integers n, the nth harmonic number is\nHn\nD\n1 C 1\n2 C 1\n3 C 1\n4 C \u0003 \u0003 \u0003 C 1\nn\nD\nn\nX\nkD1\n1\nk\nD\nln n C O.1/ :\n(A.7)\n(We shall prove a related bound in Section A.2.)\nIntegrating and differentiating series\nBy integrating or differentiating the formulas above, additional formulas arise. For\nexample, by differentiating both sides of the inﬁnite geometric series (A.6) and\nmultiplying by x, we get\n1148\nAppendix A\nSummations\n1\nX\nkD0\nkxk D\nx\n.1 \u0005 x/2\n(A.8)\nfor jxj < 1.\nTelescoping series\nFor any sequence a0; a1; : : : ; an,\nn\nX\nkD1\n.ak \u0005 ak\u00031/ D an \u0005 a0 ;\n(A.9)\nsince each of the terms a1; a2; : : : ; an\u00031 is added in exactly once and subtracted out\nexactly once. We say that the sum telescopes. Similarly,\nn\u00031\nX\nkD0\n.ak \u0005 akC1/ D a0 \u0005 an :\nAs an example of a telescoping sum, consider the series\nn\u00031\nX\nkD1\n1\nk.k C 1/ :\nSince we can rewrite each term as\n1\nk.k C 1/ D 1\nk \u0005\n1\nk C 1 ;\nwe get\nn\u00031\nX\nkD1\n1\nk.k C 1/\nD\nn\u00031\nX\nkD1\n\u00021\nk \u0005\n1\nk C 1\n\u0003\nD\n1 \u0005 1\nn :\nProducts\nWe can write the ﬁnite product a1a2 \u0003 \u0003 \u0003 an as\nn\nY\nkD1\nak :\nIf n D 0, the value of the product is deﬁned to be 1. We can convert a formula with\na product to a formula with a summation by using the identity\nlg\n n\nY\nkD1\nak\n!\nD\nn\nX\nkD1\nlg ak :\nA.2\nBounding summations\n1149\nExercises\nA.1-1\nFind a simple formula for Pn\nkD1.2k \u0005 1/.\nA.1-2\n?\nShow that Pn\nkD1 1=.2k \u0005 1/ D ln.pn/ C O.1/ by manipulating the harmonic\nseries.\nA.1-3\nShow that P1\nkD0 k2xk D x.1 C x/=.1 \u0005 x/3 for 0 < jxj < 1.\nA.1-4\n?\nShow that P1\nkD0.k \u0005 1/=2k D 0.\nA.1-5\n?\nEvaluate the sum P1\nkD1.2k C 1/x2k.\nA.1-6\nProve that Pn\nkD1 O.fk.i// D O\n\u000b Pn\nkD1 fk.i/\n\f\nby using the linearity property of\nsummations.",
    "parent_eb238cc9-c93e-4f67-a6d1-f3cdef8031b0": "series.\nA.1-3\nShow that P1\nkD0 k2xk D x.1 C x/=.1 \u0005 x/3 for 0 < jxj < 1.\nA.1-4\n?\nShow that P1\nkD0.k \u0005 1/=2k D 0.\nA.1-5\n?\nEvaluate the sum P1\nkD1.2k C 1/x2k.\nA.1-6\nProve that Pn\nkD1 O.fk.i// D O\n\u000b Pn\nkD1 fk.i/\n\f\nby using the linearity property of\nsummations.\nA.1-7\nEvaluate the product Qn\nkD1 2 \u0003 4k.\nA.1-8\n?\nEvaluate the product Qn\nkD2.1 \u0005 1=k2/.\nA.2\nBounding summations\nWe have many techniques at our disposal for bounding the summations that de-\nscribe the running times of algorithms. Here are some of the most frequently used\nmethods.\nMathematical induction\nThe most basic way to evaluate a series is to use mathematical induction. As an\nexample, let us prove that the arithmetic series Pn\nkD1 k evaluates to 1\n2n.nC1/. We\ncan easily verify this assertion for n D 1. We make the inductive assumption that\n1150\nAppendix A\nSummations\nit holds for n, and we prove that it holds for n C 1. We have\nnC1\nX\nkD1\nk\nD\nn\nX\nkD1\nk C .n C 1/\nD\n1\n2n.n C 1/ C .n C 1/\nD\n1\n2.n C 1/.n C 2/ :\nYou don’t always need to guess the exact value of a summation in order to use\nmathematical induction. Instead, you can use induction to prove a bound on a sum-\nmation. As an example, let us prove that the geometric series Pn\nkD0 3k is O.3n/.\nMore speciﬁcally, let us prove that Pn\nkD0 3k \u0002 c3n for some constant c. For the\ninitial condition n D 0, we have P0\nkD0 3k D 1 \u0002 c \u0003 1 as long as c \u0006 1. Assuming\nthat the bound holds for n, let us prove that it holds for n C 1. We have\nnC1\nX\nkD0\n3k\nD\nn\nX\nkD0\n3k C 3nC1\n\u0002\nc3n C 3nC1\n(by the inductive hypothesis)\nD\n\u00021\n3 C 1\nc\n\u0003\nc3nC1\n\u0002\nc3nC1\nas long as .1=3 C 1=c/ \u0002 1 or, equivalently, c \u0006 3=2. Thus, Pn\nkD0 3k D O.3n/,\nas we wished to show.\nWe have to be careful when we use asymptotic notation to prove bounds by in-\nduction. Consider the following fallacious proof that Pn\nkD1 k D O.n/. Certainly,\nP1\nkD1 k D O.1/. Assuming that the bound holds for n, we now prove it for n C 1:\nnC1\nX\nkD1\nk\nD\nn\nX\nkD1\nk C .n C 1/\nD\nO.n/ C .n C 1/",
    "parent_f23d9a56-896a-43a5-90c2-8907b913c130": "wrong!!\nD\nO.n C 1/ :\nThe bug in the argument is that the “constant” hidden by the “big-oh” grows with n\nand thus is not constant. We have not shown that the same constant works for all n.\nBounding the terms\nWe can sometimes obtain a good upper bound on a series by bounding each term\nof the series, and it often sufﬁces to use the largest term to bound the others. For\nA.2\nBounding summations\n1151\nexample, a quick upper bound on the arithmetic series (A.1) is\nn\nX\nkD1\nk\n\u0002\nn\nX\nkD1\nn\nD\nn2 :\nIn general, for a series Pn\nkD1 ak, if we let amax D max1\u0005k\u0005n ak, then\nn\nX\nkD1\nak \u0002 n \u0003 amax :\nThe technique of bounding each term in a series by the largest term is a weak\nmethod when the series can in fact be bounded by a geometric series. Given the\nseries Pn\nkD0 ak, suppose that akC1=ak \u0002 r for all k \u0006 0, where 0 < r < 1 is a\nconstant. We can bound the sum by an inﬁnite decreasing geometric series, since\nak \u0002 a0rk, and thus\nn\nX\nkD0\nak\n\u0002\n1\nX\nkD0\na0rk\nD\na0\n1\nX\nkD0\nrk\nD\na0\n1\n1 \u0005 r :\nWe can apply this method to bound the summation P1\nkD1.k=3k/. In order to\nstart the summation at k D 0, we rewrite it as P1\nkD0..k C 1/=3kC1/. The ﬁrst\nterm (a0) is 1=3, and the ratio (r) of consecutive terms is\n.k C 2/=3kC2\n.k C 1/=3kC1\nD\n1\n3 \u0003 k C 2\nk C 1\n\u0002\n2\n3\nfor all k \u0006 0. Thus, we have\n1\nX\nkD1\nk\n3k\nD\n1\nX\nkD0\nk C 1\n3kC1\n\u0002\n1\n3 \u0003\n1\n1 \u0005 2=3\nD\n1 :\n1152\nAppendix A\nSummations\nA common bug in applying this method is to show that the ratio of consecu-\ntive terms is less than 1 and then to assume that the summation is bounded by a\ngeometric series. An example is the inﬁnite harmonic series, which diverges since\n1\nX\nkD1\n1\nk\nD\nlim\nn!1\nn\nX\nkD1\n1\nk\nD\nlim\nn!1 ‚.lg n/\nD\n1 :\nThe ratio of the .kC1/st and kth terms in this series is k=.kC1/ < 1, but the series\nis not bounded by a decreasing geometric series. To bound a series by a geometric\nseries, we must show that there is an r < 1, which is a constant, such that the ratio\nof all pairs of consecutive terms never exceeds r. In the harmonic series, no such r",
    "parent_be754df1-7360-4cec-ae36-1f45a6a50a8f": "is not bounded by a decreasing geometric series. To bound a series by a geometric\nseries, we must show that there is an r < 1, which is a constant, such that the ratio\nof all pairs of consecutive terms never exceeds r. In the harmonic series, no such r\nexists because the ratio becomes arbitrarily close to 1.\nSplitting summations\nOne way to obtain bounds on a difﬁcult summation is to express the series as the\nsum of two or more series by partitioning the range of the index and then to bound\neach of the resulting series. For example, suppose we try to ﬁnd a lower bound\non the arithmetic series Pn\nkD1 k, which we have already seen has an upper bound\nof n2. We might attempt to bound each term in the summation by the smallest term,\nbut since that term is 1, we get a lower bound of n for the summation—far off from\nour upper bound of n2.\nWe can obtain a better lower bound by ﬁrst splitting the summation. Assume for\nconvenience that n is even. We have\nn\nX\nkD1\nk\nD\nn=2\nX\nkD1\nk C\nn\nX\nkDn=2C1\nk\n\u0006\nn=2\nX\nkD1\n0 C\nn\nX\nkDn=2C1\n.n=2/\nD\n.n=2/2\nD\n\u0004.n2/ ;\nwhich is an asymptotically tight bound, since Pn\nkD1 k D O.n2/.\nFor a summation arising from the analysis of an algorithm, we can often split\nthe summation and ignore a constant number of the initial terms. Generally, this\ntechnique applies when each term ak in a summation Pn\nkD0 ak is independent of n.\nA.2\nBounding summations\n1153\nThen for any constant k0 > 0, we can write\nn\nX\nkD0\nak\nD\nk0\u00031\nX\nkD0\nak C\nn\nX\nkDk0\nak\nD\n‚.1/ C\nn\nX\nkDk0\nak ;\nsince the initial terms of the summation are all constant and there are a constant\nnumber of them. We can then use other methods to bound Pn\nkDk0 ak. This tech-\nnique applies to inﬁnite summations as well. For example, to ﬁnd an asymptotic\nupper bound on\n1\nX\nkD0\nk2\n2k ;\nwe observe that the ratio of consecutive terms is\n.k C 1/2=2kC1\nk2=2k\nD\n.k C 1/2\n2k2\n\u0002\n8\n9\nif k \u0006 3. Thus, the summation can be split into\n1\nX\nkD0\nk2\n2k\nD\n2\nX\nkD0\nk2\n2k C\n1\nX\nkD3\nk2\n2k\n\u0002\n2\nX\nkD0\nk2\n2k C 9\n8\n1\nX\nkD0\n\u00028\n9\n\u0003k\nD\nO.1/ ;",
    "parent_42c00f82-5fe2-4fab-9d42-480b0d2089f6": "upper bound on\n1\nX\nkD0\nk2\n2k ;\nwe observe that the ratio of consecutive terms is\n.k C 1/2=2kC1\nk2=2k\nD\n.k C 1/2\n2k2\n\u0002\n8\n9\nif k \u0006 3. Thus, the summation can be split into\n1\nX\nkD0\nk2\n2k\nD\n2\nX\nkD0\nk2\n2k C\n1\nX\nkD3\nk2\n2k\n\u0002\n2\nX\nkD0\nk2\n2k C 9\n8\n1\nX\nkD0\n\u00028\n9\n\u0003k\nD\nO.1/ ;\nsince the ﬁrst summation has a constant number of terms and the second summation\nis a decreasing geometric series.\nThe technique of splitting summations can help us determine asymptotic bounds\nin much more difﬁcult situations. For example, we can obtain a bound of O.lg n/\non the harmonic series (A.7):\nHn D\nn\nX\nkD1\n1\nk :\nWe do so by splitting the range 1 to n into blg nc C 1 pieces and upper-bounding\nthe contribution of each piece by 1. For i D 0; 1; : : : ; blg nc, the ith piece consists\n1154\nAppendix A\nSummations\nof the terms starting at 1=2i and going up to but not including 1=2iC1. The last\npiece might contain terms not in the original harmonic series, and thus we have\nn\nX\nkD1\n1\nk\n\u0002\nblg nc\nX\niD0\n2i\u00031\nX\njD0\n1\n2i C j\n\u0002\nblg nc\nX\niD0\n2i\u00031\nX\njD0\n1\n2i\nD\nblg nc\nX\niD0\n1\n\u0002\nlg n C 1 :\n(A.10)\nApproximation by integrals\nWhen a summation has the form Pn\nkDm f .k/, where f .k/ is a monotonically in-\ncreasing function, we can approximate it by integrals:\nZ n\nm\u00031\nf .x/ dx \u0002\nn\nX\nkDm\nf .k/ \u0002\nZ nC1\nm\nf .x/ dx :\n(A.11)\nFigure A.1 justiﬁes this approximation. The summation is represented as the area\nof the rectangles in the ﬁgure, and the integral is the shaded region under the curve.\nWhen f .k/ is a monotonically decreasing function, we can use a similar method\nto provide the bounds\nZ nC1\nm\nf .x/ dx \u0002\nn\nX\nkDm\nf .k/ \u0002\nZ n\nm\u00031\nf .x/ dx :\n(A.12)\nThe integral approximation (A.12) gives a tight estimate for the nth harmonic\nnumber. For a lower bound, we obtain\nn\nX\nkD1\n1\nk\n\u0006\nZ nC1\n1\ndx\nx\nD\nln.n C 1/ :\n(A.13)\nFor the upper bound, we derive the inequality\nn\nX\nkD2\n1\nk\n\u0002\nZ n\n1\ndx\nx\nD\nln n ;\nA.2\nBounding summations\n1155\nn+1\nn–1\nn–2\nm+2\nm\nm –1\nf (m)\nf (m+1)\nf (m+2)\nf (n–2)\nf (n–1)\nf (n)\nf (x)\nx\n…\n…\nn\n…\n…\n(a)\nm+1\nn+1\nn–1\nn–2\nm+2\nm\nm –1",
    "parent_6b8eb2bd-1d57-4eb5-aaa3-7cb2dd08ed38": "n\nX\nkD1\n1\nk\n\u0006\nZ nC1\n1\ndx\nx\nD\nln.n C 1/ :\n(A.13)\nFor the upper bound, we derive the inequality\nn\nX\nkD2\n1\nk\n\u0002\nZ n\n1\ndx\nx\nD\nln n ;\nA.2\nBounding summations\n1155\nn+1\nn–1\nn–2\nm+2\nm\nm –1\nf (m)\nf (m+1)\nf (m+2)\nf (n–2)\nf (n–1)\nf (n)\nf (x)\nx\n…\n…\nn\n…\n…\n(a)\nm+1\nn+1\nn–1\nn–2\nm+2\nm\nm –1\nf (m)\nf (m+1)\nf (m+2)\nf (n–2)\nf (n–1)\nf (n)\nf (x)\nx\n…\n…\nn\n…\n…\n(b)\nm+1\nFigure A.1\nApproximation of Pn\nkDm f .k/ by integrals. The area of each rectangle is shown\nwithin the rectangle, and the total rectangle area represents the value of the summation. The in-\ntegral is represented by the shaded area under the curve.\nBy comparing areas in (a), we get\nR n\nm\u00031 f .x/dx \u0002 Pn\nkDm f .k/, and then by shifting the rectangles one unit to the right, we get\nPn\nkDm f .k/ \u0002\nR nC1\nm\nf .x/dx in (b).\n1156\nAppendix A\nSummations\nwhich yields the bound\nn\nX\nkD1\n1\nk \u0002 ln n C 1 :\n(A.14)\nExercises\nA.2-1\nShow that Pn\nkD1 1=k2 is bounded above by a constant.\nA.2-2\nFind an asymptotic upper bound on the summation\nblg nc\nX\nkD0\n˙\nn=2k\u000e\n:\nA.2-3\nShow that the nth harmonic number is \u0004.lg n/ by splitting the summation.\nA.2-4\nApproximate Pn\nkD1 k3 with an integral.\nA.2-5\nWhy didn’t we use the integral approximation (A.12) directly on Pn\nkD1 1=k to\nobtain an upper bound on the nth harmonic number?\nProblems\nA-1\nBounding summations\nGive asymptotically tight bounds on the following summations. Assume that r \u0006 0\nand s \u0006 0 are constants.\na.\nn\nX\nkD1\nkr.\nb.\nn\nX\nkD1\nlgs k.\nNotes for Appendix A\n1157\nc.\nn\nX\nkD1\nkr lgs k.\nAppendix notes\nKnuth [209] provides an excellent reference for the material presented here. You\ncan ﬁnd basic properties of series in any good calculus book, such as Apostol [18]\nor Thomas et al. [334].\nB\nSets, Etc.\nMany chapters of this book touch on the elements of discrete mathematics. This\nappendix reviews more completely the notations, deﬁnitions, and elementary prop-\nerties of sets, relations, functions, graphs, and trees. If you are already well versed\nin this material, you can probably just skim this chapter.\nB.1\nSets",
    "parent_46beb883-5f21-4336-8200-993c700401e7": "appendix reviews more completely the notations, deﬁnitions, and elementary prop-\nerties of sets, relations, functions, graphs, and trees. If you are already well versed\nin this material, you can probably just skim this chapter.\nB.1\nSets\nA set is a collection of distinguishable objects, called its members or elements. If\nan object x is a member of a set S, we write x 2 S (read “x is a member of S”\nor, more brieﬂy, “x is in S”). If x is not a member of S, we write x 62 S. We\ncan describe a set by explicitly listing its members as a list inside braces. For\nexample, we can deﬁne a set S to contain precisely the numbers 1, 2, and 3 by\nwriting S D f1; 2; 3g. Since 2 is a member of the set S, we can write 2 2 S, and\nsince 4 is not a member, we have 4 … S. A set cannot contain the same object more\nthan once,1 and its elements are not ordered. Two sets A and B are equal, written\nA D B, if they contain the same elements. For example, f1; 2; 3; 1g D f1; 2; 3g D\nf3; 2; 1g.\nWe adopt special notations for frequently encountered sets:\n\u0002\n; denotes the empty set, that is, the set containing no members.\n\u0002\nZ denotes the set of integers, that is, the set f: : : ; \u00052; \u00051; 0; 1; 2; : : :g.\n\u0002\nR denotes the set of real numbers.\n\u0002\nN denotes the set of natural numbers, that is, the set f0; 1; 2; : : :g.2\n1A variation of a set, which can contain the same object more than once, is called a multiset.\n2Some authors start the natural numbers with 1 instead of 0. The modern trend seems to be to start\nwith 0.\nB.1\nSets\n1159\nIf all the elements of a set A are contained in a set B, that is, if x 2 A implies\nx 2 B, then we write A \u0007 B and say that A is a subset of B. A set A is a\nproper subset of B, written A \r B, if A \u0007 B but A ¤ B. (Some authors use the\nsymbol “\r” to denote the ordinary subset relation, rather than the proper-subset\nrelation.) For any set A, we have A \u0007 A. For two sets A and B, we have A D B\nif and only if A \u0007 B and B \u0007 A. For any three sets A, B, and C, if A \u0007 B",
    "parent_caf8ad88-e12e-4fdb-8c42-18bb17432754": "symbol “\r” to denote the ordinary subset relation, rather than the proper-subset\nrelation.) For any set A, we have A \u0007 A. For two sets A and B, we have A D B\nif and only if A \u0007 B and B \u0007 A. For any three sets A, B, and C, if A \u0007 B\nand B \u0007 C, then A \u0007 C. For any set A, we have ; \u0007 A.\nWe sometimes deﬁne sets in terms of other sets. Given a set A, we can deﬁne a\nset B \u0007 A by stating a property that distinguishes the elements of B. For example,\nwe can deﬁne the set of even integers by fx W x 2 Z and x=2 is an integerg. The\ncolon in this notation is read “such that.” (Some authors use a vertical bar in place\nof the colon.)\nGiven two sets A and B, we can also deﬁne new sets by applying set operations:\n\u0002\nThe intersection of sets A and B is the set\nA \\ B D fx W x 2 A and x 2 Bg :\n\u0002\nThe union of sets A and B is the set\nA [ B D fx W x 2 A or x 2 Bg :\n\u0002\nThe difference between two sets A and B is the set\nA \u0005 B D fx W x 2 A and x … Bg :\nSet operations obey the following laws:\nEmpty set laws:\nA \\ ;\nD\n; ;\nA [ ;\nD\nA :\nIdempotency laws:\nA \\ A\nD\nA ;\nA [ A\nD\nA :\nCommutative laws:\nA \\ B\nD\nB \\ A ;\nA [ B\nD\nB [ A :\n1160\nAppendix B\nSets, Etc.\nA\nA\nA\nA\nA\nA\nB\nB\nB\nB\nB\n\u0005\n\u0005\n.B \\ C/\n[\n[\nD\nD\nD\nD\nA \u0005 .B \\ C/\n.A \u0005 B/\n.A \u0005 C/\nC\nC\nC\nC\nC\nFigure B.1\nA Venn diagram illustrating the ﬁrst of DeMorgan’s laws (B.2). Each of the sets A, B,\nand C is represented as a circle.\nAssociative laws:\nA \\ .B \\ C/\nD\n.A \\ B/ \\ C ;\nA [ .B [ C/\nD\n.A [ B/ [ C :\nDistributive laws:\nA \\ .B [ C/\nD\n.A \\ B/ [ .A \\ C/ ;\nA [ .B \\ C/\nD\n.A [ B/ \\ .A [ C/ :\n(B.1)\nAbsorption laws:\nA \\ .A [ B/\nD\nA ;\nA [ .A \\ B/\nD\nA :\nDeMorgan’s laws:\nA \u0005 .B \\ C/\nD\n.A \u0005 B/ [ .A \u0005 C/ ;\nA \u0005 .B [ C/\nD\n.A \u0005 B/ \\ .A \u0005 C/ :\n(B.2)\nFigure B.1 illustrates the ﬁrst of DeMorgan’s laws, using a Venn diagram: a graph-\nical picture in which sets are represented as regions of the plane.\nOften, all the sets under consideration are subsets of some larger set U called the\nuniverse. For example, if we are considering various sets made up only of integers,",
    "parent_fa22f24b-d052-4dc3-ba13-a05d77eea3c6": "ical picture in which sets are represented as regions of the plane.\nOften, all the sets under consideration are subsets of some larger set U called the\nuniverse. For example, if we are considering various sets made up only of integers,\nthe set Z of integers is an appropriate universe. Given a universe U , we deﬁne the\ncomplement of a set A as A D U \u0005 A D fx W x 2 U and x 62 Ag. For any set\nA \u0007 U , we have the following laws:\nA\nD\nA ;\nA \\ A\nD\n; ;\nA [ A\nD\nU :\nB.1\nSets\n1161\nWe can rewrite DeMorgan’s laws (B.2) with set complements. For any two sets\nB; C \u0007 U , we have\nB \\ C\nD\nB [ C ;\nB [ C\nD\nB \\ C :\nTwo sets A and B are disjoint if they have no elements in common, that is, if\nA\\B D ;. A collection S D fSig of nonempty sets forms a partition of a set S if\n\u0002\nthe sets are pairwise disjoint, that is, Si; Sj 2 S and i ¤ j imply Si \\ Sj D ;,\nand\n\u0002\ntheir union is S, that is,\nS D\n[\nSi 2S\nSi :\nIn other words, S forms a partition of S if each element of S appears in exactly\none Si 2 S.\nThe number of elements in a set is the cardinality (or size) of the set, denoted jSj.\nTwo sets have the same cardinality if their elements can be put into a one-to-one\ncorrespondence. The cardinality of the empty set is j;j D 0. If the cardinality of a\nset is a natural number, we say the set is ﬁnite; otherwise, it is inﬁnite. An inﬁnite\nset that can be put into a one-to-one correspondence with the natural numbers N is\ncountably inﬁnite; otherwise, it is uncountable. For example, the integers Z are\ncountable, but the reals R are uncountable.\nFor any two ﬁnite sets A and B, we have the identity\njA [ Bj D jAj C jBj \u0005 jA \\ Bj ;\n(B.3)\nfrom which we can conclude that\njA [ Bj \u0002 jAj C jBj :\nIf A and B are disjoint, then jA \\ Bj D 0 and thus jA [ Bj D jAj C jBj. If\nA \u0007 B, then jAj \u0002 jBj.\nA ﬁnite set of n elements is sometimes called an n-set. A 1-set is called a\nsingleton. A subset of k elements of a set is sometimes called a k-subset.",
    "parent_4f4edfc6-0b76-4cf3-aa14-f9313b594a43": "jA [ Bj \u0002 jAj C jBj :\nIf A and B are disjoint, then jA \\ Bj D 0 and thus jA [ Bj D jAj C jBj. If\nA \u0007 B, then jAj \u0002 jBj.\nA ﬁnite set of n elements is sometimes called an n-set. A 1-set is called a\nsingleton. A subset of k elements of a set is sometimes called a k-subset.\nWe denote the set of all subsets of a set S, including the empty set and S itself,\nby 2S; we call 2S the power set of S. For example, 2fa;bg D f;; fag ; fbg ; fa; bgg.\nThe power set of a ﬁnite set S has cardinality 2jSj (see Exercise B.1-5).\nWe sometimes care about setlike structures in which the elements are ordered.\nAn ordered pair of two elements a and b is denoted .a; b/ and is deﬁned formally\nas the set .a; b/ D fa; fa; bgg. Thus, the ordered pair .a; b/ is not the same as the\nordered pair .b; a/.\n1162\nAppendix B\nSets, Etc.\nThe Cartesian product of two sets A and B, denoted A \t B, is the set of all\nordered pairs such that the ﬁrst element of the pair is an element of A and the\nsecond is an element of B. More formally,\nA \t B D f.a; b/ W a 2 A and b 2 Bg :\nFor example, fa; bg\tfa; b; cg D f.a; a/; .a; b/; .a; c/; .b; a/; .b; b/; .b; c/g. When\nA and B are ﬁnite sets, the cardinality of their Cartesian product is\njA \t Bj D jAj \u0003 jBj :\n(B.4)\nThe Cartesian product of n sets A1; A2; : : : ; An is the set of n-tuples\nA1 \t A2 \t \u0003 \u0003 \u0003 \t An D f.a1; a2; : : : ; an/ W ai 2 Ai for i D 1; 2; : : : ; ng ;\nwhose cardinality is\njA1 \t A2 \t \u0003 \u0003 \u0003 \t Anj D jA1j \u0003 jA2j \u0003 \u0003 \u0003 jAnj\nif all sets are ﬁnite. We denote an n-fold Cartesian product over a single set A by\nthe set\nAn D A \t A \t \u0003 \u0003 \u0003 \t A ;\nwhose cardinality is jAnj D jAjn if A is ﬁnite. We can also view an n-tuple as a\nﬁnite sequence of length n (see page 1166).\nExercises\nB.1-1\nDraw Venn diagrams that illustrate the ﬁrst of the distributive laws (B.1).\nB.1-2\nProve the generalization of DeMorgan’s laws to any ﬁnite collection of sets:\nA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ An\nD\nA1 [ A2 [ \u0003 \u0003 \u0003 [ An ;\nA1 [ A2 [ \u0003 \u0003 \u0003 [ An\nD\nA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ An :\nB.2\nRelations\n1163\nB.1-3\n?",
    "parent_53dbd94d-985b-44d9-9a4c-14da85841f69": "Exercises\nB.1-1\nDraw Venn diagrams that illustrate the ﬁrst of the distributive laws (B.1).\nB.1-2\nProve the generalization of DeMorgan’s laws to any ﬁnite collection of sets:\nA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ An\nD\nA1 [ A2 [ \u0003 \u0003 \u0003 [ An ;\nA1 [ A2 [ \u0003 \u0003 \u0003 [ An\nD\nA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ An :\nB.2\nRelations\n1163\nB.1-3\n?\nProve the generalization of equation (B.3), which is called the principle of inclu-\nsion and exclusion:\njA1 [ A2 [ \u0003 \u0003 \u0003 [ Anj D\njA1j C jA2j C \u0003 \u0003 \u0003 C jAnj\n\u0005 jA1 \\ A2j \u0005 jA1 \\ A3j \u0005 \u0003 \u0003 \u0003\n(all pairs)\nC jA1 \\ A2 \\ A3j C \u0003 \u0003 \u0003\n(all triples)\n:::\nC .\u00051/n\u00031 jA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Anj :\nB.1-4\nShow that the set of odd natural numbers is countable.\nB.1-5\nShow that for any ﬁnite set S, the power set 2S has 2jSj elements (that is, there\nare 2jSj distinct subsets of S).\nB.1-6\nGive an inductive deﬁnition for an n-tuple by extending the set-theoretic deﬁnition\nfor an ordered pair.\nB.2\nRelations\nA binary relation R on two sets A and B is a subset of the Cartesian product A\tB.\nIf .a; b/ 2 R, we sometimes write a R b. When we say that R is a binary relation\non a set A, we mean that R is a subset of A \t A. For example, the “less than”\nrelation on the natural numbers is the set f.a; b/ W a; b 2 N and a < bg. An n-ary\nrelation on sets A1; A2; : : : ; An is a subset of A1 \t A2 \t \u0003 \u0003 \u0003 \t An.\nA binary relation R \u0007 A \t A is reﬂexive if\na R a\nfor all a 2 A. For example, “D” and “\u0002” are reﬂexive relations on N, but “<” is\nnot. The relation R is symmetric if\na R b implies b R a\nfor all a; b 2 A. For example, “D” is symmetric, but “<” and “\u0002” are not. The\nrelation R is transitive if\na R b and b R c imply a R c\n1164\nAppendix B\nSets, Etc.\nfor all a; b; c 2 A. For example, the relations “<,” “\u0002,” and “D” are transitive, but\nthe relation R D f.a; b/ W a; b 2 N and a D b \u0005 1g is not, since 3 R 4 and 4 R 5\ndo not imply 3 R 5.\nA relation that is reﬂexive, symmetric, and transitive is an equivalence relation.\nFor example, “D” is an equivalence relation on the natural numbers, but “<” is not.",
    "parent_b8b445d8-092f-4f19-a752-74c0c18dc9b1": "the relation R D f.a; b/ W a; b 2 N and a D b \u0005 1g is not, since 3 R 4 and 4 R 5\ndo not imply 3 R 5.\nA relation that is reﬂexive, symmetric, and transitive is an equivalence relation.\nFor example, “D” is an equivalence relation on the natural numbers, but “<” is not.\nIf R is an equivalence relation on a set A, then for a 2 A, the equivalence class\nof a is the set Œa\u0002 D fb 2 A W a R bg, that is, the set of all elements equivalent to a.\nFor example, if we deﬁne R D f.a; b/ W a; b 2 N and a C b is an even numberg,\nthen R is an equivalence relation, since a C a is even (reﬂexive), a C b is even\nimplies b C a is even (symmetric), and a C b is even and b C c is even imply\na C c is even (transitive). The equivalence class of 4 is Œ4\u0002 D f0; 2; 4; 6; : : :g, and\nthe equivalence class of 3 is Œ3\u0002 D f1; 3; 5; 7; : : :g. A basic theorem of equivalence\nclasses is the following.\nTheorem B.1 (An equivalence relation is the same as a partition)\nThe equivalence classes of any equivalence relation R on a set A form a partition\nof A, and any partition of A determines an equivalence relation on A for which the\nsets in the partition are the equivalence classes.\nProof\nFor the ﬁrst part of the proof, we must show that the equivalence classes\nof R are nonempty, pairwise-disjoint sets whose union is A. Because R is reﬂex-\nive, a 2 Œa\u0002, and so the equivalence classes are nonempty; moreover, since every\nelement a 2 A belongs to the equivalence class Œa\u0002, the union of the equivalence\nclasses is A. It remains to show that the equivalence classes are pairwise disjoint,\nthat is, if two equivalence classes Œa\u0002 and Œb\u0002 have an element c in common, then\nthey are in fact the same set. Suppose that a R c and b R c. By symmetry, c R b,\nand by transitivity, a R b. Thus, for any arbitrary element x 2 Œa\u0002, we have x R a\nand, by transitivity, x R b, and thus Œa\u0002 \u0007 Œb\u0002. Similarly, Œb\u0002 \u0007 Œa\u0002, and thus\nŒa\u0002 D Œb\u0002.\nFor the second part of the proof, let A D fAig be a partition of A, and deﬁne",
    "parent_00f613da-9cad-4d32-a532-f62294ab95b1": "and by transitivity, a R b. Thus, for any arbitrary element x 2 Œa\u0002, we have x R a\nand, by transitivity, x R b, and thus Œa\u0002 \u0007 Œb\u0002. Similarly, Œb\u0002 \u0007 Œa\u0002, and thus\nŒa\u0002 D Œb\u0002.\nFor the second part of the proof, let A D fAig be a partition of A, and deﬁne\nR D f.a; b/ W there exists i such that a 2 Ai and b 2 Aig. We claim that R is an\nequivalence relation on A. Reﬂexivity holds, since a 2 Ai implies a R a. Symme-\ntry holds, because if a R b, then a and b are in the same set Ai, and hence b R a.\nIf a R b and b R c, then all three elements are in the same set Ai, and thus a R c\nand transitivity holds. To see that the sets in the partition are the equivalence\nclasses of R, observe that if a 2 Ai, then x 2 Œa\u0002 implies x 2 Ai, and x 2 Ai\nimplies x 2 Œa\u0002.\nA binary relation R on a set A is antisymmetric if\na R b and b R a imply a D b :\nB.2\nRelations\n1165\nFor example, the “\u0002” relation on the natural numbers is antisymmetric, since a \u0002 b\nand b \u0002 a imply a D b. A relation that is reﬂexive, antisymmetric, and transitive\nis a partial order, and we call a set on which a partial order is deﬁned a partially\nordered set. For example, the relation “is a descendant of” is a partial order on the\nset of all people (if we view individuals as being their own descendants).\nIn a partially ordered set A, there may be no single “maximum” element a such\nthat b R a for all b 2 A. Instead, the set may contain several maximal elements a\nsuch that for no b 2 A, where b ¤ a, is it the case that a R b. For example, a\ncollection of different-sized boxes may contain several maximal boxes that don’t\nﬁt inside any other box, yet it has no single “maximum” box into which any other\nbox will ﬁt.3\nA relation R on a set A is a total relation if for all a; b 2 A, we have a R b\nor b R a (or both), that is, if every pairing of elements of A is related by R. A\npartial order that is also a total relation is a total order or linear order. For example,",
    "parent_84e02ab2-150b-478c-befd-cc87e738c0c9": "box will ﬁt.3\nA relation R on a set A is a total relation if for all a; b 2 A, we have a R b\nor b R a (or both), that is, if every pairing of elements of A is related by R. A\npartial order that is also a total relation is a total order or linear order. For example,\nthe relation “\u0002” is a total order on the natural numbers, but the “is a descendant\nof” relation is not a total order on the set of all people, since there are individuals\nneither of whom is descended from the other. A total relation that is transitive, but\nnot necessarily reﬂexive and antisymmetric, is a total preorder.\nExercises\nB.2-1\nProve that the subset relation “\u0007” on all subsets of Z is a partial order but not a\ntotal order.\nB.2-2\nShow that for any positive integer n, the relation “equivalent modulo n” is an equiv-\nalence relation on the integers. (We say that a \b b .mod n/ if there exists an\ninteger q such that a \u0005 b D qn.) Into what equivalence classes does this relation\npartition the integers?\nB.2-3\nGive examples of relations that are\na. reﬂexive and symmetric but not transitive,\nb. reﬂexive and transitive but not symmetric,\nc. symmetric and transitive but not reﬂexive.\n3To be precise, in order for the “ﬁt inside” relation to be a partial order, we need to view a box as\nﬁtting inside itself.\n1166\nAppendix B\nSets, Etc.\nB.2-4\nLet S be a ﬁnite set, and let R be an equivalence relation on S \t S. Show that if\nin addition R is antisymmetric, then the equivalence classes of S with respect to R\nare singletons.\nB.2-5\nProfessor Narcissus claims that if a relation R is symmetric and transitive, then it is\nalso reﬂexive. He offers the following proof. By symmetry, a R b implies b R a.\nTransitivity, therefore, implies a R a. Is the professor correct?\nB.3\nFunctions\nGiven two sets A and B, a function f is a binary relation on A and B such that\nfor all a 2 A, there exists precisely one b 2 B such that .a; b/ 2 f . The set A is\ncalled the domain of f , and the set B is called the codomain of f . We sometimes",
    "parent_aa60920a-be8d-43a3-95b2-6123c0dc8404": "B.3\nFunctions\nGiven two sets A and B, a function f is a binary relation on A and B such that\nfor all a 2 A, there exists precisely one b 2 B such that .a; b/ 2 f . The set A is\ncalled the domain of f , and the set B is called the codomain of f . We sometimes\nwrite f W A ! B; and if .a; b/ 2 f , we write b D f .a/, since b is uniquely\ndetermined by the choice of a.\nIntuitively, the function f assigns an element of B to each element of A. No\nelement of A is assigned two different elements of B, but the same element of B\ncan be assigned to two different elements of A. For example, the binary relation\nf D f.a; b/ W a; b 2 N and b D a mod 2g\nis a function f W N ! f0; 1g, since for each natural number a, there is exactly one\nvalue b in f0; 1g such that b D a mod 2. For this example, 0 D f .0/, 1 D f .1/,\n0 D f .2/, etc. In contrast, the binary relation\ng D f.a; b/ W a; b 2 N and a C b is eveng\nis not a function, since .1; 3/ and .1; 5/ are both in g, and thus for the choice a D 1,\nthere is not precisely one b such that .a; b/ 2 g.\nGiven a function f W A ! B, if b D f .a/, we say that a is the argument of f\nand that b is the value of f at a. We can deﬁne a function by stating its value for\nevery element of its domain. For example, we might deﬁne f .n/ D 2n for n 2 N,\nwhich means f D f.n; 2n/ W n 2 Ng. Two functions f and g are equal if they\nhave the same domain and codomain and if, for all a in the domain, f .a/ D g.a/.\nA ﬁnite sequence of length n is a function f whose domain is the set of n\nintegers f0; 1; : : : ; n \u0005 1g. We often denote a ﬁnite sequence by listing its values:\nhf .0/; f .1/; : : : ; f .n \u0005 1/i. An inﬁnite sequence is a function whose domain is\nthe set N of natural numbers. For example, the Fibonacci sequence, deﬁned by\nrecurrence (3.22), is the inﬁnite sequence h0; 1; 1; 2; 3; 5; 8; 13; 21; : : :i.\nB.3\nFunctions\n1167\nWhen the domain of a function f is a Cartesian product, we often omit the extra",
    "parent_dfb1ad71-d804-42cc-a7f3-823a1af3605d": "the set N of natural numbers. For example, the Fibonacci sequence, deﬁned by\nrecurrence (3.22), is the inﬁnite sequence h0; 1; 1; 2; 3; 5; 8; 13; 21; : : :i.\nB.3\nFunctions\n1167\nWhen the domain of a function f is a Cartesian product, we often omit the extra\nparentheses surrounding the argument of f . For example, if we had a function\nf W A1 \t A2 \t \u0003 \u0003 \u0003 \t An ! B, we would write b D f .a1; a2; : : : ; an/ instead\nof b D f ..a1; a2; : : : ; an//. We also call each ai an argument to the function f ,\nthough technically the (single) argument to f is the n-tuple .a1; a2; : : : ; an/.\nIf f W A ! B is a function and b D f .a/, then we sometimes say that b is the\nimage of a under f . The image of a set A0 \u0007 A under f is deﬁned by\nf .A0/ D fb 2 B W b D f .a/ for some a 2 A0g :\nThe range of f is the image of its domain, that is, f .A/. For example, the range\nof the function f W N ! N deﬁned by f .n/ D 2n is f .N/ D fm W m D 2n for\nsome n 2 Ng, in other words, the set of nonnegative even integers.\nA function is a surjection if its range is its codomain. For example, the function\nf .n/ D bn=2c is a surjective function from N to N, since every element in N\nappears as the value of f for some argument. In contrast, the function f .n/ D 2n\nis not a surjective function from N to N, since no argument to f can produce 3 as a\nvalue. The function f .n/ D 2n is, however, a surjective function from the natural\nnumbers to the even numbers. A surjection f W A ! B is sometimes described as\nmapping A onto B. When we say that f is onto, we mean that it is surjective.\nA function f W A ! B is an injection if distinct arguments to f produce\ndistinct values, that is, if a ¤ a0 implies f .a/ ¤ f .a0/. For example, the function\nf .n/ D 2n is an injective function from N to N, since each even number b is the\nimage under f of at most one element of the domain, namely b=2. The function\nf .n/ D bn=2c is not injective, since the value 1 is produced by two arguments: 2",
    "parent_7b58b864-77b2-4581-867e-ad265c66399b": "f .n/ D 2n is an injective function from N to N, since each even number b is the\nimage under f of at most one element of the domain, namely b=2. The function\nf .n/ D bn=2c is not injective, since the value 1 is produced by two arguments: 2\nand 3. An injection is sometimes called a one-to-one function.\nA function f W A ! B is a bijection if it is injective and surjective. For example,\nthe function f .n/ D .\u00051/n dn=2e is a bijection from N to Z:\n0\n!\n0 ;\n1\n!\n\u00051 ;\n2\n!\n1 ;\n3\n!\n\u00052 ;\n4\n!\n2 ;\n:::\nThe function is injective, since no element of Z is the image of more than one\nelement of N. It is surjective, since every element of Z appears as the image of\nsome element of N. Hence, the function is bijective. A bijection is sometimes\ncalled a one-to-one correspondence, since it pairs elements in the domain and\ncodomain. A bijection from a set A to itself is sometimes called a permutation.\nWhen a function f is bijective, we deﬁne its inverse f \u00031 as\nf \u00031.b/ D a if and only if f .a/ D b :\n1168\nAppendix B\nSets, Etc.\nFor example, the inverse of the function f .n/ D .\u00051/n dn=2e is\nf \u00031.m/ D\n(\n2m\nif m \u0006 0 ;\n\u00052m \u0005 1\nif m < 0 :\nExercises\nB.3-1\nLet A and B be ﬁnite sets, and let f W A ! B be a function. Show that\na. if f is injective, then jAj \u0002 jBj;\nb. if f is surjective, then jAj \u0006 jBj.\nB.3-2\nIs the function f .x/ D x C 1 bijective when the domain and the codomain are N?\nIs it bijective when the domain and the codomain are Z?\nB.3-3\nGive a natural deﬁnition for the inverse of a binary relation such that if a relation\nis in fact a bijective function, its relational inverse is its functional inverse.\nB.3-4\n?\nGive a bijection from Z to Z \t Z.\nB.4\nGraphs\nThis section presents two kinds of graphs: directed and undirected. Certain def-\ninitions in the literature differ from those given here, but for the most part, the\ndifferences are slight. Section 22.1 shows how we can represent graphs in com-\nputer memory.\nA directed graph (or digraph) G is a pair .V; E/, where V is a ﬁnite set and E",
    "parent_64d8def9-f14a-4590-b9b0-4505b2d5155f": "initions in the literature differ from those given here, but for the most part, the\ndifferences are slight. Section 22.1 shows how we can represent graphs in com-\nputer memory.\nA directed graph (or digraph) G is a pair .V; E/, where V is a ﬁnite set and E\nis a binary relation on V . The set V is called the vertex set of G, and its elements\nare called vertices (singular: vertex). The set E is called the edge set of G, and its\nelements are called edges. Figure B.2(a) is a pictorial representation of a directed\ngraph on the vertex set f1; 2; 3; 4; 5; 6g. Vertices are represented by circles in the\nﬁgure, and edges are represented by arrows. Note that self-loops—edges from a\nvertex to itself—are possible.\nIn an undirected graph G D .V; E/, the edge set E consists of unordered\npairs of vertices, rather than ordered pairs. That is, an edge is a set fu; \u0003g, where\nB.4\nGraphs\n1169\n1\n2\n3\n4\n5\n6\n(a)\n1\n2\n3\n4\n5\n6\n(b)\n1\n2\n3\n6\n(c)\nFigure B.2\nDirected and undirected graphs.\n(a) A directed graph G D .V; E/, where V D\nf1; 2; 3; 4; 5; 6g and E D f.1; 2/; .2; 2/; .2; 4/; .2; 5/; .4; 1/; .4; 5/; .5; 4/; .6; 3/g. The edge .2; 2/\nis a self-loop.\n(b) An undirected graph G D .V; E/, where V\nD f1; 2; 3; 4; 5; 6g and E D\nf.1; 2/; .1; 5/; .2; 5/; .3; 6/g. The vertex 4 is isolated. (c) The subgraph of the graph in part (a)\ninduced by the vertex set f1; 2; 3; 6g.\nu; \u0003 2 V and u ¤ \u0003. By convention, we use the notation .u; \u0003/ for an edge, rather\nthan the set notation fu; \u0003g, and we consider .u; \u0003/ and .\u0003; u/ to be the same edge.\nIn an undirected graph, self-loops are forbidden, and so every edge consists of two\ndistinct vertices. Figure B.2(b) is a pictorial representation of an undirected graph\non the vertex set f1; 2; 3; 4; 5; 6g.\nMany deﬁnitions for directed and undirected graphs are the same, although cer-\ntain terms have slightly different meanings in the two contexts. If .u; \u0003/ is an edge\nin a directed graph G D .V; E/, we say that .u; \u0003/ is incident from or leaves",
    "parent_a116285a-74ff-4a7d-a6e8-a3155dd9e9bb": "on the vertex set f1; 2; 3; 4; 5; 6g.\nMany deﬁnitions for directed and undirected graphs are the same, although cer-\ntain terms have slightly different meanings in the two contexts. If .u; \u0003/ is an edge\nin a directed graph G D .V; E/, we say that .u; \u0003/ is incident from or leaves\nvertex u and is incident to or enters vertex \u0003. For example, the edges leaving ver-\ntex 2 in Figure B.2(a) are .2; 2/, .2; 4/, and .2; 5/. The edges entering vertex 2 are\n.1; 2/ and .2; 2/. If .u; \u0003/ is an edge in an undirected graph G D .V; E/, we say\nthat .u; \u0003/ is incident on vertices u and \u0003. In Figure B.2(b), the edges incident on\nvertex 2 are .1; 2/ and .2; 5/.\nIf .u; \u0003/ is an edge in a graph G D .V; E/, we say that vertex \u0003 is adjacent to\nvertex u. When the graph is undirected, the adjacency relation is symmetric. When\nthe graph is directed, the adjacency relation is not necessarily symmetric. If \u0003 is\nadjacent to u in a directed graph, we sometimes write u ! \u0003. In parts (a) and (b)\nof Figure B.2, vertex 2 is adjacent to vertex 1, since the edge .1; 2/ belongs to both\ngraphs. Vertex 1 is not adjacent to vertex 2 in Figure B.2(a), since the edge .2; 1/\ndoes not belong to the graph.\nThe degree of a vertex in an undirected graph is the number of edges incident on\nit. For example, vertex 2 in Figure B.2(b) has degree 2. A vertex whose degree is 0,\nsuch as vertex 4 in Figure B.2(b), is isolated. In a directed graph, the out-degree\nof a vertex is the number of edges leaving it, and the in-degree of a vertex is the\nnumber of edges entering it. The degree of a vertex in a directed graph is its in-\n1170\nAppendix B\nSets, Etc.\ndegree plus its out-degree. Vertex 2 in Figure B.2(a) has in-degree 2, out-degree 3,\nand degree 5.\nA path of length k from a vertex u to a vertex u0 in a graph G D .V; E/\nis a sequence h\u00030; \u00031; \u00032; : : : ; \u0003ki of vertices such that u D \u00030, u0 D \u0003k, and\n.\u0003i\u00031; \u0003i/ 2 E for i D 1; 2; : : : ; k. The length of the path is the number of",
    "parent_b2b44b27-e669-4860-b94c-063412f090f7": "and degree 5.\nA path of length k from a vertex u to a vertex u0 in a graph G D .V; E/\nis a sequence h\u00030; \u00031; \u00032; : : : ; \u0003ki of vertices such that u D \u00030, u0 D \u0003k, and\n.\u0003i\u00031; \u0003i/ 2 E for i D 1; 2; : : : ; k. The length of the path is the number of\nedges in the path. The path contains the vertices \u00030; \u00031; : : : ; \u0003k and the edges\n.\u00030; \u00031/; .\u00031; \u00032/; : : : ; .\u0003k\u00031; \u0003k/. (There is always a 0-length path from u to u.) If\nthere is a path p from u to u0, we say that u0 is reachable from u via p, which we\nsometimes write as u\np; u0 if G is directed. A path is simple4 if all vertices in the\npath are distinct. In Figure B.2(a), the path h1; 2; 5; 4i is a simple path of length 3.\nThe path h2; 5; 4; 5i is not simple.\nA subpath of path p D h\u00030; \u00031; : : : ; \u0003ki is a contiguous subsequence of its ver-\ntices. That is, for any 0 \u0002 i \u0002 j \u0002 k, the subsequence of vertices h\u0003i; \u0003iC1; : : : ; \u0003ji\nis a subpath of p.\nIn a directed graph, a path h\u00030; \u00031; : : : ; \u0003ki forms a cycle if \u00030 D \u0003k and the\npath contains at least one edge. The cycle is simple if, in addition, \u00031; \u00032; : : : ; \u0003k\nare distinct. A self-loop is a cycle of length 1. Two paths h\u00030; \u00031; \u00032; : : : ; \u0003k\u00031; \u00030i\nand h\u00030\n0; \u00030\n1; \u00030\n2; : : : ; \u00030\nk\u00031; \u00030\n0i form the same cycle if there exists an integer j such\nthat \u00030\ni D \u0003.iCj/ mod k for i D 0; 1; : : : ; k \u0005 1. In Figure B.2(a), the path h1; 2; 4; 1i\nforms the same cycle as the paths h2; 4; 1; 2i and h4; 1; 2; 4i. This cycle is simple,\nbut the cycle h1; 2; 4; 5; 4; 1i is not. The cycle h2; 2i formed by the edge .2; 2/ is\na self-loop. A directed graph with no self-loops is simple. In an undirected graph,\na path h\u00030; \u00031; : : : ; \u0003ki forms a cycle if k \u0006 3 and \u00030 D \u0003k; the cycle is simple if\n\u00031; \u00032; : : : ; \u0003k are distinct. For example, in Figure B.2(b), the path h1; 2; 5; 1i is a\nsimple cycle. A graph with no cycles is acyclic.\nAn undirected graph is connected if every vertex is reachable from all other",
    "parent_ab7cab42-75a6-4014-8126-3fb51f03f142": "\u00031; \u00032; : : : ; \u0003k are distinct. For example, in Figure B.2(b), the path h1; 2; 5; 1i is a\nsimple cycle. A graph with no cycles is acyclic.\nAn undirected graph is connected if every vertex is reachable from all other\nvertices. The connected components of a graph are the equivalence classes of\nvertices under the “is reachable from” relation. The graph in Figure B.2(b) has\nthree connected components: f1; 2; 5g, f3; 6g, and f4g. Every vertex in f1; 2; 5g is\nreachable from every other vertex in f1; 2; 5g. An undirected graph is connected\nif it has exactly one connected component. The edges of a connected component\nare those that are incident on only the vertices of the component; in other words,\nedge .u; \u0003/ is an edge of a connected component only if both u and \u0003 are vertices\nof the component.\nA directed graph is strongly connected if every two vertices are reachable from\neach other. The strongly connected components of a directed graph are the equiv-\n4Some authors refer to what we call a path as a “walk” and to what we call a simple path as just a\n“path.” We use the terms “path” and “simple path” throughout this book in a manner consistent with\ntheir deﬁnitions.\nB.4\nGraphs\n1171\n1\n2\n3\n4\n5\n6\nu\nv\nw\nx\ny\nz\n(a)\n1\n2\n3\n4\n5\nu\nv\nw\nx\ny\n(b)\nG\nG′\nFigure B.3\n(a) A pair of isomorphic graphs. The vertices of the top graph are mapped to the\nvertices of the bottom graph by f .1/ D u; f .2/ D \u0003; f .3/ D w; f .4/ D x; f .5/ D y; f .6/ D ´.\n(b) Two graphs that are not isomorphic, since the top graph has a vertex of degree 4 and the bottom\ngraph does not.\nalence classes of vertices under the “are mutually reachable” relation. A directed\ngraph is strongly connected if it has only one strongly connected component. The\ngraph in Figure B.2(a) has three strongly connected components: f1; 2; 4; 5g, f3g,\nand f6g.\nAll pairs of vertices in f1; 2; 4; 5g are mutually reachable.\nThe ver-\ntices f3; 6g do not form a strongly connected component, since vertex 6 cannot\nbe reached from vertex 3.",
    "parent_564fc543-e04f-4407-a0b1-29c94b4b790a": "graph in Figure B.2(a) has three strongly connected components: f1; 2; 4; 5g, f3g,\nand f6g.\nAll pairs of vertices in f1; 2; 4; 5g are mutually reachable.\nThe ver-\ntices f3; 6g do not form a strongly connected component, since vertex 6 cannot\nbe reached from vertex 3.\nTwo graphs G D .V; E/ and G0 D .V 0; E0/ are isomorphic if there exists a\nbijection f W V ! V 0 such that .u; \u0003/ 2 E if and only if .f .u/; f .\u0003// 2 E0.\nIn other words, we can relabel the vertices of G to be vertices of G0, maintain-\ning the corresponding edges in G and G0. Figure B.3(a) shows a pair of iso-\nmorphic graphs G and G0 with respective vertex sets V D f1; 2; 3; 4; 5; 6g and\nV 0 D fu; \u0003; w; x; y; ´g. The mapping from V to V 0 given by f .1/ D u; f .2/ D \u0003;\nf .3/ D w; f .4/ D x; f .5/ D y; f .6/ D ´ provides the required bijective func-\ntion. The graphs in Figure B.3(b) are not isomorphic. Although both graphs have\n5 vertices and 7 edges, the top graph has a vertex of degree 4 and the bottom graph\ndoes not.\nWe say that a graph G0 D .V 0; E0/ is a subgraph of G D .V; E/ if V 0 \u0007 V\nand E0 \u0007 E. Given a set V 0 \u0007 V , the subgraph of G induced by V 0 is the graph\nG0 D .V 0; E0/, where\nE0 D f.u; \u0003/ 2 E W u; \u0003 2 V 0g :\n1172\nAppendix B\nSets, Etc.\nThe subgraph induced by the vertex set f1; 2; 3; 6g in Figure B.2(a) appears in\nFigure B.2(c) and has the edge set f.1; 2/; .2; 2/; .6; 3/g.\nGiven an undirected graph G D .V; E/, the directed version of G is the directed\ngraph G0 D .V; E0/, where .u; \u0003/ 2 E0 if and only if .u; \u0003/ 2 E. That is, we\nreplace each undirected edge .u; \u0003/ in G by the two directed edges .u; \u0003/ and .\u0003; u/\nin the directed version. Given a directed graph G D .V; E/, the undirected version\nof G is the undirected graph G0 D .V; E0/, where .u; \u0003/ 2 E0 if and only if u ¤ \u0003\nand .u; \u0003/ 2 E. That is, the undirected version contains the edges of G “with\ntheir directions removed” and with self-loops eliminated. (Since .u; \u0003/ and .\u0003; u/",
    "parent_aba294d5-79a9-462c-96b3-9ecddb6571f1": "of G is the undirected graph G0 D .V; E0/, where .u; \u0003/ 2 E0 if and only if u ¤ \u0003\nand .u; \u0003/ 2 E. That is, the undirected version contains the edges of G “with\ntheir directions removed” and with self-loops eliminated. (Since .u; \u0003/ and .\u0003; u/\nare the same edge in an undirected graph, the undirected version of a directed\ngraph contains it only once, even if the directed graph contains both edges .u; \u0003/\nand .\u0003; u/.) In a directed graph G D .V; E/, a neighbor of a vertex u is any vertex\nthat is adjacent to u in the undirected version of G. That is, \u0003 is a neighbor of u if\nu ¤ \u0003 and either .u; \u0003/ 2 E or .\u0003; u/ 2 E. In an undirected graph, u and \u0003 are\nneighbors if they are adjacent.\nSeveral kinds of graphs have special names. A complete graph is an undirected\ngraph in which every pair of vertices is adjacent. A bipartite graph is an undirected\ngraph G D .V; E/ in which V can be partitioned into two sets V1 and V2 such that\n.u; \u0003/ 2 E implies either u 2 V1 and \u0003 2 V2 or u 2 V2 and \u0003 2 V1. That is, all\nedges go between the two sets V1 and V2. An acyclic, undirected graph is a forest,\nand a connected, acyclic, undirected graph is a (free) tree (see Section B.5). We\noften take the ﬁrst letters of “directed acyclic graph” and call such a graph a dag.\nThere are two variants of graphs that you may occasionally encounter. A multi-\ngraph is like an undirected graph, but it can have both multiple edges between ver-\ntices and self-loops. A hypergraph is like an undirected graph, but each hyperedge,\nrather than connecting two vertices, connects an arbitrary subset of vertices. Many\nalgorithms written for ordinary directed and undirected graphs can be adapted to\nrun on these graphlike structures.\nThe contraction of an undirected graph G D .V; E/ by an edge e D .u; \u0003/ is a\ngraph G0 D .V 0; E0/, where V 0 D V \u0005 fu; \u0003g [ fxg and x is a new vertex. The set\nof edges E0 is formed from E by deleting the edge .u; \u0003/ and, for each vertex w",
    "parent_c662861f-138d-4eae-ac0f-2bf76bce542d": "run on these graphlike structures.\nThe contraction of an undirected graph G D .V; E/ by an edge e D .u; \u0003/ is a\ngraph G0 D .V 0; E0/, where V 0 D V \u0005 fu; \u0003g [ fxg and x is a new vertex. The set\nof edges E0 is formed from E by deleting the edge .u; \u0003/ and, for each vertex w\nincident on u or \u0003, deleting whichever of .u; w/ and .\u0003; w/ is in E and adding the\nnew edge .x; w/. In effect, u and \u0003 are “contracted” into a single vertex.\nExercises\nB.4-1\nAttendees of a faculty party shake hands to greet each other, and each professor\nremembers how many times he or she shook hands. At the end of the party, the\ndepartment head adds up the number of times that each professor shook hands.\nB.5\nTrees\n1173\nShow that the result is even by proving the handshaking lemma: if G D .V; E/ is\nan undirected graph, then\nX\n\u00052V\ndegree.\u0003/ D 2 jEj :\nB.4-2\nShow that if a directed or undirected graph contains a path between two vertices u\nand \u0003, then it contains a simple path between u and \u0003. Show that if a directed graph\ncontains a cycle, then it contains a simple cycle.\nB.4-3\nShow that any connected, undirected graph G D .V; E/ satisﬁes jEj \u0006 jV j \u0005 1.\nB.4-4\nVerify that in an undirected graph, the “is reachable from” relation is an equiv-\nalence relation on the vertices of the graph. Which of the three properties of an\nequivalence relation hold in general for the “is reachable from” relation on the\nvertices of a directed graph?\nB.4-5\nWhat is the undirected version of the directed graph in Figure B.2(a)? What is the\ndirected version of the undirected graph in Figure B.2(b)?\nB.4-6\n?\nShow that we can represent a hypergraph by a bipartite graph if we let incidence in\nthe hypergraph correspond to adjacency in the bipartite graph. (Hint: Let one set\nof vertices in the bipartite graph correspond to vertices of the hypergraph, and let\nthe other set of vertices of the bipartite graph correspond to hyperedges.)\nB.5\nTrees\nAs with graphs, there are many related, but slightly different, notions of trees. This",
    "parent_ee86f735-6b5e-424e-9f1f-a539a6447100": "of vertices in the bipartite graph correspond to vertices of the hypergraph, and let\nthe other set of vertices of the bipartite graph correspond to hyperedges.)\nB.5\nTrees\nAs with graphs, there are many related, but slightly different, notions of trees. This\nsection presents deﬁnitions and mathematical properties of several kinds of trees.\nSections 10.4 and 22.1 describe how we can represent trees in computer memory.\nB.5.1\nFree trees\nAs deﬁned in Section B.4, a free tree is a connected, acyclic, undirected graph. We\noften omit the adjective “free” when we say that a graph is a tree. If an undirected\ngraph is acyclic but possibly disconnected, it is a forest. Many algorithms that work\n1174\nAppendix B\nSets, Etc.\n(a)\n(b)\n(c)\nFigure B.4\n(a) A free tree. (b) A forest. (c) A graph that contains a cycle and is therefore neither\na tree nor a forest.\nfor trees also work for forests. Figure B.4(a) shows a free tree, and Figure B.4(b)\nshows a forest. The forest in Figure B.4(b) is not a tree because it is not connected.\nThe graph in Figure B.4(c) is connected but neither a tree nor a forest, because it\ncontains a cycle.\nThe following theorem captures many important facts about free trees.\nTheorem B.2 (Properties of free trees)\nLet G D .V; E/ be an undirected graph. The following statements are equivalent.\n1. G is a free tree.\n2. Any two vertices in G are connected by a unique simple path.\n3. G is connected, but if any edge is removed from E, the resulting graph is dis-\nconnected.\n4. G is connected, and jEj D jV j \u0005 1.\n5. G is acyclic, and jEj D jV j \u0005 1.\n6. G is acyclic, but if any edge is added to E, the resulting graph contains a cycle.\nProof\n(1) ) (2): Since a tree is connected, any two vertices in G are connected\nby at least one simple path. Suppose, for the sake of contradiction, that vertices u\nand \u0003 are connected by two distinct simple paths p1 and p2, as shown in Figure B.5.\nLet w be the vertex at which the paths ﬁrst diverge; that is, w is the ﬁrst vertex",
    "parent_e524433c-2dda-4048-b9f8-85e0a05d5035": "by at least one simple path. Suppose, for the sake of contradiction, that vertices u\nand \u0003 are connected by two distinct simple paths p1 and p2, as shown in Figure B.5.\nLet w be the vertex at which the paths ﬁrst diverge; that is, w is the ﬁrst vertex\non both p1 and p2 whose successor on p1 is x and whose successor on p2 is y,\nwhere x ¤ y. Let ´ be the ﬁrst vertex at which the paths reconverge; that is, ´ is\nthe ﬁrst vertex following w on p1 that is also on p2. Let p0 be the subpath of p1\nfrom w through x to ´, and let p00 be the subpath of p2 from w through y to ´.\nPaths p0 and p00 share no vertices except their endpoints. Thus, the path obtained by\nconcatenating p0 and the reverse of p00 is a cycle, which contradicts our assumption\nB.5\nTrees\n1175\nu\nw\nz\nv\nx\ny\np′\np′′\nFigure B.5\nA step in the proof of Theorem B.2: if (1) G is a free tree, then (2) any two vertices\nin G are connected by a unique simple path. Assume for the sake of contradiction that vertices u\nand \u0003 are connected by two distinct simple paths p1 and p2. These paths ﬁrst diverge at vertex w,\nand they ﬁrst reconverge at vertex ´. The path p0 concatenated with the reverse of the path p00 forms\na cycle, which yields the contradiction.\nthat G is a tree. Thus, if G is a tree, there can be at most one simple path between\ntwo vertices.\n(2) ) (3): If any two vertices in G are connected by a unique simple path,\nthen G is connected. Let .u; \u0003/ be any edge in E. This edge is a path from u to \u0003,\nand so it must be the unique path from u to \u0003. If we remove .u; \u0003/ from G, there\nis no path from u to \u0003, and hence its removal disconnects G.\n(3) ) (4): By assumption, the graph G is connected, and by Exercise B.4-3, we\nhave jEj \u0006 jV j \u0005 1. We shall prove jEj \u0002 jV j \u0005 1 by induction. A connected\ngraph with n D 1 or n D 2 vertices has n \u0005 1 edges. Suppose that G has n \u0006 3\nvertices and that all graphs satisfying (3) with fewer than n vertices also satisfy",
    "parent_14e832c4-e64b-485f-87c5-d69b01f67aa2": "have jEj \u0006 jV j \u0005 1. We shall prove jEj \u0002 jV j \u0005 1 by induction. A connected\ngraph with n D 1 or n D 2 vertices has n \u0005 1 edges. Suppose that G has n \u0006 3\nvertices and that all graphs satisfying (3) with fewer than n vertices also satisfy\njEj \u0002 jV j \u0005 1. Removing an arbitrary edge from G separates the graph into k \u0006 2\nconnected components (actually k D 2). Each component satisﬁes (3), or else G\nwould not satisfy (3). If we view each connected component Vi, with edge set Ei,\nas its own free tree, then because each component has fewer than jV j vertices, by\nthe inductive hypothesis we have jEij \u0002 jVij \u0005 1. Thus, the number of edges in all\ncomponents combined is at most jV j \u0005 k \u0002 jV j \u0005 2. Adding in the removed edge\nyields jEj \u0002 jV j \u0005 1.\n(4) ) (5): Suppose that G is connected and that jEj D jV j \u0005 1. We must show\nthat G is acyclic. Suppose that G has a cycle containing k vertices \u00031; \u00032; : : : ; \u0003k,\nand without loss of generality assume that this cycle is simple. Let Gk D .Vk; Ek/\nbe the subgraph of G consisting of the cycle.\nNote that jVkj D jEkj D k.\nIf k < jV j, there must be a vertex \u0003kC1 2 V \u0005 Vk that is adjacent to some ver-\ntex \u0003i 2 Vk, since G is connected. Deﬁne GkC1 D .VkC1; EkC1/ to be the sub-\ngraph of G with VkC1 D Vk [ f\u0003kC1g and EkC1 D Ek [ f.\u0003i; \u0003kC1/g. Note that\njVkC1j D jEkC1j D k C 1. If k C 1 < jV j, we can continue, deﬁning GkC2 in\nthe same manner, and so forth, until we obtain Gn D .Vn; En/, where n D jV j,\n1176\nAppendix B\nSets, Etc.\nVn D V , and jEnj D jVnj D jV j. Since Gn is a subgraph of G, we have En \u0007 E,\nand hence jEj \u0006 jV j, which contradicts the assumption that jEj D jV j \u0005 1. Thus,\nG is acyclic.\n(5) ) (6): Suppose that G is acyclic and that jEj D jV j \u0005 1. Let k be the\nnumber of connected components of G. Each connected component is a free tree\nby deﬁnition, and since (1) implies (5), the sum of all edges in all connected com-\nponents of G is jV j \u0005 k. Consequently, we must have k D 1, and G is in fact a",
    "parent_68493f30-e64f-4087-9866-8ece64c888b5": "number of connected components of G. Each connected component is a free tree\nby deﬁnition, and since (1) implies (5), the sum of all edges in all connected com-\nponents of G is jV j \u0005 k. Consequently, we must have k D 1, and G is in fact a\ntree. Since (1) implies (2), any two vertices in G are connected by a unique simple\npath. Thus, adding any edge to G creates a cycle.\n(6) ) (1): Suppose that G is acyclic but that adding any edge to E creates a\ncycle. We must show that G is connected. Let u and \u0003 be arbitrary vertices in G.\nIf u and \u0003 are not already adjacent, adding the edge .u; \u0003/ creates a cycle in which\nall edges but .u; \u0003/ belong to G. Thus, the cycle minus edge .u; \u0003/ must contain a\npath from u to \u0003, and since u and \u0003 were chosen arbitrarily, G is connected.\nB.5.2\nRooted and ordered trees\nA rooted tree is a free tree in which one of the vertices is distinguished from the\nothers. We call the distinguished vertex the root of the tree. We often refer to a\nvertex of a rooted tree as a node5 of the tree. Figure B.6(a) shows a rooted tree on\na set of 12 nodes with root 7.\nConsider a node x in a rooted tree T with root r. We call any node y on the\nunique simple path from r to x an ancestor of x. If y is an ancestor of x, then x is\na descendant of y. (Every node is both an ancestor and a descendant of itself.) If y\nis an ancestor of x and x ¤ y, then y is a proper ancestor of x and x is a proper\ndescendant of y. The subtree rooted at x is the tree induced by descendants of x,\nrooted at x. For example, the subtree rooted at node 8 in Figure B.6(a) contains\nnodes 8, 6, 5, and 9.\nIf the last edge on the simple path from the root r of a tree T to a node x is .y; x/,\nthen y is the parent of x, and x is a child of y. The root is the only node in T with\nno parent. If two nodes have the same parent, they are siblings. A node with no\nchildren is a leaf or external node. A nonleaf node is an internal node.",
    "parent_39905895-68b1-4a85-9931-8cec8a693906": "then y is the parent of x, and x is a child of y. The root is the only node in T with\nno parent. If two nodes have the same parent, they are siblings. A node with no\nchildren is a leaf or external node. A nonleaf node is an internal node.\n5The term “node” is often used in the graph theory literature as a synonym for “vertex.” We reserve\nthe term “node” to mean a vertex of a rooted tree.\nB.5\nTrees\n1177\n9\n6\n5\n8\n1\n12\n3\n10\n7\n11\n2\n4\nheight = 4\ndepth 0\ndepth 1\ndepth 2\ndepth 3\ndepth 4\n(a)\n9\n6\n5\n8\n12\n3\n10\n7\n11\n2\n4\n(b)\n1\nFigure B.6\nRooted and ordered trees. (a) A rooted tree with height 4. The tree is drawn in a\nstandard way: the root (node 7) is at the top, its children (nodes with depth 1) are beneath it, their\nchildren (nodes with depth 2) are beneath them, and so forth. If the tree is ordered, the relative left-\nto-right order of the children of a node matters; otherwise it doesn’t. (b) Another rooted tree. As a\nrooted tree, it is identical to the tree in (a), but as an ordered tree it is different, since the children of\nnode 3 appear in a different order.\nThe number of children of a node x in a rooted tree T equals the degree of x.6\nThe length of the simple path from the root r to a node x is the depth of x in T .\nA level of a tree consists of all nodes at the same depth. The height of a node in a\ntree is the number of edges on the longest simple downward path from the node to\na leaf, and the height of a tree is the height of its root. The height of a tree is also\nequal to the largest depth of any node in the tree.\nAn ordered tree is a rooted tree in which the children of each node are ordered.\nThat is, if a node has k children, then there is a ﬁrst child, a second child, . . . ,\nand a kth child. The two trees in Figure B.6 are different when considered to be\nordered trees, but the same when considered to be just rooted trees.\nB.5.3\nBinary and positional trees\nWe deﬁne binary trees recursively. A binary tree T is a structure deﬁned on a ﬁnite\nset of nodes that either\n\u0002",
    "parent_46a07d59-a57c-439b-9f21-6f3f1739ecad": "and a kth child. The two trees in Figure B.6 are different when considered to be\nordered trees, but the same when considered to be just rooted trees.\nB.5.3\nBinary and positional trees\nWe deﬁne binary trees recursively. A binary tree T is a structure deﬁned on a ﬁnite\nset of nodes that either\n\u0002\ncontains no nodes, or\n6Notice that the degree of a node depends on whether we consider T to be a rooted tree or a free tree.\nThe degree of a vertex in a free tree is, as in any undirected graph, the number of adjacent vertices.\nIn a rooted tree, however, the degree is the number of children—the parent of a node does not count\ntoward its degree.\n1178\nAppendix B\nSets, Etc.\n3\n2\n4\n1\n6\n7\n5\n(a)\n3\n2\n4\n1\n6\n7\n5\n(b)\n3\n2\n4\n1\n6\n7\n5\n(c)\nFigure B.7\nBinary trees. (a) A binary tree drawn in a standard way. The left child of a node is\ndrawn beneath the node and to the left. The right child is drawn beneath and to the right. (b) A binary\ntree different from the one in (a). In (a), the left child of node 7 is 5 and the right child is absent.\nIn (b), the left child of node 7 is absent and the right child is 5. As ordered trees, these trees are\nthe same, but as binary trees, they are distinct. (c) The binary tree in (a) represented by the internal\nnodes of a full binary tree: an ordered tree in which each internal node has degree 2. The leaves in\nthe tree are shown as squares.\n\u0002\nis composed of three disjoint sets of nodes: a root node, a binary tree called its\nleft subtree, and a binary tree called its right subtree.\nThe binary tree that contains no nodes is called the empty tree or null tree, some-\ntimes denoted NIL. If the left subtree is nonempty, its root is called the left child of\nthe root of the entire tree. Likewise, the root of a nonnull right subtree is the right\nchild of the root of the entire tree. If a subtree is the null tree NIL, we say that the\nchild is absent or missing. Figure B.7(a) shows a binary tree.",
    "parent_d7359a39-e380-463b-a491-6e476131cd70": "the root of the entire tree. Likewise, the root of a nonnull right subtree is the right\nchild of the root of the entire tree. If a subtree is the null tree NIL, we say that the\nchild is absent or missing. Figure B.7(a) shows a binary tree.\nA binary tree is not simply an ordered tree in which each node has degree at\nmost 2. For example, in a binary tree, if a node has just one child, the position\nof the child—whether it is the left child or the right child—matters. In an or-\ndered tree, there is no distinguishing a sole child as being either left or right. Fig-\nure B.7(b) shows a binary tree that differs from the tree in Figure B.7(a) because of\nthe position of one node. Considered as ordered trees, however, the two trees are\nidentical.\nWe can represent the positioning information in a binary tree by the internal\nnodes of an ordered tree, as shown in Figure B.7(c). The idea is to replace each\nmissing child in the binary tree with a node having no children. These leaf nodes\nare drawn as squares in the ﬁgure. The tree that results is a full binary tree: each\nnode is either a leaf or has degree exactly 2. There are no degree-1 nodes. Conse-\nquently, the order of the children of a node preserves the position information.\nWe can extend the positioning information that distinguishes binary trees from\nordered trees to trees with more than 2 children per node. In a positional tree, the\nB.5\nTrees\n1179\nheight = 3\ndepth 0\ndepth 1\ndepth 2\ndepth 3\nFigure B.8\nA complete binary tree of height 3 with 8 leaves and 7 internal nodes.\nchildren of a node are labeled with distinct positive integers. The ith child of a\nnode is absent if no child is labeled with integer i. A k-ary tree is a positional tree\nin which for every node, all children with labels greater than k are missing. Thus,\na binary tree is a k-ary tree with k D 2.\nA complete k-ary tree is a k-ary tree in which all leaves have the same depth\nand all internal nodes have degree k. Figure B.8 shows a complete binary tree of",
    "parent_5e6f8f09-9a76-408d-8dc8-cae382941b20": "in which for every node, all children with labels greater than k are missing. Thus,\na binary tree is a k-ary tree with k D 2.\nA complete k-ary tree is a k-ary tree in which all leaves have the same depth\nand all internal nodes have degree k. Figure B.8 shows a complete binary tree of\nheight 3. How many leaves does a complete k-ary tree of height h have? The root\nhas k children at depth 1, each of which has k children at depth 2, etc. Thus, the\nnumber of leaves at depth h is kh. Consequently, the height of a complete k-ary\ntree with n leaves is logk n. The number of internal nodes of a complete k-ary tree\nof height h is\n1 C k C k2 C \u0003 \u0003 \u0003 C kh\u00031\nD\nh\u00031\nX\niD0\nki\nD\nkh \u0005 1\nk \u0005 1\nby equation (A.5). Thus, a complete binary tree has 2h \u0005 1 internal nodes.\nExercises\nB.5-1\nDraw all the free trees composed of the three vertices x, y, and ´. Draw all the\nrooted trees with nodes x, y, and ´ with x as the root. Draw all the ordered trees\nwith nodes x, y, and ´ with x as the root. Draw all the binary trees with nodes x,\ny, and ´ with x as the root.\n1180\nAppendix B\nSets, Etc.\nB.5-2\nLet G D .V; E/ be a directed acyclic graph in which there is a vertex \u00030 2 V\nsuch that there exists a unique path from \u00030 to every vertex \u0003 2 V . Prove that the\nundirected version of G forms a tree.\nB.5-3\nShow by induction that the number of degree-2 nodes in any nonempty binary tree\nis 1 fewer than the number of leaves. Conclude that the number of internal nodes\nin a full binary tree is 1 fewer than the number of leaves.\nB.5-4\nUse induction to show that a nonempty binary tree with n nodes has height at\nleast blg nc.\nB.5-5\n?\nThe internal path length of a full binary tree is the sum, taken over all internal\nnodes of the tree, of the depth of each node. Likewise, the external path length is\nthe sum, taken over all leaves of the tree, of the depth of each leaf. Consider a full\nbinary tree with n internal nodes, internal path length i, and external path length e.\nProve that e D i C 2n.\nB.5-6\n?",
    "parent_06ff67a6-c65d-40b2-acd0-ddde14e3493f": "nodes of the tree, of the depth of each node. Likewise, the external path length is\nthe sum, taken over all leaves of the tree, of the depth of each leaf. Consider a full\nbinary tree with n internal nodes, internal path length i, and external path length e.\nProve that e D i C 2n.\nB.5-6\n?\nLet us associate a “weight” w.x/ D 2\u0003d with each leaf x of depth d in a binary\ntree T , and let L be the set of leaves of T . Prove that P\nx2L w.x/ \u0002 1. (This is\nknown as the Kraft inequality.)\nB.5-7\n?\nShow that if L \u0006 2, then every binary tree with L leaves contains a subtree having\nbetween L=3 and 2L=3 leaves, inclusive.\nProblems\nB-1\nGraph coloring\nGiven an undirected graph G D .V; E/, a k-coloring of G is a function c W V !\nf0; 1; : : : ; k \u0005 1g such that c.u/ ¤ c.\u0003/ for every edge .u; \u0003/ 2 E. In other words,\nthe numbers 0; 1; : : : ; k \u0005 1 represent the k colors, and adjacent vertices must have\ndifferent colors.\na. Show that any tree is 2-colorable.\nProblems for Appendix B\n1181\nb. Show that the following are equivalent:\n1. G is bipartite.\n2. G is 2-colorable.\n3. G has no cycles of odd length.\nc. Let d be the maximum degree of any vertex in a graph G. Prove that we can\ncolor G with d C 1 colors.\nd. Show that if G has O.jV j/ edges, then we can color G with O.\np\njV j/ colors.\nB-2\nFriendly graphs\nReword each of the following statements as a theorem about undirected graphs,\nand then prove it. Assume that friendship is symmetric but not reﬂexive.\na. Any group of at least two people contains at least two people with the same\nnumber of friends in the group.\nb. Every group of six people contains either at least three mutual friends or at least\nthree mutual strangers.\nc. Any group of people can be partitioned into two subgroups such that at least\nhalf the friends of each person belong to the subgroup of which that person is\nnot a member.\nd. If everyone in a group is the friend of at least half the people in the group, then",
    "parent_d4cb2b2a-262a-45b8-a8b2-fa8e5207d090": "three mutual strangers.\nc. Any group of people can be partitioned into two subgroups such that at least\nhalf the friends of each person belong to the subgroup of which that person is\nnot a member.\nd. If everyone in a group is the friend of at least half the people in the group, then\nthe group can be seated around a table in such a way that everyone is seated\nbetween two friends.\nB-3\nBisecting trees\nMany divide-and-conquer algorithms that operate on graphs require that the graph\nbe bisected into two nearly equal-sized subgraphs, which are induced by a partition\nof the vertices. This problem investigates bisections of trees formed by removing a\nsmall number of edges. We require that whenever two vertices end up in the same\nsubtree after removing edges, then they must be in the same partition.\na. Show that we can partition the vertices of any n-vertex binary tree into two\nsets A and B, such that jAj \u0002 3n=4 and jBj \u0002 3n=4, by removing a single\nedge.\nb. Show that the constant 3=4 in part (a) is optimal in the worst case by giving\nan example of a simple binary tree whose most evenly balanced partition upon\nremoval of a single edge has jAj D 3n=4.\n1182\nAppendix B\nSets, Etc.\nc. Show that by removing at most O.lg n/ edges, we can partition the vertices\nof any n-vertex binary tree into two sets A and B such that jAj D bn=2c\nand jBj D dn=2e.\nAppendix notes\nG. Boole pioneered the development of symbolic logic, and he introduced many of\nthe basic set notations in a book published in 1854. Modern set theory was created\nby G. Cantor during the period 1874–1895. Cantor focused primarily on sets of\ninﬁnite cardinality. The term “function” is attributed to G. W. Leibniz, who used it\nto refer to several kinds of mathematical formulas. His limited deﬁnition has been\ngeneralized many times. Graph theory originated in 1736, when L. Euler proved\nthat it was impossible to cross each of the seven bridges in the city of K¨onigsberg\nexactly once and return to the starting point.",
    "parent_ae252843-6790-4e29-9ebd-da8d3852ad56": "to refer to several kinds of mathematical formulas. His limited deﬁnition has been\ngeneralized many times. Graph theory originated in 1736, when L. Euler proved\nthat it was impossible to cross each of the seven bridges in the city of K¨onigsberg\nexactly once and return to the starting point.\nThe book by Harary [160] provides a useful compendium of many deﬁnitions\nand results from graph theory.\nC\nCounting and Probability\nThis appendix reviews elementary combinatorics and probability theory. If you\nhave a good background in these areas, you may want to skim the beginning of this\nappendix lightly and concentrate on the later sections. Most of this book’s chapters\ndo not require probability, but for some chapters it is essential.\nSection C.1 reviews elementary results in counting theory, including standard\nformulas for counting permutations and combinations. The axioms of probability\nand basic facts concerning probability distributions form Section C.2. Random\nvariables are introduced in Section C.3, along with the properties of expectation\nand variance. Section C.4 investigates the geometric and binomial distributions\nthat arise from studying Bernoulli trials. The study of the binomial distribution\ncontinues in Section C.5, an advanced discussion of the “tails” of the distribution.\nC.1\nCounting\nCounting theory tries to answer the question “How many?” without actually enu-\nmerating all the choices. For example, we might ask, “How many different n-bit\nnumbers are there?” or “How many orderings of n distinct elements are there?” In\nthis section, we review the elements of counting theory. Since some of the material\nassumes a basic understanding of sets, you might wish to start by reviewing the\nmaterial in Section B.1.\nRules of sum and product\nWe can sometimes express a set of items that we wish to count as a union of disjoint\nsets or as a Cartesian product of sets.\nThe rule of sum says that the number of ways to choose one element from one",
    "parent_318d9e75-bede-4db4-899e-556f3729dae7": "material in Section B.1.\nRules of sum and product\nWe can sometimes express a set of items that we wish to count as a union of disjoint\nsets or as a Cartesian product of sets.\nThe rule of sum says that the number of ways to choose one element from one\nof two disjoint sets is the sum of the cardinalities of the sets. That is, if A and B\nare two ﬁnite sets with no members in common, then jA [ Bj D jAj C jBj, which\n1184\nAppendix C\nCounting and Probability\nfollows from equation (B.3). For example, each position on a car’s license plate\nis a letter or a digit. The number of possibilities for each position is therefore\n26 C 10 D 36, since there are 26 choices if it is a letter and 10 choices if it is a\ndigit.\nThe rule of product says that the number of ways to choose an ordered pair is the\nnumber of ways to choose the ﬁrst element times the number of ways to choose the\nsecond element. That is, if A and B are two ﬁnite sets, then jA \t Bj D jAj \u0003 jBj,\nwhich is simply equation (B.4). For example, if an ice-cream parlor offers 28\nﬂavors of ice cream and 4 toppings, the number of possible sundaes with one scoop\nof ice cream and one topping is 28 \u0003 4 D 112.\nStrings\nA string over a ﬁnite set S is a sequence of elements of S. For example, there are 8\nbinary strings of length 3:\n000; 001; 010; 011; 100; 101; 110; 111 :\nWe sometimes call a string of length k a k-string. A substring s0 of a string s\nis an ordered sequence of consecutive elements of s. A k-substring of a string\nis a substring of length k. For example, 010 is a 3-substring of 01101001 (the\n3-substring that begins in position 4), but 111 is not a substring of 01101001.\nWe can view a k-string over a set S as an element of the Cartesian product S k\nof k-tuples; thus, there are jSjk strings of length k. For example, the number of\nbinary k-strings is 2k. Intuitively, to construct a k-string over an n-set, we have n\nways to pick the ﬁrst element; for each of these choices, we have n ways to pick the",
    "parent_b64c800d-61b7-4d3c-bfb6-103df0923be3": "of k-tuples; thus, there are jSjk strings of length k. For example, the number of\nbinary k-strings is 2k. Intuitively, to construct a k-string over an n-set, we have n\nways to pick the ﬁrst element; for each of these choices, we have n ways to pick the\nsecond element; and so forth k times. This construction leads to the k-fold product\nn \u0003 n \u0003 \u0003 \u0003 n D nk as the number of k-strings.\nPermutations\nA permutation of a ﬁnite set S is an ordered sequence of all the elements of S,\nwith each element appearing exactly once. For example, if S D fa; b; cg, then S\nhas 6 permutations:\nabc; acb; bac; bca; cab; cba :\nThere are nŠ permutations of a set of n elements, since we can choose the ﬁrst\nelement of the sequence in n ways, the second in n \u0005 1 ways, the third in n \u0005 2\nways, and so on.\nA k-permutation of S is an ordered sequence of k elements of S, with no ele-\nment appearing more than once in the sequence. (Thus, an ordinary permutation is\nan n-permutation of an n-set.) The twelve 2-permutations of the set fa; b; c; dg are\nC.1\nCounting\n1185\nab; ac; ad; ba; bc; bd; ca; cb; cd; da; db; dc :\nThe number of k-permutations of an n-set is\nn.n \u0005 1/.n \u0005 2/ \u0003 \u0003 \u0003 .n \u0005 k C 1/ D\nnŠ\n.n \u0005 k/Š ;\n(C.1)\nsince we have n ways to choose the ﬁrst element, n \u0005 1 ways to choose the second\nelement, and so on, until we have selected k elements, the last being a selection\nfrom the remaining n \u0005 k C 1 elements.\nCombinations\nA k-combination of an n-set S is simply a k-subset of S. For example, the 4-set\nfa; b; c; dg has six 2-combinations:\nab; ac; ad; bc; bd; cd :\n(Here we use the shorthand of denoting the 2-subset fa; bg by ab, and so on.)\nWe can construct a k-combination of an n-set by choosing k distinct (different)\nelements from the n-set. The order in which we select the elements does not matter.\nWe can express the number of k-combinations of an n-set in terms of the number\nof k-permutations of an n-set. Every k-combination has exactly kŠ permutations",
    "parent_352de8d5-0e6b-4773-92e3-950a6b40e96d": "elements from the n-set. The order in which we select the elements does not matter.\nWe can express the number of k-combinations of an n-set in terms of the number\nof k-permutations of an n-set. Every k-combination has exactly kŠ permutations\nof its elements, each of which is a distinct k-permutation of the n-set. Thus, the\nnumber of k-combinations of an n-set is the number of k-permutations divided\nby kŠ; from equation (C.1), this quantity is\nnŠ\nkŠ .n \u0005 k/Š :\n(C.2)\nFor k D 0, this formula tells us that the number of ways to choose 0 elements from\nan n-set is 1 (not 0), since 0Š D 1.\nBinomial coefﬁcients\nThe notation\n\u000bn\nk\n\f\n(read “n choose k”) denotes the number of k-combinations of\nan n-set. From equation (C.2), we have\n \nn\nk\n!\nD\nnŠ\nkŠ .n \u0005 k/Š :\nThis formula is symmetric in k and n \u0005 k:\n \nn\nk\n!\nD\n \nn\nn \u0005 k\n!\n:\n(C.3)\n1186\nAppendix C\nCounting and Probability\nThese numbers are also known as binomial coefﬁcients, due to their appearance in\nthe binomial expansion:\n.x C y/n D\nn\nX\nkD0\n \nn\nk\n!\nxkyn\u0003k :\n(C.4)\nA special case of the binomial expansion occurs when x D y D 1:\n2n D\nn\nX\nkD0\n \nn\nk\n!\n:\nThis formula corresponds to counting the 2n binary n-strings by the number of 1s\nthey contain:\n\u000bn\nk\n\f\nbinary n-strings contain exactly k 1s, since we have\n\u000bn\nk\n\f\nways to\nchoose k out of the n positions in which to place the 1s.\nMany identities involve binomial coefﬁcients. The exercises at the end of this\nsection give you the opportunity to prove a few.\nBinomial bounds\nWe sometimes need to bound the size of a binomial coefﬁcient. For 1 \u0002 k \u0002 n,\nwe have the lower bound\n \nn\nk\n!\nD\nn.n \u0005 1/ \u0003 \u0003 \u0003 .n \u0005 k C 1/\nk.k \u0005 1/ \u0003 \u0003 \u0003 1\nD\n\u0004n\nk\n\u0005 \u0002n \u0005 1\nk \u0005 1\n\u0003\n\u0003 \u0003 \u0003\n\u0002n \u0005 k C 1\n1\n\u0003\n\u0006\n\u0004n\nk\n\u0005k\n:\nTaking advantage of the inequality kŠ \u0006 .k=e/k derived from Stirling’s approxi-\nmation (3.18), we obtain the upper bounds\n \nn\nk\n!\nD\nn.n \u0005 1/ \u0003 \u0003 \u0003 .n \u0005 k C 1/\nk.k \u0005 1/ \u0003 \u0003 \u0003 1\n\u0002\nnk\nkŠ\n\u0002\n\u0004en\nk\n\u0005k\n:\n(C.5)\nFor all integers k such that 0 \u0002 k \u0002 n, we can use induction (see Exercise C.1-12)\nto prove the bound\nC.1",
    "parent_8f90a36e-3691-468c-83ee-58800a796449": "mation (3.18), we obtain the upper bounds\n \nn\nk\n!\nD\nn.n \u0005 1/ \u0003 \u0003 \u0003 .n \u0005 k C 1/\nk.k \u0005 1/ \u0003 \u0003 \u0003 1\n\u0002\nnk\nkŠ\n\u0002\n\u0004en\nk\n\u0005k\n:\n(C.5)\nFor all integers k such that 0 \u0002 k \u0002 n, we can use induction (see Exercise C.1-12)\nto prove the bound\nC.1\nCounting\n1187\n \nn\nk\n!\n\u0002\nnn\nkk.n \u0005 k/n\u0003k ;\n(C.6)\nwhere for convenience we assume that 00 D 1. For k D \u0005n, where 0 \u0002 \u0005 \u0002 1, we\ncan rewrite this bound as\n \nn\n\u0005n\n!\n\u0002\nnn\n.\u0005n/\tn..1 \u0005 \u0005/n/.1\u0003\t/n\nD\n \u00021\n\u0005\n\u0003\t \u0002\n1\n1 \u0005 \u0005\n\u00031\u0003\t!n\nD\n2n H.\t/ ;\nwhere\nH.\u0005/ D \u0005\u0005 lg \u0005 \u0005 .1 \u0005 \u0005/ lg.1 \u0005 \u0005/\n(C.7)\nis the (binary) entropy function and where, for convenience, we assume that\n0 lg 0 D 0, so that H.0/ D H.1/ D 0.\nExercises\nC.1-1\nHow many k-substrings does an n-string have? (Consider identical k-substrings at\ndifferent positions to be different.) How many substrings does an n-string have in\ntotal?\nC.1-2\nAn n-input, m-output boolean function is a function from fTRUE; FALSEgn to\nfTRUE; FALSEgm. How many n-input, 1-output boolean functions are there? How\nmany n-input, m-output boolean functions are there?\nC.1-3\nIn how many ways can n professors sit around a circular conference table? Con-\nsider two seatings to be the same if one can be rotated to form the other.\nC.1-4\nIn how many ways can we choose three distinct numbers from the set f1; 2; : : : ; 99g\nso that their sum is even?\n1188\nAppendix C\nCounting and Probability\nC.1-5\nProve the identity\n \nn\nk\n!\nD n\nk\n \nn \u0005 1\nk \u0005 1\n!\n(C.8)\nfor 0 < k \u0002 n.\nC.1-6\nProve the identity\n \nn\nk\n!\nD\nn\nn \u0005 k\n \nn \u0005 1\nk\n!\nfor 0 \u0002 k < n.\nC.1-7\nTo choose k objects from n, you can make one of the objects distinguished and\nconsider whether the distinguished object is chosen. Use this approach to prove\nthat\n \nn\nk\n!\nD\n \nn \u0005 1\nk\n!\nC\n \nn \u0005 1\nk \u0005 1\n!\n:\nC.1-8\nUsing the result of Exercise C.1-7, make a table for n D 0; 1; : : : ; 6 and 0 \u0002 k \u0002 n\nof the binomial coefﬁcients\n\u000bn\nk\n\f\nwith\n\u000b0\n0\n\f\nat the top,\n\u000b1\n0\n\f\nand\n\u000b1\n1\n\f\non the next line, and\nso forth. Such a table of binomial coefﬁcients is called Pascal’s triangle.\nC.1-9\nProve that\nn\nX\niD1\ni D\n \nn C 1\n2\n!",
    "parent_8f925a90-29b5-4264-8d4b-d22156f66a85": "of the binomial coefﬁcients\n\u000bn\nk\n\f\nwith\n\u000b0\n0\n\f\nat the top,\n\u000b1\n0\n\f\nand\n\u000b1\n1\n\f\non the next line, and\nso forth. Such a table of binomial coefﬁcients is called Pascal’s triangle.\nC.1-9\nProve that\nn\nX\niD1\ni D\n \nn C 1\n2\n!\n:\nC.1-10\nShow that for any integers n \u0006 0 and 0 \u0002 k \u0002 n, the expression\n\u000bn\nk\n\f\nachieves its\nmaximum value when k D bn=2c or k D dn=2e.\nC.1-11\n?\nArgue that for any integers n \u0006 0, j \u0006 0, k \u0006 0, and j C k \u0002 n,\n \nn\nj C k\n!\n\u0002\n \nn\nj\n! \nn \u0005 j\nk\n!\n:\n(C.9)\nC.2\nProbability\n1189\nProvide both an algebraic proof and an argument based on a method for choosing\nj C k items out of n. Give an example in which equality does not hold.\nC.1-12\n?\nUse induction on all integers k such that 0 \u0002 k \u0002 n=2 to prove inequality (C.6),\nand use equation (C.3) to extend it to all integers k such that 0 \u0002 k \u0002 n.\nC.1-13\n?\nUse Stirling’s approximation to prove that\n \n2n\nn\n!\nD\n22n\np\u0006n.1 C O.1=n// :\n(C.10)\nC.1-14\n?\nBy differentiating the entropy function H.\u0005/, show that it achieves its maximum\nvalue at \u0005 D 1=2. What is H.1=2/?\nC.1-15\n?\nShow that for any integer n \u0006 0,\nn\nX\nkD0\n \nn\nk\n!\nk D n2n\u00031 :\n(C.11)\nC.2\nProbability\nProbability is an essential tool for the design and analysis of probabilistic and ran-\ndomized algorithms. This section reviews basic probability theory.\nWe deﬁne probability in terms of a sample space S, which is a set whose ele-\nments are called elementary events. We can think of each elementary event as a\npossible outcome of an experiment. For the experiment of ﬂipping two distinguish-\nable coins, with each individual ﬂip resulting in a head (H) or a tail (T), we can view\nthe sample space as consisting of the set of all possible 2-strings over fH; Tg:\nS D fHH; HT; TH; TTg :\n1190\nAppendix C\nCounting and Probability\nAn event is a subset1 of the sample space S. For example, in the experiment of\nﬂipping two coins, the event of obtaining one head and one tail is fHT; THg. The\nevent S is called the certain event, and the event ; is called the null event. We say",
    "parent_670292b2-b172-4914-bd63-c1e8563198b9": "1190\nAppendix C\nCounting and Probability\nAn event is a subset1 of the sample space S. For example, in the experiment of\nﬂipping two coins, the event of obtaining one head and one tail is fHT; THg. The\nevent S is called the certain event, and the event ; is called the null event. We say\nthat two events A and B are mutually exclusive if A\\B D ;. We sometimes treat\nan elementary event s 2 S as the event fsg. By deﬁnition, all elementary events\nare mutually exclusive.\nAxioms of probability\nA probability distribution Pr fg on a sample space S is a mapping from events of S\nto real numbers satisfying the following probability axioms:\n1. Pr fAg \u0006 0 for any event A.\n2. Pr fSg D 1.\n3. Pr fA [ Bg D Pr fAg C Pr fBg for any two mutually exclusive events A\nand B. More generally, for any (ﬁnite or countably inﬁnite) sequence of events\nA1; A2; : : : that are pairwise mutually exclusive,\nPr\n([\ni\nAi\n)\nD\nX\ni\nPr fAig :\nWe call Pr fAg the probability of the event A. We note here that axiom 2 is a\nnormalization requirement: there is really nothing fundamental about choosing 1\nas the probability of the certain event, except that it is natural and convenient.\nSeveral results follow immediately from these axioms and basic set theory (see\nSection B.1). The null event ; has probability Pr f;g D 0. If A \u0007 B, then\nPr fAg \u0002 Pr fBg. Using A to denote the event S \u0005 A (the complement of A),\nwe have Pr\n˚\nA",
    "parent_451e5454-9f5e-4f18-a6b1-32655d7d9788": "D 1 \u0005 Pr fAg. For any two events A and B,\nPr fA [ Bg\nD\nPr fAg C Pr fBg \u0005 Pr fA \\ Bg\n(C.12)\n\u0002\nPr fAg C Pr fBg :\n(C.13)\n1For a general probability distribution, there may be some subsets of the sample space S that are not\nconsidered to be events. This situation usually arises when the sample space is uncountably inﬁnite.\nThe main requirement for what subsets are events is that the set of events of a sample space be closed\nunder the operations of taking the complement of an event, forming the union of a ﬁnite or countable\nnumber of events, and taking the intersection of a ﬁnite or countable number of events. Most of\nthe probability distributions we shall see are over ﬁnite or countable sample spaces, and we shall\ngenerally consider all subsets of a sample space to be events. A notable exception is the continuous\nuniform probability distribution, which we shall see shortly.\nC.2\nProbability\n1191\nIn our coin-ﬂipping example, suppose that each of the four elementary events\nhas probability 1=4. Then the probability of getting at least one head is\nPr fHH; HT; THg\nD\nPr fHHg C Pr fHTg C Pr fTHg\nD\n3=4 :\nAlternatively, since the probability of getting strictly less than one head is\nPr fTTg D 1=4, the probability of getting at least one head is 1 \u0005 1=4 D 3=4.\nDiscrete probability distributions\nA probability distribution is discrete if it is deﬁned over a ﬁnite or countably inﬁnite\nsample space. Let S be the sample space. Then for any event A,\nPr fAg D\nX\ns2A\nPr fsg ;\nsince elementary events, speciﬁcally those in A, are mutually exclusive. If S is\nﬁnite and every elementary event s 2 S has probability\nPr fsg D 1= jSj ;\nthen we have the uniform probability distribution on S. In such a case the experi-\nment is often described as “picking an element of S at random.”\nAs an example, consider the process of ﬂipping a fair coin, one for which the\nprobability of obtaining a head is the same as the probability of obtaining a tail, that",
    "parent_dc4a1fea-a402-45ce-bbff-813ce8736b73": "ment is often described as “picking an element of S at random.”\nAs an example, consider the process of ﬂipping a fair coin, one for which the\nprobability of obtaining a head is the same as the probability of obtaining a tail, that\nis, 1=2. If we ﬂip the coin n times, we have the uniform probability distribution\ndeﬁned on the sample space S D fH; Tgn, a set of size 2n. We can represent each\nelementary event in S as a string of length n over fH; Tg, each string occurring with\nprobability 1=2n. The event\nA D fexactly k heads and exactly n \u0005 k tails occurg\nis a subset of S of size jAj D\n\u000bn\nk\n\f\n, since\n\u000bn\nk\n\f\nstrings of length n over fH; Tg contain\nexactly k H’s. The probability of event A is thus Pr fAg D\n\u000bn\nk\n\f\n=2n.\nContinuous uniform probability distribution\nThe continuous uniform probability distribution is an example of a probability\ndistribution in which not all subsets of the sample space are considered to be\nevents. The continuous uniform probability distribution is deﬁned over a closed\ninterval Œa; b\u0002 of the reals, where a < b. Our intuition is that each point in the in-\nterval Œa; b\u0002 should be “equally likely.” There are an uncountable number of points,\nhowever, so if we give all points the same ﬁnite, positive probability, we cannot si-\nmultaneously satisfy axioms 2 and 3. For this reason, we would like to associate a\n1192\nAppendix C\nCounting and Probability\nprobability only with some of the subsets of S, in such a way that the axioms are\nsatisﬁed for these events.\nFor any closed interval Œc; d\u0002, where a \u0002 c \u0002 d \u0002 b, the continuous uniform\nprobability distribution deﬁnes the probability of the event Œc; d\u0002 to be\nPr fŒc; d\u0002g D d \u0005 c\nb \u0005 a :\nNote that for any point x D Œx; x\u0002, the probability of x is 0.\nIf we remove\nthe endpoints of an interval Œc; d\u0002, we obtain the open interval .c; d/.\nSince\nŒc; d\u0002 D Œc; c\u0002 [ .c; d/ [ Œd; d\u0002, axiom 3 gives us Pr fŒc; d\u0002g D Pr f.c; d/g. Gen-\nerally, the set of events for the continuous uniform probability distribution contains",
    "parent_11eff6b0-61a4-4cdd-b317-8817d97c6930": "If we remove\nthe endpoints of an interval Œc; d\u0002, we obtain the open interval .c; d/.\nSince\nŒc; d\u0002 D Œc; c\u0002 [ .c; d/ [ Œd; d\u0002, axiom 3 gives us Pr fŒc; d\u0002g D Pr f.c; d/g. Gen-\nerally, the set of events for the continuous uniform probability distribution contains\nany subset of the sample space Œa; b\u0002 that can be obtained by a ﬁnite or countable\nunion of open and closed intervals, as well as certain more complicated sets.\nConditional probability and independence\nSometimes we have some prior partial knowledge about the outcome of an exper-\niment. For example, suppose that a friend has ﬂipped two fair coins and has told\nyou that at least one of the coins showed a head. What is the probability that both\ncoins are heads? The information given eliminates the possibility of two tails. The\nthree remaining elementary events are equally likely, so we infer that each occurs\nwith probability 1=3. Since only one of these elementary events shows two heads,\nthe answer to our question is 1=3.\nConditional probability formalizes the notion of having prior partial knowledge\nof the outcome of an experiment. The conditional probability of an event A given\nthat another event B occurs is deﬁned to be\nPr fA j Bg D Pr fA \\ Bg\nPr fBg\n(C.14)\nwhenever Pr fBg ¤ 0. (We read “Pr fA j Bg” as “the probability of A given B.”)\nIntuitively, since we are given that event B occurs, the event that A also occurs\nis A \\ B. That is, A \\ B is the set of outcomes in which both A and B occur.\nBecause the outcome is one of the elementary events in B, we normalize the prob-\nabilities of all the elementary events in B by dividing them by Pr fBg, so that they\nsum to 1. The conditional probability of A given B is, therefore, the ratio of the\nprobability of event A \\ B to the probability of event B. In the example above, A\nis the event that both coins are heads, and B is the event that at least one coin is a\nhead. Thus, Pr fA j Bg D .1=4/=.3=4/ D 1=3.\nTwo events are independent if\nPr fA \\ Bg D Pr fAg Pr fBg ;\n(C.15)",
    "parent_48f25fca-94a0-4b38-89bd-a839cf61c920": "probability of event A \\ B to the probability of event B. In the example above, A\nis the event that both coins are heads, and B is the event that at least one coin is a\nhead. Thus, Pr fA j Bg D .1=4/=.3=4/ D 1=3.\nTwo events are independent if\nPr fA \\ Bg D Pr fAg Pr fBg ;\n(C.15)\nwhich is equivalent, if Pr fBg ¤ 0, to the condition\nC.2\nProbability\n1193\nPr fA j Bg D Pr fAg :\nFor example, suppose that we ﬂip two fair coins and that the outcomes are inde-\npendent. Then the probability of two heads is .1=2/.1=2/ D 1=4. Now suppose\nthat one event is that the ﬁrst coin comes up heads and the other event is that the\ncoins come up differently. Each of these events occurs with probability 1=2, and\nthe probability that both events occur is 1=4; thus, according to the deﬁnition of\nindependence, the events are independent—even though you might think that both\nevents depend on the ﬁrst coin. Finally, suppose that the coins are welded to-\ngether so that they both fall heads or both fall tails and that the two possibilities are\nequally likely. Then the probability that each coin comes up heads is 1=2, but the\nprobability that they both come up heads is 1=2 ¤ .1=2/.1=2/. Consequently, the\nevent that one comes up heads and the event that the other comes up heads are not\nindependent.\nA collection A1; A2; : : : ; An of events is said to be pairwise independent if\nPr fAi \\ Ajg D Pr fAig Pr fAjg\nfor all 1 \u0002 i < j \u0002 n. We say that the events of the collection are (mutually)\nindependent if every k-subset Ai1; Ai2; : : : ; Aik of the collection, where 2 \u0002 k \u0002 n\nand 1 \u0002 i1 < i2 < \u0003 \u0003 \u0003 < ik \u0002 n, satisﬁes\nPr fAi1 \\ Ai2 \\ \u0003 \u0003 \u0003 \\ Aikg D Pr fAi1g Pr fAi2g \u0003 \u0003 \u0003 Pr fAikg :\nFor example, suppose we ﬂip two fair coins. Let A1 be the event that the ﬁrst coin\nis heads, let A2 be the event that the second coin is heads, and let A3 be the event\nthat the two coins are different. We have\nPr fA1g\nD\n1=2 ;\nPr fA2g\nD\n1=2 ;\nPr fA3g\nD\n1=2 ;\nPr fA1 \\ A2g\nD\n1=4 ;\nPr fA1 \\ A3g\nD\n1=4 ;\nPr fA2 \\ A3g\nD\n1=4 ;",
    "parent_3cccea4b-4554-4917-b866-590ab13f54ec": "is heads, let A2 be the event that the second coin is heads, and let A3 be the event\nthat the two coins are different. We have\nPr fA1g\nD\n1=2 ;\nPr fA2g\nD\n1=2 ;\nPr fA3g\nD\n1=2 ;\nPr fA1 \\ A2g\nD\n1=4 ;\nPr fA1 \\ A3g\nD\n1=4 ;\nPr fA2 \\ A3g\nD\n1=4 ;\nPr fA1 \\ A2 \\ A3g\nD\n0 :\nSince for 1 \u0002 i < j \u0002 3, we have Pr fAi \\ Ajg D Pr fAig Pr fAjg D 1=4, the\nevents A1, A2, and A3 are pairwise independent. The events are not mutually inde-\npendent, however, because Pr fA1 \\ A2 \\ A3g D 0 and Pr fA1g Pr fA2g Pr fA3g D\n1=8 ¤ 0.\n1194\nAppendix C\nCounting and Probability\nBayes’s theorem\nFrom the deﬁnition of conditional probability (C.14) and the commutative law\nA \\ B D B \\ A, it follows that for two events A and B, each with nonzero\nprobability,\nPr fA \\ Bg\nD\nPr fBg Pr fA j Bg\n(C.16)\nD\nPr fAg Pr fB j Ag :\nSolving for Pr fA j Bg, we obtain\nPr fA j Bg D Pr fAg Pr fB j Ag\nPr fBg\n;\n(C.17)\nwhich is known as Bayes’s theorem. The denominator Pr fBg is a normalizing\nconstant, which we can reformulate as follows. Since B D .B \\ A/ [ .B \\ A/,\nand since B \\ A and B \\ A are mutually exclusive events,\nPr fBg\nD\nPr fB \\ Ag C Pr\n˚\nB \\ A",
    "parent_62c1c8ed-638d-479b-972d-7ae8474acdbe": "D\nPr fAg Pr fB j Ag C Pr\n˚\nA\n\nPr\n˚\nB j A\n\n:\nSubstituting into equation (C.17), we obtain an equivalent form of Bayes’s theo-\nrem:\nPr fA j Bg D\nPr fAg Pr fB j Ag\nPr fAg Pr fB j Ag C Pr\n˚\nA\n\nPr\n˚\nB j A\n\n :\n(C.18)\nBayes’s theorem can simplify the computing of conditional probabilities. For\nexample, suppose that we have a fair coin and a biased coin that always comes up\nheads. We run an experiment consisting of three independent events: we choose\none of the two coins at random, we ﬂip that coin once, and then we ﬂip it again.\nSuppose that the coin we have chosen comes up heads both times. What is the\nprobability that it is biased?\nWe solve this problem using Bayes’s theorem. Let A be the event that we choose\nthe biased coin, and let B be the event that the chosen coin comes up heads both\ntimes. We wish to determine Pr fA j Bg. We have Pr fAg D 1=2, Pr fB j Ag D 1,\nPr\n˚\nA\n\nD 1=2, and Pr\n˚\nB j A\n\nD 1=4; hence,\nPr fA j Bg\nD\n.1=2/ \u0003 1\n.1=2/ \u0003 1 C .1=2/ \u0003 .1=4/\nD\n4=5 :\nExercises\nC.2-1\nProfessor Guildenstern ﬂips a fair\n?\ncoin twice. What is the probability that Professor Rosencrantz obtains more heads\nProfessor Rosencrantz ﬂips a fair coin once.\nthan Professor Guildenstern\nC.2\nProbability\n1195\nC.2-2\nProve Boole’s inequality: For any ﬁnite or countably inﬁnite sequence of events\nA1; A2; : : :,\nPr fA1 [ A2 [ \u0003 \u0003 \u0003g \u0002 Pr fA1g C Pr fA2g C \u0003 \u0003 \u0003 :\n(C.19)\nC.2-3\nSuppose we shufﬂe a deck of 10 cards, each bearing a distinct number from 1 to 10,\nto mix the cards thoroughly. We then remove three cards, one at a time, from the\ndeck. What is the probability that we select the three cards in sorted (increasing)\norder?\nC.2-4\nProve that\nPr fA j Bg C Pr\n˚\nA j B",
    "parent_9560bcfe-2a88-4021-9724-d5ce6f0857df": "D 1 :\nC.2-5\nProve that for any collection of events A1; A2; : : : ; An,\nPr fA1 \\ A2 \\ \u0003 \u0003 \u0003 \\ Ang D Pr fA1g \u0003 Pr fA2 j A1g \u0003 Pr fA3 j A1 \\ A2g \u0003 \u0003 \u0003\nPr fAn j A1 \\ A2 \\ \u0003 \u0003 \u0003 \\ An\u00031g :\nC.2-6\n?\nDescribe a procedure that takes as input two integers a and b such that 0 < a < b\nand, using fair coin ﬂips, produces as output heads with probability a=b and tails\nwith probability .b \u0005 a/=b. Give a bound on the expected number of coin ﬂips,\nwhich should be O.1/. (Hint: Represent a=b in binary.)\nC.2-7\n?\nShow how to construct a set of n events that are pairwise independent but such that\nno subset of k > 2 of them is mutually independent.\nC.2-8\n?\nTwo events A and B are conditionally independent, given C, if\nPr fA \\ B j Cg D Pr fA j Cg \u0003 Pr fB j Cg :\nGive a simple but nontrivial example of two events that are not independent but are\nconditionally independent given a third event.\nC.2-9\n?\nYou are a contestant in a game show in which a prize is hidden behind one of\nthree curtains. You will win the prize if you select the correct curtain. After you\n1196\nAppendix C\nCounting and Probability\nhave picked one curtain but before the curtain is lifted, the emcee lifts one of the\nother curtains, knowing that it will reveal an empty stage, and asks if you would\nlike to switch from your current selection to the remaining curtain. How would\nyour chances change if you switch? (This question is the celebrated Monty Hall\nproblem, named after a game-show host who often presented contestants with just\nthis dilemma.)\nC.2-10\n?\nA prison warden has randomly picked one prisoner among three to go free. The\nother two will be executed. The guard knows which one will go free but is forbid-\nden to give any prisoner information regarding his status. Let us call the prisoners\nX, Y , and Z. Prisoner X asks the guard privately which of Y or Z will be exe-\ncuted, arguing that since he already knows that at least one of them must die, the",
    "parent_9358f6d6-5cb9-43f0-881a-5a0bbd94524a": "den to give any prisoner information regarding his status. Let us call the prisoners\nX, Y , and Z. Prisoner X asks the guard privately which of Y or Z will be exe-\ncuted, arguing that since he already knows that at least one of them must die, the\nguard won’t be revealing any information about his own status. The guard tells X\nthat Y is to be executed. Prisoner X feels happier now, since he ﬁgures that either\nhe or prisoner Z will go free, which means that his probability of going free is\nnow 1=2. Is he right, or are his chances still 1=3? Explain.\nC.3\nDiscrete random variables\nA (discrete) random variable X is a function from a ﬁnite or countably inﬁnite\nsample space S to the real numbers. It associates a real number with each possible\noutcome of an experiment, which allows us to work with the probability distribu-\ntion induced on the resulting set of numbers. Random variables can also be deﬁned\nfor uncountably inﬁnite sample spaces, but they raise technical issues that are un-\nnecessary to address for our purposes. Henceforth, we shall assume that random\nvariables are discrete.\nFor a random variable X and a real number x, we deﬁne the event X D x to be\nfs 2 S W X.s/ D xg; thus,\nPr fX D xg D\nX\ns2SWX.s/Dx\nPr fsg :\nThe function\nf .x/ D Pr fX D xg\nis the probability density function of the random variable X. From the probability\naxioms, Pr fX D xg \u0006 0 and P\nx Pr fX D xg D 1.\nAs an example, consider the experiment of rolling a pair of ordinary, 6-sided\ndice. There are 36 possible elementary events in the sample space. We assume\nC.3\nDiscrete random variables\n1197\nthat the probability distribution is uniform, so that each elementary event s 2 S is\nequally likely: Pr fsg D 1=36. Deﬁne the random variable X to be the maximum of\nthe two values showing on the dice. We have Pr fX D 3g D 5=36, since X assigns\na value of 3 to 5 of the 36 possible elementary events, namely, .1; 3/, .2; 3/, .3; 3/,\n.3; 2/, and .3; 1/.",
    "parent_462ca468-97d6-4648-b098-0ac3c37e469f": "equally likely: Pr fsg D 1=36. Deﬁne the random variable X to be the maximum of\nthe two values showing on the dice. We have Pr fX D 3g D 5=36, since X assigns\na value of 3 to 5 of the 36 possible elementary events, namely, .1; 3/, .2; 3/, .3; 3/,\n.3; 2/, and .3; 1/.\nWe often deﬁne several random variables on the same sample space. If X and Y\nare random variables, the function\nf .x; y/ D Pr fX D x and Y D yg\nis the joint probability density function of X and Y . For a ﬁxed value y,\nPr fY D yg D\nX\nx\nPr fX D x and Y D yg ;\nand similarly, for a ﬁxed value x,\nPr fX D xg D\nX\ny\nPr fX D x and Y D yg :\nUsing the deﬁnition (C.14) of conditional probability, we have\nPr fX D x j Y D yg D Pr fX D x and Y D yg\nPr fY D yg\n:\nWe deﬁne two random variables X and Y to be independent if for all x and y, the\nevents X D x and Y D y are independent or, equivalently, if for all x and y, we\nhave Pr fX D x and Y D yg D Pr fX D xg Pr fY D yg.\nGiven a set of random variables deﬁned over the same sample space, we can\ndeﬁne new random variables as sums, products, or other functions of the original\nvariables.\nExpected value of a random variable\nThe simplest and most useful summary of the distribution of a random variable is\nthe “average” of the values it takes on. The expected value (or, synonymously,\nexpectation or mean) of a discrete random variable X is\nE ŒX\u0002 D\nX\nx\nx \u0003 Pr fX D xg ;\n(C.20)\nwhich is well deﬁned if the sum is ﬁnite or converges absolutely. Sometimes the\nexpectation of X is denoted by \rX or, when the random variable is apparent from\ncontext, simply by \r.\nConsider a game in which you ﬂip two fair coins. You earn $3 for each head but\nlose $2 for each tail. The expected value of the random variable X representing\n1198\nAppendix C\nCounting and Probability\nyour earnings is\nE ŒX\u0002\nD\n6 \u0003 Pr f2 H’sg C 1 \u0003 Pr f1 H, 1 Tg \u0005 4 \u0003 Pr f2 T’sg\nD\n6.1=4/ C 1.1=2/ \u0005 4.1=4/\nD\n1 :\nThe expectation of the sum of two random variables is the sum of their expecta-\ntions, that is,",
    "parent_283cac78-7b71-4330-94b5-3dc0698087e2": "1198\nAppendix C\nCounting and Probability\nyour earnings is\nE ŒX\u0002\nD\n6 \u0003 Pr f2 H’sg C 1 \u0003 Pr f1 H, 1 Tg \u0005 4 \u0003 Pr f2 T’sg\nD\n6.1=4/ C 1.1=2/ \u0005 4.1=4/\nD\n1 :\nThe expectation of the sum of two random variables is the sum of their expecta-\ntions, that is,\nE ŒX C Y \u0002 D E ŒX\u0002 C E ŒY \u0002 ;\n(C.21)\nwhenever E ŒX\u0002 and E ŒY \u0002 are deﬁned. We call this property linearity of expecta-\ntion, and it holds even if X and Y are not independent. It also extends to ﬁnite and\nabsolutely convergent summations of expectations. Linearity of expectation is the\nkey property that enables us to perform probabilistic analyses by using indicator\nrandom variables (see Section 5.2).\nIf X is any random variable, any function g.x/ deﬁnes a new random vari-\nable g.X/. If the expectation of g.X/ is deﬁned, then\nE Œg.X/\u0002 D\nX\nx\ng.x/ \u0003 Pr fX D xg :\nLetting g.x/ D ax, we have for any constant a,\nE ŒaX\u0002 D aE ŒX\u0002 :\n(C.22)\nConsequently, expectations are linear: for any two random variables X and Y and\nany constant a,\nE ŒaX C Y \u0002 D aE ŒX\u0002 C E ŒY \u0002 :\n(C.23)\nWhen two random variables X and Y are independent and each has a deﬁned\nexpectation,\nE ŒXY \u0002\nD\nX\nx\nX\ny\nxy \u0003 Pr fX D x and Y D yg\nD\nX\nx\nX\ny\nxy \u0003 Pr fX D xg Pr fY D yg\nD\n X\nx\nx \u0003 Pr fX D xg\n!  X\ny\ny \u0003 Pr fY D yg\n!\nD\nE ŒX\u0002 E ŒY \u0002 :\nIn general, when n random variables X1; X2; : : : ; Xn are mutually independent,\nE ŒX1X2 \u0003 \u0003 \u0003 Xn\u0002 D E ŒX1\u0002 E ŒX2\u0002 \u0003 \u0003 \u0003 E ŒXn\u0002 :\n(C.24)\nC.3\nDiscrete random variables\n1199\nWhen a random variable X takes on values from the set of natural numbers\nN D f0; 1; 2; : : :g, we have a nice formula for its expectation:\nE ŒX\u0002\nD\n1\nX\niD0\ni \u0003 Pr fX D ig\nD\n1\nX\niD0\ni.Pr fX \u0006 ig \u0005 Pr fX \u0006 i C 1g/\nD\n1\nX\niD1\nPr fX \u0006 ig ;\n(C.25)\nsince each term Pr fX \u0006 ig is added in i times and subtracted out i \u0005 1 times\n(except Pr fX \u0006 0g, which is added in 0 times and not subtracted out at all).\nWhen we apply a convex function f .x/ to a random variable X, Jensen’s in-\nequality gives us\nE Œf .X/\u0002 \u0006 f .E ŒX\u0002/ ;\n(C.26)",
    "parent_f10b7576-9118-4d0c-ae8b-9b061cbc3750": "Pr fX \u0006 ig ;\n(C.25)\nsince each term Pr fX \u0006 ig is added in i times and subtracted out i \u0005 1 times\n(except Pr fX \u0006 0g, which is added in 0 times and not subtracted out at all).\nWhen we apply a convex function f .x/ to a random variable X, Jensen’s in-\nequality gives us\nE Œf .X/\u0002 \u0006 f .E ŒX\u0002/ ;\n(C.26)\nprovided that the expectations exist and are ﬁnite. (A function f .x/ is convex\nif for all x and y and for all 0 \u0002 \u0005 \u0002 1, we have f .\u0005x C .1 \u0005 \u0005/y/ \u0002\n\u0005f .x/ C .1 \u0005 \u0005/f .y/.)\nVariance and standard deviation\nThe expected value of a random variable does not tell us how “spread out” the\nvariable’s values are. For example, if we have random variables X and Y for which\nPr fX D 1=4g D Pr fX D 3=4g D 1=2 and Pr fY D 0g D Pr fY D 1g D 1=2,\nthen both E ŒX\u0002 and E ŒY \u0002 are 1=2, yet the actual values taken on by Y are farther\nfrom the mean than the actual values taken on by X.\nThe notion of variance mathematically expresses how far from the mean a ran-\ndom variable’s values are likely to be. The variance of a random variable X with\nmean E ŒX\u0002 is\nVar ŒX\u0002\nD\nE\n\u000f\n.X \u0005 E ŒX\u0002/2\u0010\nD\nE\n\u000f\nX 2 \u0005 2XE ŒX\u0002 C E2 ŒX\u0002\n\u0010\nD\nE\n\u000f\nX 2\u0010\n\u0005 2E ŒXE ŒX\u0002\u0002 C E2 ŒX\u0002\nD\nE\n\u000f\nX 2\u0010\n\u0005 2E2 ŒX\u0002 C E2 ŒX\u0002\nD\nE\n\u000f\nX 2\u0010\n\u0005 E2 ŒX\u0002 :\n(C.27)\nTo justify the equality E ŒE2 ŒX\u0002\u0002 D E2 ŒX\u0002, note that because E ŒX\u0002 is a real num-\nber and not a random variable, so is E2 ŒX\u0002. The equality E ŒXE ŒX\u0002\u0002 D E2 ŒX\u0002\n1200\nAppendix C\nCounting and Probability\nfollows from equation (C.22), with a D E ŒX\u0002. Rewriting equation (C.27) yields\nan expression for the expectation of the square of a random variable:\nE\n\u000f\nX 2\u0010\nD Var ŒX\u0002 C E2 ŒX\u0002 :\n(C.28)\nThe variance of a random variable X and the variance of aX are related (see\nExercise C.3-10):\nVar ŒaX\u0002 D a2Var ŒX\u0002 :\nWhen X and Y are independent random variables,\nVar ŒX C Y \u0002 D Var ŒX\u0002 C Var ŒY \u0002 :\nIn general, if n random variables X1; X2; : : : ; Xn are pairwise independent, then\nVar\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nVar ŒXi\u0002 :\n(C.29)\nThe standard deviation of a random variable X is the nonnegative square root",
    "parent_a610853e-6930-47d7-837d-6390206a6435": "When X and Y are independent random variables,\nVar ŒX C Y \u0002 D Var ŒX\u0002 C Var ŒY \u0002 :\nIn general, if n random variables X1; X2; : : : ; Xn are pairwise independent, then\nVar\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nVar ŒXi\u0002 :\n(C.29)\nThe standard deviation of a random variable X is the nonnegative square root\nof the variance of X. The standard deviation of a random variable X is sometimes\ndenoted \tX or simply \t when the random variable X is understood from context.\nWith this notation, the variance of X is denoted \t 2.\nExercises\nC.3-1\nSuppose we roll two ordinary, 6-sided dice. What is the expectation of the sum\nof the two values showing? What is the expectation of the maximum of the two\nvalues showing?\nC.3-2\nAn array AŒ1 : : n\u0002 contains n distinct numbers that are randomly ordered, with each\npermutation of the n numbers being equally likely. What is the expectation of the\nindex of the maximum element in the array? What is the expectation of the index\nof the minimum element in the array?\nC.3-3\nA carnival game consists of three dice in a cage. A player can bet a dollar on any\nof the numbers 1 through 6. The cage is shaken, and the payoff is as follows. If the\nplayer’s number doesn’t appear on any of the dice, he loses his dollar. Otherwise,\nif his number appears on exactly k of the three dice, for k D 1; 2; 3, he keeps his\ndollar and wins k more dollars. What is his expected gain from playing the carnival\ngame once?\nC.4\nThe geometric and binomial distributions\n1201\nC.3-4\nArgue that if X and Y are nonnegative random variables, then\nE Œmax.X; Y /\u0002 \u0002 E ŒX\u0002 C E ŒY \u0002 :\nC.3-5\n?\nLet X and Y be independent random variables. Prove that f .X/ and g.Y / are\nindependent for any choice of functions f and g.\nC.3-6\n?\nLet X be a nonnegative random variable, and suppose that E ŒX\u0002 is well deﬁned.\nProve Markov’s inequality:\nPr fX \u0006 tg \u0002 E ŒX\u0002 =t\n(C.30)\nfor all t > 0.\nC.3-7\n?\nLet S be a sample space, and let X and X 0 be random variables such that",
    "parent_3bf64366-b6bf-4c5e-bade-1b493ac07df7": "independent for any choice of functions f and g.\nC.3-6\n?\nLet X be a nonnegative random variable, and suppose that E ŒX\u0002 is well deﬁned.\nProve Markov’s inequality:\nPr fX \u0006 tg \u0002 E ŒX\u0002 =t\n(C.30)\nfor all t > 0.\nC.3-7\n?\nLet S be a sample space, and let X and X 0 be random variables such that\nX.s/ \u0006 X 0.s/ for all s 2 S. Prove that for any real constant t,\nPr fX \u0006 tg \u0006 Pr fX 0 \u0006 tg :\nC.3-8\nWhich is larger: the expectation of the square of a random variable, or the square\nof its expectation?\nC.3-9\nShow that for any random variable X that takes on only the values 0 and 1, we have\nVar ŒX\u0002 D E ŒX\u0002 E Œ1 \u0005 X\u0002.\nC.3-10\nProve that Var ŒaX\u0002 D a2Var ŒX\u0002 from the deﬁnition (C.27) of variance.\nC.4\nThe geometric and binomial distributions\nWe can think of a coin ﬂip as an instance of a Bernoulli trial, which is an experi-\nment with only two possible outcomes: success, which occurs with probability p,\nand failure, which occurs with probability q D 1\u0005p. When we speak of Bernoulli\ntrials collectively, we mean that the trials are mutually independent and, unless we\nspeciﬁcally say otherwise, that each has the same probability p for success. Two\n1202\nAppendix C\nCounting and Probability\n0.05\n0.10\n0.15\n0.20\n0.25\n1\n2\n3\n4\n5\n6\n7\n8\n9 10 11 12 13 14 15\n0.30\n0.35\nk\n\u00022\n3\n\u0003k\u00031 \u00021\n3\n\u0003\nFigure C.1\nA geometric distribution with probability p D 1=3 of success and a probability\nq D 1 \u0005 p of failure. The expectation of the distribution is 1=p D 3.\nimportant distributions arise from Bernoulli trials: the geometric distribution and\nthe binomial distribution.\nThe geometric distribution\nSuppose we have a sequence of Bernoulli trials, each with a probability p of suc-\ncess and a probability q D 1\u0005p of failure. How many trials occur before we obtain\na success? Let us deﬁne the random variable X be the number of trials needed to\nobtain a success. Then X has values in the range f1; 2; : : :g, and for k \u0006 1,\nPr fX D kg D qk\u00031p ;\n(C.31)",
    "parent_708cd608-0833-4a9b-81d8-6a8d9009bddf": "cess and a probability q D 1\u0005p of failure. How many trials occur before we obtain\na success? Let us deﬁne the random variable X be the number of trials needed to\nobtain a success. Then X has values in the range f1; 2; : : :g, and for k \u0006 1,\nPr fX D kg D qk\u00031p ;\n(C.31)\nsince we have k \u0005 1 failures before the one success. A probability distribution sat-\nisfying equation (C.31) is said to be a geometric distribution. Figure C.1 illustrates\nsuch a distribution.\nC.4\nThe geometric and binomial distributions\n1203\nAssuming that q < 1, we can calculate the expectation of a geometric distribu-\ntion using identity (A.8):\nE ŒX\u0002\nD\n1\nX\nkD1\nkqk\u00031p\nD\np\nq\n1\nX\nkD0\nkqk\nD\np\nq \u0003\nq\n.1 \u0005 q/2\nD\np\nq \u0003 q\np2\nD\n1=p :\n(C.32)\nThus, on average, it takes 1=p trials before we obtain a success, an intuitive result.\nThe variance, which can be calculated similarly, but using Exercise A.1-3, is\nVar ŒX\u0002 D q=p2 :\n(C.33)\nAs an example, suppose we repeatedly roll two dice until we obtain either a\nseven or an eleven. Of the 36 possible outcomes, 6 yield a seven and 2 yield an\neleven. Thus, the probability of success is p D 8=36 D 2=9, and we must roll\n1=p D 9=2 D 4:5 times on average to obtain a seven or eleven.\nThe binomial distribution\nHow many successes occur during n Bernoulli trials, where a success occurs with\nprobability p and a failure with probability q D 1 \u0005 p? Deﬁne the random vari-\nable X to be the number of successes in n trials. Then X has values in the range\nf0; 1; : : : ; ng, and for k D 0; 1; : : : ; n,\nPr fX D kg D\n \nn\nk\n!\npkqn\u0003k ;\n(C.34)\nsince there are\n\u000bn\nk\n\f\nways to pick which k of the n trials are successes, and the\nprobability that each occurs is pkqn\u0003k. A probability distribution satisfying equa-\ntion (C.34) is said to be a binomial distribution. For convenience, we deﬁne the\nfamily of binomial distributions using the notation\nb.kI n; p/ D\n \nn\nk\n!\npk.1 \u0005 p/n\u0003k :\n(C.35)\nFigure C.2 illustrates a binomial distribution. The name “binomial” comes from the",
    "parent_fd83f7ba-9109-4aae-b36b-78da9e10fe58": "tion (C.34) is said to be a binomial distribution. For convenience, we deﬁne the\nfamily of binomial distributions using the notation\nb.kI n; p/ D\n \nn\nk\n!\npk.1 \u0005 p/n\u0003k :\n(C.35)\nFigure C.2 illustrates a binomial distribution. The name “binomial” comes from the\nright-hand side of equation (C.34) being the kth term of the expansion of .p Cq/n.\nConsequently, since p C q D 1,\n1204\nAppendix C\nCounting and Probability\n0.05\n0.10\n0.15\n0.20\n0.25\nk\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9 10 11 12 13 14 15\nb (k; 15, 1/3)\nFigure C.2\nThe binomial distribution b.kI 15; 1=3/ resulting from n D 15 Bernoulli trials, each\nwith probability p D 1=3 of success. The expectation of the distribution is np D 5.\nn\nX\nkD0\nb.kI n; p/ D 1 ;\n(C.36)\nas axiom 2 of the probability axioms requires.\nWe can compute the expectation of a random variable having a binomial distri-\nbution from equations (C.8) and (C.36). Let X be a random variable that follows\nthe binomial distribution b.kI n; p/, and let q D 1 \u0005 p. By the deﬁnition of expec-\ntation, we have\nE ŒX\u0002\nD\nn\nX\nkD0\nk \u0003 Pr fX D kg\nD\nn\nX\nkD0\nk \u0003 b.kI n; p/\nD\nn\nX\nkD1\nk\n \nn\nk\n!\npkqn\u0003k\nD\nnp\nn\nX\nkD1\n \nn \u0005 1\nk \u0005 1\n!\npk\u00031qn\u0003k\n(by equation (C.8))\nD\nnp\nn\u00031\nX\nkD0\n \nn \u0005 1\nk\n!\npkq.n\u00031/\u0003k\nC.4\nThe geometric and binomial distributions\n1205\nD\nnp\nn\u00031\nX\nkD0\nb.kI n \u0005 1; p/\nD\nnp\n(by equation (C.36)) .\n(C.37)\nBy using the linearity of expectation, we can obtain the same result with sub-\nstantially less algebra. Let Xi be the random variable describing the number of\nsuccesses in the ith trial. Then E ŒXi\u0002 D p \u0003 1 C q \u0003 0 D p, and by linearity of\nexpectation (equation (C.21)), the expected number of successes for n trials is\nE ŒX\u0002\nD\nE\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nE ŒXi\u0002\nD\nn\nX\niD1\np\nD\nnp :\n(C.38)\nWe can use the same approach to calculate the variance of the distribution. Using\nequation (C.27), we have Var ŒXi\u0002 D E ŒX 2\ni \u0002 \u0005 E2 ŒXi\u0002. Since Xi only takes on the\nvalues 0 and 1, we have X 2\ni D Xi, which implies E ŒX 2\ni \u0002 D E ŒXi\u0002 D p. Hence,\nVar ŒXi\u0002 D p \u0005 p2 D p.1 \u0005 p/ D pq :\n(C.39)",
    "parent_75305f10-7e3b-4237-ad65-d95ceb796429": "(C.38)\nWe can use the same approach to calculate the variance of the distribution. Using\nequation (C.27), we have Var ŒXi\u0002 D E ŒX 2\ni \u0002 \u0005 E2 ŒXi\u0002. Since Xi only takes on the\nvalues 0 and 1, we have X 2\ni D Xi, which implies E ŒX 2\ni \u0002 D E ŒXi\u0002 D p. Hence,\nVar ŒXi\u0002 D p \u0005 p2 D p.1 \u0005 p/ D pq :\n(C.39)\nTo compute the variance of X, we take advantage of the independence of the n\ntrials; thus, by equation (C.29),\nVar ŒX\u0002\nD\nVar\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nVar ŒXi\u0002\nD\nn\nX\niD1\npq\nD\nnpq :\n(C.40)\nAs Figure C.2 shows, the binomial distribution b.kI n; p/ increases with k until\nit reaches the mean np, and then it decreases. We can prove that the distribution\nalways behaves in this manner by looking at the ratio of successive terms:\n1206\nAppendix C\nCounting and Probability\nb.kI n; p/\nb.k \u0005 1I n; p/\nD\n\u000bn\nk\n\f\npkqn\u0003k\n\u000b n\nk\u00031\n\f\npk\u00031qn\u0003kC1\nD\nnŠ.k \u0005 1/Š.n \u0005 k C 1/Šp\nkŠ.n \u0005 k/ŠnŠq\nD\n.n \u0005 k C 1/p\nkq\n(C.41)\nD\n1 C .n C 1/p \u0005 k\nkq\n:\nThis ratio is greater than 1 precisely when .n C 1/p \u0005 k is positive.\nConse-\nquently, b.kI n; p/ > b.k \u0005 1I n; p/ for k < .n C 1/p (the distribution increases),\nand b.kI n; p/ < b.k \u0005 1I n; p/ for k > .n C 1/p (the distribution decreases).\nIf k D .n C 1/p is an integer, then b.kI n; p/ D b.k \u0005 1I n; p/, and so the distri-\nbution then has two maxima: at k D .nC1/p and at k\u00051 D .nC1/p\u00051 D np \u0005 q.\nOtherwise, it attains a maximum at the unique integer k that lies in the range\nnp \u0005 q < k < .n C 1/p.\nThe following lemma provides an upper bound on the binomial distribution.\nLemma C.1\nLet n \u0006 0, let 0 < p < 1, let q D 1 \u0005 p, and let 0 \u0002 k \u0002 n. Then\nb.kI n; p/ \u0002\n\u0004np\nk\n\u0005k \u0004 nq\nn \u0005 k\n\u0005n\u0003k\n:\nProof\nUsing equation (C.6), we have\nb.kI n; p/\nD\n \nn\nk\n!\npkqn\u0003k\n\u0002\n\u0004n\nk\n\u0005k \u0004\nn\nn \u0005 k\n\u0005n\u0003k\npkqn\u0003k\nD\n\u0004np\nk\n\u0005k \u0004 nq\nn \u0005 k\n\u0005n\u0003k\n:\nExercises\nC.4-1\nVerify axiom 2 of the probability axioms for the geometric distribution.\nC.4-2\nHow many times on average must we ﬂip 6 fair coins before we obtain 3 heads\nand 3 tails?\nC.4\nThe geometric and binomial distributions\n1207\nC.4-3",
    "parent_dae1212a-4265-4be0-9628-35f75e1f72c7": "\u0004n\nk\n\u0005k \u0004\nn\nn \u0005 k\n\u0005n\u0003k\npkqn\u0003k\nD\n\u0004np\nk\n\u0005k \u0004 nq\nn \u0005 k\n\u0005n\u0003k\n:\nExercises\nC.4-1\nVerify axiom 2 of the probability axioms for the geometric distribution.\nC.4-2\nHow many times on average must we ﬂip 6 fair coins before we obtain 3 heads\nand 3 tails?\nC.4\nThe geometric and binomial distributions\n1207\nC.4-3\nShow that b.kI n; p/ D b.n \u0005 kI n; q/, where q D 1 \u0005 p.\nC.4-4\nShow that value of the maximum of the binomial distribution b.kI n; p/ is approx-\nimately 1=p2\u0006npq, where q D 1 \u0005 p.\nC.4-5\n?\nShow that the probability of no successes in n Bernoulli trials, each with probability\np D 1=n, is approximately 1=e. Show that the probability of exactly one success\nis also approximately 1=e.\nC.4-6\n?\nProfessor Rosencrantz ﬂips a fair coin n times, and so does Professor Guildenstern.\nShow that the probability that they get the same number of heads is\n\u000b2n\nn\n\f\n=4n. (Hint:\nFor Professor Rosencrantz, call a head a success; for Professor Guildenstern, call\na tail a success.) Use your argument to verify the identity\nn\nX\nkD0\n \nn\nk\n!2\nD\n \n2n\nn\n!\n:\nC.4-7\n?\nShow that for 0 \u0002 k \u0002 n,\nb.kI n; 1=2/ \u0002 2n H.k=n/\u0003n ;\nwhere H.x/ is the entropy function (C.7).\nC.4-8\n?\nConsider n Bernoulli trials, where for i D 1; 2; : : : ; n, the ith trial has probabil-\nity pi of success, and let X be the random variable denoting the total number of\nsuccesses. Let p \u0006 pi for all i D 1; 2; : : : ; n. Prove that for 1 \u0002 k \u0002 n,\nPr fX < kg \u0006\nk\u00031\nX\niD0\nb.iI n; p/ :\nC.4-9\n?\nLet X be the random variable for the total number of successes in a set A of n\nBernoulli trials, where the ith trial has a probability pi of success, and let X 0\nbe the random variable for the total number of successes in a second set A0 of n\nBernoulli trials, where the ith trial has a probability p0\ni \u0006 pi of success. Prove that\nfor 0 \u0002 k \u0002 n,\n1208\nAppendix C\nCounting and Probability\nPr fX 0 \u0006 kg \u0006 Pr fX \u0006 kg :\n(Hint: Show how to obtain the Bernoulli trials in A0 by an experiment involving\nthe trials of A, and use the result of Exercise C.3-7.)\n?\nC.5",
    "parent_f2aa485f-b9d6-47fa-86ad-7e7f7fcd9bed": "i \u0006 pi of success. Prove that\nfor 0 \u0002 k \u0002 n,\n1208\nAppendix C\nCounting and Probability\nPr fX 0 \u0006 kg \u0006 Pr fX \u0006 kg :\n(Hint: Show how to obtain the Bernoulli trials in A0 by an experiment involving\nthe trials of A, and use the result of Exercise C.3-7.)\n?\nC.5\nThe tails of the binomial distribution\nThe probability of having at least, or at most, k successes in n Bernoulli trials,\neach with probability p of success, is often of more interest than the probability of\nhaving exactly k successes. In this section, we investigate the tails of the binomial\ndistribution: the two regions of the distribution b.kI n; p/ that are far from the\nmean np. We shall prove several important bounds on (the sum of all terms in) a\ntail.\nWe ﬁrst provide a bound on the right tail of the distribution b.kI n; p/. We can\ndetermine bounds on the left tail by inverting the roles of successes and failures.\nTheorem C.2\nConsider a sequence of n Bernoulli trials, where success occurs with probability p.\nLet X be the random variable denoting the total number of successes. Then for\n0 \u0002 k \u0002 n, the probability of at least k successes is\nPr fX \u0006 kg\nD\nn\nX\niDk\nb.iI n; p/\n\u0002\n \nn\nk\n!\npk :\nProof\nFor S \u0007 f1; 2; : : : ; ng, we let AS denote the event that the ith trial is a\nsuccess for every i 2 S. Clearly Pr fASg D pk if jSj D k. We have\nPr fX \u0006 kg\nD\nPr fthere exists S \u0007 f1; 2; : : : ; ng W jSj D k and ASg\nD\nPr\n\u0011\n[\nS\u0007f1;2;:::;ngWjSjDk\nAS\n\u0012\n\u0002\nX\nS\u0007f1;2;:::;ngWjSjDk\nPr fASg\n(by inequality (C.19))\nD\n \nn\nk\n!\npk :\nC.5\nThe tails of the binomial distribution\n1209\nThe following corollary restates the theorem for the left tail of the binomial\ndistribution. In general, we shall leave it to you to adapt the proofs from one tail to\nthe other.\nCorollary C.3\nConsider a sequence of n Bernoulli trials, where success occurs with probabil-\nity p. If X is the random variable denoting the total number of successes, then for\n0 \u0002 k \u0002 n, the probability of at most k successes is\nPr fX \u0002 kg\nD\nk\nX\niD0\nb.iI n; p/\n\u0002\n \nn\nn \u0005 k\n!\n.1 \u0005 p/n\u0003k\nD",
    "parent_40c61af9-a80f-431d-bfa0-fcd8b53fb5b5": "Corollary C.3\nConsider a sequence of n Bernoulli trials, where success occurs with probabil-\nity p. If X is the random variable denoting the total number of successes, then for\n0 \u0002 k \u0002 n, the probability of at most k successes is\nPr fX \u0002 kg\nD\nk\nX\niD0\nb.iI n; p/\n\u0002\n \nn\nn \u0005 k\n!\n.1 \u0005 p/n\u0003k\nD\n \nn\nk\n!\n.1 \u0005 p/n\u0003k :\nOur next bound concerns the left tail of the binomial distribution. Its corollary\nshows that, far from the mean, the left tail diminishes exponentially.\nTheorem C.4\nConsider a sequence of n Bernoulli trials, where success occurs with probability p\nand failure with probability q D 1 \u0005 p. Let X be the random variable denoting the\ntotal number of successes. Then for 0 < k < np, the probability of fewer than k\nsuccesses is\nPr fX < kg\nD\nk\u00031\nX\niD0\nb.iI n; p/\n<\nkq\nnp \u0005 k b.kI n; p/ :\nProof\nWe bound the series Pk\u00031\niD0 b.iI n; p/ by a geometric series using the tech-\nnique from Section A.2, page 1151. For i D 1; 2; : : : ; k, we have from equa-\ntion (C.41),\nb.i \u0005 1I n; p/\nb.iI n; p/\nD\niq\n.n \u0005 i C 1/p\n<\niq\n.n \u0005 i/p\n\u0002\nkq\n.n \u0005 k/p :\n1210\nAppendix C\nCounting and Probability\nIf we let\nx\nD\nkq\n.n \u0005 k/p\n<\nkq\n.n \u0005 np/p\nD\nkq\nnqp\nD\nk\nnp\n<\n1 ;\nit follows that\nb.i \u0005 1I n; p/ < x b.iI n; p/\nfor 0 < i \u0002 k. Iteratively applying this inequality k \u0005 i times, we obtain\nb.iI n; p/ < xk\u0003i b.kI n; p/\nfor 0 \u0002 i < k, and hence\nk\u00031\nX\niD0\nb.iI n; p/\n<\nk\u00031\nX\niD0\nxk\u0003ib.kI n; p/\n<\nb.kI n; p/\n1\nX\niD0\nxi\nD\nx\n1 \u0005 x b.kI n; p/\nD\nkq\nnp \u0005 k b.kI n; p/ :\nCorollary C.5\nConsider a sequence of n Bernoulli trials, where success occurs with probability p\nand failure with probability q D 1 \u0005 p. Then for 0 < k \u0002 np=2, the probability of\nfewer than k successes is less than one half of the probability of fewer than k C 1\nsuccesses.\nProof\nBecause k \u0002 np=2, we have\nkq\nnp \u0005 k\n\u0002\n.np=2/q\nnp \u0005 .np=2/\nC.5\nThe tails of the binomial distribution\n1211\nD\n.np=2/q\nnp=2\n\u0002\n1 ;\n(C.42)\nsince q \u0002 1. Letting X be the random variable denoting the number of successes,",
    "parent_ef6388cc-1843-4303-acde-39daa303a56e": "successes.\nProof\nBecause k \u0002 np=2, we have\nkq\nnp \u0005 k\n\u0002\n.np=2/q\nnp \u0005 .np=2/\nC.5\nThe tails of the binomial distribution\n1211\nD\n.np=2/q\nnp=2\n\u0002\n1 ;\n(C.42)\nsince q \u0002 1. Letting X be the random variable denoting the number of successes,\nTheorem C.4 and inequality (C.42) imply that the probability of fewer than k suc-\ncesses is\nPr fX < kg D\nk\u00031\nX\niD0\nb.iI n; p/ < b.kI n; p/ :\nThus we have\nPr fX < kg\nPr fX < k C 1g\nD\nPk\u00031\niD0 b.iI n; p/\nPk\niD0 b.iI n; p/\nD\nPk\u00031\niD0 b.iI n; p/\nPk\u00031\niD0 b.iI n; p/ C b.kI n; p/\n<\n1=2 ;\nsince Pk\u00031\niD0 b.iI n; p/ < b.kI n; p/.\nBounds on the right tail follow similarly. Exercise C.5-2 asks you to prove them.\nCorollary C.6\nConsider a sequence of n Bernoulli trials, where success occurs with probability p.\nLet X be the random variable denoting the total number of successes. Then for\nnp < k < n, the probability of more than k successes is\nPr fX > kg\nD\nn\nX\niDkC1\nb.iI n; p/\n<\n.n \u0005 k/p\nk \u0005 np b.kI n; p/ :\nCorollary C.7\nConsider a sequence of n Bernoulli trials, where success occurs with probability p\nand failure with probability q D 1 \u0005 p. Then for .np C n/=2 < k < n, the\nprobability of more than k successes is less than one half of the probability of\nmore than k \u0005 1 successes.\nThe next theorem considers n Bernoulli trials, each with a probability pi of\nsuccess, for i D 1; 2; : : : ; n. As the subsequent corollary shows, we can use the\n1212\nAppendix C\nCounting and Probability\ntheorem to provide a bound on the right tail of the binomial distribution by setting\npi D p for each trial.\nTheorem C.8\nConsider a sequence of n Bernoulli trials, where in the ith trial, for i D 1; 2; : : : ; n,\nsuccess occurs with probability pi and failure occurs with probability qi D 1 \u0005 pi.\nLet X be the random variable describing the total number of successes, and let\n\r D E ŒX\u0002. Then for r > \r,\nPr fX \u0005 \r \u0006 rg \u0002\n\u0004\re\nr\n\u0005r\n:\nProof\nSince for any ˛ > 0, the function e˛x is strictly increasing in x,\nPr fX \u0005 \r \u0006 rg D Pr\n˚\ne˛.X\u0003\n/ \u0006 e˛r\n;\n(C.43)",
    "parent_a78b5aca-013d-4296-b71a-607d6942f9fd": "Let X be the random variable describing the total number of successes, and let\n\r D E ŒX\u0002. Then for r > \r,\nPr fX \u0005 \r \u0006 rg \u0002\n\u0004\re\nr\n\u0005r\n:\nProof\nSince for any ˛ > 0, the function e˛x is strictly increasing in x,\nPr fX \u0005 \r \u0006 rg D Pr\n˚\ne˛.X\u0003\n/ \u0006 e˛r\n;\n(C.43)\nwhere we will determine ˛ later. Using Markov’s inequality (C.30), we obtain\nPr\n˚\ne˛.X\u0003\n/ \u0006 e˛r\n\u0002 E\n\u000f\ne˛.X\u0003\n/\u0010\ne\u0003˛r :\n(C.44)\nThe bulk of the proof consists of bounding E\n\u000f\ne˛.X\u0003\n/\u0010\nand substituting a suit-\nable value for ˛ in inequality (C.44). First, we evaluate E\n\u000f\ne˛.X\u0003\n/\u0010\n. Using the\ntechnique of indicator random variables (see Section 5.2), let Xi D I fthe ith\nBernoulli trial is a successg for i D 1; 2; : : : ; n; that is, Xi is the random vari-\nable that is 1 if the ith Bernoulli trial is a success and 0 if it is a failure. Thus,\nX D\nn\nX\niD1\nXi ;\nand by linearity of expectation,\n\r D E ŒX\u0002 D E\n\" n\nX\niD1\nXi\n#\nD\nn\nX\niD1\nE ŒXi\u0002 D\nn\nX\niD1\npi ;\nwhich implies\nX \u0005 \r D\nn\nX\niD1\n.Xi \u0005 pi/ :\nTo evaluate E\n\u000f\ne˛.X\u0003\n/\u0010\n, we substitute for X \u0005 \r, obtaining\nE\n\u000f\ne˛.X\u0003\n/\u0010\nD\nE\n\u000f\ne˛ Pn\niD1.Xi \u0003pi/\u0010\nD\nE\n\" n\nY\niD1\ne˛.Xi \u0003pi/\n#\nD\nn\nY\niD1\nE\n\u000f\ne˛.Xi \u0003pi /\u0010\n;\nC.5\nThe tails of the binomial distribution\n1213\nwhich follows from (C.24), since the mutual independence of the random vari-\nables Xi implies the mutual independence of the random variables e˛.Xi \u0003pi / (see\nExercise C.3-5). By the deﬁnition of expectation,\nE\n\u000f\ne˛.Xi \u0003pi /\u0010\nD\ne˛.1\u0003pi /pi C e˛.0\u0003pi /qi\nD\npie˛qi C qie\u0003˛pi\n\u0002\npie˛ C 1\n(C.45)\n\u0002\nexp.pie˛/ ;\nwhere exp.x/ denotes the exponential function: exp.x/ D ex. (Inequality (C.45)\nfollows from the inequalities ˛ > 0, qi \u0002 1, e˛qi \u0002 e˛, and e\u0003˛pi \u0002 1, and the last\nline follows from inequality (3.12).) Consequently,\nE\n\u000f\ne˛.X\u0003\n/\u0010\nD\nn\nY\niD1\nE\n\u000f\ne˛.Xi \u0003pi /\u0010\n\u0002\nn\nY\niD1\nexp.pie˛/\nD\nexp\n n\nX\niD1\npie˛\n!\nD\nexp.\re˛/ ;\n(C.46)\nsince \r D Pn\niD1 pi. Therefore, from equation (C.43) and inequalities (C.44)\nand (C.46), it follows that\nPr fX \u0005 \r \u0006 rg \u0002 exp.\re˛ \u0005 ˛r/ :\n(C.47)\nChoosing ˛ D ln.r=\r/ (see Exercise C.5-7), we obtain\nPr fX \u0005 \r \u0006 rg\n\u0002\nexp.\reln.r=",
    "parent_538f9f68-541a-458c-b93f-f00dce758dbd": "\u0002\nn\nY\niD1\nexp.pie˛/\nD\nexp\n n\nX\niD1\npie˛\n!\nD\nexp.\re˛/ ;\n(C.46)\nsince \r D Pn\niD1 pi. Therefore, from equation (C.43) and inequalities (C.44)\nand (C.46), it follows that\nPr fX \u0005 \r \u0006 rg \u0002 exp.\re˛ \u0005 ˛r/ :\n(C.47)\nChoosing ˛ D ln.r=\r/ (see Exercise C.5-7), we obtain\nPr fX \u0005 \r \u0006 rg\n\u0002\nexp.\reln.r=\n/ \u0005 r ln.r=\r//\nD\nexp.r \u0005 r ln.r=\r//\nD\ner\n.r=\r/r\nD\n\u0004\re\nr\n\u0005r\n:\nWhen applied to Bernoulli trials in which each trial has the same probability of\nsuccess, Theorem C.8 yields the following corollary bounding the right tail of a\nbinomial distribution.\n1214\nAppendix C\nCounting and Probability\nCorollary C.9\nConsider a sequence of n Bernoulli trials, where in each trial success occurs with\nprobability p and failure occurs with probability q D 1 \u0005 p. Then for r > np,\nPr fX \u0005 np \u0006 rg\nD\nn\nX\nkDdnpCre\nb.kI n; p/\n\u0002\n\u0004npe\nr\n\u0005r\n:\nProof\nBy equation (C.37), we have \r D E ŒX\u0002 D np.\nExercises\nC.5-1\n?\nWhich is less likely: obtaining no heads when you ﬂip a fair coin n times, or\nobtaining fewer than n heads when you ﬂip the coin 4n times?\nC.5-2\n?\nProve Corollaries C.6 and C.7.\nC.5-3\n?\nShow that\nk\u00031\nX\niD0\n \nn\ni\n!\nai < .a C 1/n\nk\nna \u0005 k.a C 1/ b.kI n; a=.a C 1//\nfor all a > 0 and all k such that 0 < k < na=.a C 1/.\nC.5-4\n?\nProve that if 0 < k < np, where 0 < p < 1 and q D 1 \u0005 p, then\nk\u00031\nX\niD0\npiqn\u0003i <\nkq\nnp \u0005 k\n\u0004np\nk\n\u0005k \u0004 nq\nn \u0005 k\n\u0005n\u0003k\n:\nC.5-5\n?\nShow that the conditions of Theorem C.8 imply that\nPr f\r \u0005 X \u0006 rg \u0002\n\u0002.n \u0005 \r/e\nr\n\u0003r\n:\nSimilarly, show that the conditions of Corollary C.9 imply that\nPr fnp \u0005 X \u0006 rg \u0002\n\u0004nqe\nr\n\u0005r\n:\nProblems for Appendix C\n1215\nC.5-6\n?\nConsider a sequence of n Bernoulli trials, where in the ith trial, for i D 1; 2; : : : ; n,\nsuccess occurs with probability pi and failure occurs with probability qi D 1 \u0005 pi.\nLet X be the random variable describing the total number of successes, and let\n\r D E ŒX\u0002. Show that for r \u0006 0,\nPr fX \u0005 \r \u0006 rg \u0002 e\u0003r2=2n :\n(Hint: Prove that pie˛qi C qie\u0003˛pi \u0002 e˛2=2. Then follow the outline of the proof",
    "parent_27043157-9807-48f5-be6e-55ab40b9af59": "Let X be the random variable describing the total number of successes, and let\n\r D E ŒX\u0002. Show that for r \u0006 0,\nPr fX \u0005 \r \u0006 rg \u0002 e\u0003r2=2n :\n(Hint: Prove that pie˛qi C qie\u0003˛pi \u0002 e˛2=2. Then follow the outline of the proof\nof Theorem C.8, using this inequality in place of inequality (C.45).)\nC.5-7\n?\nShow that choosing ˛ D ln.r=\r/ minimizes the right-hand side of inequal-\nity (C.47).\nProblems\nC-1\nBalls and bins\nIn this problem, we investigate the effect of various assumptions on the number of\nways of placing n balls into b distinct bins.\na. Suppose that the n balls are distinct and that their order within a bin does not\nmatter. Argue that the number of ways of placing the balls in the bins is bn.\nb. Suppose that the balls are distinct and that the balls in each bin are ordered.\nProve that there are exactly .b C n \u0005 1/Š=.b \u0005 1/Š ways to place the balls in the\nbins. (Hint: Consider the number of ways of arranging n distinct balls and b\u00051\nindistinguishable sticks in a row.)\nc. Suppose that the balls are identical, and hence their order within a bin does not\nmatter. Show that the number of ways of placing the balls in the bins is\n\u000bbCn\u00031\nn\n\f\n.\n(Hint: Of the arrangements in part (b), how many are repeated if the balls are\nmade identical?)\nd. Suppose that the balls are identical and that no bin may contain more than one\nball, so that n \u0002 b. Show that the number of ways of placing the balls is\n\u000bb\nn\n\f\n.\ne. Suppose that the balls are identical and that no bin may be left empty. Assuming\nthat n \u0006 b, show that the number of ways of placing the balls is\n\u000bn\u00031\nb\u00031\n\f\n.\n1216\nAppendix C\nCounting and Probability\nAppendix notes\nThe ﬁrst general methods for solving probability problems were discussed in a\nfamous correspondence between B. Pascal and P. de Fermat, which began in 1654,\nand in a book by C. Huygens in 1657. Rigorous probability theory began with the\nwork of J. Bernoulli in 1713 and A. De Moivre in 1730. Further developments of",
    "parent_9cd82e42-e76b-4633-a7a7-818dd8eb5957": "famous correspondence between B. Pascal and P. de Fermat, which began in 1654,\nand in a book by C. Huygens in 1657. Rigorous probability theory began with the\nwork of J. Bernoulli in 1713 and A. De Moivre in 1730. Further developments of\nthe theory were provided by P.-S. Laplace, S.-D. Poisson, and C. F. Gauss.\nSums of random variables were originally studied by P. L. Chebyshev and A. A.\nMarkov. A. N. Kolmogorov axiomatized probability theory in 1933. Chernoff [66]\nand Hoeffding [173] provided bounds on the tails of distributions. Seminal work\nin random combinatorial structures was done by P. Erd¨os.\nKnuth [209] and Liu [237] are good references for elementary combinatorics\nand counting. Standard textbooks such as Billingsley [46], Chung [67], Drake [95],\nFeller [104], and Rozanov [300] offer comprehensive introductions to probability.\nD\nMatrices\nMatrices arise in numerous applications, including, but by no means limited to,\nscientiﬁc computing. If you have seen matrices before, much of the material in this\nappendix will be familiar to you, but some of it might be new. Section D.1 covers\nbasic matrix deﬁnitions and operations, and Section D.2 presents some basic matrix\nproperties.\nD.1\nMatrices and matrix operations\nIn this section, we review some basic concepts of matrix theory and some funda-\nmental properties of matrices.\nMatrices and vectors\nA matrix is a rectangular array of numbers. For example,\nA\nD\n\u0002 a11\na12\na13\na21\na22\na23\n\u0003\nD\n\u0002 1\n2\n3\n4\n5\n6\n\u0003\n(D.1)\nis a 2 \t 3 matrix A D .aij/, where for i D 1; 2 and j D 1; 2; 3, we denote the\nelement of the matrix in row i and column j by aij. We use uppercase letters\nto denote matrices and corresponding subscripted lowercase letters to denote their\nelements. We denote the set of all m\tn matrices with real-valued entries by Rm\bn\nand, in general, the set of m \t n matrices with entries drawn from a set S by S m\bn.\nThe transpose of a matrix A is the matrix AT obtained by exchanging the rows",
    "parent_906b38e2-dc79-4b44-9463-c1e28b9f2d23": "elements. We denote the set of all m\tn matrices with real-valued entries by Rm\bn\nand, in general, the set of m \t n matrices with entries drawn from a set S by S m\bn.\nThe transpose of a matrix A is the matrix AT obtained by exchanging the rows\nand columns of A. For the matrix A of equation (D.1),\n1218\nAppendix D\nMatrices\nAT D\n\u0005\n1\n4\n2\n5\n3\n6\n\u0006\n:\nA vector is a one-dimensional array of numbers. For example,\nx D\n\u0005\n2\n3\n5\n\u0006\nis a vector of size 3. We sometimes call a vector of length n an n-vector. We\nuse lowercase letters to denote vectors, and we denote the ith element of a size-n\nvector x by xi, for i D 1; 2; : : : ; n. We take the standard form of a vector to be\nas a column vector equivalent to an n \t 1 matrix; the corresponding row vector is\nobtained by taking the transpose:\nxT D . 2\n3\n5 / :\nThe unit vector ei is the vector whose ith element is 1 and all of whose other\nelements are 0. Usually, the size of a unit vector is clear from the context.\nA zero matrix is a matrix all of whose entries are 0. Such a matrix is often\ndenoted 0, since the ambiguity between the number 0 and a matrix of 0s is usually\neasily resolved from context. If a matrix of 0s is intended, then the size of the\nmatrix also needs to be derived from the context.\nSquare matrices\nSquare n \t n matrices arise frequently. Several special cases of square matrices\nare of particular interest:\n1. A diagonal matrix has aij D 0 whenever i ¤ j . Because all of the off-diagonal\nelements are zero, we can specify the matrix by listing the elements along the\ndiagonal:\ndiag.a11; a22; : : : ; ann/ D\n˙\na11\n0\n: : :\n0\n0\na22\n: : :\n0\n:::\n:::\n:::\n:::\n0\n0\n: : :\nann\n\u0007\n:\n2. The n \t n identity matrix In is a diagonal matrix with 1s along the diagonal:\nIn\nD\ndiag.1; 1; : : : ; 1/\nD\n˙\n1\n0\n: : :\n0\n0\n1\n: : :\n0\n:::\n:::\n:::\n:::\n0\n0\n: : :\n1\n\u0007\n:\nD.1\nMatrices and matrix operations\n1219\nWhen I appears without a subscript, we derive its size from the context. The ith\ncolumn of an identity matrix is the unit vector ei.",
    "parent_8ff12008-73ee-4b65-8d57-086b2c445e4a": "In\nD\ndiag.1; 1; : : : ; 1/\nD\n˙\n1\n0\n: : :\n0\n0\n1\n: : :\n0\n:::\n:::\n:::\n:::\n0\n0\n: : :\n1\n\u0007\n:\nD.1\nMatrices and matrix operations\n1219\nWhen I appears without a subscript, we derive its size from the context. The ith\ncolumn of an identity matrix is the unit vector ei.\n3. A tridiagonal matrix T is one for which tij D 0 if ji \u0005 j j > 1. Nonzero entries\nappear only on the main diagonal, immediately above the main diagonal (ti;iC1\nfor i D 1; 2; : : : ; n \u0005 1), or immediately below the main diagonal (tiC1;i for\ni D 1; 2; : : : ; n \u0005 1):\nT D\n\u0002\nt11\nt12\n0\n0\n: : :\n0\n0\n0\nt21\nt22\nt23\n0\n: : :\n0\n0\n0\n0\nt32\nt33\nt34\n: : :\n0\n0\n0\n:::\n:::\n:::\n:::\n:::\n:::\n:::\n:::\n0\n0\n0\n0\n: : :\ntn\u00032;n\u00032\ntn\u00032;n\u00031\n0\n0\n0\n0\n0\n: : :\ntn\u00031;n\u00032\ntn\u00031;n\u00031\ntn\u00031;n\n0\n0\n0\n0\n: : :\n0\ntn;n\u00031\ntnn\n˘\n:\n4. An upper-triangular matrix U is one for which uij D 0 if i > j . All entries\nbelow the diagonal are zero:\nU D\n˙\nu11\nu12\n: : :\nu1n\n0\nu22\n: : :\nu2n\n:::\n:::\n:::\n:::\n0\n0\n: : :\nunn\n\u0007\n:\nAn upper-triangular matrix is unit upper-triangular if it has all 1s along the\ndiagonal.\n5. A lower-triangular matrix L is one for which lij D 0 if i < j . All entries\nabove the diagonal are zero:\nL D\n˙\nl11\n0\n: : :\n0\nl21\nl22\n: : :\n0\n:::\n:::\n:::\n:::\nln1\nln2\n: : :\nlnn\n\u0007\n:\nA lower-triangular matrix is unit lower-triangular if it has all 1s along the\ndiagonal.\n1220\nAppendix D\nMatrices\n6. A permutation matrix P has exactly one 1 in each row or column, and 0s\nelsewhere. An example of a permutation matrix is\nP D\nˇ\n0\n1\n0\n0\n0\n0\n0\n0\n1\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n1\n0\n0\n\u0003\n:\nSuch a matrix is called a permutation matrix because multiplying a vector x\nby a permutation matrix has the effect of permuting (rearranging) the elements\nof x. Exercise D.1-4 explores additional properties of permutation matrices.\n7. A symmetric matrix A satisﬁes the condition A D AT. For example,\n\u0005\n1\n2\n3\n2\n6\n4\n3\n4\n5\n\u0006\nis a symmetric matrix.\nBasic matrix operations\nThe elements of a matrix or vector are numbers from a number system, such as",
    "parent_9a2908d4-21ad-4d22-961d-c6075eb0fd0b": "of x. Exercise D.1-4 explores additional properties of permutation matrices.\n7. A symmetric matrix A satisﬁes the condition A D AT. For example,\n\u0005\n1\n2\n3\n2\n6\n4\n3\n4\n5\n\u0006\nis a symmetric matrix.\nBasic matrix operations\nThe elements of a matrix or vector are numbers from a number system, such as\nthe real numbers, the complex numbers, or integers modulo a prime. The number\nsystem deﬁnes how to add and multiply numbers. We can extend these deﬁnitions\nto encompass addition and multiplication of matrices.\nWe deﬁne matrix addition as follows. If A D .aij/ and B D .bij/ are m \t n\nmatrices, then their matrix sum C D .cij/ D ACB is the m\tn matrix deﬁned by\ncij D aij C bij\nfor i D 1; 2; : : : ; m and j D 1; 2; : : : ; n. That is, matrix addition is performed\ncomponentwise. A zero matrix is the identity for matrix addition:\nA C 0 D A D 0 C A :\nIf \u0005 is a number and A D .aij/ is a matrix, then \u0005A D .\u0005aij/ is the scalar\nmultiple of A obtained by multiplying each of its elements by \u0005. As a special case,\nwe deﬁne the negative of a matrix A D .aij/ to be \u00051 \u0003 A D \u0005A, so that the ij th\nentry of \u0005A is \u0005aij. Thus,\nA C .\u0005A/ D 0 D .\u0005A/ C A :\nD.1\nMatrices and matrix operations\n1221\nWe use the negative of a matrix to deﬁne matrix subtraction: A \u0005 B D A C .\u0005B/.\nWe deﬁne matrix multiplication as follows. We start with two matrices A and B\nthat are compatible in the sense that the number of columns of A equals the number\nof rows of B. (In general, an expression containing a matrix product AB is always\nassumed to imply that matrices A and B are compatible.) If A D .aik/ is an m \t n\nmatrix and B D .bkj/ is an n \t p matrix, then their matrix product C D AB is the\nm \t p matrix C D .cij/, where\ncij D\nn\nX\nkD1\naikbkj\n(D.2)\nfor i D 1; 2; : : : ; m and j D 1; 2; : : : ; p. The procedure SQUARE-MATRIX-\nMULTIPLY in Section 4.2 implements matrix multiplication in the straightfor-\nward manner based on equation (D.2), assuming that the matrices are square:\nm D n D p.",
    "parent_6e63fa87-5f48-4785-9851-5f9ff0ff23ea": "m \t p matrix C D .cij/, where\ncij D\nn\nX\nkD1\naikbkj\n(D.2)\nfor i D 1; 2; : : : ; m and j D 1; 2; : : : ; p. The procedure SQUARE-MATRIX-\nMULTIPLY in Section 4.2 implements matrix multiplication in the straightfor-\nward manner based on equation (D.2), assuming that the matrices are square:\nm D n D p.\nTo multiply n \t n matrices, SQUARE-MATRIX-MULTIPLY per-\nforms n3 multiplications and n2.n \u0005 1/ additions, and so its running time is ‚.n3/.\nMatrices have many (but not all) of the algebraic properties typical of numbers.\nIdentity matrices are identities for matrix multiplication:\nImA D AIn D A\nfor any m \t n matrix A. Multiplying by a zero matrix gives a zero matrix:\nA 0 D 0 :\nMatrix multiplication is associative:\nA.BC/ D .AB/C\nfor compatible matrices A, B, and C. Matrix multiplication distributes over addi-\ntion:\nA.B C C/\nD\nAB C AC ;\n.B C C/D\nD\nBD C CD :\nFor n > 1, multiplication of n \t n matrices is not commutative. For example, if\nA D\n\u0002 0\n1\n0\n0\n\u0003\nand B D\n\u0002 0\n0\n1\n0\n\u0003\n, then\nAB D\n\u0002 1\n0\n0\n0\n\u0003\nand\nBA D\n\u0002 0\n0\n0\n1\n\u0003\n:\n1222\nAppendix D\nMatrices\nWe deﬁne matrix-vector products or vector-vector products as if the vector were\nthe equivalent n \t 1 matrix (or a 1 \t n matrix, in the case of a row vector). Thus,\nif A is an m \t n matrix and x is an n-vector, then Ax is an m-vector. If x and y\nare n-vectors, then\nxTy D\nn\nX\niD1\nxiyi\nis a number (actually a 1 \t 1 matrix) called the inner product of x and y. The ma-\ntrix xyT is an n\tn matrix Z called the outer product of x and y, with ´ij D xiyj.\nThe (euclidean) norm kxk of an n-vector x is deﬁned by\nkxk\nD\n.x2\n1 C x2\n2 C \u0003 \u0003 \u0003 C x2\nn/1=2\nD\n.xTx/1=2 :\nThus, the norm of x is its length in n-dimensional euclidean space.\nExercises\nD.1-1\nShow that if A and B are symmetric n \t n matrices, then so are A C B and A \u0005 B.\nD.1-2\nProve that .AB/T D BTAT and that ATA is always a symmetric matrix.\nD.1-3\nProve that the product of two lower-triangular matrices is lower-triangular.\nD.1-4",
    "parent_f9a635d2-ac9c-443a-8b08-88e7175b7dc3": "Exercises\nD.1-1\nShow that if A and B are symmetric n \t n matrices, then so are A C B and A \u0005 B.\nD.1-2\nProve that .AB/T D BTAT and that ATA is always a symmetric matrix.\nD.1-3\nProve that the product of two lower-triangular matrices is lower-triangular.\nD.1-4\nProve that if P is an n \t n permutation matrix and A is an n \t n matrix, then the\nmatrix product PA is A with its rows permuted, and the matrix product AP is A\nwith its columns permuted. Prove that the product of two permutation matrices is\na permutation matrix.\nD.2\nBasic matrix properties\nIn this section, we deﬁne some basic properties pertaining to matrices: inverses,\nlinear dependence and independence, rank, and determinants. We also deﬁne the\nclass of positive-deﬁnite matrices.\nD.2\nBasic matrix properties\n1223\nMatrix inverses, ranks, and determinants\nWe deﬁne the inverse of an n \t n matrix A to be the n \t n matrix, denoted A\u00031 (if\nit exists), such that AA\u00031 D In D A\u00031A. For example,\n\u0002 1\n1\n1\n0\n\u0003\u00031\nD\n\u0002 0\n1\n1\n\u00051\n\u0003\n:\nMany nonzero n \t n matrices do not have inverses. A matrix without an inverse is\ncalled noninvertible, or singular. An example of a nonzero singular matrix is\n\u0002 1\n0\n1\n0\n\u0003\n:\nIf a matrix has an inverse, it is called invertible, or nonsingular. Matrix inverses,\nwhen they exist, are unique. (See Exercise D.2-1.) If A and B are nonsingular\nn \t n matrices, then\n.BA/\u00031 D A\u00031B\u00031 :\nThe inverse operation commutes with the transpose operation:\n.A\u00031/T D .AT/\u00031 :\nThe vectors x1; x2; : : : ; xn are linearly dependent if there exist coefﬁcients\nc1; c2; : : : ; cn, not all of which are zero, such that c1x1 C c2x2 C \u0003 \u0003 \u0003 C cnxn D 0.\nThe row vectors x1 D . 1\n2\n3 /, x2 D . 2\n6\n4 /, and x3 D . 4\n11\n9 / are\nlinearly dependent, for example, since 2x1 C 3x2 \u0005 2x3 D 0. If vectors are not\nlinearly dependent, they are linearly independent. For example, the columns of an\nidentity matrix are linearly independent.\nThe column rank of a nonzero m \t n matrix A is the size of the largest set",
    "parent_8a1f1038-a7fc-497e-b981-01b8d1f0bb09": "11\n9 / are\nlinearly dependent, for example, since 2x1 C 3x2 \u0005 2x3 D 0. If vectors are not\nlinearly dependent, they are linearly independent. For example, the columns of an\nidentity matrix are linearly independent.\nThe column rank of a nonzero m \t n matrix A is the size of the largest set\nof linearly independent columns of A. Similarly, the row rank of A is the size\nof the largest set of linearly independent rows of A. A fundamental property of\nany matrix A is that its row rank always equals its column rank, so that we can\nsimply refer to the rank of A. The rank of an m \t n matrix is an integer between 0\nand min.m; n/, inclusive. (The rank of a zero matrix is 0, and the rank of an n \t n\nidentity matrix is n.) An alternate, but equivalent and often more useful, deﬁnition\nis that the rank of a nonzero m \t n matrix A is the smallest number r such that\nthere exist matrices B and C of respective sizes m \t r and r \t n such that\nA D BC :\nA square n \t n matrix has full rank if its rank is n. An m \t n matrix has full\ncolumn rank if its rank is n. The following theorem gives a fundamental property\nof ranks.\n1224\nAppendix D\nMatrices\nTheorem D.1\nA square matrix has full rank if and only if it is nonsingular.\nA null vector for a matrix A is a nonzero vector x such that Ax D 0. The\nfollowing theorem (whose proof is left as Exercise D.2-7) and its corollary relate\nthe notions of column rank and singularity to null vectors.\nTheorem D.2\nA matrix A has full column rank if and only if it does not have a null vector.\nCorollary D.3\nA square matrix A is singular if and only if it has a null vector.\nThe ij th minor of an n\tn matrix A, for n > 1, is the .n\u00051/\t.n\u00051/ matrix AŒij\u0004\nobtained by deleting the ith row and j th column of A. We deﬁne the determinant\nof an n \t n matrix A recursively in terms of its minors by\ndet.A/ D\n‚\na11\nif n D 1 ;\nn\nX\njD1\n.\u00051/1Cja1j det.AŒ1j\u0004/\nif n > 1 :\nThe term .\u00051/iCj det.AŒij\u0004/ is known as the cofactor of the element aij.",
    "parent_050b6bb4-4315-49f4-89ef-14a3ba2de03e": "obtained by deleting the ith row and j th column of A. We deﬁne the determinant\nof an n \t n matrix A recursively in terms of its minors by\ndet.A/ D\n‚\na11\nif n D 1 ;\nn\nX\njD1\n.\u00051/1Cja1j det.AŒ1j\u0004/\nif n > 1 :\nThe term .\u00051/iCj det.AŒij\u0004/ is known as the cofactor of the element aij.\nThe following theorems, whose proofs are omitted here, express fundamental\nproperties of the determinant.\nTheorem D.4 (Determinant properties)\nThe determinant of a square matrix A has the following properties:\n\u0002\nIf any row or any column of A is zero, then det.A/ D 0.\n\u0002\nThe determinant of A is multiplied by \u0005 if the entries of any one row (or any\none column) of A are all multiplied by \u0005.\n\u0002\nThe determinant of A is unchanged if the entries in one row (respectively, col-\numn) are added to those in another row (respectively, column).\n\u0002\nThe determinant of A equals the determinant of AT.\n\u0002\nThe determinant of A is multiplied by \u00051 if any two rows (or any two columns)\nare exchanged.\nAlso, for any square matrices A and B, we have det.AB/ D det.A/ det.B/.\nD.2\nBasic matrix properties\n1225\nTheorem D.5\nAn n \t n matrix A is singular if and only if det.A/ D 0.\nPositive-deﬁnite matrices\nPositive-deﬁnite matrices play an important role in many applications. An n \t n\nmatrix A is positive-deﬁnite if xTAx\n> 0 for all n-vectors x\n¤ 0.\nFor\nexample, the identity matrix is positive-deﬁnite, since for any nonzero vector\nx D . x1\nx2\n\u0003 \u0003 \u0003\nxn /T,\nxTInx\nD\nxTx\nD\nn\nX\niD1\nx2\ni\n>\n0 :\nMatrices that arise in applications are often positive-deﬁnite due to the following\ntheorem.\nTheorem D.6\nFor any matrix A with full column rank, the matrix ATA is positive-deﬁnite.\nProof\nWe must show that xT.ATA/x > 0 for any nonzero vector x. For any\nvector x,\nxT.ATA/x\nD\n.Ax/T.Ax/\n(by Exercise D.1-2)\nD\nkAxk2 :\nNote that kAxk2 is just the sum of the squares of the elements of the vector Ax.\nTherefore, kAxk2 \u0006 0. If kAxk2 D 0, every element of Ax is 0, which is to say\nAx D 0. Since A has full column rank, Ax D 0 implies x D 0, by Theorem D.2.",
    "parent_b0bedc6b-d27d-49d6-b480-c74e78871ab3": "vector x,\nxT.ATA/x\nD\n.Ax/T.Ax/\n(by Exercise D.1-2)\nD\nkAxk2 :\nNote that kAxk2 is just the sum of the squares of the elements of the vector Ax.\nTherefore, kAxk2 \u0006 0. If kAxk2 D 0, every element of Ax is 0, which is to say\nAx D 0. Since A has full column rank, Ax D 0 implies x D 0, by Theorem D.2.\nHence, ATA is positive-deﬁnite.\nSection 28.3 explores other properties of positive-deﬁnite matrices.\nExercises\nD.2-1\nProve that matrix inverses are unique, that is, if B and C are inverses of A, then\nB D C.\nD.2-2\nProve that the determinant of a lower-triangular or upper-triangular matrix is equal\nto the product of its diagonal elements. Prove that the inverse of a lower-triangular\nmatrix, if it exists, is lower-triangular.\n1226\nAppendix D\nMatrices\nD.2-3\nProve that if P is a permutation matrix, then P is invertible, its inverse is P T,\nand P T is a permutation matrix.\nD.2-4\nLet A and B be n \t n matrices such that AB D I. Prove that if A0 is obtained\nfrom A by adding row j into row i, then subtracting column i from column j of B\nyields the inverse B0 of A0.\nD.2-5\nLet A be a nonsingular n \t n matrix with complex entries. Show that every entry\nof A\u00031 is real if and only if every entry of A is real.\nD.2-6\nShow that if A is a nonsingular, symmetric, n \t n matrix, then A\u00031 is symmetric.\nShow that if B is an arbitrary m \t n matrix, then the m \t m matrix given by the\nproduct BABT is symmetric.\nD.2-7\nProve Theorem D.2. That is, show that a matrix A has full column rank if and only\nif Ax D 0 implies x D 0. (Hint: Express the linear dependence of one column on\nthe others as a matrix-vector equation.)\nD.2-8\nProve that for any two compatible matrices A and B,\nrank.AB/ \u0002 min.rank.A/; rank.B// ;\nwhere equality holds if either A or B is a nonsingular square matrix. (Hint: Use\nthe alternate deﬁnition of the rank of a matrix.)\nProblems\nD-1\nVandermonde matrix\nGiven numbers x0; x1; : : : ; xn\u00031, prove that the determinant of the Vandermonde\nmatrix\nV.x0; x1; : : : ; xn\u00031/ D\n˙ 1\nx0\nx2\n0\n\u0003 \u0003 \u0003\nxn\u00031",
    "parent_b0dd45d1-ec55-4bff-8ddf-31cfa21a14d9": "the alternate deﬁnition of the rank of a matrix.)\nProblems\nD-1\nVandermonde matrix\nGiven numbers x0; x1; : : : ; xn\u00031, prove that the determinant of the Vandermonde\nmatrix\nV.x0; x1; : : : ; xn\u00031/ D\n˙ 1\nx0\nx2\n0\n\u0003 \u0003 \u0003\nxn\u00031\n0\n1\nx1\nx2\n1\n\u0003 \u0003 \u0003\nxn\u00031\n1\n:::\n:::\n:::\n:::\n:::\n1\nxn\u00031\nx2\nn\u00031\n\u0003 \u0003 \u0003\nxn\u00031\nn\u00031\n\u0007\nProblems for Appendix D\n1227\nis\ndet.V.x0; x1; : : : ; xn\u00031// D\nY\n0\u0005j<k\u0005n\u00031\n.xk \u0005 xj/ :\n(Hint: Multiply column i by \u0005x0 and add it to column i C 1 for i D n \u0005 1;\nn \u0005 2; : : : ; 1, and then use induction.)\nD-2\nPermutations deﬁned by matrix-vector multiplication over GF.2/\nOne class of permutations of the integers in the set Sn D f0; 1; 2; : : : ; 2n \u0005 1g is\ndeﬁned by matrix multiplication over GF.2/. For each integer x in Sn, we view its\nbinary representation as an n-bit vector\n\u0003\nx0\nx1\nx2\n:::\nxn\u00031\n\u0004\n;\nwhere x D Pn\u00031\niD0 xi2i. If A is an n \t n matrix in which each entry is either 0\nor 1, then we can deﬁne a permutation mapping each value x in Sn to the number\nwhose binary representation is the matrix-vector product Ax. Here, we perform\nall arithmetic over GF.2/: all values are either 0 or 1, and with one exception the\nusual rules of addition and multiplication apply. The exception is that 1 C 1 D 0.\nYou can think of arithmetic over GF.2/ as being just like regular integer arithmetic,\nexcept that you use only the least signiﬁcant bit.\nAs an example, for S2 D f0; 1; 2; 3g, the matrix\nA D\n\u0002 1\n0\n1\n1\n\u0003\ndeﬁnes the following permutation \u0006A: \u0006A.0/ D 0, \u0006A.1/ D 3, \u0006A.2/ D 2,\n\u0006A.3/ D 1. To see why \u0006A.3/ D 1, observe that, working in GF.2/,\n\u0006A.3/\nD\n\u0002 1\n0\n1\n1\n\u0003\u0002 1\n1\n\u0003\nD\n\u0002 1 \u0003 1 C 0 \u0003 1\n1 \u0003 1 C 1 \u0003 1\n\u0003\nD\n\u0002 1\n0\n\u0003\n;\nwhich is the binary representation of 1.\n1228\nAppendix D\nMatrices\nFor the remainder of this problem, we work over GF.2/, and all matrix and\nvector entries are 0 or 1. We deﬁne the rank of a 0-1 matrix (a matrix for which\neach entry is either 0 or 1) over GF.2/ the same as for a regular matrix, but with all",
    "parent_fd430962-365e-41a3-b323-15fddde937c3": "1228\nAppendix D\nMatrices\nFor the remainder of this problem, we work over GF.2/, and all matrix and\nvector entries are 0 or 1. We deﬁne the rank of a 0-1 matrix (a matrix for which\neach entry is either 0 or 1) over GF.2/ the same as for a regular matrix, but with all\narithmetic that determines linear independence performed over GF.2/. We deﬁne\nthe range of an n \t n 0-1 matrix A by\nR.A/ D fy W y D Ax for some x 2 Sng ;\nso that R.A/ is the set of numbers in Sn that we can produce by multiplying each\nvalue x in Sn by A.\na. If r is the rank of matrix A, prove that jR.A/j D 2r. Conclude that A deﬁnes a\npermutation on Sn only if A has full rank.\nFor a given n \t n matrix A and a given value y 2 R.A/, we deﬁne the preimage\nof y by\nP .A; y/ D fx W Ax D yg ;\nso that P .A; y/ is the set of values in Sn that map to y when multiplied by A.\nb. If r is the rank of n \t n matrix A and y 2 R.A/, prove that jP .A; y/j D 2n\u0003r.\nLet 0 \u0002 m \u0002 n, and suppose we partition the set Sn into blocks of consec-\nutive numbers, where the ith block consists of the 2m numbers i2m; i2m C 1;\ni2m C 2; : : : ; .i C 1/2m \u0005 1. For any subset S \u0007 Sn, deﬁne B.S; m/ to be the\nset of size-2m blocks of Sn containing some element of S. As an example, when\nn D 3, m D 1, and S D f1; 4; 5g, then B.S; m/ consists of blocks 0 (since 1 is in\nthe 0th block) and 2 (since both 4 and 5 are in block 2).\nc. Let r be the rank of the lower left .n \u0005 m/ \t m submatrix of A, that is, the\nmatrix formed by taking the intersection of the bottom n \u0005 m rows and the\nleftmost m columns of A. Let S be any size-2m block of Sn, and let S 0 D\nfy W y D Ax for some x 2 Sg. Prove that jB.S 0; m/j D 2r and that for each\nblock in B.S 0; m/, exactly 2m\u0003r numbers in S map to that block.\nBecause multiplying the zero vector by any matrix yields a zero vector, the set\nof permutations of Sn deﬁned by multiplying by n \t n 0-1 matrices with full rank\nover GF.2/ cannot include all permutations of Sn. Let us extend the class of per-",
    "parent_30840e1e-833b-4fd7-8a52-89962f53d6ef": "Because multiplying the zero vector by any matrix yields a zero vector, the set\nof permutations of Sn deﬁned by multiplying by n \t n 0-1 matrices with full rank\nover GF.2/ cannot include all permutations of Sn. Let us extend the class of per-\nmutations deﬁned by matrix-vector multiplication to include an additive term, so\nthat x 2 Sn maps to Ax C c, where c is an n-bit vector and addition is performed\nover GF.2/. For example, when\nA D\n\u0002 1\n0\n1\n1\n\u0003\nNotes for Appendix D\n1229\nand\nc D\n\u0002 0\n1\n\u0003\n;\nwe get the following permutation \u0006A;c: \u0006A;c.0/ D 2, \u0006A;c.1/ D 1, \u0006A;c.2/ D 0,\n\u0006A;c.3/ D 3. We call any permutation that maps x 2 Sn to Ax C c, for some n \t n\n0-1 matrix A with full rank and some n-bit vector c, a linear permutation.\nd. Use a counting argument to show that the number of linear permutations of Sn\nis much less than the number of permutations of Sn.\ne. Give an example of a value of n and a permutation of Sn that cannot be achieved\nby any linear permutation. (Hint: For a given permutation, think about how\nmultiplying a matrix by a unit vector relates to the columns of the matrix.)\nAppendix notes\nLinear-algebra textbooks provide plenty of background information on matrices.\nThe books by Strang [323, 324] are particularly good.\nBibliography\n[1] Milton Abramowitz and Irene A. Stegun, editors. Handbook of Mathematical Functions.\nDover, 1965.\n[2] G. M. Adel’son-Vel’ski˘ı and E. M. Landis. An algorithm for the organization of information.\nSoviet Mathematics Doklady, 3(5):1259–1263, 1962.\n[3] Alok Aggarwal and Jeffrey Scott Vitter. The input/output complexity of sorting and related\nproblems. Communications of the ACM, 31(9):1116–1127, 1988.\n[4] Manindra Agrawal, Neeraj Kayal, and Nitin Saxena.\nPRIMES is in P. Annals of Mathe-\nmatics, 160(2):781–793, 2004.\n[5] Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman.\nThe Design and Analysis of\nComputer Algorithms. Addison-Wesley, 1974.\n[6] Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. Data Structures and Algorithms.",
    "parent_7b7142e8-a071-474d-bde6-e7e08c076d2e": "PRIMES is in P. Annals of Mathe-\nmatics, 160(2):781–793, 2004.\n[5] Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman.\nThe Design and Analysis of\nComputer Algorithms. Addison-Wesley, 1974.\n[6] Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. Data Structures and Algorithms.\nAddison-Wesley, 1983.\n[7] Ravindra K. Ahuja, Thomas L. Magnanti, and James B. Orlin. Network Flows: Theory,\nAlgorithms, and Applications. Prentice Hall, 1993.\n[8] Ravindra K. Ahuja, Kurt Mehlhorn, James B. Orlin, and Robert E. Tarjan. Faster algorithms\nfor the shortest path problem. Journal of the ACM, 37:213–223, 1990.\n[9] Ravindra K. Ahuja and James B. Orlin. A fast and simple algorithm for the maximum ﬂow\nproblem. Operations Research, 37(5):748–759, 1989.\n[10] Ravindra K. Ahuja, James B. Orlin, and Robert E. Tarjan. Improved time bounds for the\nmaximum ﬂow problem. SIAM Journal on Computing, 18(5):939–954, 1989.\n[11] Mikl´os Ajtai, Nimrod Megiddo, and Orli Waarts. Improved algorithms and analysis for\nsecretary problems and generalizations. In Proceedings of the 36th Annual Symposium on\nFoundations of Computer Science, pages 473–482, 1995.\n[12] Selim G. Akl. The Design and Analysis of Parallel Algorithms. Prentice Hall, 1989.\n[13] Mohamad Akra and Louay Bazzi. On the solution of linear recurrence equations. Compu-\ntational Optimization and Applications, 10(2):195–210, 1998.\n[14] Noga Alon. Generating pseudo-random permutations and maximum ﬂow algorithms. In-\nformation Processing Letters, 35:201–204, 1990.\n1232\nBibliography\n[15] Arne Andersson. Balanced search trees made simple. In Proceedings of the Third Workshop\non Algorithms and Data Structures, volume 709 of Lecture Notes in Computer Science,\npages 60–71. Springer, 1993.\n[16] Arne Andersson. Faster deterministic sorting and searching in linear space. In Proceedings\nof the 37th Annual Symposium on Foundations of Computer Science, pages 135–141, 1996.",
    "parent_9cd6fcf9-56bf-4382-99bf-63970562b0ff": "on Algorithms and Data Structures, volume 709 of Lecture Notes in Computer Science,\npages 60–71. Springer, 1993.\n[16] Arne Andersson. Faster deterministic sorting and searching in linear space. In Proceedings\nof the 37th Annual Symposium on Foundations of Computer Science, pages 135–141, 1996.\n[17] Arne Andersson, Torben Hagerup, Stefan Nilsson, and Rajeev Raman. Sorting in linear\ntime? Journal of Computer and System Sciences, 57:74–93, 1998.\n[18] Tom M. Apostol. Calculus, volume 1. Blaisdell Publishing Company, second edition, 1967.\n[19] Nimar S. Arora, Robert D. Blumofe, and C. Greg Plaxton. Thread scheduling for multipro-\ngrammed multiprocessors. In Proceedings of the 10th Annual ACM Symposium on Parallel\nAlgorithms and Architectures, pages 119–129, 1998.\n[20] Sanjeev Arora. Probabilistic checking of proofs and the hardness of approximation prob-\nlems. PhD thesis, University of California, Berkeley, 1994.\n[21] Sanjeev Arora.\nThe approximability of NP-hard problems.\nIn Proceedings of the 30th\nAnnual ACM Symposium on Theory of Computing, pages 337–348, 1998.\n[22] Sanjeev Arora. Polynomial time approximation schemes for euclidean traveling salesman\nand other geometric problems. Journal of the ACM, 45(5):753–782, 1998.\n[23] Sanjeev Arora and Carsten Lund. Hardness of approximations. In Dorit S. Hochbaum,\neditor, Approximation Algorithms for NP-Hard Problems, pages 399–446. PWS Publishing\nCompany, 1997.\n[24] Javed A. Aslam. A simple bound on the expected height of a randomly built binary search\ntree. Technical Report TR2001-387, Dartmouth College Department of Computer Science,\n2001.\n[25] Mikhail J. Atallah, editor. Algorithms and Theory of Computation Handbook. CRC Press,\n1999.\n[26] G. Ausiello, P. Crescenzi, G. Gambosi, V. Kann, A. Marchetti-Spaccamela, and M. Protasi.\nComplexity and Approximation: Combinatorial Optimization Problems and Their Approx-\nimability Properties. Springer, 1999.",
    "parent_014d08c1-f7f5-48c1-9135-929fee6c36cd": "1999.\n[26] G. Ausiello, P. Crescenzi, G. Gambosi, V. Kann, A. Marchetti-Spaccamela, and M. Protasi.\nComplexity and Approximation: Combinatorial Optimization Problems and Their Approx-\nimability Properties. Springer, 1999.\n[27] Shai Avidan and Ariel Shamir. Seam carving for content-aware image resizing. ACM Trans-\nactions on Graphics, 26(3), article 10, 2007.\n[28] Sara Baase and Alan Van Gelder. Computer Algorithms: Introduction to Design and Anal-\nysis. Addison-Wesley, third edition, 2000.\n[29] Eric Bach. Private communication, 1989.\n[30] Eric Bach. Number-theoretic algorithms. In Annual Review of Computer Science, volume 4,\npages 119–172. Annual Reviews, Inc., 1990.\n[31] Eric Bach and Jeffrey Shallit. Algorithmic Number Theory—Volume I: Efﬁcient Algorithms.\nThe MIT Press, 1996.\n[32] David H. Bailey, King Lee, and Horst D. Simon. Using Strassen’s algorithm to accelerate\nthe solution of linear systems. The Journal of Supercomputing, 4(4):357–371, 1990.\nBibliography\n1233\n[33] Surender Baswana, Ramesh Hariharan, and Sandeep Sen.\nImproved decremental algo-\nrithms for maintaining transitive closure and all-pairs shortest paths. Journal of Algorithms,\n62(2):74–92, 2007.\n[34] R. Bayer. Symmetric binary B-trees: Data structure and maintenance algorithms. Acta\nInformatica, 1(4):290–306, 1972.\n[35] R. Bayer and E. M. McCreight. Organization and maintenance of large ordered indexes.\nActa Informatica, 1(3):173–189, 1972.\n[36] Pierre Beauchemin, Gilles Brassard, Claude Cr´epeau, Claude Goutier, and Carl Pomerance.\nThe generation of random numbers that are probably prime. Journal of Cryptology, 1(1):53–\n64, 1988.\n[37] Richard Bellman. Dynamic Programming. Princeton University Press, 1957.\n[38] Richard Bellman. On a routing problem. Quarterly of Applied Mathematics, 16(1):87–90,\n1958.\n[39] Michael Ben-Or. Lower bounds for algebraic computation trees. In Proceedings of the\nFifteenth Annual ACM Symposium on Theory of Computing, pages 80–86, 1983.",
    "parent_c6f0c11d-fb11-4d3e-9d71-79ce13f76b0e": "[38] Richard Bellman. On a routing problem. Quarterly of Applied Mathematics, 16(1):87–90,\n1958.\n[39] Michael Ben-Or. Lower bounds for algebraic computation trees. In Proceedings of the\nFifteenth Annual ACM Symposium on Theory of Computing, pages 80–86, 1983.\n[40] Michael A. Bender, Erik D. Demaine, and Martin Farach-Colton. Cache-oblivious B-trees.\nIn Proceedings of the 41st Annual Symposium on Foundations of Computer Science, pages\n399–409, 2000.\n[41] Samuel W. Bent and John W. John. Finding the median requires 2n comparisons. In Pro-\nceedings of the Seventeenth Annual ACM Symposium on Theory of Computing, pages 213–\n216, 1985.\n[42] Jon L. Bentley. Writing Efﬁcient Programs. Prentice Hall, 1982.\n[43] Jon L. Bentley. Programming Pearls. Addison-Wesley, 1986.\n[44] Jon L. Bentley, Dorothea Haken, and James B. Saxe. A general method for solving divide-\nand-conquer recurrences. SIGACT News, 12(3):36–44, 1980.\n[45] Daniel Bienstock and Benjamin McClosky. Tightening simplex mixed-integer sets with\nguaranteed bounds. Optimization Online, July 2008.\n[46] Patrick Billingsley. Probability and Measure. John Wiley & Sons, second edition, 1986.\n[47] Guy E. Blelloch. Scan Primitives and Parallel Vector Models. PhD thesis, Department of\nElectrical Engineering and Computer Science, MIT, 1989. Available as MIT Laboratory for\nComputer Science Technical Report MIT/LCS/TR-463.\n[48] Guy E. Blelloch.\nProgramming parallel algorithms.\nCommunications of the ACM,\n39(3):85–97, 1996.\n[49] Guy E. Blelloch, Phillip B. Gibbons, and Yossi Matias. Provably efﬁcient scheduling for\nlanguages with ﬁne-grained parallelism. In Proceedings of the 7th Annual ACM Symposium\non Parallel Algorithms and Architectures, pages 1–12, 1995.\n[50] Manuel Blum, Robert W. Floyd, Vaughan Pratt, Ronald L. Rivest, and Robert E. Tarjan.\nTime bounds for selection. Journal of Computer and System Sciences, 7(4):448–461, 1973.\n[51] Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson,",
    "parent_e183732d-9349-48f4-aea0-e62498dfe7d1": "[50] Manuel Blum, Robert W. Floyd, Vaughan Pratt, Ronald L. Rivest, and Robert E. Tarjan.\nTime bounds for selection. Journal of Computer and System Sciences, 7(4):448–461, 1973.\n[51] Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson,\nKeith H. Randall, and Yuli Zhou. Cilk: An efﬁcient multithreaded runtime system. Journal\nof Parallel and Distributed Computing, 37(1):55–69, 1996.\n1234\nBibliography\n[52] Robert D. Blumofe and Charles E. Leiserson. Scheduling multithreaded computations by\nwork stealing. Journal of the ACM, 46(5):720–748, 1999.\n[53] B´ela Bollob´as. Random Graphs. Academic Press, 1985.\n[54] Gilles Brassard and Paul Bratley. Fundamentals of Algorithmics. Prentice Hall, 1996.\n[55] Richard P. Brent. The parallel evaluation of general arithmetic expressions. Journal of the\nACM, 21(2):201–206, 1974.\n[56] Richard P. Brent. An improved Monte Carlo factorization algorithm. BIT, 20(2):176–184,\n1980.\n[57] J. P. Buhler, H. W. Lenstra, Jr., and Carl Pomerance. Factoring integers with the number\nﬁeld sieve. In A. K. Lenstra and H. W. Lenstra, Jr., editors, The Development of the Number\nField Sieve, volume 1554 of Lecture Notes in Mathematics, pages 50–94. Springer, 1993.\n[58] J. Lawrence Carter and Mark N. Wegman. Universal classes of hash functions. Journal of\nComputer and System Sciences, 18(2):143–154, 1979.\n[59] Barbara Chapman, Gabriele Jost, and Ruud van der Pas. Using OpenMP: Portable Shared\nMemory Parallel Programming. The MIT Press, 2007.\n[60] Bernard Chazelle. A minimum spanning tree algorithm with inverse-Ackermann type com-\nplexity. Journal of the ACM, 47(6):1028–1047, 2000.\n[61] Joseph Cheriyan and Torben Hagerup. A randomized maximum-ﬂow algorithm. SIAM\nJournal on Computing, 24(2):203–226, 1995.\n[62] Joseph Cheriyan and S. N. Maheshwari. Analysis of preﬂow push algorithms for maximum\nnetwork ﬂow. SIAM Journal on Computing, 18(6):1057–1086, 1989.",
    "parent_4254a851-79e9-47b2-be86-1c593b95aad1": "[61] Joseph Cheriyan and Torben Hagerup. A randomized maximum-ﬂow algorithm. SIAM\nJournal on Computing, 24(2):203–226, 1995.\n[62] Joseph Cheriyan and S. N. Maheshwari. Analysis of preﬂow push algorithms for maximum\nnetwork ﬂow. SIAM Journal on Computing, 18(6):1057–1086, 1989.\n[63] Boris V. Cherkassky and Andrew V. Goldberg. On implementing the push-relabel method\nfor the maximum ﬂow problem. Algorithmica, 19(4):390–410, 1997.\n[64] Boris V. Cherkassky, Andrew V. Goldberg, and Tomasz Radzik. Shortest paths algorithms:\nTheory and experimental evaluation. Mathematical Programming, 73(2):129–174, 1996.\n[65] Boris V. Cherkassky, Andrew V. Goldberg, and Craig Silverstein. Buckets, heaps, lists and\nmonotone priority queues. SIAM Journal on Computing, 28(4):1326–1346, 1999.\n[66] H. Chernoff. A measure of asymptotic efﬁciency for tests of a hypothesis based on the sum\nof observations. Annals of Mathematical Statistics, 23(4):493–507, 1952.\n[67] Kai Lai Chung. Elementary Probability Theory with Stochastic Processes. Springer, 1974.\n[68] V. Chv´atal. A greedy heuristic for the set-covering problem. Mathematics of Operations\nResearch, 4(3):233–235, 1979.\n[69] V. Chv´atal. Linear Programming. W. H. Freeman and Company, 1983.\n[70] V. Chv´atal, D. A. Klarner, and D. E. Knuth. Selected combinatorial research problems.\nTechnical Report STAN-CS-72-292, Computer Science Department, Stanford University,\n1972.\n[71] Cilk Arts, Inc., Burlington, Massachusetts. Cilk++ Programmer’s Guide, 2008. Available\nat http://www.cilk.com/archive/docs/cilk1guide.\nBibliography\n1235\n[72] Alan Cobham. The intrinsic computational difﬁculty of functions. In Proceedings of the\n1964 Congress for Logic, Methodology, and the Philosophy of Science, pages 24–30. North-\nHolland, 1964.\n[73] H. Cohen and H. W. Lenstra, Jr. Primality testing and Jacobi sums. Mathematics of Com-\nputation, 42(165):297–330, 1984.\n[74] D. Comer. The ubiquitous B-tree. ACM Computing Surveys, 11(2):121–137, 1979.",
    "parent_a81c2ad3-3d05-401a-b807-95b91e842ff2": "Holland, 1964.\n[73] H. Cohen and H. W. Lenstra, Jr. Primality testing and Jacobi sums. Mathematics of Com-\nputation, 42(165):297–330, 1984.\n[74] D. Comer. The ubiquitous B-tree. ACM Computing Surveys, 11(2):121–137, 1979.\n[75] Stephen Cook. The complexity of theorem proving procedures. In Proceedings of the Third\nAnnual ACM Symposium on Theory of Computing, pages 151–158, 1971.\n[76] James W. Cooley and John W. Tukey. An algorithm for the machine calculation of complex\nFourier series. Mathematics of Computation, 19(90):297–301, 1965.\n[77] Don Coppersmith.\nModiﬁcations to the number ﬁeld sieve.\nJournal of Cryptology,\n6(3):169–180, 1993.\n[78] Don Coppersmith and Shmuel Winograd. Matrix multiplication via arithmetic progression.\nJournal of Symbolic Computation, 9(3):251–280, 1990.\n[79] Thomas H. Cormen, Thomas Sundquist, and Leonard F. Wisniewski. Asymptotically tight\nbounds for performing BMMC permutations on parallel disk systems. SIAM Journal on\nComputing, 28(1):105–136, 1998.\n[80] Don Dailey and Charles E. Leiserson. Using Cilk to write multiprocessor chess programs.\nIn H. J. van den Herik and B. Monien, editors, Advances in Computer Games, volume 9,\npages 25–52. University of Maastricht, Netherlands, 2001.\n[81] Paolo D’Alberto and Alexandru Nicolau. Adaptive Strassen’s matrix multiplication. In\nProceedings of the 21st Annual International Conference on Supercomputing, pages 284–\n292, June 2007.\n[82] Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani. Algorithms. McGraw-Hill,\n2008.\n[83] Roman Dementiev, Lutz Kettner, Jens Mehnert, and Peter Sanders. Engineering a sorted list\ndata structure for 32 bit keys. In Proceedings of the Sixth Workshop on Algorithm Engineer-\ning and Experiments and the First Workshop on Analytic Algorithmics and Combinatorics,\npages 142–151, January 2004.\n[84] Camil Demetrescu and Giuseppe F. Italiano. Fully dynamic all pairs shortest paths with real\nedge weights. Journal of Computer and System Sciences, 72(5):813–837, 2006.",
    "parent_f126d479-d5b9-41a1-bdf7-b0cd8dfd19a3": "ing and Experiments and the First Workshop on Analytic Algorithmics and Combinatorics,\npages 142–151, January 2004.\n[84] Camil Demetrescu and Giuseppe F. Italiano. Fully dynamic all pairs shortest paths with real\nedge weights. Journal of Computer and System Sciences, 72(5):813–837, 2006.\n[85] Eric V. Denardo and Bennett L. Fox. Shortest-route methods: 1. Reaching, pruning, and\nbuckets. Operations Research, 27(1):161–186, 1979.\n[86] Martin Dietzfelbinger, Anna Karlin, Kurt Mehlhorn, Friedhelm Meyer auf der Heide, Hans\nRohnert, and Robert E. Tarjan. Dynamic perfect hashing: Upper and lower bounds. SIAM\nJournal on Computing, 23(4):738–761, 1994.\n[87] Whitﬁeld Difﬁe and Martin E. Hellman. New directions in cryptography. IEEE Transac-\ntions on Information Theory, IT-22(6):644–654, 1976.\n[88] E. W. Dijkstra. A note on two problems in connexion with graphs. Numerische Mathematik,\n1(1):269–271, 1959.\n1236\nBibliography\n[89] E. A. Dinic. Algorithm for solution of a problem of maximum ﬂow in a network with power\nestimation. Soviet Mathematics Doklady, 11(5):1277–1280, 1970.\n[90] Brandon Dixon, Monika Rauch, and Robert E. Tarjan. Veriﬁcation and sensitivity analysis\nof minimum spanning trees in linear time. SIAM Journal on Computing, 21(6):1184–1192,\n1992.\n[91] John D. Dixon. Factorization and primality tests. The American Mathematical Monthly,\n91(6):333–352, 1984.\n[92] Dorit Dor, Johan H˚astad, Staffan Ulfberg, and Uri Zwick. On lower bounds for selecting\nthe median. SIAM Journal on Discrete Mathematics, 14(3):299–311, 2001.\n[93] Dorit Dor and Uri Zwick. Selecting the median. SIAM Journal on Computing, 28(5):1722–\n1758, 1999.\n[94] Dorit Dor and Uri Zwick. Median selection requires .2 C \b/n comparisons. SIAM Journal\non Discrete Mathematics, 14(3):312–325, 2001.\n[95] Alvin W. Drake. Fundamentals of Applied Probability Theory. McGraw-Hill, 1967.\n[96] James R. Driscoll, Harold N. Gabow, Ruth Shrairman, and Robert E. Tarjan. Relaxed heaps:",
    "parent_48d8ff48-2cf8-4f60-9b40-c84ab59a0e21": "on Discrete Mathematics, 14(3):312–325, 2001.\n[95] Alvin W. Drake. Fundamentals of Applied Probability Theory. McGraw-Hill, 1967.\n[96] James R. Driscoll, Harold N. Gabow, Ruth Shrairman, and Robert E. Tarjan. Relaxed heaps:\nAn alternative to Fibonacci heaps with applications to parallel computation. Communica-\ntions of the ACM, 31(11):1343–1354, 1988.\n[97] James R. Driscoll, Neil Sarnak, Daniel D. Sleator, and Robert E. Tarjan.\nMaking data\nstructures persistent. Journal of Computer and System Sciences, 38(1):86–124, 1989.\n[98] Derek L. Eager, John Zahorjan, and Edward D. Lazowska. Speedup versus efﬁciency in\nparallel systems. IEEE Transactions on Computers, 38(3):408–423, 1989.\n[99] Herbert Edelsbrunner. Algorithms in Combinatorial Geometry, volume 10 of EATCS Mono-\ngraphs on Theoretical Computer Science. Springer, 1987.\n[100] Jack Edmonds. Paths, trees, and ﬂowers. Canadian Journal of Mathematics, 17:449–467,\n1965.\n[101] Jack Edmonds. Matroids and the greedy algorithm. Mathematical Programming, 1(1):127–\n136, 1971.\n[102] Jack Edmonds and Richard M. Karp. Theoretical improvements in the algorithmic efﬁ-\nciency for network ﬂow problems. Journal of the ACM, 19(2):248–264, 1972.\n[103] Shimon Even. Graph Algorithms. Computer Science Press, 1979.\n[104] William Feller. An Introduction to Probability Theory and Its Applications. John Wiley &\nSons, third edition, 1968.\n[105] Robert W. Floyd.\nAlgorithm 97 (SHORTEST PATH).\nCommunications of the ACM,\n5(6):345, 1962.\n[106] Robert W. Floyd. Algorithm 245 (TREESORT). Communications of the ACM, 7(12):701,\n1964.\n[107] Robert W. Floyd. Permuting information in idealized two-level storage. In Raymond E.\nMiller and James W. Thatcher, editors, Complexity of Computer Computations, pages 105–\n109. Plenum Press, 1972.\nBibliography\n1237\n[108] Robert W. Floyd and Ronald L. Rivest. Expected time bounds for selection. Communica-\ntions of the ACM, 18(3):165–172, 1975.",
    "parent_6003a59e-f636-446e-99f3-56b5ecb776d4": "Miller and James W. Thatcher, editors, Complexity of Computer Computations, pages 105–\n109. Plenum Press, 1972.\nBibliography\n1237\n[108] Robert W. Floyd and Ronald L. Rivest. Expected time bounds for selection. Communica-\ntions of the ACM, 18(3):165–172, 1975.\n[109] Lestor R. Ford, Jr. and D. R. Fulkerson. Flows in Networks. Princeton University Press,\n1962.\n[110] Lestor R. Ford, Jr. and Selmer M. Johnson. A tournament problem. The American Mathe-\nmatical Monthly, 66(5):387–389, 1959.\n[111] Michael L. Fredman. New bounds on the complexity of the shortest path problem. SIAM\nJournal on Computing, 5(1):83–89, 1976.\n[112] Michael L. Fredman, J´anos Koml´os, and Endre Szemer´edi. Storing a sparse table with O.1/\nworst case access time. Journal of the ACM, 31(3):538–544, 1984.\n[113] Michael L. Fredman and Michael E. Saks. The cell probe complexity of dynamic data struc-\ntures. In Proceedings of the Twenty First Annual ACM Symposium on Theory of Computing,\npages 345–354, 1989.\n[114] Michael L. Fredman and Robert E. Tarjan. Fibonacci heaps and their uses in improved\nnetwork optimization algorithms. Journal of the ACM, 34(3):596–615, 1987.\n[115] Michael L. Fredman and Dan E. Willard. Surpassing the information theoretic bound with\nfusion trees. Journal of Computer and System Sciences, 47(3):424–436, 1993.\n[116] Michael L. Fredman and Dan E. Willard. Trans-dichotomous algorithms for minimum span-\nning trees and shortest paths. Journal of Computer and System Sciences, 48(3):533–551,\n1994.\n[117] Matteo Frigo and Steven G. Johnson. The design and implementation of FFTW3. Proceed-\nings of the IEEE, 93(2):216–231, 2005.\n[118] Matteo Frigo, Charles E. Leiserson, and Keith H. Randall. The implementation of the Cilk-5\nmultithreaded language. In Proceedings of the 1998 ACM SIGPLAN Conference on Pro-\ngramming Language Design and Implementation, pages 212–223, 1998.\n[119] Harold N. Gabow. Path-based depth-ﬁrst search for strong and biconnected components.",
    "parent_dbfd7edc-0de7-4670-8743-84785271d1c8": "multithreaded language. In Proceedings of the 1998 ACM SIGPLAN Conference on Pro-\ngramming Language Design and Implementation, pages 212–223, 1998.\n[119] Harold N. Gabow. Path-based depth-ﬁrst search for strong and biconnected components.\nInformation Processing Letters, 74(3–4):107–114, 2000.\n[120] Harold N. Gabow, Z. Galil, T. Spencer, and Robert E. Tarjan. Efﬁcient algorithms for ﬁnd-\ning minimum spanning trees in undirected and directed graphs. Combinatorica, 6(2):109–\n122, 1986.\n[121] Harold N. Gabow and Robert E. Tarjan. A linear-time algorithm for a special case of disjoint\nset union. Journal of Computer and System Sciences, 30(2):209–221, 1985.\n[122] Harold N. Gabow and Robert E. Tarjan. Faster scaling algorithms for network problems.\nSIAM Journal on Computing, 18(5):1013–1036, 1989.\n[123] Zvi Galil and Oded Margalit. All pairs shortest distances for graphs with small integer\nlength edges. Information and Computation, 134(2):103–139, 1997.\n[124] Zvi Galil and Oded Margalit. All pairs shortest paths for graphs with small integer length\nedges. Journal of Computer and System Sciences, 54(2):243–254, 1997.\n[125] Zvi Galil and Kunsoo Park. Dynamic programming with convexity, concavity and sparsity.\nTheoretical Computer Science, 92(1):49–76, 1992.\n1238\nBibliography\n[126] Zvi Galil and Joel Seiferas. Time-space-optimal string matching. Journal of Computer and\nSystem Sciences, 26(3):280–294, 1983.\n[127] Igal Galperin and Ronald L. Rivest. Scapegoat trees. In Proceedings of the 4th ACM-SIAM\nSymposium on Discrete Algorithms, pages 165–174, 1993.\n[128] Michael R. Garey, R. L. Graham, and J. D. Ullman. Worst-case analyis of memory al-\nlocation algorithms. In Proceedings of the Fourth Annual ACM Symposium on Theory of\nComputing, pages 143–150, 1972.\n[129] Michael R. Garey and David S. Johnson. Computers and Intractability: A Guide to the\nTheory of NP-Completeness. W. H. Freeman, 1979.",
    "parent_39bba897-c5f6-4b8d-9d10-a44f807863f1": "location algorithms. In Proceedings of the Fourth Annual ACM Symposium on Theory of\nComputing, pages 143–150, 1972.\n[129] Michael R. Garey and David S. Johnson. Computers and Intractability: A Guide to the\nTheory of NP-Completeness. W. H. Freeman, 1979.\n[130] Saul Gass. Linear Programming: Methods and Applications. International Thomson Pub-\nlishing, fourth edition, 1975.\n[131] F˘anic˘a Gavril. Algorithms for minimum coloring, maximum clique, minimum covering by\ncliques, and maximum independent set of a chordal graph. SIAM Journal on Computing,\n1(2):180–187, 1972.\n[132] Alan George and Joseph W-H Liu. Computer Solution of Large Sparse Positive Deﬁnite\nSystems. Prentice Hall, 1981.\n[133] E. N. Gilbert and E. F. Moore. Variable-length binary encodings. Bell System Technical\nJournal, 38(4):933–967, 1959.\n[134] Michel X. Goemans and David P. Williamson.\nImproved approximation algorithms for\nmaximum cut and satisﬁability problems using semideﬁnite programming. Journal of the\nACM, 42(6):1115–1145, 1995.\n[135] Michel X. Goemans and David P. Williamson. The primal-dual method for approximation\nalgorithms and its application to network design problems. In Dorit S. Hochbaum, editor,\nApproximation Algorithms for NP-Hard Problems, pages 144–191. PWS Publishing Com-\npany, 1997.\n[136] Andrew V. Goldberg. Efﬁcient Graph Algorithms for Sequential and Parallel Computers.\nPhD thesis, Department of Electrical Engineering and Computer Science, MIT, 1987.\n[137] Andrew V. Goldberg. Scaling algorithms for the shortest paths problem. SIAM Journal on\nComputing, 24(3):494–504, 1995.\n[138] Andrew V. Goldberg and Satish Rao. Beyond the ﬂow decomposition barrier. Journal of\nthe ACM, 45(5):783–797, 1998.\n[139] Andrew V. Goldberg, ´Eva Tardos, and Robert E. Tarjan. Network ﬂow algorithms. In Bern-\nhard Korte, L´aszl´o Lov´asz, Hans J¨urgen Pr¨omel, and Alexander Schrijver, editors, Paths,\nFlows, and VLSI-Layout, pages 101–164. Springer, 1990.",
    "parent_b028d311-eae9-44d9-b631-b402dd12e292": "the ACM, 45(5):783–797, 1998.\n[139] Andrew V. Goldberg, ´Eva Tardos, and Robert E. Tarjan. Network ﬂow algorithms. In Bern-\nhard Korte, L´aszl´o Lov´asz, Hans J¨urgen Pr¨omel, and Alexander Schrijver, editors, Paths,\nFlows, and VLSI-Layout, pages 101–164. Springer, 1990.\n[140] Andrew V. Goldberg and Robert E. Tarjan. A new approach to the maximum ﬂow problem.\nJournal of the ACM, 35(4):921–940, 1988.\n[141] D. Goldfarb and M. J. Todd. Linear programming. In G. L. Nemhauser, A. H. G. Rinnooy-\nKan, and M. J. Todd, editors, Handbook in Operations Research and Management Science,\nVol. 1, Optimization, pages 73–170. Elsevier Science Publishers, 1989.\n[142] ShaﬁGoldwasser and Silvio Micali. Probabilistic encryption. Journal of Computer and\nSystem Sciences, 28(2):270–299, 1984.\nBibliography\n1239\n[143] ShaﬁGoldwasser, Silvio Micali, and Ronald L. Rivest. A digital signature scheme secure\nagainst adaptive chosen-message attacks.\nSIAM Journal on Computing, 17(2):281–308,\n1988.\n[144] Gene H. Golub and Charles F. Van Loan. Matrix Computations. The Johns Hopkins Uni-\nversity Press, third edition, 1996.\n[145] G. H. Gonnet. Handbook of Algorithms and Data Structures. Addison-Wesley, 1984.\n[146] Rafael C. Gonzalez and Richard E. Woods. Digital Image Processing. Addison-Wesley,\n1992.\n[147] Michael T. Goodrich and Roberto Tamassia. Data Structures and Algorithms in Java. John\nWiley & Sons, 1998.\n[148] Michael T. Goodrich and Roberto Tamassia. Algorithm Design: Foundations, Analysis, and\nInternet Examples. John Wiley & Sons, 2001.\n[149] Ronald L. Graham. Bounds for certain multiprocessor anomalies. Bell System Technical\nJournal, 45(9):1563–1581, 1966.\n[150] Ronald L. Graham. An efﬁcient algorithm for determining the convex hull of a ﬁnite planar\nset. Information Processing Letters, 1(4):132–133, 1972.\n[151] Ronald L. Graham and Pavol Hell. On the history of the minimum spanning tree problem.\nAnnals of the History of Computing, 7(1):43–57, 1985.",
    "parent_57a0e05e-a2a1-4450-b679-3a9411fb0d90": "[150] Ronald L. Graham. An efﬁcient algorithm for determining the convex hull of a ﬁnite planar\nset. Information Processing Letters, 1(4):132–133, 1972.\n[151] Ronald L. Graham and Pavol Hell. On the history of the minimum spanning tree problem.\nAnnals of the History of Computing, 7(1):43–57, 1985.\n[152] Ronald L. Graham, Donald E. Knuth, and Oren Patashnik.\nConcrete Mathematics.\nAddison-Wesley, second edition, 1994.\n[153] David Gries. The Science of Programming. Springer, 1981.\n[154] M. Gr¨otschel, L´aszl´o Lov´asz, and Alexander Schrijver. Geometric Algorithms and Combi-\nnatorial Optimization. Springer, 1988.\n[155] Leo J. Guibas and Robert Sedgewick. A dichromatic framework for balanced trees. In\nProceedings of the 19th Annual Symposium on Foundations of Computer Science, pages\n8–21, 1978.\n[156] Dan Gusﬁeld. Algorithms on Strings, Trees, and Sequences: Computer Science and Com-\nputational Biology. Cambridge University Press, 1997.\n[157] H. Halberstam and R. E. Ingram, editors. The Mathematical Papers of Sir William Rowan\nHamilton, volume III (Algebra). Cambridge University Press, 1967.\n[158] Yijie Han. Improved fast integer sorting in linear space. In Proceedings of the 12th ACM-\nSIAM Symposium on Discrete Algorithms, pages 793–796, 2001.\n[159] Yijie Han. An O.n3.log log n= log n/5=4/ time algorithm for all pairs shortest path. Algo-\nrithmica, 51(4):428–434, 2008.\n[160] Frank Harary. Graph Theory. Addison-Wesley, 1969.\n[161] Gregory C. Harfst and Edward M. Reingold. A potential-based amortized analysis of the\nunion-ﬁnd data structure. SIGACT News, 31(3):86–95, 2000.\n[162] J. Hartmanis and R. E. Stearns. On the computational complexity of algorithms. Transac-\ntions of the American Mathematical Society, 117:285–306, May 1965.\n1240\nBibliography\n[163] Michael T. Heideman, Don H. Johnson, and C. Sidney Burrus. Gauss and the history of the\nFast Fourier Transform. IEEE ASSP Magazine, 1(4):14–21, 1984.",
    "parent_30799078-41c6-4fac-b0e8-cc1561bbb6fd": "tions of the American Mathematical Society, 117:285–306, May 1965.\n1240\nBibliography\n[163] Michael T. Heideman, Don H. Johnson, and C. Sidney Burrus. Gauss and the history of the\nFast Fourier Transform. IEEE ASSP Magazine, 1(4):14–21, 1984.\n[164] Monika R. Henzinger and Valerie King. Fully dynamic biconnectivity and transitive clo-\nsure. In Proceedings of the 36th Annual Symposium on Foundations of Computer Science,\npages 664–672, 1995.\n[165] Monika R. Henzinger and Valerie King. Randomized fully dynamic graph algorithms with\npolylogarithmic time per operation. Journal of the ACM, 46(4):502–516, 1999.\n[166] Monika R. Henzinger, Satish Rao, and Harold N. Gabow. Computing vertex connectivity:\nNew bounds from old techniques. Journal of Algorithms, 34(2):222–250, 2000.\n[167] Nicholas J. Higham. Exploiting fast matrix multiplication within the level 3 BLAS. ACM\nTransactions on Mathematical Software, 16(4):352–368, 1990.\n[168] W. Daniel Hillis and Jr. Guy L. Steele. Data parallel algorithms. Communications of the\nACM, 29(12):1170–1183, 1986.\n[169] C. A. R. Hoare. Algorithm 63 (PARTITION) and algorithm 65 (FIND). Communications\nof the ACM, 4(7):321–322, 1961.\n[170] C. A. R. Hoare. Quicksort. Computer Journal, 5(1):10–15, 1962.\n[171] Dorit S. Hochbaum. Efﬁcient bounds for the stable set, vertex cover and set packing prob-\nlems. Discrete Applied Mathematics, 6(3):243–254, 1983.\n[172] Dorit S. Hochbaum, editor. Approximation Algorithms for NP-Hard Problems. PWS Pub-\nlishing Company, 1997.\n[173] W. Hoeffding. On the distribution of the number of successes in independent trials. Annals\nof Mathematical Statistics, 27(3):713–721, 1956.\n[174] Micha Hofri. Probabilistic Analysis of Algorithms. Springer, 1987.\n[175] Micha Hofri. Analysis of Algorithms. Oxford University Press, 1995.\n[176] John E. Hopcroft and Richard M. Karp. An n5=2 algorithm for maximum matchings in\nbipartite graphs. SIAM Journal on Computing, 2(4):225–231, 1973.",
    "parent_81924ea6-0cc1-4f99-abb7-34abe82bff48": "[174] Micha Hofri. Probabilistic Analysis of Algorithms. Springer, 1987.\n[175] Micha Hofri. Analysis of Algorithms. Oxford University Press, 1995.\n[176] John E. Hopcroft and Richard M. Karp. An n5=2 algorithm for maximum matchings in\nbipartite graphs. SIAM Journal on Computing, 2(4):225–231, 1973.\n[177] John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. Introduction to Automata The-\nory, Languages, and Computation. Addison Wesley, third edition, 2006.\n[178] John E. Hopcroft and Robert E. Tarjan. Efﬁcient algorithms for graph manipulation. Com-\nmunications of the ACM, 16(6):372–378, 1973.\n[179] John E. Hopcroft and Jeffrey D. Ullman. Set merging algorithms. SIAM Journal on Com-\nputing, 2(4):294–303, 1973.\n[180] John E. Hopcroft and Jeffrey D. Ullman. Introduction to Automata Theory, Languages, and\nComputation. Addison-Wesley, 1979.\n[181] Ellis Horowitz, Sartaj Sahni, and Sanguthevar Rajasekaran. Computer Algorithms. Com-\nputer Science Press, 1998.\n[182] T. C. Hu and M. T. Shing. Computation of matrix chain products. Part I. SIAM Journal on\nComputing, 11(2):362–373, 1982.\n[183] T. C. Hu and M. T. Shing. Computation of matrix chain products. Part II. SIAM Journal on\nComputing, 13(2):228–251, 1984.\nBibliography\n1241\n[184] T. C. Hu and A. C. Tucker. Optimal computer search trees and variable-length alphabetic\ncodes. SIAM Journal on Applied Mathematics, 21(4):514–532, 1971.\n[185] David A. Huffman. A method for the construction of minimum-redundancy codes. Pro-\nceedings of the IRE, 40(9):1098–1101, 1952.\n[186] Steven Huss-Lederman, Elaine M. Jacobson, Jeremy R. Johnson, Anna Tsao, and Thomas\nTurnbull. Implementation of Strassen’s algorithm for matrix multiplication. In Proceedings\nof the 1996 ACM/IEEE Conference on Supercomputing, article 32, 1996.\n[187] Oscar H. Ibarra and Chul E. Kim. Fast approximation algorithms for the knapsack and sum\nof subset problems. Journal of the ACM, 22(4):463–468, 1975.\n[188] E. J. Isaac and R. C. Singleton.",
    "parent_57e129d3-a18e-4c03-8cf6-6fc5032aa16b": "of the 1996 ACM/IEEE Conference on Supercomputing, article 32, 1996.\n[187] Oscar H. Ibarra and Chul E. Kim. Fast approximation algorithms for the knapsack and sum\nof subset problems. Journal of the ACM, 22(4):463–468, 1975.\n[188] E. J. Isaac and R. C. Singleton.\nSorting by address calculation.\nJournal of the ACM,\n3(3):169–174, 1956.\n[189] R. A. Jarvis. On the identiﬁcation of the convex hull of a ﬁnite set of points in the plane.\nInformation Processing Letters, 2(1):18–21, 1973.\n[190] David S. Johnson. Approximation algorithms for combinatorial problems. Journal of Com-\nputer and System Sciences, 9(3):256–278, 1974.\n[191] David S. Johnson. The NP-completeness column: An ongoing guide—The tale of the sec-\nond prover. Journal of Algorithms, 13(3):502–524, 1992.\n[192] Donald B. Johnson. Efﬁcient algorithms for shortest paths in sparse networks. Journal of\nthe ACM, 24(1):1–13, 1977.\n[193] Richard Johnsonbaugh and Marcus Schaefer. Algorithms. Pearson Prentice Hall, 2004.\n[194] A. Karatsuba and Yu. Ofman. Multiplication of multidigit numbers on automata. Soviet\nPhysics—Doklady, 7(7):595–596, 1963. Translation of an article in Doklady Akademii Nauk\nSSSR, 145(2), 1962.\n[195] David R. Karger, Philip N. Klein, and Robert E. Tarjan. A randomized linear-time algorithm\nto ﬁnd minimum spanning trees. Journal of the ACM, 42(2):321–328, 1995.\n[196] David R. Karger, Daphne Koller, and Steven J. Phillips. Finding the hidden path: Time\nbounds for all-pairs shortest paths. SIAM Journal on Computing, 22(6):1199–1217, 1993.\n[197] Howard Karloff. Linear Programming. Birkh¨auser, 1991.\n[198] N. Karmarkar. A new polynomial-time algorithm for linear programming. Combinatorica,\n4(4):373–395, 1984.\n[199] Richard M. Karp. Reducibility among combinatorial problems. In Raymond E. Miller and\nJames W. Thatcher, editors, Complexity of Computer Computations, pages 85–103. Plenum\nPress, 1972.\n[200] Richard M. Karp. An introduction to randomized algorithms. Discrete Applied Mathemat-",
    "parent_696912ee-a57e-4f45-8ccb-46eabf11ba33": "[199] Richard M. Karp. Reducibility among combinatorial problems. In Raymond E. Miller and\nJames W. Thatcher, editors, Complexity of Computer Computations, pages 85–103. Plenum\nPress, 1972.\n[200] Richard M. Karp. An introduction to randomized algorithms. Discrete Applied Mathemat-\nics, 34(1–3):165–201, 1991.\n[201] Richard M. Karp and Michael O. Rabin. Efﬁcient randomized pattern-matching algorithms.\nIBM Journal of Research and Development, 31(2):249–260, 1987.\n[202] A. V. Karzanov. Determining the maximal ﬂow in a network by the method of preﬂows.\nSoviet Mathematics Doklady, 15(2):434–437, 1974.\n1242\nBibliography\n[203] Valerie King.\nA simpler minimum spanning tree veriﬁcation algorithm.\nAlgorithmica,\n18(2):263–270, 1997.\n[204] Valerie King, Satish Rao, and Robert E. Tarjan. A faster deterministic maximum ﬂow algo-\nrithm. Journal of Algorithms, 17(3):447–474, 1994.\n[205] Jeffrey H. Kingston.\nAlgorithms and Data Structures: Design, Correctness, Analysis.\nAddison-Wesley, second edition, 1997.\n[206] D. G. Kirkpatrick and R. Seidel. The ultimate planar convex hull algorithm? SIAM Journal\non Computing, 15(2):287–299, 1986.\n[207] Philip N. Klein and Neal E. Young. Approximation algorithms for NP-hard optimization\nproblems. In CRC Handbook on Algorithms, pages 34-1–34-19. CRC Press, 1999.\n[208] Jon Kleinberg and ´Eva Tardos. Algorithm Design. Addison-Wesley, 2006.\n[209] Donald E. Knuth. Fundamental Algorithms, volume 1 of The Art of Computer Program-\nming. Addison-Wesley, 1968. Third edition, 1997.\n[210] Donald E. Knuth. Seminumerical Algorithms, volume 2 of The Art of Computer Program-\nming. Addison-Wesley, 1969. Third edition, 1997.\n[211] Donald E. Knuth. Sorting and Searching, volume 3 of The Art of Computer Programming.\nAddison-Wesley, 1973. Second edition, 1998.\n[212] Donald E. Knuth. Optimum binary search trees. Acta Informatica, 1(1):14–25, 1971.\n[213] Donald E. Knuth. Big omicron and big omega and big theta. SIGACT News, 8(2):18–23,\n1976.",
    "parent_d6e2d035-3714-472f-8de4-fb1275625c0a": "Addison-Wesley, 1973. Second edition, 1998.\n[212] Donald E. Knuth. Optimum binary search trees. Acta Informatica, 1(1):14–25, 1971.\n[213] Donald E. Knuth. Big omicron and big omega and big theta. SIGACT News, 8(2):18–23,\n1976.\n[214] Donald E. Knuth, James H. Morris, Jr., and Vaughan R. Pratt. Fast pattern matching in\nstrings. SIAM Journal on Computing, 6(2):323–350, 1977.\n[215] J. Koml´os. Linear veriﬁcation for spanning trees. Combinatorica, 5(1):57–65, 1985.\n[216] Bernhard Korte and L´aszl´o Lov´asz. Mathematical structures underlying greedy algorithms.\nIn F. Gecseg, editor, Fundamentals of Computation Theory, volume 117 of Lecture Notes in\nComputer Science, pages 205–209. Springer, 1981.\n[217] Bernhard Korte and L´aszl´o Lov´asz. Structural properties of greedoids. Combinatorica,\n3(3–4):359–374, 1983.\n[218] Bernhard Korte and L´aszl´o Lov´asz. Greedoids—A structural framework for the greedy\nalgorithm. In W. Pulleybank, editor, Progress in Combinatorial Optimization, pages 221–\n243. Academic Press, 1984.\n[219] Bernhard Korte and L´aszl´o Lov´asz. Greedoids and linear objective functions. SIAM Journal\non Algebraic and Discrete Methods, 5(2):229–238, 1984.\n[220] Dexter C. Kozen. The Design and Analysis of Algorithms. Springer, 1992.\n[221] David W. Krumme, George Cybenko, and K. N. Venkataraman. Gossiping in minimal time.\nSIAM Journal on Computing, 21(1):111–139, 1992.\n[222] Joseph B. Kruskal, Jr. On the shortest spanning subtree of a graph and the traveling salesman\nproblem. Proceedings of the American Mathematical Society, 7(1):48–50, 1956.\n[223] Leslie Lamport. How to make a multiprocessor computer that correctly executes multipro-\ncess programs. IEEE Transactions on Computers, C-28(9):690–691, 1979.\nBibliography\n1243\n[224] Eugene L. Lawler. Combinatorial Optimization: Networks and Matroids. Holt, Rinehart,\nand Winston, 1976.\n[225] Eugene L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, and D. B. Shmoys, editors. The",
    "parent_6b755afc-72a4-40ca-979e-8b0e9f35017d": "cess programs. IEEE Transactions on Computers, C-28(9):690–691, 1979.\nBibliography\n1243\n[224] Eugene L. Lawler. Combinatorial Optimization: Networks and Matroids. Holt, Rinehart,\nand Winston, 1976.\n[225] Eugene L. Lawler, J. K. Lenstra, A. H. G. Rinnooy Kan, and D. B. Shmoys, editors. The\nTraveling Salesman Problem. John Wiley & Sons, 1985.\n[226] C. Y. Lee. An algorithm for path connection and its applications. IRE Transactions on\nElectronic Computers, EC-10(3):346–365, 1961.\n[227] Tom Leighton. Tight bounds on the complexity of parallel sorting. IEEE Transactions on\nComputers, C-34(4):344–354, 1985.\n[228] Tom Leighton. Notes on better master theorems for divide-and-conquer recurrences. Class\nnotes. Available at http://citeseer.ist.psu.edu/252350.html, October 1996.\n[229] Tom Leighton and Satish Rao. Multicommodity max-ﬂow min-cut theorems and their use\nin designing approximation algorithms. Journal of the ACM, 46(6):787–832, 1999.\n[230] Daan Leijen and Judd Hall.\nOptimize managed code for multi-core machines.\nMSDN\nMagazine, October 2007.\n[231] Debra A. Lelewer and Daniel S. Hirschberg. Data compression. ACM Computing Surveys,\n19(3):261–296, 1987.\n[232] A. K. Lenstra, H. W. Lenstra, Jr., M. S. Manasse, and J. M. Pollard. The number ﬁeld sieve.\nIn A. K. Lenstra and H. W. Lenstra, Jr., editors, The Development of the Number Field Sieve,\nvolume 1554 of Lecture Notes in Mathematics, pages 11–42. Springer, 1993.\n[233] H. W. Lenstra, Jr.\nFactoring integers with elliptic curves.\nAnnals of Mathematics,\n126(3):649–673, 1987.\n[234] L. A. Levin. Universal sorting problems. Problemy Peredachi Informatsii, 9(3):265–266,\n1973. In Russian.\n[235] Anany Levitin. Introduction to the Design & Analysis of Algorithms. Addison-Wesley,\n2007.\n[236] Harry R. Lewis and Christos H. Papadimitriou. Elements of the Theory of Computation.\nPrentice Hall, second edition, 1998.\n[237] C. L. Liu. Introduction to Combinatorial Mathematics. McGraw-Hill, 1968.",
    "parent_935f30d8-6985-4d87-acaf-74ab92e9a438": "2007.\n[236] Harry R. Lewis and Christos H. Papadimitriou. Elements of the Theory of Computation.\nPrentice Hall, second edition, 1998.\n[237] C. L. Liu. Introduction to Combinatorial Mathematics. McGraw-Hill, 1968.\n[238] L´aszl´o Lov´asz. On the ratio of optimal integral and fractional covers. Discrete Mathemat-\nics, 13(4):383–390, 1975.\n[239] L´aszl´o Lov´asz and M. D. Plummer. Matching Theory, volume 121 of Annals of Discrete\nMathematics. North Holland, 1986.\n[240] Bruce M. Maggs and Serge A. Plotkin.\nMinimum-cost spanning tree as a path-ﬁnding\nproblem. Information Processing Letters, 26(6):291–293, 1988.\n[241] Michael Main. Data Structures and Other Objects Using Java. Addison-Wesley, 1999.\n[242] Udi Manber. Introduction to Algorithms: A Creative Approach. Addison-Wesley, 1989.\n[243] Conrado Mart´ınez and Salvador Roura. Randomized binary search trees. Journal of the\nACM, 45(2):288–323, 1998.\n[244] William J. Masek and Michael S. Paterson. A faster algorithm computing string edit dis-\ntances. Journal of Computer and System Sciences, 20(1):18–31, 1980.\n1244\nBibliography\n[245] H. A. Maurer, Th. Ottmann, and H.-W. Six. Implementing dictionaries using binary trees of\nvery small height. Information Processing Letters, 5(1):11–14, 1976.\n[246] Ernst W. Mayr, Hans J¨urgen Pr¨omel, and Angelika Steger, editors. Lectures on Proof Veriﬁ-\ncation and Approximation Algorithms, volume 1367 of Lecture Notes in Computer Science.\nSpringer, 1998.\n[247] C. C. McGeoch.\nAll pairs shortest paths and the essential subgraph.\nAlgorithmica,\n13(5):426–441, 1995.\n[248] M. D. McIlroy.\nA killer adversary for quicksort.\nSoftware—Practice and Experience,\n29(4):341–344, 1999.\n[249] Kurt Mehlhorn.\nSorting and Searching, volume 1 of Data Structures and Algorithms.\nSpringer, 1984.\n[250] Kurt Mehlhorn. Graph Algorithms and NP-Completeness, volume 2 of Data Structures and\nAlgorithms. Springer, 1984.\n[251] Kurt Mehlhorn. Multidimensional Searching and Computational Geometry, volume 3 of",
    "parent_cb5cfc4d-855e-44d2-b3dc-5448da762591": "Sorting and Searching, volume 1 of Data Structures and Algorithms.\nSpringer, 1984.\n[250] Kurt Mehlhorn. Graph Algorithms and NP-Completeness, volume 2 of Data Structures and\nAlgorithms. Springer, 1984.\n[251] Kurt Mehlhorn. Multidimensional Searching and Computational Geometry, volume 3 of\nData Structures and Algorithms. Springer, 1984.\n[252] Kurt Mehlhorn and Stefan N¨aher. Bounded ordered dictionaries in O.log log N/ time and\nO.n/ space. Information Processing Letters, 35(4):183–189, 1990.\n[253] Kurt Mehlhorn and Stefan N¨aher. LEDA: A Platform for Combinatorial and Geometric\nComputing. Cambridge University Press, 1999.\n[254] Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone. Handbook of Applied\nCryptography. CRC Press, 1997.\n[255] Gary L. Miller. Riemann’s hypothesis and tests for primality. Journal of Computer and\nSystem Sciences, 13(3):300–317, 1976.\n[256] John C. Mitchell. Foundations for Programming Languages. The MIT Press, 1996.\n[257] Joseph S. B. Mitchell. Guillotine subdivisions approximate polygonal subdivisions: A sim-\nple polynomial-time approximation scheme for geometric TSP, k-MST, and related prob-\nlems. SIAM Journal on Computing, 28(4):1298–1309, 1999.\n[258] Louis Monier. Algorithmes de Factorisation D’Entiers. PhD thesis, L’Universit´e Paris-Sud,\n1980.\n[259] Louis Monier. Evaluation and comparison of two efﬁcient probabilistic primality testing\nalgorithms. Theoretical Computer Science, 12(1):97–108, 1980.\n[260] Edward F. Moore. The shortest path through a maze. In Proceedings of the International\nSymposium on the Theory of Switching, pages 285–292. Harvard University Press, 1959.\n[261] Rajeev Motwani, Joseph (Sefﬁ) Naor, and Prabakhar Raghavan. Randomized approxima-\ntion algorithms in combinatorial optimization. In Dorit Hochbaum, editor, Approximation\nAlgorithms for NP-Hard Problems, chapter 11, pages 447–481. PWS Publishing Company,\n1997.\n[262] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University",
    "parent_95639f2e-1778-4e96-aa8f-9485c71898fc": "tion algorithms in combinatorial optimization. In Dorit Hochbaum, editor, Approximation\nAlgorithms for NP-Hard Problems, chapter 11, pages 447–481. PWS Publishing Company,\n1997.\n[262] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University\nPress, 1995.\n[263] J. I. Munro and V. Raman. Fast stable in-place sorting with O.n/ data moves. Algorithmica,\n16(2):151–160, 1996.\nBibliography\n1245\n[264] J. Nievergelt and E. M. Reingold. Binary search trees of bounded balance. SIAM Journal\non Computing, 2(1):33–43, 1973.\n[265] Ivan Niven and Herbert S. Zuckerman. An Introduction to the Theory of Numbers. John\nWiley & Sons, fourth edition, 1980.\n[266] Alan V. Oppenheim and Ronald W. Schafer, with John R. Buck.\nDiscrete-Time Signal\nProcessing. Prentice Hall, second edition, 1998.\n[267] Alan V. Oppenheim and Alan S. Willsky, with S. Hamid Nawab. Signals and Systems.\nPrentice Hall, second edition, 1997.\n[268] James B. Orlin. A polynomial time primal network simplex algorithm for minimum cost\nﬂows. Mathematical Programming, 78(1):109–129, 1997.\n[269] Joseph O’Rourke. Computational Geometry in C. Cambridge University Press, second\nedition, 1998.\n[270] Christos H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994.\n[271] Christos H. Papadimitriou and Kenneth Steiglitz. Combinatorial Optimization: Algorithms\nand Complexity. Prentice Hall, 1982.\n[272] Michael S. Paterson. Progress in selection. In Proceedings of the Fifth Scandinavian Work-\nshop on Algorithm Theory, pages 368–379, 1996.\n[273] Mihai Pˇatras¸cu and Mikkel Thorup. Time-space trade-offs for predecessor search. In Pro-\nceedings of the 38th Annual ACM Symposium on Theory of Computing, pages 232–240,\n2006.\n[274] Mihai Pˇatras¸cu and Mikkel Thorup. Randomization does not help searching predecessors.\nIn Proceedings of the 18th ACM-SIAM Symposium on Discrete Algorithms, pages 555–564,\n2007.\n[275] Pavel A. Pevzner. Computational Molecular Biology: An Algorithmic Approach. The MIT\nPress, 2000.",
    "parent_34a390cb-69f7-44b1-a5ee-68c95dcf363d": "2006.\n[274] Mihai Pˇatras¸cu and Mikkel Thorup. Randomization does not help searching predecessors.\nIn Proceedings of the 18th ACM-SIAM Symposium on Discrete Algorithms, pages 555–564,\n2007.\n[275] Pavel A. Pevzner. Computational Molecular Biology: An Algorithmic Approach. The MIT\nPress, 2000.\n[276] Steven Phillips and Jeffery Westbrook. Online load balancing and network ﬂow. In Pro-\nceedings of the 25th Annual ACM Symposium on Theory of Computing, pages 402–411,\n1993.\n[277] J. M. Pollard. A Monte Carlo method for factorization. BIT, 15(3):331–334, 1975.\n[278] J. M. Pollard. Factoring with cubic integers. In A. K. Lenstra and H. W. Lenstra, Jr., editors,\nThe Development of the Number Field Sieve, volume 1554 of Lecture Notes in Mathematics,\npages 4–10. Springer, 1993.\n[279] Carl Pomerance.\nOn the distribution of pseudoprimes.\nMathematics of Computation,\n37(156):587–593, 1981.\n[280] Carl Pomerance, editor. Proceedings of the AMS Symposia in Applied Mathematics: Com-\nputational Number Theory and Cryptography. American Mathematical Society, 1990.\n[281] William K. Pratt. Digital Image Processing. John Wiley & Sons, fourth edition, 2007.\n[282] Franco P. Preparata and Michael Ian Shamos. Computational Geometry: An Introduction.\nSpringer, 1985.\n1246\nBibliography\n[283] William H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. Numer-\nical Recipes in C++: The Art of Scientiﬁc Computing. Cambridge University Press, second\nedition, 2002.\n[284] William H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. Numer-\nical Recipes: The Art of Scientiﬁc Computing. Cambridge University Press, third edition,\n2007.\n[285] R. C. Prim. Shortest connection networks and some generalizations. Bell System Technical\nJournal, 36(6):1389–1401, 1957.\n[286] William Pugh. Skip lists: A probabilistic alternative to balanced trees. Communications of\nthe ACM, 33(6):668–676, 1990.",
    "parent_34a3c755-c406-4642-8ff3-08f92b38ec73": "2007.\n[285] R. C. Prim. Shortest connection networks and some generalizations. Bell System Technical\nJournal, 36(6):1389–1401, 1957.\n[286] William Pugh. Skip lists: A probabilistic alternative to balanced trees. Communications of\nthe ACM, 33(6):668–676, 1990.\n[287] Paul W. Purdom, Jr. and Cynthia A. Brown. The Analysis of Algorithms. Holt, Rinehart,\nand Winston, 1985.\n[288] Michael O. Rabin. Probabilistic algorithms. In J. F. Traub, editor, Algorithms and Com-\nplexity: New Directions and Recent Results, pages 21–39. Academic Press, 1976.\n[289] Michael O. Rabin. Probabilistic algorithm for testing primality. Journal of Number Theory,\n12(1):128–138, 1980.\n[290] P. Raghavan and C. D. Thompson. Randomized rounding: A technique for provably good\nalgorithms and algorithmic proofs. Combinatorica, 7(4):365–374, 1987.\n[291] Rajeev Raman. Recent results on the single-source shortest paths problem. SIGACT News,\n28(2):81–87, 1997.\n[292] James Reinders. Intel Threading Building Blocks: Outﬁtting C++ for Multi-core Processor\nParallelism. O’Reilly Media, Inc., 2007.\n[293] Edward M. Reingold, J¨urg Nievergelt, and Narsingh Deo. Combinatorial Algorithms: The-\nory and Practice. Prentice Hall, 1977.\n[294] Edward M. Reingold, Kenneth J. Urban, and David Gries. K-M-P string matching revisited.\nInformation Processing Letters, 64(5):217–223, 1997.\n[295] Hans Riesel. Prime Numbers and Computer Methods for Factorization, volume 126 of\nProgress in Mathematics. Birkh¨auser, second edition, 1994.\n[296] Ronald L. Rivest, Adi Shamir, and Leonard M. Adleman. A method for obtaining digital\nsignatures and public-key cryptosystems.\nCommunications of the ACM, 21(2):120–126,\n1978. See also U.S. Patent 4,405,829.\n[297] Herbert Robbins.\nA remark on Stirling’s formula.\nAmerican Mathematical Monthly,\n62(1):26–29, 1955.\n[298] D. J. Rosenkrantz, R. E. Stearns, and P. M. Lewis. An analysis of several heuristics for the\ntraveling salesman problem. SIAM Journal on Computing, 6(3):563–581, 1977.",
    "parent_09f61754-d59b-4c16-9124-52c3c5158f04": "[297] Herbert Robbins.\nA remark on Stirling’s formula.\nAmerican Mathematical Monthly,\n62(1):26–29, 1955.\n[298] D. J. Rosenkrantz, R. E. Stearns, and P. M. Lewis. An analysis of several heuristics for the\ntraveling salesman problem. SIAM Journal on Computing, 6(3):563–581, 1977.\n[299] Salvador Roura.\nAn improved master theorem for divide-and-conquer recurrences.\nIn\nProceedings of Automata, Languages and Programming, 24th International Colloquium,\nICALP’97, volume 1256 of Lecture Notes in Computer Science, pages 449–459. Springer,\n1997.\n[300] Y. A. Rozanov. Probability Theory: A Concise Course. Dover, 1969.\nBibliography\n1247\n[301] S. Sahni and T. Gonzalez.\nP-complete approximation problems.\nJournal of the ACM,\n23(3):555–565, 1976.\n[302] A. Sch¨onhage, M. Paterson, and N. Pippenger. Finding the median. Journal of Computer\nand System Sciences, 13(2):184–199, 1976.\n[303] Alexander Schrijver. Theory of Linear and Integer Programming. John Wiley & Sons,\n1986.\n[304] Alexander Schrijver. Paths and ﬂows—A historical survey. CWI Quarterly, 6(3):169–183,\n1993.\n[305] Robert Sedgewick.\nImplementing quicksort programs.\nCommunications of the ACM,\n21(10):847–857, 1978.\n[306] Robert Sedgewick. Algorithms. Addison-Wesley, second edition, 1988.\n[307] Robert Sedgewick and Philippe Flajolet. An Introduction to the Analysis of Algorithms.\nAddison-Wesley, 1996.\n[308] Raimund Seidel. On the all-pairs-shortest-path problem in unweighted undirected graphs.\nJournal of Computer and System Sciences, 51(3):400–403, 1995.\n[309] Raimund Seidel and C. R. Aragon. Randomized search trees. Algorithmica, 16(4–5):464–\n497, 1996.\n[310] Jo˜ao Setubal and Jo˜ao Meidanis. Introduction to Computational Molecular Biology. PWS\nPublishing Company, 1997.\n[311] Clifford A. Shaffer. A Practical Introduction to Data Structures and Algorithm Analysis.\nPrentice Hall, second edition, 2001.\n[312] Jeffrey Shallit. Origins of the analysis of the Euclidean algorithm. Historia Mathematica,\n21(4):401–419, 1994.",
    "parent_dbcd4e8e-dbaf-4cca-92f5-45ef568bafe0": "Publishing Company, 1997.\n[311] Clifford A. Shaffer. A Practical Introduction to Data Structures and Algorithm Analysis.\nPrentice Hall, second edition, 2001.\n[312] Jeffrey Shallit. Origins of the analysis of the Euclidean algorithm. Historia Mathematica,\n21(4):401–419, 1994.\n[313] Michael I. Shamos and Dan Hoey. Geometric intersection problems. In Proceedings of the\n17th Annual Symposium on Foundations of Computer Science, pages 208–215, 1976.\n[314] M. Sharir. A strong-connectivity algorithm and its applications in data ﬂow analysis. Com-\nputers and Mathematics with Applications, 7(1):67–72, 1981.\n[315] David B. Shmoys. Computing near-optimal solutions to combinatorial optimization prob-\nlems. In William Cook, L´aszl´o Lov´asz, and Paul Seymour, editors, Combinatorial Opti-\nmization, volume 20 of DIMACS Series in Discrete Mathematics and Theoretical Computer\nScience. American Mathematical Society, 1995.\n[316] Avi Shoshan and Uri Zwick.\nAll pairs shortest paths in undirected graphs with integer\nweights. In Proceedings of the 40th Annual Symposium on Foundations of Computer Sci-\nence, pages 605–614, 1999.\n[317] Michael Sipser. Introduction to the Theory of Computation. Thomson Course Technology,\nsecond edition, 2006.\n[318] Steven S. Skiena. The Algorithm Design Manual. Springer, second edition, 1998.\n[319] Daniel D. Sleator and Robert E. Tarjan. A data structure for dynamic trees. Journal of\nComputer and System Sciences, 26(3):362–391, 1983.\n1248\nBibliography\n[320] Daniel D. Sleator and Robert E. Tarjan. Self-adjusting binary search trees. Journal of the\nACM, 32(3):652–686, 1985.\n[321] Joel Spencer. Ten Lectures on the Probabilistic Method, volume 64 of CBMS-NSF Regional\nConference Series in Applied Mathematics. Society for Industrial and Applied Mathematics,\n1993.\n[322] Daniel A. Spielman and Shang-Hua Teng. Smoothed analysis of algorithms: Why the sim-\nplex algorithm usually takes polynomial time. Journal of the ACM, 51(3):385–463, 2004.",
    "parent_b0d2d6e7-8558-40b5-9e95-be3652b7a84f": "Conference Series in Applied Mathematics. Society for Industrial and Applied Mathematics,\n1993.\n[322] Daniel A. Spielman and Shang-Hua Teng. Smoothed analysis of algorithms: Why the sim-\nplex algorithm usually takes polynomial time. Journal of the ACM, 51(3):385–463, 2004.\n[323] Gilbert Strang. Introduction to Applied Mathematics. Wellesley-Cambridge Press, 1986.\n[324] Gilbert Strang. Linear Algebra and Its Applications. Thomson Brooks/Cole, fourth edition,\n2006.\n[325] Volker Strassen. Gaussian elimination is not optimal. Numerische Mathematik, 14(3):354–\n356, 1969.\n[326] T. G. Szymanski. A special case of the maximal common subsequence problem. Technical\nReport TR-170, Computer Science Laboratory, Princeton University, 1975.\n[327] Robert E. Tarjan. Depth ﬁrst search and linear graph algorithms. SIAM Journal on Com-\nputing, 1(2):146–160, 1972.\n[328] Robert E. Tarjan. Efﬁciency of a good but not linear set union algorithm. Journal of the\nACM, 22(2):215–225, 1975.\n[329] Robert E. Tarjan. A class of algorithms which require nonlinear time to maintain disjoint\nsets. Journal of Computer and System Sciences, 18(2):110–127, 1979.\n[330] Robert E. Tarjan. Data Structures and Network Algorithms. Society for Industrial and\nApplied Mathematics, 1983.\n[331] Robert E. Tarjan. Amortized computational complexity. SIAM Journal on Algebraic and\nDiscrete Methods, 6(2):306–318, 1985.\n[332] Robert E. Tarjan. Class notes: Disjoint set union. COS 423, Princeton University, 1999.\n[333] Robert E. Tarjan and Jan van Leeuwen. Worst-case analysis of set union algorithms. Jour-\nnal of the ACM, 31(2):245–281, 1984.\n[334] George B. Thomas, Jr., Maurice D. Weir, Joel Hass, and Frank R. Giordano.\nThomas’\nCalculus. Addison-Wesley, eleventh edition, 2005.\n[335] Mikkel Thorup. Faster deterministic sorting and priority queues in linear space. In Pro-\nceedings of the 9th ACM-SIAM Symposium on Discrete Algorithms, pages 550–555, 1998.",
    "parent_0434aa11-6a32-43b9-adb4-9a2b9c9a2b78": "Thomas’\nCalculus. Addison-Wesley, eleventh edition, 2005.\n[335] Mikkel Thorup. Faster deterministic sorting and priority queues in linear space. In Pro-\nceedings of the 9th ACM-SIAM Symposium on Discrete Algorithms, pages 550–555, 1998.\n[336] Mikkel Thorup. Undirected single-source shortest paths with positive integer weights in\nlinear time. Journal of the ACM, 46(3):362–394, 1999.\n[337] Mikkel Thorup. On RAM priority queues. SIAM Journal on Computing, 30(1):86–109,\n2000.\n[338] Richard Tolimieri, Myoung An, and Chao Lu. Mathematics of Multidimensional Fourier\nTransform Algorithms. Springer, second edition, 1997.\n[339] P. van Emde Boas. Preserving order in a forest in less than logarithmic time. In Proceedings\nof the 16th Annual Symposium on Foundations of Computer Science, pages 75–84, 1975.\nBibliography\n1249\n[340] P. van Emde Boas. Preserving order in a forest in less than logarithmic time and linear\nspace. Information Processing Letters, 6(3):80–82, 1977.\n[341] P. van Emde Boas, R. Kaas, and E. Zijlstra. Design and implementation of an efﬁcient\npriority queue. Mathematical Systems Theory, 10(1):99–127, 1976.\n[342] Jan van Leeuwen, editor. Handbook of Theoretical Computer Science, Volume A: Algo-\nrithms and Complexity. Elsevier Science Publishers and the MIT Press, 1990.\n[343] Charles Van Loan. Computational Frameworks for the Fast Fourier Transform. Society for\nIndustrial and Applied Mathematics, 1992.\n[344] Robert J. Vanderbei. Linear Programming: Foundations and Extensions. Kluwer Academic\nPublishers, 1996.\n[345] Vijay V. Vazirani. Approximation Algorithms. Springer, 2001.\n[346] Rakesh M. Verma. General techniques for analyzing recursive algorithms with applications.\nSIAM Journal on Computing, 26(2):568–581, 1997.\n[347] Hao Wang and Bill Lin. Pipelined van Emde Boas tree: Algorithms, analysis, and ap-\nplications. In 26th IEEE International Conference on Computer Communications, pages\n2471–2475, 2007.",
    "parent_c598924f-bce9-43bf-9433-4327cd091be2": "SIAM Journal on Computing, 26(2):568–581, 1997.\n[347] Hao Wang and Bill Lin. Pipelined van Emde Boas tree: Algorithms, analysis, and ap-\nplications. In 26th IEEE International Conference on Computer Communications, pages\n2471–2475, 2007.\n[348] Antony F. Ware. Fast approximate Fourier transforms for irregularly spaced data. SIAM\nReview, 40(4):838–856, 1998.\n[349] Stephen Warshall. A theorem on boolean matrices. Journal of the ACM, 9(1):11–12, 1962.\n[350] Michael S. Waterman.\nIntroduction to Computational Biology, Maps, Sequences and\nGenomes. Chapman & Hall, 1995.\n[351] Mark Allen Weiss. Data Structures and Problem Solving Using C++. Addison-Wesley,\nsecond edition, 2000.\n[352] Mark Allen Weiss. Data Structures and Problem Solving Using Java. Addison-Wesley,\nthird edition, 2006.\n[353] Mark Allen Weiss. Data Structures and Algorithm Analysis in C++. Addison-Wesley, third\nedition, 2007.\n[354] Mark Allen Weiss.\nData Structures and Algorithm Analysis in Java.\nAddison-Wesley,\nsecond edition, 2007.\n[355] Hassler Whitney. On the abstract properties of linear dependence. American Journal of\nMathematics, 57(3):509–533, 1935.\n[356] Herbert S. Wilf. Algorithms and Complexity. A K Peters, second edition, 2002.\n[357] J. W. J. Williams. Algorithm 232 (HEAPSORT). Communications of the ACM, 7(6):347–\n348, 1964.\n[358] Shmuel Winograd. On the algebraic complexity of functions. In Actes du Congr`es Interna-\ntional des Math´ematiciens, volume 3, pages 283–288, 1970.\n[359] Andrew C.-C. Yao. A lower bound to ﬁnding convex hulls. Journal of the ACM, 28(4):780–\n787, 1981.\n[360] Chee Yap. A real elementary approach to the master recurrence and generalizations. Un-\npublished manuscript. Available at http://cs.nyu.edu/yap/papers/, July 2008.\n1250\nBibliography\n[361] Yinyu Ye. Interior Point Algorithms: Theory and Analysis. John Wiley & Sons, 1997.\n[362] Daniel Zwillinger, editor. CRC Standard Mathematical Tables and Formulae. Chapman &\nHall/CRC Press, 31st edition, 2003.\nIndex",
    "parent_db887143-3462-420c-a41c-2836f3b443e9": "1250\nBibliography\n[361] Yinyu Ye. Interior Point Algorithms: Theory and Analysis. John Wiley & Sons, 1997.\n[362] Daniel Zwillinger, editor. CRC Standard Mathematical Tables and Formulae. Chapman &\nHall/CRC Press, 31st edition, 2003.\nIndex\nThis index uses the following conventions. Numbers are alphabetized as if spelled\nout; for example, “2-3-4 tree” is indexed as if it were “two-three-four tree.” When\nan entry refers to a place other than the main text, the page number is followed by\na tag: ex. for exercise, pr. for problem, ﬁg. for ﬁgure, and n. for footnote. A tagged\npage number often indicates the ﬁrst page of an exercise or problem, which is not\nnecessarily the page on which the reference actually appears.\n˛.n/, 574\n\u0007 (golden ratio), 59, 108pr.\ny\u0007 (conjugate of the golden ratio), 59\n\u0007.n/ (Euler’s phi function), 943\n\u000f.n/-approximation algorithm, 1106, 1123\no-notation, 50–51, 64\nO-notation, 45ﬁg., 47–48, 64\nO0-notation, 62pr.\ne\nO-notation, 62pr.\n!-notation, 51\n\u0004-notation, 45ﬁg., 48–49, 64\n1\n\u0004-notation, 62pr.\ne\n\u0004-notation, 62pr.\n‚-notation, 44–47, 45ﬁg., 64\ne\n‚-notation, 62pr.\nf g (set), 1158\n2 (set member), 1158\n62 (not a set member), 1158\n;\n(empty language), 1058\n(empty set), 1158\n\u0007 (subset), 1159\n\r (proper subset), 1159\nW (such that), 1159\n\\ (set intersection), 1159\n[ (set union), 1159\n\u0005 (set difference), 1159\nj j\n(ﬂow value), 710\n(length of a string), 986\n(set cardinality), 1161\n\t\n(Cartesian product), 1162\n(cross product), 1016\nh i\n(sequence), 1166\n(standard encoding), 1057\n\u000bn\nk\n\f\n(choose), 1185\nk k (euclidean norm), 1222\nŠ (factorial), 57\nd e (ceiling), 54\nb c (ﬂoor), 54\n#p\n(lower square root), 546\n\"p\n(upper square root), 546\nP (sum), 1145\nQ (product), 1148\n! (adjacency relation), 1169\n; (reachability relation), 1170\n^ (AND), 697, 1071\n: (NOT), 1071\n_ (OR), 697, 1071\n˚ (group operator), 939\n˝ (convolution operator), 901\n1252\nIndex\n\u0004 (closure operator), 1058\nj (divides relation), 927\n−(does-not-divide relation), 927\n\b (equivalent modulo n), 54, 1165ex.",
    "parent_9daba499-4ffb-4dd0-9331-86eeb9eba778": "! (adjacency relation), 1169\n; (reachability relation), 1170\n^ (AND), 697, 1071\n: (NOT), 1071\n_ (OR), 697, 1071\n˚ (group operator), 939\n˝ (convolution operator), 901\n1252\nIndex\n\u0004 (closure operator), 1058\nj (divides relation), 927\n−(does-not-divide relation), 927\n\b (equivalent modulo n), 54, 1165ex.\n6\b (not equivalent modulo n), 54\nŒa\u0002n (equivalence class modulo n), 928\nCn (addition modulo n), 940\n\u0003n (multiplication modulo n), 940\n. a\np / (Legendre symbol), 982pr.\n\" (empty string), 986, 1058\n< (preﬁx relation), 986\n= (sufﬁx relation), 986\n<x (above relation), 1022\n// (comment symbol), 21\n\u000b (much-greater-than relation), 574\n\f (much-less-than relation), 783\n\u0002P (polynomial-time reducibility relation),\n1067, 1077ex.\nAA-tree, 338\nabelian group, 940\nABOVE, 1024\nabove relation (<x), 1022\nabsent child, 1178\nabsolutely convergent series, 1146\nabsorption laws for sets, 1160\nabstract problem, 1054\nacceptable pair of integers, 972\nacceptance\nby an algorithm, 1058\nby a ﬁnite automaton, 996\naccepting state, 995\naccounting method, 456–459\nfor binary counters, 458\nfor dynamic tables, 465–466\nfor stack operations, 457–458, 458ex.\nAckermann’s function, 585\nactivity-selection problem, 415–422, 450\nacyclic graph, 1170\nrelation to matroids, 448pr.\nadd instruction, 23\naddition\nof binary integers, 22ex.\nof matrices, 1220\nmodulo n (Cn), 940\nof polynomials, 898\nadditive group modulo n, 940\naddressing, open, see open-address hash table\nADD-SUBARRAY, 805pr.\nadjacency-list representation, 590\nreplaced by a hash table, 593ex.\nadjacency-matrix representation, 591\nadjacency relation (!), 1169\nadjacent vertices, 1169\nadmissible edge, 749\nadmissible network, 749–750\nadversary, 190\naggregate analysis, 452–456\nfor binary counters, 454–455\nfor breadth-ﬁrst search, 597\nfor depth-ﬁrst search, 606\nfor Dijkstra’s algorithm, 661\nfor disjoint-set data structures, 566–567,\n568ex.\nfor dynamic tables, 465\nfor Fibonacci heaps, 518, 522ex.\nfor Graham’s scan, 1036\nfor the Knuth-Morris-Pratt algorithm, 1006",
    "parent_75b6fd43-69c6-4c2b-9af1-ee18bbf8d7b9": "for binary counters, 454–455\nfor breadth-ﬁrst search, 597\nfor depth-ﬁrst search, 606\nfor Dijkstra’s algorithm, 661\nfor disjoint-set data structures, 566–567,\n568ex.\nfor dynamic tables, 465\nfor Fibonacci heaps, 518, 522ex.\nfor Graham’s scan, 1036\nfor the Knuth-Morris-Pratt algorithm, 1006\nfor Prim’s algorithm, 636\nfor rod-cutting, 367\nfor shortest paths in a dag, 655\nfor stack operations, 452–454\naggregate ﬂow, 863\nAkra-Bazzi method for solving a recurrence,\n112–113\nalgorithm, 5\ncorrectness of, 6\norigin of word, 42\nrunning time of, 25\nas a technology, 13\nAlice, 959\nALLOCATE-NODE, 492\nALLOCATE-OBJECT, 244\nallocation of objects, 243–244\nall-pairs shortest paths, 644, 684–707\nin dynamic graphs, 707\nin \b-dense graphs, 706pr.\nFloyd-Warshall algorithm for, 693–697, 706\nJohnson’s algorithm for, 700–706\nby matrix multiplication, 686–693, 706–707\nby repeated squaring, 689–691\nalphabet, 995, 1057\n˛.n/, 574\namortized analysis, 451–478\naccounting method of, 456–459\naggregate analysis, 367, 452–456\nIndex\n1253\nfor bit-reversal permutation, 472pr.\nfor breadth-ﬁrst search, 597\nfor depth-ﬁrst search, 606\nfor Dijkstra’s algorithm, 661\nfor disjoint-set data structures, 566–567,\n568ex., 572ex., 575–581, 581–582ex.\nfor dynamic tables, 463–471\nfor Fibonacci heaps, 509–512, 517–518,\n520–522, 522ex.\nfor the generic push-relabel algorithm, 746\nfor Graham’s scan, 1036\nfor the Knuth-Morris-Pratt algorithm, 1006\nfor making binary search dynamic, 473pr.\npotential method of, 459–463\nfor restructuring red-black trees, 474pr.\nfor self-organizing lists with move-to-front,\n476pr.\nfor shortest paths in a dag, 655\nfor stacks on secondary storage, 502pr.\nfor weight-balanced trees, 473pr.\namortized cost\nin the accounting method, 456\nin aggregate analysis, 452\nin the potential method, 459\nancestor, 1176\nleast common, 584pr.\nAND function (^), 697, 1071\nAND gate, 1070\nand, in pseudocode, 22\nantiparallel edges, 711–712\nantisymmetric relation, 1164\nANY-SEGMENTS-INTERSECT, 1025\napproximation",
    "parent_d339fd66-c5ee-486a-b5a2-9017b329b617": "in the accounting method, 456\nin aggregate analysis, 452\nin the potential method, 459\nancestor, 1176\nleast common, 584pr.\nAND function (^), 697, 1071\nAND gate, 1070\nand, in pseudocode, 22\nantiparallel edges, 711–712\nantisymmetric relation, 1164\nANY-SEGMENTS-INTERSECT, 1025\napproximation\nby least squares, 835–839\nof summation by integrals, 1154–1156\napproximation algorithm, 10, 1105–1140\nfor bin packing, 1134pr.\nfor MAX-CNF satisﬁability, 1127ex.\nfor maximum clique, 1111ex., 1134pr.\nfor maximum matching, 1135pr.\nfor maximum spanning tree, 1137pr.\nfor maximum-weight cut, 1127ex.\nfor MAX-3-CNF satisﬁability, 1123–1124,\n1139\nfor minimum-weight vertex cover,\n1124–1127, 1139\nfor parallel machine scheduling, 1136pr.\nrandomized, 1123\nfor set cover, 1117–1122, 1139\nfor subset sum, 1128–1134, 1139\nfor traveling-salesman problem, 1111–1117,\n1139\nfor vertex cover, 1108–1111, 1139\nfor weighted set cover, 1135pr.\nfor 0-1 knapsack problem, 1137pr., 1139\napproximation error, 836\napproximation ratio, 1106, 1123\napproximation scheme, 1107\nAPPROX-MIN-WEIGHT-VC, 1126\nAPPROX-SUBSET-SUM, 1131\nAPPROX-TSP-TOUR, 1112\nAPPROX-VERTEX-COVER, 1109\narbitrage, 679pr.\narc, see edge\nargument of a function, 1166–1167\narithmetic instructions, 23\narithmetic, modular, 54, 939–946\narithmetic series, 1146\narithmetic with inﬁnities, 650\narm, 485\narray, 21\nMonge, 110pr.\npassing as a parameter, 21\narticulation point, 621pr.\nassignment\nmultiple, 21\nsatisfying, 1072, 1079\ntruth, 1072, 1079\nassociative laws for sets, 1160\nassociative operation, 939\nasymptotically larger, 52\nasymptotically nonnegative, 45\nasymptotically positive, 45\nasymptotically smaller, 52\nasymptotically tight bound, 45\nasymptotic efﬁciency, 43\nasymptotic lower bound, 48\nasymptotic notation, 43–53, 62pr.\nand graph algorithms, 588\nand linearity of summations, 1146\nasymptotic upper bound, 47\nattribute of an object, 21\naugmentation of a ﬂow, 716\naugmenting data structures, 339–355\naugmenting path, 719–720, 763pr.",
    "parent_d3a41615-fcea-47a6-8f01-bc80e0d92b5c": "asymptotic efﬁciency, 43\nasymptotic lower bound, 48\nasymptotic notation, 43–53, 62pr.\nand graph algorithms, 588\nand linearity of summations, 1146\nasymptotic upper bound, 47\nattribute of an object, 21\naugmentation of a ﬂow, 716\naugmenting data structures, 339–355\naugmenting path, 719–720, 763pr.\nauthentication, 284pr., 960–961, 964\n1254\nIndex\nautomaton\nﬁnite, 995\nstring-matching, 996–1002\nauxiliary hash function, 272\nauxiliary linear program, 886\naverage-case running time, 28, 116\nAVL-INSERT, 333pr.\nAVL tree, 333pr., 337\naxioms, for probability, 1190\nbabyface, 602ex.\nback edge, 609, 613\nback substitution, 817\nBAD-SET-COVER-INSTANCE, 1122ex.\nBALANCE, 333pr.\nbalanced search tree\nAA-trees, 338\nAVL trees, 333pr., 337\nB-trees, 484–504\nk-neighbor trees, 338\nred-black trees, 308–338\nscapegoat trees, 338\nsplay trees, 338, 482\ntreaps, 333pr., 338\n2-3-4 trees, 489, 503pr.\n2-3 trees, 337, 504\nweight-balanced trees, 338, 473pr.\nballs and bins, 133–134, 1215pr.\nbase-a pseudoprime, 967\nbase case, 65, 84\nbase, in DNA, 391\nbasic feasible solution, 866\nbasic solution, 866\nbasic variable, 855\nbasis function, 835\nBayes’s theorem, 1194\nBELLMAN-FORD, 651\nBellman-Ford algorithm, 651–655, 682\nfor all-pairs shortest paths, 684\nin Johnson’s algorithm, 702–704\nand objective functions, 670ex.\nto solve systems of difference constraints,\n668\nYen’s improvement to, 678pr.\nBELOW, 1024\nBernoulli trial, 1201\nand balls and bins, 133–134\nand streaks, 135–139\nbest-case running time, 29ex., 49\nBFS, 595\nBIASED-RANDOM, 117ex.\nbiconnected component, 621pr.\nbig-oh notation, 45ﬁg., 47–48, 64\nbig-omega notation, 45ﬁg., 48–49, 64\nbijective function, 1167\nbinary character code, 428\nbinary counter\nanalyzed by accounting method, 458\nanalyzed by aggregate analysis, 454–455\nanalyzed by potential method, 461–462\nbit-reversed, 472pr.\nbinary entropy function, 1187\nbinary gcd algorithm, 981pr.\nbinary heap, see heap\nbinary relation, 1163\nbinary search, 39ex.\nwith fast insertion, 473pr.\nin insertion sort, 39ex.",
    "parent_ba65a88b-cab5-4feb-97dd-aed0ae5c89bf": "analyzed by aggregate analysis, 454–455\nanalyzed by potential method, 461–462\nbit-reversed, 472pr.\nbinary entropy function, 1187\nbinary gcd algorithm, 981pr.\nbinary heap, see heap\nbinary relation, 1163\nbinary search, 39ex.\nwith fast insertion, 473pr.\nin insertion sort, 39ex.\nin multithreaded merging, 799–800\nin searching B-trees, 499ex.\nBINARY-SEARCH, 799\nbinary search tree, 286–307\nAA-trees, 338\nAVL trees, 333pr., 337\ndeletion from, 295–298, 299ex.\nwith equal keys, 303pr.\ninsertion into, 294–295\nk-neighbor trees, 338\nmaximum key of, 291\nminimum key of, 291\noptimal, 397–404, 413\npredecessor in, 291–292\nquerying, 289–294\nrandomly built, 299–303, 304pr.\nright-converting of, 314ex.\nscapegoat trees, 338\nsearching, 289–291\nfor sorting, 299ex.\nsplay trees, 338\nsuccessor in, 291–292\nand treaps, 333pr.\nweight-balanced trees, 338\nsee also red-black tree\nbinary-search-tree property, 287\nin treaps, 333pr.\nvs. min-heap property, 289ex.\nIndex\n1255\nbinary tree, 1177\nfull, 1178\nnumber of different ones, 306pr.\nrepresentation of, 246\nsuperimposed upon a bit vector, 533–534\nsee also binary search tree\nbinomial coefﬁcient, 1186–1187\nbinomial distribution, 1203–1206\nand balls and bins, 133\nmaximum value of, 1207ex.\ntails of, 1208–1215\nbinomial expansion, 1186\nbinomial heap, 527pr.\nbinomial tree, 527pr.\nbin packing, 1134pr.\nbipartite graph, 1172\ncorresponding ﬂow network of, 732\nd-regular, 736ex.\nand hypergraphs, 1173ex.\nbipartite matching, 530, 732–736, 747ex., 766\nHopcroft-Karp algorithm for, 763pr.\nbirthday paradox, 130–133, 142ex.\nbisection of a tree, 1181pr.\nbitonic euclidean traveling-salesman problem,\n405pr.\nbitonic sequence, 682pr.\nbitonic tour, 405pr.\nbit operation, 927\nin Euclid’s algorithm, 981pr.\nbit-reversal permutation, 472pr., 918\nBIT-REVERSE-COPY, 918\nbit-reversed binary counter, 472pr.\nBIT-REVERSED-INCREMENT, 472pr.\nbit vector, 255ex., 532–536\nblack-height, 309\nblack vertex, 594, 603\nblocking ﬂow, 765\nblock structure in pseudocode, 20\nBob, 959",
    "parent_caf9a09e-8a63-444c-bab5-c916310cbb25": "in Euclid’s algorithm, 981pr.\nbit-reversal permutation, 472pr., 918\nBIT-REVERSE-COPY, 918\nbit-reversed binary counter, 472pr.\nBIT-REVERSED-INCREMENT, 472pr.\nbit vector, 255ex., 532–536\nblack-height, 309\nblack vertex, 594, 603\nblocking ﬂow, 765\nblock structure in pseudocode, 20\nBob, 959\nBoole’s inequality, 1195ex.\nboolean combinational circuit, 1071\nboolean combinational element, 1070\nboolean connective, 1079\nboolean formula, 1049, 1066ex., 1079,\n1086ex.\nboolean function, 1187ex.\nboolean matrix multiplication, 832ex.\nBor˙uvka’s algorithm, 641\nbottleneck spanning tree, 640pr.\nbottleneck traveling-salesman problem,\n1117ex.\nbottom of a stack, 233\nBOTTOM-UP-CUT-ROD, 366\nbottom-up method, for dynamic programming,\n365\nbound\nasymptotically tight, 45\nasymptotic lower, 48\nasymptotic upper, 47\non binomial coefﬁcients, 1186–1187\non binomial distributions, 1206\npolylogarithmic, 57\non the tails of a binomial distribution,\n1208–1215\nsee also lower bounds\nboundary condition, in a recurrence, 67, 84\nboundary of a polygon, 1020ex.\nbounding a summation, 1149–1156\nbox, nesting, 678pr.\nBC-tree, 488\nbranching factor, in B-trees, 487\nbranch instructions, 23\nbreadth-ﬁrst search, 594–602, 623\nin maximum ﬂow, 727–730, 766\nand shortest paths, 597–600, 644\nsimilarity to Dijkstra’s algorithm, 662,\n663ex.\nbreadth-ﬁrst tree, 594, 600\nbridge, 621pr.\nB\u0004-tree, 489n.\nB-tree, 484–504\ncompared with red-black trees, 484, 490\ncreating, 492\ndeletion from, 499–502\nfull node in, 489\nheight of, 489–490\ninsertion into, 493–497\nminimum degree of, 489\nminimum key of, 497ex.\nproperties of, 488–491\nsearching, 491–492\nsplitting a node in, 493–495\n2-3-4 trees, 489\nB-TREE-CREATE, 492\nB-TREE-DELETE, 499\nB-TREE-INSERT, 495\n1256\nIndex\nB-TREE-INSERT-NONFULL, 496\nB-TREE-SEARCH, 492, 499ex.\nB-TREE-SPLIT-CHILD, 494\nBUBBLESORT, 40pr.\nbucket, 200\nbucket sort, 200–204\nBUCKET-SORT, 201\nBUILD-MAX-HEAP, 157\nBUILD-MAX-HEAP0, 167pr.\nBUILD-MIN-HEAP, 159\nbutterﬂy operation, 915\nby, in pseudocode, 21\ncache, 24, 449pr.",
    "parent_3e6146e9-e4a9-4be6-95a6-02e7d3e946b0": "1256\nIndex\nB-TREE-INSERT-NONFULL, 496\nB-TREE-SEARCH, 492, 499ex.\nB-TREE-SPLIT-CHILD, 494\nBUBBLESORT, 40pr.\nbucket, 200\nbucket sort, 200–204\nBUCKET-SORT, 201\nBUILD-MAX-HEAP, 157\nBUILD-MAX-HEAP0, 167pr.\nBUILD-MIN-HEAP, 159\nbutterﬂy operation, 915\nby, in pseudocode, 21\ncache, 24, 449pr.\ncache hit, 449pr.\ncache miss, 449pr.\ncache obliviousness, 504\ncaching, off-line, 449pr.\ncall\nin a multithreaded computation, 776\nof a subroutine, 23, 25n.\nby value, 21\ncall edge, 778\ncancellation lemma, 907\ncancellation of ﬂow, 717\ncanonical form for task scheduling, 444\ncapacity\nof a cut, 721\nof an edge, 709\nresidual, 716, 719\nof a vertex, 714ex.\ncapacity constraint, 709–710\ncardinality of a set (j j), 1161\nCarmichael number, 968, 975ex.\nCartesian product (\t), 1162\nCartesian sum, 906ex.\ncascading cut, 520\nCASCADING-CUT, 519\nCatalan numbers, 306pr., 372\nceiling function (d e), 54\nin master theorem, 103–106\nceiling instruction, 23\ncertain event, 1190\ncertiﬁcate\nin a cryptosystem, 964\nfor veriﬁcation algorithms, 1063\nCHAINED-HASH-DELETE, 258\nCHAINED-HASH-INSERT, 258\nCHAINED-HASH-SEARCH, 258\nchaining, 257–260, 283pr.\nchain of a convex hull, 1038\nchanging a key, in a Fibonacci heap, 529pr.\nchanging variables, in the substitution method,\n86–87\ncharacter code, 428\nchess-playing program, 790–791\nchild\nin a binary tree, 1178\nin a multithreaded computation, 776\nin a rooted tree, 1176\nchild list in a Fibonacci heap, 507\nChinese remainder theorem, 950–954, 983\nchip multiprocessor, 772\nchirp transform, 914ex.\nchoose\n\u000bn\nk\n\f\n, 1185\nchord, 345ex.\nCilk, 774, 812\nCilk++, 774, 812\nciphertext, 960\ncircuit\nboolean combinational, 1071\ndepth of, 919\nfor fast Fourier transform, 919–920\nCIRCUIT-SAT, 1072\ncircuit satisﬁability, 1070–1077\ncircular, doubly linked list with a sentinel, 239\ncircular linked list, 236\nsee also linked list\nclass\ncomplexity, 1059\nequivalence, 1164\nclassiﬁcation of edges\nin breadth-ﬁrst search, 621pr.\nin depth-ﬁrst search, 609–610, 611ex.\nin a multithreaded dag, 778–779",
    "parent_c51f9f23-e620-4ef3-9911-a38df4415ffb": "circuit satisﬁability, 1070–1077\ncircular, doubly linked list with a sentinel, 239\ncircular linked list, 236\nsee also linked list\nclass\ncomplexity, 1059\nequivalence, 1164\nclassiﬁcation of edges\nin breadth-ﬁrst search, 621pr.\nin depth-ﬁrst search, 609–610, 611ex.\nin a multithreaded dag, 778–779\nclause, 1081–1082\nclean area, 208pr.\nclique, 1086–1089, 1105\napproximation algorithm for, 1111ex.,\n1134pr.\nCLIQUE, 1087\nclosed interval, 348\nclosed semiring, 707\nclosest pair, ﬁnding, 1039–1044, 1047\nclosest-point heuristic, 1117ex.\nIndex\n1257\nclosure\ngroup property, 939\nof a language, 1058\noperator (\u0004), 1058\ntransitive, see transitive closure\ncluster\nin a bit vector with a superimposed tree of\nconstant height, 534\nfor parallel computing, 772\nin proto van Emde Boas structures, 538\nin van Emde Boas trees, 546\nclustering, 272\nCNF (conjunctive normal form), 1049, 1082\nCNF satisﬁability, 1127ex.\ncoarsening leaves of recursion\nin merge sort, 39pr.\nwhen recursively spawning, 787\ncode, 428–429\nHuffman, 428–437, 450\ncodeword, 429\ncodomain, 1166\ncoefﬁcient\nbinomial, 1186\nof a polynomial, 55, 898\nin slack form, 856\ncoefﬁcient representation, 900\nand fast multiplication, 903–905\ncofactor, 1224\ncoin changing, 446pr.\ncolinearity, 1016\ncollision, 257\nresolution by chaining, 257–260\nresolution by open addressing, 269–277\ncollision-resistant hash function, 964\ncoloring, 1103pr., 1180pr.\ncolor, of a red-black-tree node, 308\ncolumn-major order, 208pr.\ncolumn rank, 1223\ncolumnsort, 208pr.\ncolumn vector, 1218\ncombination, 1185\ncombinational circuit, 1071\ncombinational element, 1070\ncombine step, in divide-and-conquer, 30, 65\ncomment, in pseudocode (//), 21\ncommodity, 862\ncommon divisor, 929\ngreatest, see greatest common divisor\ncommon multiple, 939ex.\ncommon subexpression, 915\ncommon subsequence, 7, 391\nlongest, 7, 390–397, 413\ncommutative laws for sets, 1159\ncommutative operation, 940\nCOMPACTIFY-LIST, 245ex.\ncompact list, 250pr.\nCOMPACT-LIST-SEARCH, 250pr.\nCOMPACT-LIST-SEARCH0, 251pr.",
    "parent_9b0dd784-86f0-47ed-9d3a-a4e9e78c6250": "common multiple, 939ex.\ncommon subexpression, 915\ncommon subsequence, 7, 391\nlongest, 7, 390–397, 413\ncommutative laws for sets, 1159\ncommutative operation, 940\nCOMPACTIFY-LIST, 245ex.\ncompact list, 250pr.\nCOMPACT-LIST-SEARCH, 250pr.\nCOMPACT-LIST-SEARCH0, 251pr.\ncomparable line segments, 1022\nCOMPARE-EXCHANGE, 208pr.\ncompare-exchange operation, 208pr.\ncomparison sort, 191\nand binary search trees, 289ex.\nrandomized, 205pr.\nand selection, 222\ncompatible activities, 415\ncompatible matrices, 371, 1221\ncompetitive analysis, 476pr.\ncomplement\nof an event, 1190\nof a graph, 1090\nof a language, 1058\nSchur, 820, 834\nof a set, 1160\ncomplementary slackness, 894pr.\ncomplete graph, 1172\ncomplete k-ary tree, 1179\nsee also heap\ncompleteness of a language, 1077ex.\ncomplete step, 782\ncompletion time, 447pr., 1136pr.\ncomplexity class, 1059\nco-NP, 1064\nNP, 1049, 1064\nNPC, 1050, 1069\nP, 1049, 1055\ncomplexity measure, 1059\ncomplex numbers\ninverting matrices of, 832ex.\nmultiplication of, 83ex.\ncomplex root of unity, 906\ninterpolation at, 912–913\ncomponent\nbiconnected, 621pr.\nconnected, 1170\nstrongly connected, 1170\n1258\nIndex\ncomponent graph, 617\ncomposite number, 928\nwitness to, 968\ncomposition, of multithreaded computations,\n784ﬁg.\ncomputational depth, 812\ncomputational geometry, 1014–1047\ncomputational problem, 5–6\ncomputation dag, 777\ncomputation, multithreaded, 777\nCOMPUTE-PREFIX-FUNCTION, 1006\nCOMPUTE-TRANSITION-FUNCTION, 1001\nconcatenation\nof languages, 1058\nof strings, 986\nconcrete problem, 1055\nconcurrency keywords, 774, 776, 785\nconcurrency platform, 773\nconditional branch instruction, 23\nconditional independence, 1195ex.\nconditional probability, 1192, 1194\nconﬁguration, 1074\nconjugate of the golden ratio (y\u0007), 59\nconjugate transpose, 832ex.\nconjunctive normal form, 1049, 1082\nconnected component, 1170\nidentiﬁed using depth-ﬁrst search, 612ex.\nidentiﬁed using disjoint-set data structures,\n562–564\nCONNECTED-COMPONENTS, 563\nconnected graph, 1170\nconnective, 1079",
    "parent_3e14f080-95d8-4201-aae4-f3d48158b4d6": "conjugate of the golden ratio (y\u0007), 59\nconjugate transpose, 832ex.\nconjunctive normal form, 1049, 1082\nconnected component, 1170\nidentiﬁed using depth-ﬁrst search, 612ex.\nidentiﬁed using disjoint-set data structures,\n562–564\nCONNECTED-COMPONENTS, 563\nconnected graph, 1170\nconnective, 1079\nco-NP (complexity class), 1064\nconquer step, in divide-and-conquer, 30, 65\nconservation of ﬂow, 709–710\nconsistency\nof literals, 1088\nsequential, 779, 812\nCONSOLIDATE, 516\nconsolidating a Fibonacci-heap root list,\n513–517\nconstraint, 851\ndifference, 665\nequality, 670ex., 852–853\ninequality, 852–853\nlinear, 846\nnonnegativity, 851, 853\ntight, 865\nviolation of, 865\nconstraint graph, 666–668\ncontain, in a path, 1170\ncontinuation edge, 778\ncontinuous uniform probability distribution,\n1192\ncontraction\nof a dynamic table, 467–471\nof a matroid, 442\nof an undirected graph by an edge, 1172\ncontrol instructions, 23\nconvergence property, 650, 672–673\nconvergent series, 1146\nconverting binary to decimal, 933ex.\nconvex combination of points, 1015\nconvex function, 1199\nconvex hull, 8, 1029–1039, 1046pr.\nconvex layers, 1044pr.\nconvex polygon, 1020ex.\nconvex set, 714ex.\nconvolution (˝), 901\nconvolution theorem, 913\ncopy instruction, 23\ncorrectness of an algorithm, 6\ncorresponding ﬂow network for bipartite\nmatching, 732\ncountably inﬁnite set, 1161\ncounter, see binary counter\ncounting, 1183–1189\nprobabilistic, 143pr.\ncounting sort, 194–197\nin radix sort, 198\nCOUNTING-SORT, 195\ncoupon collector’s problem, 134\ncover\npath, 761pr.\nby a subset, 1118\nvertex, 1089, 1108, 1124–1127, 1139\ncovertical, 1024\nCREATE-NEW-RS-VEB-TREE, 557pr.\ncredit, 456\ncritical edge, 729\ncritical path\nof a dag, 657\nof a multithreaded computation, 779\ncross a cut, 626\ncross edge, 609\ncross product (\t), 1016\nIndex\n1259\ncryptosystem, 958–965, 983\ncubic spline, 840pr.\ncurrency exchange, 390ex., 679pr.\ncurve ﬁtting, 835–839\ncut\ncapacity of, 721\ncascading, 520\nof a ﬂow network, 720–724\nminimum, 721, 731ex.\nnet ﬂow across, 720",
    "parent_f72d33f2-6ea3-4f9e-b43c-97feb3b2eee6": "cross a cut, 626\ncross edge, 609\ncross product (\t), 1016\nIndex\n1259\ncryptosystem, 958–965, 983\ncubic spline, 840pr.\ncurrency exchange, 390ex., 679pr.\ncurve ﬁtting, 835–839\ncut\ncapacity of, 721\ncascading, 520\nof a ﬂow network, 720–724\nminimum, 721, 731ex.\nnet ﬂow across, 720\nof an undirected graph, 626\nweight of, 1127ex.\nCUT, 519\nCUT-ROD, 363\ncutting, in a Fibonacci heap, 519\ncycle of a graph, 1170\nhamiltonian, 1049, 1061\nminimum mean-weight, 680pr.\nnegative-weight, see negative-weight cycle\nand shortest paths, 646–647\ncyclic group, 955\ncyclic rotation, 1012ex.\ncycling, of simplex algorithm, 875\ndag, see directed acyclic graph\nDAG-SHORTEST-PATHS, 655\nd-ary heap, 167pr.\nin shortest-paths algorithms, 706pr.\ndata-movement instructions, 23\ndata-parallel model, 811\ndata structure, 9, 229–355, 481–585\nAA-trees, 338\naugmentation of, 339–355\nAVL trees, 333pr., 337\nbinary search trees, 286–307\nbinomial heaps, 527pr.\nbit vectors, 255ex., 532–536\nB-trees, 484–504\ndeques, 236ex.\ndictionaries, 229\ndirect-address tables, 254–255\nfor disjoint sets, 561–585\nfor dynamic graphs, 483\ndynamic sets, 229–231\ndynamic trees, 482\nexponential search trees, 212, 483\nFibonacci heaps, 505–530\nfusion trees, 212, 483\nhash tables, 256–261\nheaps, 151–169\ninterval trees, 348–354\nk-neighbor trees, 338\nlinked lists, 236–241\nmergeable heap, 505\norder-statistic trees, 339–345\npersistent, 331pr., 482\npotential of, 459\npriority queues, 162–166\nproto van Emde Boas structures, 538–545\nqueues, 232, 234–235\nradix trees, 304pr.\nred-black trees, 308–338\nrelaxed heaps, 530\nrooted trees, 246–249\nscapegoat trees, 338\non secondary storage, 484–487\nskip lists, 338\nsplay trees, 338, 482\nstacks, 232–233\ntreaps, 333pr., 338\n2-3-4 heaps, 529pr.\n2-3-4 trees, 489, 503pr.\n2-3 trees, 337, 504\nvan Emde Boas trees, 531–560\nweight-balanced trees, 338\ndata type, 23\ndeadline, 444\ndeallocation of objects, 243–244\ndecision by an algorithm, 1058–1059\ndecision problem, 1051, 1054\nand optimization problems, 1051",
    "parent_4e166bd2-7e1e-47e5-a1c3-44081928ece6": "treaps, 333pr., 338\n2-3-4 heaps, 529pr.\n2-3-4 trees, 489, 503pr.\n2-3 trees, 337, 504\nvan Emde Boas trees, 531–560\nweight-balanced trees, 338\ndata type, 23\ndeadline, 444\ndeallocation of objects, 243–244\ndecision by an algorithm, 1058–1059\ndecision problem, 1051, 1054\nand optimization problems, 1051\ndecision tree, 192–193\nDECREASE-KEY, 162, 505\ndecreasing a key\nin Fibonacci heaps, 519–522\nin 2-3-4 heaps, 529pr.\nDECREMENT, 456ex.\ndegeneracy, 874\ndegree\nof a binomial-tree root, 527pr.\nmaximum, of a Fibonacci heap, 509,\n523–526\nminimum, of a B-tree, 489\nof a node, 1177\nof a polynomial, 55, 898\nof a vertex, 1169\n1260\nIndex\ndegree-bound, 898\nDELETE, 230, 505\nDELETE-LARGER-HALF, 463ex.\ndeletion\nfrom binary search trees, 295–298, 299ex.\nfrom a bit vector with a superimposed binary\ntree, 534\nfrom a bit vector with a superimposed tree of\nconstant height, 535\nfrom B-trees, 499–502\nfrom chained hash tables, 258\nfrom direct-address tables, 254\nfrom dynamic tables, 467–471\nfrom Fibonacci heaps, 522, 526pr.\nfrom heaps, 166ex.\nfrom interval trees, 349\nfrom linked lists, 238\nfrom open-address hash tables, 271\nfrom order-statistic trees, 343–344\nfrom proto van Emde Boas structures, 544\nfrom queues, 234\nfrom red-black trees, 323–330\nfrom stacks, 232\nfrom sweep-line statuses, 1024\nfrom 2-3-4 heaps, 529pr.\nfrom van Emde Boas trees, 554–556\nDeMorgan’s laws\nfor propositional logic, 1083\nfor sets, 1160, 1162ex.\ndense graph, 589\n\b-dense, 706pr.\ndensity\nof prime numbers, 965–966\nof a rod, 370ex.\ndependence\nand indicator random variables, 119\nlinear, 1223\nsee also independence\ndepth\naverage, of a node in a randomly built binary\nsearch tree, 304pr.\nof a circuit, 919\nof a node in a rooted tree, 1177\nof quicksort recursion tree, 178ex.\nof a stack, 188pr.\ndepth-determination problem, 583pr.\ndepth-ﬁrst forest, 603\ndepth-ﬁrst search, 603–612, 623\nin ﬁnding articulation points, bridges, and\nbiconnected components, 621pr.\nin ﬁnding strongly connected components,\n615–621, 623",
    "parent_9c2c6161-6853-4059-b35c-10602c3f8c32": "of quicksort recursion tree, 178ex.\nof a stack, 188pr.\ndepth-determination problem, 583pr.\ndepth-ﬁrst forest, 603\ndepth-ﬁrst search, 603–612, 623\nin ﬁnding articulation points, bridges, and\nbiconnected components, 621pr.\nin ﬁnding strongly connected components,\n615–621, 623\nin topological sorting, 612–615\ndepth-ﬁrst tree, 603\ndeque, 236ex.\nDEQUEUE, 235\nderivative of a series, 1147\ndescendant, 1176\ndestination vertex, 644\ndet, see determinant\ndeterminacy race, 788\ndeterminant, 1224–1225\nand matrix multiplication, 832ex.\ndeterministic algorithm, 123\nmultithreaded, 787\nDETERMINISTIC-SEARCH, 143pr.\nDFS, 604\nDFS-VISIT, 604\nDFT (discrete Fourier transform), 9, 909\ndiagonal matrix, 1218\nLUP decomposition of, 827ex.\ndiameter of a tree, 602ex.\ndictionary, 229\ndifference constraints, 664–670\ndifference equation, see recurrence\ndifference of sets (\u0005), 1159\nsymmetric, 763pr.\ndifferentiation of a series, 1147\ndigital signature, 960\ndigraph, see directed graph\nDIJKSTRA, 658\nDijkstra’s algorithm, 658–664, 682\nfor all-pairs shortest paths, 684, 704\nimplemented with a Fibonacci heap, 662\nimplemented with a min-heap, 662\nwith integer edge weights, 664ex.\nin Johnson’s algorithm, 702\nsimilarity to breadth-ﬁrst search, 662,\n663ex.\nsimilarity to Prim’s algorithm, 634, 662\nDIRECT-ADDRESS-DELETE, 254\ndirect addressing, 254–255, 532–536\nDIRECT-ADDRESS-INSERT, 254\nDIRECT-ADDRESS-SEARCH, 254\ndirect-address table, 254–255\ndirected acyclic graph (dag), 1172\nIndex\n1261\nand back edges, 613\nand component graphs, 617\nand hamiltonian paths, 1066ex.\nlongest simple path in, 404pr.\nfor representing a multithreaded\ncomputation, 777\nsingle-source shortest-paths algorithm for,\n655–658\ntopological sort of, 612–615, 623\ndirected graph, 1168\nall-pairs shortest paths in, 684–707\nconstraint graph, 666\nEuler tour of, 623pr., 1048\nhamiltonian cycle of, 1049\nand longest paths, 1048\npath cover of, 761pr.\nPERT chart, 657, 657ex.\nsemiconnected, 621ex.\nshortest path in, 643\nsingle-source shortest paths in, 643–683",
    "parent_d9cbfbd9-f574-4bc8-9e04-4d37e7677c07": "directed graph, 1168\nall-pairs shortest paths in, 684–707\nconstraint graph, 666\nEuler tour of, 623pr., 1048\nhamiltonian cycle of, 1049\nand longest paths, 1048\npath cover of, 761pr.\nPERT chart, 657, 657ex.\nsemiconnected, 621ex.\nshortest path in, 643\nsingle-source shortest paths in, 643–683\nsingly connected, 612ex.\nsquare of, 593ex.\ntransitive closure of, 697\ntranspose of, 592ex.\nuniversal sink in, 593ex.\nsee also directed acyclic graph, graph,\nnetwork\ndirected segment, 1015–1017\ndirected version of an undirected graph, 1172\nDIRECTION, 1018\ndirty area, 208pr.\nDISCHARGE, 751\ndischarge of an overﬂowing vertex, 751\ndiscovered vertex, 594, 603\ndiscovery time, in depth-ﬁrst search, 605\ndiscrete Fourier transform, 9, 909\ndiscrete logarithm, 955\ndiscrete logarithm theorem, 955\ndiscrete probability distribution, 1191\ndiscrete random variable, 1196–1201\ndisjoint-set data structure, 561–585\nanalysis of, 575–581, 581ex.\nin connected components, 562–564\nin depth determination, 583pr.\ndisjoint-set-forest implementation of,\n568–572\nin Kruskal’s algorithm, 631\nlinear-time special case of, 585\nlinked-list implementation of, 564–568\nin off-line least common ancestors, 584pr.\nin off-line minimum, 582pr.\nin task scheduling, 448pr.\ndisjoint-set forest, 568–572\nanalysis of, 575–581, 581ex.\nrank properties of, 575, 581ex.\nsee also disjoint-set data structure\ndisjoint sets, 1161\ndisjunctive normal form, 1083\ndisk, 1028ex.\ndisk drive, 485–487\nsee also secondary storage\nDISK-READ, 487\nDISK-WRITE, 487\ndistance\nedit, 406pr.\neuclidean, 1039\nLm, 1044ex.\nManhattan, 225pr., 1044ex.\nof a shortest path, 597\ndistributed memory, 772\ndistribution\nbinomial, 1203–1206\ncontinuous uniform, 1192\ndiscrete, 1191\ngeometric, 1202–1203\nof inputs, 116, 122\nof prime numbers, 965\nprobability, 1190\nsparse-hulled, 1046pr.\nuniform, 1191\ndistributive laws for sets, 1160\ndivergent series, 1146\ndivide-and-conquer method, 30–35, 65\nanalysis of, 34–35\nfor binary search, 39ex.\nfor conversion of binary to decimal, 933ex.",
    "parent_7c20aa33-d510-49ba-ad1c-6d3bc5277c2d": "geometric, 1202–1203\nof inputs, 116, 122\nof prime numbers, 965\nprobability, 1190\nsparse-hulled, 1046pr.\nuniform, 1191\ndistributive laws for sets, 1160\ndivergent series, 1146\ndivide-and-conquer method, 30–35, 65\nanalysis of, 34–35\nfor binary search, 39ex.\nfor conversion of binary to decimal, 933ex.\nfor fast Fourier transform, 909–912\nfor ﬁnding the closest pair of points,\n1040–1043\nfor ﬁnding the convex hull, 1030\nfor matrix inversion, 829–831\nfor matrix multiplication, 76–83, 792–797\nfor maximum-subarray problem, 68–75\nfor merge sort, 30–37, 797–805\nfor multiplication, 920pr.\n1262\nIndex\nfor multithreaded matrix multiplication,\n792–797\nfor multithreaded merge sort, 797–805\nfor quicksort, 170–190\nrelation to dynamic programming, 359\nfor selection, 215–224\nsolving recurrences for, 83–106, 112–113\nfor Strassen’s algorithm, 79–83\ndivide instruction, 23\ndivides relation (j), 927\ndivide step, in divide-and-conquer, 30, 65\ndivision method, 263, 268–269ex.\ndivision theorem, 928\ndivisor, 927–928\ncommon, 929\nsee also greatest common divisor\nDNA, 6–7, 390–391, 406pr.\nDNF (disjunctive normal form), 1083\ndoes-not-divide relation (−), 927\ndomain, 1166\ndominates relation, 1045pr.\ndouble hashing, 272–274, 277ex.\ndoubly linked list, 236\nsee also linked list\ndownto, in pseudocode, 21\nd-regular graph, 736ex.\nduality, 879–886, 895pr.\nweak, 880–881, 886ex.\ndual linear program, 879\ndummy key, 397\ndynamic graph, 562n.\nall-pairs shortest paths algorithms for, 707\ndata structures for, 483\nminimum-spanning-tree algorithm for,\n637ex.\ntransitive closure of, 705pr., 707\ndynamic multithreaded algorithm, see\nmultithreaded algorithm\ndynamic multithreading, 773\ndynamic order statistics, 339–345\ndynamic-programming method, 359–413\nfor activity selection, 421ex.\nfor all-pairs shortest paths, 686–697\nfor bitonic euclidean traveling-salesman\nproblem, 405pr.\nbottom-up, 365\nfor breaking a string, 410pr.\ncompared with greedy algorithms, 381,\n390ex., 418, 423–427\nfor edit distance, 406pr.",
    "parent_687f6cc5-3938-4b8b-b6f5-d57192bc57eb": "dynamic-programming method, 359–413\nfor activity selection, 421ex.\nfor all-pairs shortest paths, 686–697\nfor bitonic euclidean traveling-salesman\nproblem, 405pr.\nbottom-up, 365\nfor breaking a string, 410pr.\ncompared with greedy algorithms, 381,\n390ex., 418, 423–427\nfor edit distance, 406pr.\nelements of, 378–390\nfor Floyd-Warshall algorithm, 693–697\nfor inventory planning, 411pr.\nfor longest common subsequence, 390–397\nfor longest palindrome subsequence, 405pr.\nfor longest simple path in a weighted\ndirected acyclic graph, 404pr.\nfor matrix-chain multiplication, 370–378\nand memoization, 387–389\nfor optimal binary search trees, 397–404\noptimal substructure in, 379–384\noverlapping subproblems in, 384–386\nfor printing neatly, 405pr.\nreconstructing an optimal solution in, 387\nrelation to divide-and-conquer, 359\nfor rod-cutting, 360–370\nfor seam carving, 409pr.\nfor signing free agents, 411pr.\ntop-down with memoization, 365\nfor transitive closure, 697–699\nfor Viterbi algorithm, 408pr.\nfor 0-1 knapsack problem, 427ex.\ndynamic set, 229–231\nsee also data structure\ndynamic table, 463–471\nanalyzed by accounting method, 465–466\nanalyzed by aggregate analysis, 465\nanalyzed by potential method, 466–471\nload factor of, 463\ndynamic tree, 482\ne, 55\nE Œ \u0002 (expected value), 1197\nearly-ﬁrst form, 444\nearly task, 444\nedge, 1168\nadmissible, 749\nantiparallel, 711–712\nattributes of, 592\nback, 609\nbridge, 621pr.\ncall, 778\ncapacity of, 709\nclassiﬁcation in breadth-ﬁrst search, 621pr.\nclassiﬁcation in depth-ﬁrst search, 609–610\nIndex\n1263\ncontinuation, 778\ncritical, 729\ncross, 609\nforward, 609\ninadmissible, 749\nlight, 626\nnegative-weight, 645–646\nresidual, 716\nreturn, 779\nsafe, 626\nsaturated, 739\nspawn, 778\ntree, 601, 603, 609\nweight of, 591\nedge connectivity, 731ex.\nedge set, 1168\nedit distance, 406pr.\nEdmonds-Karp algorithm, 727–730\nelementary event, 1189\nelementary insertion, 465\nelement of a set (2), 1158\nellipsoid algorithm, 850, 897\nelliptic-curve factorization method, 984",
    "parent_11dda291-32a4-4411-bc63-cda0f0ecdd9a": "spawn, 778\ntree, 601, 603, 609\nweight of, 591\nedge connectivity, 731ex.\nedge set, 1168\nedit distance, 406pr.\nEdmonds-Karp algorithm, 727–730\nelementary event, 1189\nelementary insertion, 465\nelement of a set (2), 1158\nellipsoid algorithm, 850, 897\nelliptic-curve factorization method, 984\nelseif, in pseudocode, 20n.\nelse, in pseudocode, 20\nempty language (;), 1058\nempty set (;), 1158\nempty set laws, 1159\nempty stack, 233\nempty string (\"), 986, 1058\nempty tree, 1178\nencoding of problem instances, 1055–1057\nendpoint\nof an interval, 348\nof a line segment, 1015\nENQUEUE, 235\nentering a vertex, 1169\nentering variable, 867\nentropy function, 1187\n\b-dense graph, 706pr.\n\b-universal hash function, 269ex.\nequality\nof functions, 1166\nlinear, 845\nof sets, 1158\nequality constraint, 670ex., 852\nand inequality constraints, 853\ntight, 865\nviolation of, 865\nequation\nand asymptotic notation, 49–50\nnormal, 837\nrecurrence, see recurrence\nequivalence class, 1164\nmodulo n (Œa\u0002n), 928\nequivalence, modular (\b), 54, 1165ex.\nequivalence relation, 1164\nand modular equivalence, 1165ex.\nequivalent linear programs, 852\nerror, in pseudocode, 22\nescape problem, 760pr.\nEUCLID, 935\nEuclid’s algorithm, 933–939, 981pr., 983\neuclidean distance, 1039\neuclidean norm (k k), 1222\nEuler’s constant, 943\nEuler’s phi function, 943\nEuler’s theorem, 954, 975ex.\nEuler tour, 623pr., 1048\nand hamiltonian cycles, 1048\nevaluation of a polynomial, 41pr., 900, 905ex.\nderivatives of, 922pr.\nat multiple points, 923pr.\nevent, 1190\nevent point, 1023\nevent-point schedule, 1023\nEXACT-SUBSET-SUM, 1129\nexcess ﬂow, 736\nexchange property, 437\nexclusion and inclusion, 1163ex.\nexecute a subroutine, 25n.\nexpansion of a dynamic table, 464–467\nexpectation, see expected value\nexpected running time, 28, 117\nexpected value, 1197–1199\nof a binomial distribution, 1204\nof a geometric distribution, 1202\nof an indicator random variable, 118\nexplored vertex, 605\nexponential function, 55–56\nexponential height, 300",
    "parent_276a7956-076c-4343-ba4c-216f2bf201c3": "expectation, see expected value\nexpected running time, 28, 117\nexpected value, 1197–1199\nof a binomial distribution, 1204\nof a geometric distribution, 1202\nof an indicator random variable, 118\nexplored vertex, 605\nexponential function, 55–56\nexponential height, 300\nexponential search tree, 212, 483\nexponential series, 1147\nexponentiation instruction, 24\nexponentiation, modular, 956\nEXTENDED-BOTTOM-UP-CUT-ROD, 369\n1264\nIndex\nEXTENDED-EUCLID, 937\nEXTEND-SHORTEST-PATHS, 688\nextension of a set, 438\nexterior of a polygon, 1020ex.\nexternal node, 1176\nexternal path length, 1180ex.\nextracting the maximum key\nfrom d-ary heaps, 167pr.\nfrom max-heaps, 163\nextracting the minimum key\nfrom Fibonacci heaps, 512–518\nfrom 2-3-4 heaps, 529pr.\nfrom Young tableaus, 167pr.\nEXTRACT-MAX, 162–163\nEXTRACT-MIN, 162, 505\nfactor, 928\ntwiddle, 912\nfactorial function (Š), 57–58\nfactorization, 975–980, 984\nunique, 931\nfailure, in a Bernoulli trial, 1201\nfair coin, 1191\nfan-out, 1071\nFarkas’s lemma, 895pr.\nfarthest-pair problem, 1030\nFASTER-ALL-PAIRS-SHORTEST-PATHS, 691,\n692ex.\nfast Fourier transform (FFT), 898–925\ncircuit for, 919–920\niterative implementation of, 915–918\nmultidimensional, 921pr.\nmultithreaded algorithm for, 804ex.\nrecursive implementation of, 909–912\nusing modular arithmetic, 923pr.\nfeasibility problem, 665, 894pr.\nfeasible linear program, 851\nfeasible region, 847\nfeasible solution, 665, 846, 851\nFermat’s theorem, 954\nFFT, see fast Fourier transform\nFFTW, 924\nFIB, 775\nFIB-HEAP-CHANGE-KEY, 529pr.\nFIB-HEAP-DECREASE-KEY, 519\nFIB-HEAP-DELETE, 522\nFIB-HEAP-EXTRACT-MIN, 513\nFIB-HEAP-INSERT, 510\nFIB-HEAP-LINK, 516\nFIB-HEAP-PRUNE, 529pr.\nFIB-HEAP-UNION, 512\nFibonacci heap, 505–530\nchanging a key in, 529pr.\ncompared with binary heaps, 506–507\ncreating, 510\ndecreasing a key in, 519–522\ndeletion from, 522, 526pr.\nin Dijkstra’s algorithm, 662\nextracting the minimum key from, 512–518\ninsertion into, 510–511\nin Johnson’s algorithm, 704\nmaximum degree of, 509, 523–526\nminimum key of, 511",
    "parent_90729653-378a-47d0-b768-17cd029a97f0": "compared with binary heaps, 506–507\ncreating, 510\ndecreasing a key in, 519–522\ndeletion from, 522, 526pr.\nin Dijkstra’s algorithm, 662\nextracting the minimum key from, 512–518\ninsertion into, 510–511\nin Johnson’s algorithm, 704\nmaximum degree of, 509, 523–526\nminimum key of, 511\npotential function for, 509\nin Prim’s algorithm, 636\npruning, 529pr.\nrunning times of operations on, 506ﬁg.\nuniting, 511–512\nFibonacci numbers, 59–60, 108pr., 523\ncomputation of, 774–780, 981pr.\nFIFO (ﬁrst-in, ﬁrst-out), 232\nsee also queue\nﬁnal-state function, 996\nﬁnal strand, 779\nFIND-DEPTH, 583pr.\nFIND-MAX-CROSSING-SUBARRAY, 71\nFIND-MAXIMUM-SUBARRAY, 72\nﬁnd path, 569\nFIND-SET, 562\ndisjoint-set-forest implementation of, 571,\n585\nlinked-list implementation of, 564\nﬁnished vertex, 603\nﬁnishing time, in depth-ﬁrst search, 605\nand strongly connected components, 618\nﬁnish time, in activity selection, 415\nﬁnite automaton, 995\nfor string matching, 996–1002\nFINITE-AUTOMATON-MATCHER, 999\nﬁnite group, 940\nﬁnite sequence, 1166\nﬁnite set, 1161\nﬁrst-ﬁt heuristic, 1134pr.\nﬁrst-in, ﬁrst-out, 232\nsee also queue\nﬁxed-length code, 429\nIndex\n1265\nﬂoating-point data type, 23\nﬂoor function (b c), 54\nin master theorem, 103–106\nﬂoor instruction, 23\nﬂow, 709–714\naggregate, 863\naugmentation of, 716\nblocking, 765\ncancellation of, 717\nexcess, 736\ninteger-valued, 733\nnet, across a cut, 720\nvalue of, 710\nﬂow conservation, 709–710\nﬂow network, 709–714\ncorresponding to a bipartite graph, 732\ncut of, 720–724\nwith multiple sources and sinks, 712\nFLOYD-WARSHALL, 695\nFLOYD-WARSHALL0, 699ex.\nFloyd-Warshall algorithm, 693–697,\n699–700ex., 706\nmultithreaded, 797ex.\nFORD-FULKERSON, 724\nFord-Fulkerson method, 714–731, 765\nFORD-FULKERSON-METHOD, 715\nforest, 1172–1173\ndepth-ﬁrst, 603\ndisjoint-set, 568–572\nfor, in pseudocode, 20–21\nand loop invariants, 19n.\nformal power series, 108pr.\nformula satisﬁability, 1079–1081, 1105\nforward edge, 609\nforward substitution, 816–817\nFourier transform, see discrete Fourier",
    "parent_7af94e3a-3738-46f1-91f5-80140d26c483": "FORD-FULKERSON-METHOD, 715\nforest, 1172–1173\ndepth-ﬁrst, 603\ndisjoint-set, 568–572\nfor, in pseudocode, 20–21\nand loop invariants, 19n.\nformal power series, 108pr.\nformula satisﬁability, 1079–1081, 1105\nforward edge, 609\nforward substitution, 816–817\nFourier transform, see discrete Fourier\ntransform, fast Fourier transform\nfractional knapsack problem, 426, 428ex.\nfree agent, 411pr.\nfreeing of objects, 243–244\nfree list, 243\nFREE-OBJECT, 244\nfree tree, 1172–1176\nfrequency domain, 898\nfull binary tree, 1178, 1180ex.\nrelation to optimal code, 430\nfull node, 489\nfull rank, 1223\nfull walk of a tree, 1114\nfully parenthesized matrix-chain product, 370\nfully polynomial-time approximation scheme,\n1107\nfor subset sum, 1128–1134, 1139\nfunction, 1166–1168\nAckermann’s, 585\nbasis, 835\nconvex, 1199\nﬁnal-state, 996\nhash, see hash function\nlinear, 26, 845\nobjective, 664, 847, 851\npotential, 459\npreﬁx, 1003–1004\nquadratic, 27\nreduction, 1067\nsufﬁx, 996\ntransition, 995, 1001–1002, 1012ex.\nfunctional iteration, 58\nfundamental theorem of linear programming,\n892\nfurthest-in-future strategy, 449pr.\nfusion tree, 212, 483\nfuzzy sorting, 189pr.\nGabow’s scaling algorithm for single-source\nshortest paths, 679pr.\ngap character, 989ex., 1002ex.\ngap heuristic, 760ex., 766\ngarbage collection, 151, 243\ngate, 1070\nGaussian elimination, 819, 842\ngcd, see greatest common divisor\ngeneral number-ﬁeld sieve, 984\ngenerating function, 108pr.\ngenerator\nof a subgroup, 944\nof Z\u0004\nn, 955\nGENERIC-MST, 626\nGENERIC-PUSH-RELABEL, 741\ngeneric push-relabel algorithm, 740–748\ngeometric distribution, 1202–1203\nand balls and bins, 134\ngeometric series, 1147\ngeometry, computational, 1014–1047\nGF.2/, 1227pr.\ngift wrapping, 1037, 1047\n1266\nIndex\nglobal variable, 21\nGoldberg’s algorithm, see push-relabel\nalgorithm\ngolden ratio (\u0007), 59, 108pr.\ngossiping, 478\nGRAFT, 583pr.\nGraham’s scan, 1030–1036, 1047\nGRAHAM-SCAN, 1031\ngraph, 1168–1173\nadjacency-list representation of, 590\nadjacency-matrix representation of, 591",
    "parent_3d0e1e8b-141f-4280-90c3-1ecdab0e4aad": "1266\nIndex\nglobal variable, 21\nGoldberg’s algorithm, see push-relabel\nalgorithm\ngolden ratio (\u0007), 59, 108pr.\ngossiping, 478\nGRAFT, 583pr.\nGraham’s scan, 1030–1036, 1047\nGRAHAM-SCAN, 1031\ngraph, 1168–1173\nadjacency-list representation of, 590\nadjacency-matrix representation of, 591\nalgorithms for, 587–766\nand asymptotic notation, 588\nattributes of, 588, 592\nbreadth-ﬁrst search of, 594–602, 623\ncoloring of, 1103pr.\ncomplement of, 1090\ncomponent, 617\nconstraint, 666–668\ndense, 589\ndepth-ﬁrst search of, 603–612, 623\ndynamic, 562n.\n\b-dense, 706pr.\nhamiltonian, 1061\nincidence matrix of, 448pr., 593ex.\ninterval, 422ex.\nnonhamiltonian, 1061\nshortest path in, 597\nsingly connected, 612ex.\nsparse, 589\nstatic, 562n.\nsubproblem, 367–368\ntour of, 1096\nweighted, 591\nsee also directed acyclic graph, directed\ngraph, ﬂow network, undirected graph,\ntree\ngraphic matroid, 437–438, 642\nGRAPH-ISOMORPHISM, 1065ex.\ngray vertex, 594, 603\ngreatest common divisor (gcd), 929–930,\n933ex.\nbinary gcd algorithm for, 981pr.\nEuclid’s algorithm for, 933–939, 981pr., 983\nwith more than two arguments, 939ex.\nrecursion theorem for, 934\ngreedoid, 450\nGREEDY, 440\nGREEDY-ACTIVITY-SELECTOR, 421\ngreedy algorithm, 414–450\nfor activity selection, 415–422\nfor coin changing, 446pr.\ncompared with dynamic programming, 381,\n390ex., 418, 423–427\nDijkstra’s algorithm, 658–664\nelements of, 423–428\nfor fractional knapsack problem, 426\ngreedy-choice property in, 424–425\nfor Huffman code, 428–437\nKruskal’s algorithm, 631–633\nand matroids, 437–443\nfor minimum spanning tree, 631–638\nfor multithreaded scheduling, 781–783\nfor off-line caching, 449pr.\noptimal substructure in, 425\nPrim’s algorithm, 634–636\nfor set cover, 1117–1122, 1139\nfor task scheduling, 443–446, 447–448pr.\non a weighted matroid, 439–442\nfor weighted set cover, 1135pr.\ngreedy-choice property, 424–425\nof activity selection, 417–418\nof Huffman codes, 433–434\nof a weighted matroid, 441\ngreedy scheduler, 782\nGREEDY-SET-COVER, 1119\ngrid, 760pr.\ngroup, 939–946",
    "parent_20b58a15-cb9e-4ac7-a803-02b86c1401b1": "for task scheduling, 443–446, 447–448pr.\non a weighted matroid, 439–442\nfor weighted set cover, 1135pr.\ngreedy-choice property, 424–425\nof activity selection, 417–418\nof Huffman codes, 433–434\nof a weighted matroid, 441\ngreedy scheduler, 782\nGREEDY-SET-COVER, 1119\ngrid, 760pr.\ngroup, 939–946\ncyclic, 955\noperator (˚), 939\nguessing the solution, in the substitution\nmethod, 84–85\nhalf 3-CNF satisﬁability, 1101ex.\nhalf-open interval, 348\nHall’s theorem, 735ex.\nhalting problem, 1048\nhalving lemma, 908\nHAM-CYCLE, 1062\nhamiltonian cycle, 1049, 1061, 1091–1096,\n1105\nhamiltonian graph, 1061\nhamiltonian path, 1066ex., 1101ex.\nHAM-PATH, 1066ex.\nhandle, 163, 507\nhandshaking lemma, 1172ex.\nIndex\n1267\nharmonic number, 1147, 1153–1154\nharmonic series, 1147, 1153–1154\nHASH-DELETE, 277ex.\nhash function, 256, 262–269\nauxiliary, 272\ncollision-resistant, 964\ndivision method for, 263, 268–269ex.\n\b-universal, 269ex.\nmultiplication method for, 263–264\nuniversal, 265–268\nhashing, 253–285\nwith chaining, 257–260, 283pr.\ndouble, 272–274, 277ex.\nk-universal, 284pr.\nin memoization, 365, 387\nwith open addressing, 269–277\nperfect, 277–282, 285\nto replace adjacency lists, 593ex.\nuniversal, 265–268\nHASH-INSERT, 270, 277ex.\nHASH-SEARCH, 271, 277ex.\nhash table, 256–261\ndynamic, 471ex.\nsecondary, 278\nsee also hashing\nhash value, 256\nhat-check problem, 122ex.\nhead\nin a disk drive, 485\nof a linked list, 236\nof a queue, 234\nheap, 151–169\nanalyzed by potential method, 462ex.\nbinomial, 527pr.\nbuilding, 156–159, 166pr.\ncompared with Fibonacci heaps, 506–507\nd-ary, 167pr., 706pr.\ndeletion from, 166ex.\nin Dijkstra’s algorithm, 662\nextracting the maximum key from, 163\nFibonacci, see Fibonacci heap\nas garbage-collected storage, 151\nheight of, 153\nin Huffman’s algorithm, 433\nto implement a mergeable heap, 506\nincreasing a key in, 163–164\ninsertion into, 164\nin Johnson’s algorithm, 704\nmax-heap, 152\nmaximum key of, 163\nmergeable, see mergeable heap\nmin-heap, 153\nin Prim’s algorithm, 636",
    "parent_e5421053-b955-463a-9afe-c71c68740fc9": "as garbage-collected storage, 151\nheight of, 153\nin Huffman’s algorithm, 433\nto implement a mergeable heap, 506\nincreasing a key in, 163–164\ninsertion into, 164\nin Johnson’s algorithm, 704\nmax-heap, 152\nmaximum key of, 163\nmergeable, see mergeable heap\nmin-heap, 153\nin Prim’s algorithm, 636\nas a priority queue, 162–166\nrelaxed, 530\nrunning times of operations on, 506ﬁg.\nand treaps, 333pr.\n2-3-4, 529pr.\nHEAP-DECREASE-KEY, 165ex.\nHEAP-DELETE, 166ex.\nHEAP-EXTRACT-MAX, 163\nHEAP-EXTRACT-MIN, 165ex.\nHEAP-INCREASE-KEY, 164\nHEAP-MAXIMUM, 163\nHEAP-MINIMUM, 165ex.\nheap property, 152\nmaintenance of, 154–156\nvs. binary-search-tree property, 289ex.\nheapsort, 151–169\nHEAPSORT, 160\nheel, 602ex.\nheight\nof a binomial tree, 527pr.\nblack-, 309\nof a B-tree, 489–490\nof a d-ary heap, 167pr.\nof a decision tree, 193\nexponential, 300\nof a heap, 153\nof a node in a heap, 153, 159ex.\nof a node in a tree, 1177\nof a red-black tree, 309\nof a tree, 1177\nheight-balanced tree, 333pr.\nheight function, in push-relabel algorithms, 738\nhereditary family of subsets, 437\nHermitian matrix, 832ex.\nhigh endpoint of an interval, 348\nhigh function, 537, 546\nHIRE-ASSISTANT, 115\nhiring problem, 114–115, 123–124, 145\non-line, 139–141\nprobabilistic analysis of, 120–121\nhit\ncache, 449pr.\nspurious, 991\n1268\nIndex\nHOARE-PARTITION, 185pr.\nHOPCROFT-KARP, 764pr.\nHopcroft-Karp bipartite matching algorithm,\n763pr.\nhorizontal ray, 1021ex.\nHorner’s rule, 41pr., 900\nin the Rabin-Karp algorithm, 990\nHUFFMAN, 431\nHuffman code, 428–437, 450\nhull, convex, 8, 1029–1039, 1046pr.\nHuman Genome Project, 6\nhyperedge, 1172\nhypergraph, 1172\nand bipartite graphs, 1173ex.\nideal parallel computer, 779\nidempotency laws for sets, 1159\nidentity, 939\nidentity matrix, 1218\nif, in pseudocode, 20\nimage, 1167\nimage compression, 409pr., 413\ninadmissible edge, 749\nincidence, 1169\nincidence matrix\nand difference constraints, 666\nof a directed graph, 448pr., 593ex.\nof an undirected graph, 448pr.\ninclusion and exclusion, 1163ex.\nincomplete step, 782",
    "parent_a9ce196c-91d2-42c6-95c7-3ed5c88c3fe2": "identity matrix, 1218\nif, in pseudocode, 20\nimage, 1167\nimage compression, 409pr., 413\ninadmissible edge, 749\nincidence, 1169\nincidence matrix\nand difference constraints, 666\nof a directed graph, 448pr., 593ex.\nof an undirected graph, 448pr.\ninclusion and exclusion, 1163ex.\nincomplete step, 782\nINCREASE-KEY, 162\nincreasing a key, in a max-heap, 163–164\nINCREMENT, 454\nincremental design method, 29\nfor ﬁnding the convex hull, 1030\nin-degree, 1169\nindentation in pseudocode, 20\nindependence\nof events, 1192–1193, 1195ex.\nof random variables, 1197\nof subproblems in dynamic programming,\n383–384\nindependent family of subsets, 437\nindependent set, 1101pr.\nof tasks, 444\nindependent strands, 789\nindex function, 537, 546\nindex of an element of Z\u0004\nn, 955\nindicator random variable, 118–121\nin analysis of expected height of a randomly\nbuilt binary search tree, 300–303\nin analysis of inserting into a treap, 333pr.\nin analysis of streaks, 138–139\nin analysis of the birthday paradox, 132–133\nin approximation algorithm for\nMAX-3-CNF satisﬁability, 1124\nin bounding the right tail of the binomial\ndistribution, 1212–1213\nin bucket sort analysis, 202–204\nexpected value of, 118\nin hashing analysis, 259–260\nin hiring-problem analysis, 120–121\nand linearity of expectation, 119\nin quicksort analysis, 182–184, 187pr.\nin randomized-selection analysis, 217–219,\n226pr.\nin universal-hashing analysis, 265–266\ninduced subgraph, 1171\ninequality constraint, 852\nand equality constraints, 853\ninequality, linear, 846\ninfeasible linear program, 851\ninfeasible solution, 851\ninﬁnite sequence, 1166\ninﬁnite set, 1161\ninﬁnite sum, 1145\ninﬁnity, arithmetic with, 650\nINITIALIZE-PREFLOW, 740\nINITIALIZE-SIMPLEX, 871, 887\nINITIALIZE-SINGLE-SOURCE, 648\ninitial strand, 779\ninjective function, 1167\ninner product, 1222\ninorder tree walk, 287, 293ex., 342\nINORDER-TREE-WALK, 288\nin-place sorting, 17, 148, 206pr.\ninput\nto an algorithm, 5\nto a combinational circuit, 1071\ndistribution of, 116, 122\nto a logic gate, 1070",
    "parent_23de40e6-da49-462f-8fc3-ff60254527d9": "INITIALIZE-SINGLE-SOURCE, 648\ninitial strand, 779\ninjective function, 1167\ninner product, 1222\ninorder tree walk, 287, 293ex., 342\nINORDER-TREE-WALK, 288\nin-place sorting, 17, 148, 206pr.\ninput\nto an algorithm, 5\nto a combinational circuit, 1071\ndistribution of, 116, 122\nto a logic gate, 1070\nsize of, 25\ninput alphabet, 995\nINSERT, 162, 230, 463ex., 505\ninsertion\ninto binary search trees, 294–295\nIndex\n1269\ninto a bit vector with a superimposed binary\ntree, 534\ninto a bit vector with a superimposed tree of\nconstant height, 534\ninto B-trees, 493–497\ninto chained hash tables, 258\ninto d-ary heaps, 167pr.\ninto direct-address tables, 254\ninto dynamic tables, 464–467\nelementary, 465\ninto Fibonacci heaps, 510–511\ninto heaps, 164\ninto interval trees, 349\ninto linked lists, 237–238\ninto open-address hash tables, 270\ninto order-statistic trees, 343\ninto proto van Emde Boas structures, 544\ninto queues, 234\ninto red-black trees, 315–323\ninto stacks, 232\ninto sweep-line statuses, 1024\ninto treaps, 333pr.\ninto 2-3-4 heaps, 529pr.\ninto van Emde Boas trees, 552–554\ninto Young tableaus, 167pr.\ninsertion sort, 12, 16–20, 25–27\nin bucket sort, 201–204\ncompared with merge sort, 14ex.\ncompared with quicksort, 178ex.\ndecision tree for, 192ﬁg.\nin merge sort, 39pr.\nin quicksort, 185ex.\nusing binary search, 39ex.\nINSERTION-SORT, 18, 26, 208pr.\ninstance\nof an abstract problem, 1051, 1054\nof a problem, 5\ninstructions of the RAM model, 23\ninteger data type, 23\ninteger linear programming, 850, 895pr.,\n1101ex.\nintegers (Z), 1158\ninteger-valued ﬂow, 733\nintegrality theorem, 734\nintegral, to approximate summations,\n1154–1156\nintegration of a series, 1147\ninterior of a polygon, 1020ex.\ninterior-point method, 850, 897\nintermediate vertex, 693\ninternal node, 1176\ninternal path length, 1180ex.\ninterpolation by a cubic spline, 840pr.\ninterpolation by a polynomial, 901, 906ex.\nat complex roots of unity, 912–913\nintersection\nof chords, 345ex.\ndetermining, for a set of line segments,\n1021–1029, 1047",
    "parent_188bd6cc-0f93-4fe0-b0f1-03e1a06bb49b": "intermediate vertex, 693\ninternal node, 1176\ninternal path length, 1180ex.\ninterpolation by a cubic spline, 840pr.\ninterpolation by a polynomial, 901, 906ex.\nat complex roots of unity, 912–913\nintersection\nof chords, 345ex.\ndetermining, for a set of line segments,\n1021–1029, 1047\ndetermining, for two line segments,\n1017–1019\nof languages, 1058\nof sets (\\), 1159\ninterval, 348\nfuzzy sorting of, 189pr.\nINTERVAL-DELETE, 349\ninterval graph, 422ex.\nINTERVAL-INSERT, 349\nINTERVAL-SEARCH, 349, 351\nINTERVAL-SEARCH-EXACTLY, 354ex.\ninterval tree, 348–354\ninterval trichotomy, 348\nintractability, 1048\ninvalid shift, 985\ninventory planning, 411pr.\ninverse\nof a bijective function, 1167\nin a group, 940\nof a matrix, 827–831, 842, 1223, 1225ex.\nmultiplicative, modulo n, 949\ninversion\nin a self-organizing list, 476pr.\nin a sequence, 41pr., 122ex., 345ex.\ninverter, 1070\ninvertible matrix, 1223\nisolated vertex, 1169\nisomorphic graphs, 1171\niterated function, 63pr.\niterated logarithm function, 58–59\nITERATIVE-FFT, 917\nITERATIVE-TREE-SEARCH, 291\niter function, 577\nJarvis’s march, 1037–1038, 1047\nJensen’s inequality, 1199\nJOHNSON, 704\n1270\nIndex\nJohnson’s algorithm, 700–706\njoining\nof red-black trees, 332pr.\nof 2-3-4 trees, 503pr.\njoint probability density function, 1197\nJosephus permutation, 355pr.\nKarmarkar’s algorithm, 897\nKarp’s minimum mean-weight cycle algorithm,\n680pr.\nk-ary tree, 1179\nk-CNF, 1049\nk-coloring, 1103pr., 1180pr.\nk-combination, 1185\nk-conjunctive normal form, 1049\nkernel of a polygon, 1038ex.\nkey, 16, 147, 162, 229\ndummy, 397\ninterpreted as a natural number, 263\nmedian, of a B-tree node, 493\npublic, 959, 962\nsecret, 959, 962\nstatic, 277\nkeywords, in pseudocode, 20–22\nmultithreaded, 774, 776–777, 785–786\n“killer adversary” for quicksort, 190\nKirchhoff’s current law, 708\nKleene star (\u0004), 1058\nKMP algorithm, 1002–1013\nKMP-MATCHER, 1005\nknapsack problem\nfractional, 426, 428ex.\n0-1, 425, 427ex., 1137pr., 1139\nk-neighbor tree, 338\nknot, of a spline, 840pr.",
    "parent_8de05318-38fe-43a8-b755-75d76cc1f53c": "multithreaded, 774, 776–777, 785–786\n“killer adversary” for quicksort, 190\nKirchhoff’s current law, 708\nKleene star (\u0004), 1058\nKMP algorithm, 1002–1013\nKMP-MATCHER, 1005\nknapsack problem\nfractional, 426, 428ex.\n0-1, 425, 427ex., 1137pr., 1139\nk-neighbor tree, 338\nknot, of a spline, 840pr.\nKnuth-Morris-Pratt algorithm, 1002–1013\nk-permutation, 126, 1184\nKraft inequality, 1180ex.\nKruskal’s algorithm, 631–633, 642\nwith integer edge weights, 637ex.\nk-sorted, 207pr.\nk-string, 1184\nk-subset, 1161\nk-substring, 1184\nkth power, 933ex.\nk-universal hashing, 284pr.\nLagrange’s formula, 902\nLagrange’s theorem, 944\nLam´e’s theorem, 936\nlanguage, 1057\ncompleteness of, 1077ex.\nproving NP-completeness of, 1078–1079\nveriﬁcation of, 1063\nlast-in, ﬁrst-out, 232\nsee also stack\nlate task, 444\nlayers\nconvex, 1044pr.\nmaximal, 1045pr.\nLCA, 584pr.\nlcm (least common multiple), 939ex.\nLCS, 7, 390–397, 413\nLCS-LENGTH, 394\nleading submatrix, 833, 839ex.\nleaf, 1176\nleast common ancestor, 584pr.\nleast common multiple, 939ex.\nleast-squares approximation, 835–839\nleaving a vertex, 1169\nleaving variable, 867\nLEFT, 152\nleft child, 1178\nleft-child, right-sibling representation, 246,\n249ex.\nLEFT-ROTATE, 313, 353ex.\nleft rotation, 312\nleft spine, 333pr.\nleft subtree, 1178\nLegendre symbol . a\np /, 982pr.\nlength\nof a path, 1170\nof a sequence, 1166\nof a spine, 333pr.\nof a string, 986, 1184\nlevel\nof a function, 573\nof a tree, 1177\nlevel function, 576\nlexicographically less than, 304pr.\nlexicographic sorting, 304pr.\nlg (binary logarithm), 56\nlg\u0004 (iterated logarithm function), 58–59\nlgk (exponentiation of logarithms), 56\nlg lg (composition of logarithms), 56\nLIFO (last-in, ﬁrst-out), 232\nIndex\n1271\nsee also stack\nlight edge, 626\nlinear constraint, 846\nlinear dependence, 1223\nlinear equality, 845\nlinear equations\nsolving modular, 946–950\nsolving systems of, 813–827\nsolving tridiagonal systems of, 840pr.\nlinear function, 26, 845\nlinear independence, 1223\nlinear inequality, 846",
    "parent_74200b9b-22bc-44bb-8d60-5c5e95fc7e9d": "Index\n1271\nsee also stack\nlight edge, 626\nlinear constraint, 846\nlinear dependence, 1223\nlinear equality, 845\nlinear equations\nsolving modular, 946–950\nsolving systems of, 813–827\nsolving tridiagonal systems of, 840pr.\nlinear function, 26, 845\nlinear independence, 1223\nlinear inequality, 846\nlinear-inequality feasibility problem, 894pr.\nlinearity of expectation, 1198\nand indicator random variables, 119\nlinearity of summations, 1146\nlinear order, 1165\nlinear permutation, 1229pr.\nlinear probing, 272\nlinear programming, 7, 843–897\nalgorithms for, 850\napplications of, 849\nduality in, 879–886\nellipsoid algorithm for, 850, 897\nﬁnding an initial solution in, 886–891\nfundamental theorem of, 892\ninterior-point methods for, 850, 897\nKarmarkar’s algorithm for, 897\nand maximum ﬂow, 860–861\nand minimum-cost circulation, 896pr.\nand minimum-cost ﬂow, 861–862\nand minimum-cost multicommodity ﬂow,\n864ex.\nand multicommodity ﬂow, 862–863\nsimplex algorithm for, 864–879, 896\nand single-pair shortest path, 859–860\nand single-source shortest paths, 664–670,\n863ex.\nslack form for, 854–857\nstandard form for, 850–854\nsee also integer linear programming, 0-1\ninteger programming\nlinear-programming relaxation, 1125\nlinear search, 22ex.\nlinear speedup, 780\nline segment, 1015\ncomparable, 1022\ndetermining turn of, 1017\ndetermining whether any intersect,\n1021–1029, 1047\ndetermining whether two intersect,\n1017–1019\nlink\nof binomial trees, 527pr.\nof Fibonacci-heap roots, 513\nof trees in a disjoint-set forest, 570–571\nLINK, 571\nlinked list, 236–241\ncompact, 245ex., 250pr.\ndeletion from, 238\nto implement disjoint sets, 564–568\ninsertion into, 237–238\nneighbor list, 750\nsearching, 237, 268ex.\nself-organizing, 476pr.\nlist, see linked list\nLIST-DELETE, 238\nLIST-DELETE0, 238\nLIST-INSERT, 238\nLIST-INSERT0, 240\nLIST-SEARCH, 237\nLIST-SEARCH0, 239\nliteral, 1082\nlittle-oh notation, 50–51, 64\nlittle-omega notation, 51\nLm-distance, 1044ex.\nln (natural logarithm), 56\nload factor\nof a dynamic table, 463",
    "parent_32c8eb52-cfb7-4e53-a476-01c4af156e59": "list, see linked list\nLIST-DELETE, 238\nLIST-DELETE0, 238\nLIST-INSERT, 238\nLIST-INSERT0, 240\nLIST-SEARCH, 237\nLIST-SEARCH0, 239\nliteral, 1082\nlittle-oh notation, 50–51, 64\nlittle-omega notation, 51\nLm-distance, 1044ex.\nln (natural logarithm), 56\nload factor\nof a dynamic table, 463\nof a hash table, 258\nload instruction, 23\nlocal variable, 21\nlogarithm function (log), 56–57\ndiscrete, 955\niterated (lg\u0004), 58–59\nlogical parallelism, 777\nlogic gate, 1070\nlongest common subsequence, 7, 390–397, 413\nlongest palindrome subsequence, 405pr.\nLONGEST-PATH, 1060ex.\nLONGEST-PATH-LENGTH, 1060ex.\nlongest simple cycle, 1101ex.\nlongest simple path, 1048\nin an unweighted graph, 382\nin a weighted directed acyclic graph, 404pr.\nLOOKUP-CHAIN, 388\n1272\nIndex\nloop, in pseudocode, 20\nparallel, 785–787\nloop invariant, 18–19\nfor breadth-ﬁrst search, 595\nfor building a heap, 157\nfor consolidating the root list of a Fibonacci\nheap, 517\nfor determining the rank of an element in an\norder-statistic tree, 342\nfor Dijkstra’s algorithm, 660\nand for loops, 19n.\nfor the generic minimum-spanning-tree\nmethod, 625\nfor the generic push-relabel algorithm, 743\nfor Graham’s scan, 1034\nfor heapsort, 160ex.\nfor Horner’s rule, 41pr.\nfor increasing a key in a heap, 166ex.\ninitialization of, 19\nfor insertion sort, 18\nmaintenance of, 19\nfor merging, 32\nfor modular exponentiation, 957\norigin of, 42\nfor partitioning, 171\nfor Prim’s algorithm, 636\nfor the Rabin-Karp algorithm, 993\nfor randomly permuting an array, 127,\n128ex.\nfor red-black tree insertion, 318\nfor the relabel-to-front algorithm, 755\nfor searching an interval tree, 352\nfor the simplex algorithm, 872\nfor string-matching automata, 998, 1000\nand termination, 19\nlow endpoint of an interval, 348\nlower bounds\non approximations, 1140\nasymptotic, 48\nfor average sorting, 207pr.\non binomial coefﬁcients, 1186\nfor comparting water jugs, 206pr.\nfor convex hull, 1038ex., 1047\nfor disjoint-set data structures, 585\nfor ﬁnding the minimum, 214",
    "parent_67bd8b90-170d-4242-957a-d3965ddcea96": "and termination, 19\nlow endpoint of an interval, 348\nlower bounds\non approximations, 1140\nasymptotic, 48\nfor average sorting, 207pr.\non binomial coefﬁcients, 1186\nfor comparting water jugs, 206pr.\nfor convex hull, 1038ex., 1047\nfor disjoint-set data structures, 585\nfor ﬁnding the minimum, 214\nfor ﬁnding the predecessor, 560\nfor length of an optimal traveling-salesman\ntour, 1112–1115\nfor median ﬁnding, 227\nfor merging, 208pr.\nfor minimum-weight vertex cover,\n1124–1126\nfor multithreaded computations, 780\nand potential functions, 478\nfor priority-queue operations, 531\nand recurrences, 67\nfor simultaneous minimum and maximum,\n215ex.\nfor size of an optimal vertex cover, 1110,\n1135pr.\nfor sorting, 191–194, 205pr., 211, 531\nfor streaks, 136–138, 142ex.\non summations, 1152, 1154\nlower median, 213\nlower square root\n\u000b\n#p\n\f\n, 546\nlower-triangular matrix, 1219, 1222ex.,\n1225ex.\nlow function, 537, 546\nLU decomposition, 806pr., 819–822\nLU-DECOMPOSITION, 821\nLUP decomposition, 806pr., 815\ncomputation of, 822–825\nof a diagonal matrix, 827ex.\nin matrix inversion, 828\nand matrix multiplication, 832ex.\nof a permutation matrix, 827ex.\nuse of, 815–819\nLUP-DECOMPOSITION, 824\nLUP-SOLVE, 817\nmain memory, 484\nMAKE-HEAP, 505\nMAKE-SET, 561\ndisjoint-set-forest implementation of, 571\nlinked-list implementation of, 564\nmakespan, 1136pr.\nMAKE-TREE, 583pr.\nManhattan distance, 225pr., 1044ex.\nmarked node, 508, 519–520\nMarkov’s inequality, 1201ex.\nmaster method for solving a recurrence, 93–97\nmaster theorem, 94\nproof of, 97–106\nmatched vertex, 732\nmatching\nbipartite, 732, 763pr.\nIndex\n1273\nmaximal, 1110, 1135pr.\nmaximum, 1135pr.\nand maximum ﬂow, 732–736, 747ex.\nperfect, 735ex.\nof strings, 985–1013\nweighted bipartite, 530\nmatric matroid, 437\nmatrix, 1217–1229\naddition of, 1220\nadjacency, 591\nconjugate transpose of, 832ex.\ndeterminant of, 1224–1225\ndiagonal, 1218\nHermitian, 832ex.\nidentity, 1218\nincidence, 448pr., 593ex.\ninversion of, 806pr., 827–831, 842\nlower-triangular, 1219, 1222ex., 1225ex.",
    "parent_c8301b97-02ee-4dd2-a0bf-069b646297de": "matric matroid, 437\nmatrix, 1217–1229\naddition of, 1220\nadjacency, 591\nconjugate transpose of, 832ex.\ndeterminant of, 1224–1225\ndiagonal, 1218\nHermitian, 832ex.\nidentity, 1218\nincidence, 448pr., 593ex.\ninversion of, 806pr., 827–831, 842\nlower-triangular, 1219, 1222ex., 1225ex.\nmultiplication of, see matrix multiplication\nnegative of, 1220\npermutation, 1220, 1222ex.\npredecessor, 685\nproduct of, with a vector, 785–787, 789–790,\n792ex.\npseudoinverse of, 837\nscalar multiple of, 1220\nsubtraction of, 1221\nsymmetric, 1220\nsymmetric positive-deﬁnite, 832–835, 842\nToeplitz, 921pr.\ntranspose of, 797ex., 1217\ntranspose of, multithreaded, 792ex.\ntridiagonal, 1219\nunit lower-triangular, 1219\nunit upper-triangular, 1219\nupper-triangular, 1219, 1225ex.\nVandermonde, 902, 1226pr.\nmatrix-chain multiplication, 370–378\nMATRIX-CHAIN-MULTIPLY\nMATRIX-CHAIN-ORDER, 375\nmatrix multiplication, 75–83, 1221\nfor all-pairs shortest paths, 686–693,\n706–707\nboolean, 832ex.\nand computing the determinant, 832ex.\ndivide-and-conquer method for, 76–83\nand LUP decomposition, 832ex.\nand matrix inversion, 828–831, 842\nmultithreaded algorithm for, 792–797,\n806pr.\nPan’s method for, 82ex.\nStrassen’s algorithm for, 79–83, 111–112\nMATRIX-MULTIPLY, 371\nmatrix-vector multiplication, multithreaded,\n785–787, 792ex.\nwith race, 789–790\nmatroid, 437–443, 448pr., 450, 642\nfor task scheduling, 443–446\nMAT-VEC, 785\nMAT-VEC-MAIN-LOOP, 786\nMAT-VEC-WRONG, 790\nMAX-CNF satisﬁability, 1127ex.\nMAX-CUT problem, 1127ex.\nMAX-FLOW-BY-SCALING, 763pr.\nmax-ﬂow min-cut theorem, 723\nmax-heap, 152\nbuilding, 156–159\nd-ary, 167pr.\ndeletion from, 166ex.\nextracting the maximum key from, 163\nin heapsort, 159–162\nincreasing a key in, 163–164\ninsertion into, 164\nmaximum key of, 163\nas a max-priority queue, 162–166\nmergeable, 250n., 481n., 505n.\nMAX-HEAPIFY, 154\nMAX-HEAP-INSERT, 164\nbuilding a heap with, 166pr.\nmax-heap property, 152\nmaintenance of, 154–156\nmaximal element, of a partially ordered set,\n1165\nmaximal layers, 1045pr.",
    "parent_7b7e2acb-b2a4-4e37-be3f-b33d6df18989": "insertion into, 164\nmaximum key of, 163\nas a max-priority queue, 162–166\nmergeable, 250n., 481n., 505n.\nMAX-HEAPIFY, 154\nMAX-HEAP-INSERT, 164\nbuilding a heap with, 166pr.\nmax-heap property, 152\nmaintenance of, 154–156\nmaximal element, of a partially ordered set,\n1165\nmaximal layers, 1045pr.\nmaximal matching, 1110, 1135pr.\nmaximal point, 1045pr.\nmaximal subset, in a matroid, 438\nmaximization linear program, 846\nand minimization linear programs, 852\nmaximum, 213\nin binary search trees, 291\nof a binomial distribution, 1207ex.\nin a bit vector with a superimposed binary\ntree, 533\nin a bit vector with a superimposed tree of\nconstant height, 535\n1274\nIndex\nﬁnding, 214–215\nin heaps, 163\nin order-statistic trees, 347ex.\nin proto van Emde Boas structures, 544ex.\nin red-black trees, 311\nin van Emde Boas trees, 550\nMAXIMUM, 162–163, 230\nmaximum bipartite matching, 732–736,\n747ex., 766\nHopcroft-Karp algorithm for, 763pr.\nmaximum degree, in a Fibonacci heap, 509,\n523–526\nmaximum ﬂow, 708–766\nEdmonds-Karp algorithm for, 727–730\nFord-Fulkerson method for, 714–731, 765\nas a linear program, 860–861\nand maximum bipartite matching, 732–736,\n747ex.\npush-relabel algorithms for, 736–760, 765\nrelabel-to-front algorithm for, 748–760\nscaling algorithm for, 762pr., 765\nupdating, 762pr.\nmaximum matching, 1135pr.\nmaximum spanning tree, 1137pr.\nmaximum-subarray problem, 68–75, 111\nmax-priority queue, 162\nMAX-3-CNF satisﬁability, 1123–1124, 1139\nMAYBE-MST-A, 641pr.\nMAYBE-MST-B, 641pr.\nMAYBE-MST-C, 641pr.\nmean, see expected value\nmean weight of a cycle, 680pr.\nmedian, 213–227\nmultithreaded algorithm for, 805ex.\nof sorted lists, 223ex.\nof two sorted lists, 804ex.\nweighted, 225pr.\nmedian key, of a B-tree node, 493\nmedian-of-3 method, 188pr.\nmember of a set (2), 1158\nmembership\nin proto van Emde Boas structures, 540–541\nin Van Emde Boas trees, 550\nmemoization, 365, 387–389\nMEMOIZED-CUT-ROD, 365\nMEMOIZED-CUT-ROD-AUX, 366\nMEMOIZED-MATRIX-CHAIN, 388\nmemory, 484\nmemory hierarchy, 24\nMERGE, 31",
    "parent_22b80a43-ae1c-4889-bc6d-adae535e9327": "median-of-3 method, 188pr.\nmember of a set (2), 1158\nmembership\nin proto van Emde Boas structures, 540–541\nin Van Emde Boas trees, 550\nmemoization, 365, 387–389\nMEMOIZED-CUT-ROD, 365\nMEMOIZED-CUT-ROD-AUX, 366\nMEMOIZED-MATRIX-CHAIN, 388\nmemory, 484\nmemory hierarchy, 24\nMERGE, 31\nmergeable heap, 481, 505\nbinomial heaps, 527pr.\nlinked-list implementation of, 250pr.\nrelaxed heaps, 530\nrunning times of operations on, 506ﬁg.\n2-3-4 heaps, 529pr.\nsee also Fibonacci heap\nmergeable max-heap, 250n., 481n., 505n.\nmergeable min-heap, 250n., 481n., 505\nMERGE-LISTS, 1129\nmerge sort, 12, 30–37\ncompared with insertion sort, 14ex.\nmultithreaded algorithm for, 797–805, 812\nuse of insertion sort in, 39pr.\nMERGE-SORT, 34\nMERGE-SORT0, 797\nmerging\nof k sorted lists, 166ex.\nlower bounds for, 208pr.\nmultithreaded algorithm for, 798–801\nof two sorted arrays, 30\nMILLER-RABIN, 970\nMiller-Rabin primality test, 968–975, 983\nMIN-GAP, 354ex.\nmin-heap, 153\nanalyzed by potential method, 462ex.\nbuilding, 156–159\nd-ary, 706pr.\nin Dijkstra’s algorithm, 662\nin Huffman’s algorithm, 433\nin Johnson’s algorithm, 704\nmergeable, 250n., 481n., 505\nas a min-priority queue, 165ex.\nin Prim’s algorithm, 636\nMIN-HEAPIFY, 156ex.\nMIN-HEAP-INSERT, 165ex.\nmin-heap ordering, 507\nmin-heap property, 153, 507\nmaintenance of, 156ex.\nin treaps, 333pr.\nvs. binary-search-tree property, 289ex.\nminimization linear program, 846\nand maximization linear programs, 852\nminimum, 213\nin binary search trees, 291\nIndex\n1275\nin a bit vector with a superimposed binary\ntree, 533\nin a bit vector with a superimposed tree of\nconstant height, 535\nin B-trees, 497ex.\nin Fibonacci heaps, 511\nﬁnding, 214–215\noff-line, 582pr.\nin order-statistic trees, 347ex.\nin proto van Emde Boas structures, 541–542\nin red-black trees, 311\nin 2-3-4 heaps, 529pr.\nin van Emde Boas trees, 550\nMINIMUM, 162, 214, 230, 505\nminimum-cost circulation, 896pr.\nminimum-cost ﬂow, 861–862\nminimum-cost multicommodity ﬂow, 864ex.\nminimum-cost spanning tree, see minimum",
    "parent_3a9f7d15-f9e5-456c-b4a5-56e2338b3060": "in proto van Emde Boas structures, 541–542\nin red-black trees, 311\nin 2-3-4 heaps, 529pr.\nin van Emde Boas trees, 550\nMINIMUM, 162, 214, 230, 505\nminimum-cost circulation, 896pr.\nminimum-cost ﬂow, 861–862\nminimum-cost multicommodity ﬂow, 864ex.\nminimum-cost spanning tree, see minimum\nspanning tree\nminimum cut, 721, 731ex.\nminimum degree, of a B-tree, 489\nminimum mean-weight cycle, 680pr.\nminimum node, of a Fibonacci heap, 508\nminimum path cover, 761pr.\nminimum spanning tree, 624–642\nin approximation algorithm for\ntraveling-salesman problem, 1112\nBor˙uvka’s algorithm for, 641\non dynamic graphs, 637ex.\ngeneric method for, 625–630\nKruskal’s algorithm for, 631–633\nPrim’s algorithm for, 634–636\nrelation to matroids, 437, 439–440\nsecond-best, 638pr.\nminimum-weight spanning tree, see minimum\nspanning tree\nminimum-weight vertex cover, 1124–1127,\n1139\nminor of a matrix, 1224\nmin-priority queue, 162\nin constructing Huffman codes, 431\nin Dijkstra’s algorithm, 661\nin Prim’s algorithm, 634, 636\nmiss, 449pr.\nmissing child, 1178\nmod, 54, 928\nmodifying operation, 230\nmodular arithmetic, 54, 923pr., 939–946\nmodular equivalence, 54, 1165ex.\nmodular exponentiation, 956\nMODULAR-EXPONENTIATION, 957\nmodular linear equations, 946–950\nMODULAR-LINEAR-EQUATION-SOLVER,\n949\nmodulo, 54, 928\nMonge array, 110pr.\nmonotone sequence, 168\nmonotonically decreasing, 53\nmonotonically increasing, 53\nMonty Hall problem, 1195ex.\nmove-to-front heuristic, 476pr., 478\nMST-KRUSKAL, 631\nMST-PRIM, 634\nMST-REDUCE, 639pr.\nmuch-greater-than (\u000b), 574\nmuch-less-than (\f), 783\nmulticommodity ﬂow, 862–863\nminimum-cost, 864ex.\nmulticore computer, 772\nmultidimensional fast Fourier transform,\n921pr.\nmultigraph, 1172\nconverting to equivalent undirected graph,\n593ex.\nmultiple, 927\nof an element modulo n, 946–950\nleast common, 939ex.\nscalar, 1220\nmultiple assignment, 21\nmultiple sources and sinks, 712\nmultiplication\nof complex numbers, 83ex.\ndivide-and-conquer method for, 920pr.\nof matrices, see matrix multiplication",
    "parent_989f0392-60a2-44bd-92d0-6380ec0224a5": "593ex.\nmultiple, 927\nof an element modulo n, 946–950\nleast common, 939ex.\nscalar, 1220\nmultiple assignment, 21\nmultiple sources and sinks, 712\nmultiplication\nof complex numbers, 83ex.\ndivide-and-conquer method for, 920pr.\nof matrices, see matrix multiplication\nof a matrix chain, 370–378\nmatrix-vector, multithreaded, 785–787,\n789–790, 792ex.\nmodulo n (\u0003n), 940\nof polynomials, 899\nmultiplication method, 263–264\nmultiplicative group modulo n, 941\nmultiplicative inverse, modulo n, 949\nmultiply instruction, 23\nMULTIPOP, 453\nmultiprocessor, 772\nMULTIPUSH, 456ex.\n1276\nIndex\nmultiset, 1158n.\nmultithreaded algorithm, 10, 772–812\nfor computing Fibonacci numbers, 774–780\nfor fast Fourier transform, 804ex.\nFloyd-Warshall algorithm, 797ex.\nfor LU decomposition, 806pr.\nfor LUP decomposition, 806pr.\nfor matrix inversion, 806pr.\nfor matrix multiplication, 792–797, 806pr.\nfor matrix transpose, 792ex., 797ex.\nfor matrix-vector product, 785–787,\n789–790, 792ex.\nfor median, 805ex.\nfor merge sorting, 797–805, 812\nfor merging, 798–801\nfor order statistics, 805ex.\nfor partitioning, 804ex.\nfor preﬁx computation, 807pr.\nfor quicksort, 811pr.\nfor reduction, 807pr.\nfor a simple stencil calculation, 809pr.\nfor solving systems of linear equations,\n806pr.\nStrassen’s algorithm, 795–796\nmultithreaded composition, 784ﬁg.\nmultithreaded computation, 777\nmultithreaded scheduling, 781–783\nmutually exclusive events, 1190\nmutually independent events, 1193\nN (set of natural numbers), 1158\nnaive algorithm, for string matching, 988–990\nNAIVE-STRING-MATCHER, 988\nnatural cubic spline, 840pr.\nnatural numbers (N), 1158\nkeys interpreted as, 263\nnegative of a matrix, 1220\nnegative-weight cycle\nand difference constraints, 667\nand relaxation, 677ex.\nand shortest paths, 645, 653–654, 692ex.,\n700ex.\nnegative-weight edges, 645–646\nneighbor, 1172\nneighborhood, 735ex.\nneighbor list, 750\nnested parallelism, 776, 805pr.\nnesting boxes, 678pr.\nnet ﬂow across a cut, 720\nnetwork\nadmissible, 749–750\nﬂow, see ﬂow network",
    "parent_3cc933e3-6605-4143-82d5-84f72b75471e": "and relaxation, 677ex.\nand shortest paths, 645, 653–654, 692ex.,\n700ex.\nnegative-weight edges, 645–646\nneighbor, 1172\nneighborhood, 735ex.\nneighbor list, 750\nnested parallelism, 776, 805pr.\nnesting boxes, 678pr.\nnet ﬂow across a cut, 720\nnetwork\nadmissible, 749–750\nﬂow, see ﬂow network\nresidual, 715–719\nfor sorting, 811\nNEXT-TO-TOP, 1031\nNIL, 21\nnode, 1176\nsee also vertex\nnonbasic variable, 855\nnondeterministic multithreaded algorithm, 787\nnondeterministic polynomial time, 1064n.\nsee also NP\nnonhamiltonian graph, 1061\nnoninstance, 1056n.\nnoninvertible matrix, 1223\nnonnegativity constraint, 851, 853\nnonoverlappable string pattern, 1002ex.\nnonsaturating push, 739, 745\nnonsingular matrix, 1223\nnontrivial power, 933ex.\nnontrivial square root of 1, modulo n, 956\nno-path property, 650, 672\nnormal equation, 837\nnorm of a vector, 1222\nNOT function (:), 1071\nnot a set member (62), 1158\nnot equivalent (6\b), 54\nNOT gate, 1070\nNP (complexity class), 1049, 1064, 1066ex.,\n1105\nNPC (complexity class), 1050, 1069\nNP-complete, 1050, 1069\nNP-completeness, 9–10, 1048–1105\nof the circuit-satisﬁability problem,\n1070–1077\nof the clique problem, 1086–1089, 1105\nof determining whether a boolean formula is\na tautology, 1086ex.\nof the formula-satisﬁability problem,\n1079–1081, 1105\nof the graph-coloring problem, 1103pr.\nof the half 3-CNF satisﬁability problem,\n1101ex.\nof the hamiltonian-cycle problem,\n1091–1096, 1105\nof the hamiltonian-path problem, 1101ex.\nIndex\n1277\nof the independent-set problem, 1101pr.\nof integer linear programming, 1101ex.\nof the longest-simple-cycle problem,\n1101ex.\nproving, of a language, 1078–1079\nof scheduling with proﬁts and deadlines,\n1104pr.\nof the set-covering problem, 1122ex.\nof the set-partition problem, 1101ex.\nof the subgraph-isomorphism problem,\n1100ex.\nof the subset-sum problem, 1097–1100\nof the 3-CNF-satisﬁability problem,\n1082–1085, 1105\nof the traveling-salesman problem,\n1096–1097\nof the vertex-cover problem, 1089–1091,\n1105",
    "parent_48098b5c-1e57-415e-b06e-8303ce50f89e": "of the set-covering problem, 1122ex.\nof the set-partition problem, 1101ex.\nof the subgraph-isomorphism problem,\n1100ex.\nof the subset-sum problem, 1097–1100\nof the 3-CNF-satisﬁability problem,\n1082–1085, 1105\nof the traveling-salesman problem,\n1096–1097\nof the vertex-cover problem, 1089–1091,\n1105\nof 0-1 integer programming, 1100ex.\nNP-hard, 1069\nn-set, 1161\nn-tuple, 1162\nnull event, 1190\nnull tree, 1178\nnull vector, 1224\nnumber-ﬁeld sieve, 984\nnumerical stability, 813, 815, 842\nn-vector, 1218\no-notation, 50–51, 64\nO-notation, 45ﬁg., 47–48, 64\nO0-notation, 62pr.\ne\nO-notation, 62pr.\nobject, 21\nallocation and freeing of, 243–244\narray implementation of, 241–246\npassing as parameter, 21\nobjective function, 664, 847, 851\nobjective value, 847, 851\noblivious compare-exchange algorithm, 208pr.\noccurrence of a pattern, 985\nOFF-LINE-MINIMUM, 583pr.\noff-line problem\ncaching, 449pr.\nleast common ancestors, 584pr.\nminimum, 582pr.\nOmega-notation, 45ﬁg., 48–49, 64\n1-approximation algorithm, 1107\none-pass method, 585\none-to-one correspondence, 1167\none-to-one function, 1167\non-line convex-hull problem, 1039ex.\non-line hiring problem, 139–141\nON-LINE-MAXIMUM, 140\non-line multithreaded scheduler, 781\nON-SEGMENT, 1018\nonto function, 1167\nopen-address hash table, 269–277\nwith double hashing, 272–274, 277ex.\nwith linear probing, 272\nwith quadratic probing, 272, 283pr.\nopen interval, 348\nOpenMP, 774\noptimal binary search tree, 397–404, 413\nOPTIMAL-BST, 402\noptimal objective value, 851\noptimal solution, 851\noptimal subset, of a matroid, 439\noptimal substructure\nof activity selection, 416\nof binary search trees, 399–400\nin dynamic programming, 379–384\nof the fractional knapsack problem, 426\nin greedy algorithms, 425\nof Huffman codes, 435\nof longest common subsequences, 392–393\nof matrix-chain multiplication, 373\nof rod-cutting, 362\nof shortest paths, 644–645, 687, 693–694\nof unweighted shortest paths, 382\nof weighted matroids, 442\nof the 0-1 knapsack problem, 426",
    "parent_5c5aa23f-eb3d-4134-8b24-293d39dcfd3b": "in greedy algorithms, 425\nof Huffman codes, 435\nof longest common subsequences, 392–393\nof matrix-chain multiplication, 373\nof rod-cutting, 362\nof shortest paths, 644–645, 687, 693–694\nof unweighted shortest paths, 382\nof weighted matroids, 442\nof the 0-1 knapsack problem, 426\noptimal vertex cover, 1108\noptimization problem, 359, 1050, 1054\napproximation algorithms for, 10,\n1106–1140\nand decision problems, 1051\nOR function (_), 697, 1071\norder\nof a group, 945\nlinear, 1165\npartial, 1165\ntotal, 1165\nordered pair, 1161\nordered tree, 1177\norder of growth, 28\n1278\nIndex\norder statistics, 213–227\ndynamic, 339–345\nmultithreaded algorithm for, 805ex.\norder-statistic tree, 339–345\nquerying, 347ex.\nOR gate, 1070\norigin, 1015\nor, in pseudocode, 22\northonormal, 842\nOS-KEY-RANK, 344ex.\nOS-RANK, 342\nOS-SELECT, 341\nout-degree, 1169\nouter product, 1222\noutput\nof an algorithm, 5\nof a combinational circuit, 1071\nof a logic gate, 1070\noverdetermined system of linear equations, 814\noverﬂow\nof a queue, 235\nof a stack, 233\noverﬂowing vertex, 736\ndischarge of, 751\noverlapping intervals, 348\nﬁnding all, 354ex.\npoint of maximum overlap, 354pr.\noverlapping rectangles, 354ex.\noverlapping subproblems, 384–386\noverlapping-sufﬁx lemma, 987\nP (complexity class), 1049, 1055, 1059,\n1061ex., 1105\npackage wrapping, 1037, 1047\npage on a disk, 486, 499ex., 502pr.\npair, ordered, 1161\npairwise disjoint sets, 1161\npairwise independence, 1193\npairwise relatively prime, 931\npalindrome, 405pr.\nPan’s method for matrix multiplication, 82ex.\nparallel algorithm, 10, 772\nsee also multithreaded algorithm\nparallel computer, 772\nideal, 779\nparallel for, in pseudocode, 785–786\nparallelism\nlogical, 777\nof a multithreaded computation, 780\nnested, 776\nof a randomized multithreaded algorithm,\n811pr.\nparallel loop, 785–787, 805pr.\nparallel-machine-scheduling problem, 1136pr.\nparallel preﬁx, 807pr.\nparallel random-access machine, 811\nparallel slackness, 781\nrule of thumb, 783\nparallel, strands being logically in, 778",
    "parent_691e88a6-e2a9-436b-a06a-255e386e133a": "nested, 776\nof a randomized multithreaded algorithm,\n811pr.\nparallel loop, 785–787, 805pr.\nparallel-machine-scheduling problem, 1136pr.\nparallel preﬁx, 807pr.\nparallel random-access machine, 811\nparallel slackness, 781\nrule of thumb, 783\nparallel, strands being logically in, 778\nparameter, 21\ncosts of passing, 107pr.\nparent\nin a breadth-ﬁrst tree, 594\nin a multithreaded computation, 776\nin a rooted tree, 1176\nPARENT, 152\nparenthesis structure of depth-ﬁrst search, 606\nparenthesis theorem, 606\nparenthesization of a matrix-chain product, 370\nparse tree, 1082\npartially ordered set, 1165\npartial order, 1165\nPARTITION, 171\nPARTITION0, 186pr.\npartition function, 361n.\npartitioning, 171–173\naround median of 3 elements, 185ex.\nHoare’s method for, 185pr.\nmultithreaded algorithm for, 804ex.\nrandomized, 179\npartition of a set, 1161, 1164\nPascal’s triangle, 1188ex.\npath, 1170\naugmenting, 719–720, 763pr.\ncritical, 657\nﬁnd, 569\nhamiltonian, 1066ex.\nlongest, 382, 1048\nshortest, see shortest paths\nsimple, 1170\nweight of, 643\nPATH, 1051, 1058\npath compression, 569\npath cover, 761pr.\npath length, of a tree, 304pr., 1180ex.\npath-relaxation property, 650, 673\nIndex\n1279\npattern, in string matching, 985\nnonoverlappable, 1002ex.\npattern matching, see string matching\npenalty, 444\nperfect hashing, 277–282, 285\nperfect linear speedup, 780\nperfect matching, 735ex.\npermutation, 1167\nbit-reversal, 472pr., 918\nJosephus, 355pr.\nk-permutation, 126, 1184\nlinear, 1229pr.\nin place, 126\nrandom, 124–128\nof a set, 1184\nuniform random, 116, 125\npermutation matrix, 1220, 1222ex., 1226ex.\nLUP decomposition of, 827ex.\nPERMUTE-BY-CYCLIC, 129ex.\nPERMUTE-BY-SORTING, 125\nPERMUTE-WITH-ALL, 129ex.\nPERMUTE-WITHOUT-IDENTITY, 128ex.\npersistent data structure, 331pr., 482\nPERSISTENT-TREE-INSERT, 331pr.\nPERT chart, 657, 657ex.\nP-FIB, 776\nphase, of the relabel-to-front algorithm, 758\nphi function (\u0007.n/), 943\nPISANO-DELETE, 526pr.\npivot\nin linear programming, 867, 869–870,\n878ex.\nin LU decomposition, 821",
    "parent_17edea53-77cf-47cd-b37a-8b4512e136d5": "persistent data structure, 331pr., 482\nPERSISTENT-TREE-INSERT, 331pr.\nPERT chart, 657, 657ex.\nP-FIB, 776\nphase, of the relabel-to-front algorithm, 758\nphi function (\u0007.n/), 943\nPISANO-DELETE, 526pr.\npivot\nin linear programming, 867, 869–870,\n878ex.\nin LU decomposition, 821\nin quicksort, 171\nPIVOT, 869\nplatter, 485\nP-MATRIX-MULTIPLY-RECURSIVE, 794\nP-MERGE, 800\nP-MERGE-SORT, 803\npointer, 21\narray implementation of, 241–246\ntrailing, 295\npoint-value representation, 901\npolar angle, 1020ex.\nPollard’s rho heuristic, 976–980, 980ex., 984\nPOLLARD-RHO, 976\npolygon, 1020ex.\nkernel of, 1038ex.\nstar-shaped, 1038ex.\npolylogarithmically bounded, 57\npolynomial, 55, 898\naddition of, 898\nasymptotic behavior of, 61pr.\ncoefﬁcient representation of, 900\nderivatives of, 922pr.\nevaluation of, 41pr., 900, 905ex., 923pr.\ninterpolation by, 901, 906ex.\nmultiplication of, 899, 903–905, 920pr.\npoint-value representation of, 901\npolynomial-growth condition, 113\npolynomially bounded, 55\npolynomially related, 1056\npolynomial-time acceptance, 1058\npolynomial-time algorithm, 927, 1048\npolynomial-time approximation scheme, 1107\nfor maximum clique, 1134pr.\npolynomial-time computability, 1056\npolynomial-time decision, 1059\npolynomial-time reducibility (\u0002P), 1067,\n1077ex.\npolynomial-time solvability, 1055\npolynomial-time veriﬁcation, 1061–1066\nPOP, 233, 452\npop from a run-time stack, 188pr.\npositional tree, 1178\npositive-deﬁnite matrix, 1225\npost-ofﬁce location problem, 225pr.\npostorder tree walk, 287\npotential function, 459\nfor lower bounds, 478\npotential method, 459–463\nfor binary counters, 461–462\nfor disjoint-set data structures, 575–581,\n582ex.\nfor dynamic tables, 466–471\nfor Fibonacci heaps, 509–512, 517–518,\n520–522\nfor the generic push-relabel algorithm, 746\nfor min-heaps, 462ex.\nfor restructuring red-black trees, 474pr.\nfor self-organizing lists with move-to-front,\n476pr.\nfor stack operations, 460–461\npotential, of a data structure, 459\npower\nof an element, modulo n, 954–958\n1280\nIndex",
    "parent_d6a98c41-a419-44ec-8f67-ec106d26e865": "520–522\nfor the generic push-relabel algorithm, 746\nfor min-heaps, 462ex.\nfor restructuring red-black trees, 474pr.\nfor self-organizing lists with move-to-front,\n476pr.\nfor stack operations, 460–461\npotential, of a data structure, 459\npower\nof an element, modulo n, 954–958\n1280\nIndex\nkth, 933ex.\nnontrivial, 933ex.\npower series, 108pr.\npower set, 1161\nPr f g (probability distribution), 1190\nPRAM, 811\npredecessor\nin binary search trees, 291–292\nin a bit vector with a superimposed binary\ntree, 534\nin a bit vector with a superimposed tree of\nconstant height, 535\nin breadth-ﬁrst trees, 594\nin B-trees, 497ex.\nin linked lists, 236\nin order-statistic trees, 347ex.\nin proto van Emde Boas structures, 544ex.\nin red-black trees, 311\nin shortest-paths trees, 647\nin Van Emde Boas trees, 551–552\nPREDECESSOR, 230\npredecessor matrix, 685\npredecessor subgraph\nin all-pairs shortest paths, 685\nin breadth-ﬁrst search, 600\nin depth-ﬁrst search, 603\nin single-source shortest paths, 647\npredecessor-subgraph property, 650, 676\npreemption, 447pr.\npreﬁx\nof a sequence, 392\nof a string (<), 986\npreﬁx code, 429\npreﬁx computation, 807pr.\npreﬁx function, 1003–1004\npreﬁx-function iteration lemma, 1007\npreﬂow, 736, 765\npreimage of a matrix, 1228pr.\npreorder, total, 1165\npreorder tree walk, 287\npresorting, 1043\nPrim’s algorithm, 634–636, 642\nwith an adjacency matrix, 637ex.\nin approximation algorithm for\ntraveling-salesman problem, 1112\nimplemented with a Fibonacci heap, 636\nimplemented with a min-heap, 636\nwith integer edge weights, 637ex.\nsimilarity to Dijkstra’s algorithm, 634, 662\nfor sparse graphs, 638pr.\nprimality testing, 965–975, 983\nMiller-Rabin test, 968–975, 983\npseudoprimality testing, 966–968\nprimal linear program, 880\nprimary clustering, 272\nprimary memory, 484\nprime distribution function, 965\nprime number, 928\ndensity of, 965–966\nprime number theorem, 965\nprimitive root of Z\u0004\nn, 955\nprincipal root of unity, 907\nprinciple of inclusion and exclusion, 1163ex.",
    "parent_a906fbb5-d351-4d37-b84e-2f6b9ec1f371": "primal linear program, 880\nprimary clustering, 272\nprimary memory, 484\nprime distribution function, 965\nprime number, 928\ndensity of, 965–966\nprime number theorem, 965\nprimitive root of Z\u0004\nn, 955\nprincipal root of unity, 907\nprinciple of inclusion and exclusion, 1163ex.\nPRINT-ALL-PAIRS-SHORTEST-PATH, 685\nPRINT-CUT-ROD-SOLUTION, 369\nPRINT-INTERSECTING-SEGMENTS, 1028ex.\nPRINT-LCS, 395\nPRINT-OPTIMAL-PARENS, 377\nPRINT-PATH, 601\nPRINT-SET, 572ex.\npriority queue, 162–166\nin constructing Huffman codes, 431\nin Dijkstra’s algorithm, 661\nheap implementation of, 162–166\nlower bounds for, 531\nmax-priority queue, 162\nmin-priority queue, 162, 165ex.\nwith monotone extractions, 168\nin Prim’s algorithm, 634, 636\nproto van Emde Boas structure\nimplementation of, 538–545\nvan Emde Boas tree implementation of,\n531–560\nsee also binary search tree, binomial heap,\nFibonacci heap\nprobabilistically checkable proof, 1105, 1140\nprobabilistic analysis, 115–116, 130–142\nof approximation algorithm for\nMAX-3-CNF satisﬁability, 1124\nand average inputs, 28\nof average node depth in a randomly built\nbinary search tree, 304pr.\nof balls and bins, 133–134\nof birthday paradox, 130–133\nof bucket sort, 201–204, 204ex.\nof collisions, 261ex., 282ex.\nIndex\n1281\nof convex hull over a sparse-hulled\ndistribution, 1046pr.\nof ﬁle comparison, 995ex.\nof fuzzy sorting of intervals, 189pr.\nof hashing with chaining, 258–260\nof height of a randomly built binary search\ntree, 299–303\nof hiring problem, 120–121, 139–141\nof insertion into a binary search tree with\nequal keys, 303pr.\nof longest-probe bound for hashing, 282pr.\nof lower bound for sorting, 205pr.\nof Miller-Rabin primality test, 971–975\nand multithreaded algorithms, 811pr.\nof on-line hiring problem, 139–141\nof open-address hashing, 274–276, 277ex.\nof partitioning, 179ex., 185ex., 187–188pr.\nof perfect hashing, 279–282\nof Pollard’s rho heuristic, 977–980\nof probabilistic counting, 143pr.\nof quicksort, 181–184, 187–188pr., 303ex.\nof Rabin-Karp algorithm, 994",
    "parent_772c580a-f8cf-46a5-a5ac-9b48c42efb32": "of on-line hiring problem, 139–141\nof open-address hashing, 274–276, 277ex.\nof partitioning, 179ex., 185ex., 187–188pr.\nof perfect hashing, 279–282\nof Pollard’s rho heuristic, 977–980\nof probabilistic counting, 143pr.\nof quicksort, 181–184, 187–188pr., 303ex.\nof Rabin-Karp algorithm, 994\nand randomized algorithms, 123–124\nof randomized selection, 217–219, 226pr.\nof searching a compact list, 250pr.\nof slot-size bound for chaining, 283pr.\nof sorting points by distance from origin,\n204ex.\nof streaks, 135–139\nof universal hashing, 265–268\nprobabilistic counting, 143pr.\nprobability, 1189–1196\nprobability density function, 1196\nprobability distribution, 1190\nprobability distribution function, 204ex.\nprobe sequence, 270\nprobing, 270, 282pr.\nsee also linear probing, quadratic probing,\ndouble hashing\nproblem\nabstract, 1054\ncomputational, 5–6\nconcrete, 1055\ndecision, 1051, 1054\nintractable, 1048\noptimization, 359, 1050, 1054\nsolution to, 6, 1054–1055\ntractable, 1048\nprocedure, 6, 16–17\nproduct .Q/, 1148\nCartesian, 1162\ncross, 1016\ninner, 1222\nof matrices, 1221, 1226ex.\nouter, 1222\nof polynomials, 899\nrule of, 1184\nscalar ﬂow, 714ex.\nprofessional wrestler, 602ex.\nprogram counter, 1073\nprogramming, see dynamic programming,\nlinear programming\nproper ancestor, 1176\nproper descendant, 1176\nproper subgroup, 944\nproper subset (\r), 1159\nproto van Emde Boas structure, 538–545\ncluster in, 538\ncompared with van Emde Boas trees, 547\ndeletion from, 544\ninsertion into, 544\nmaximum in, 544ex.\nmembership in, 540–541\nminimum in, 541–542\npredecessor in, 544ex.\nsuccessor in, 543–544\nsummary in, 540\nPROTO-VEB-INSERT, 544\nPROTO-VEB-MEMBER, 541\nPROTO-VEB-MINIMUM, 542\nproto-vEB structure, see proto van Emde Boas\nstructure\nPROTO-VEB-SUCCESSOR, 543\nprune-and-search method, 1030\npruning a Fibonacci heap, 529pr.\nP-SCAN-1, 808pr.\nP-SCAN-2, 808pr.\nP-SCAN-3, 809pr.\nP-SCAN-DOWN, 809pr.\nP-SCAN-UP, 809pr.\npseudocode, 16, 20–22\npseudoinverse, 837\npseudoprime, 966–968\nPSEUDOPRIME, 967",
    "parent_45be648e-e894-49a9-8862-7c060de7adf5": "structure\nPROTO-VEB-SUCCESSOR, 543\nprune-and-search method, 1030\npruning a Fibonacci heap, 529pr.\nP-SCAN-1, 808pr.\nP-SCAN-2, 808pr.\nP-SCAN-3, 809pr.\nP-SCAN-DOWN, 809pr.\nP-SCAN-UP, 809pr.\npseudocode, 16, 20–22\npseudoinverse, 837\npseudoprime, 966–968\nPSEUDOPRIME, 967\npseudorandom-number generator, 117\nP-SQUARE-MATRIX-MULTIPLY, 793\n1282\nIndex\nP-TRANSPOSE, 792ex.\npublic key, 959, 962\npublic-key cryptosystem, 958–965, 983\nPUSH\npush-relabel operation, 739\nstack operation, 233, 452\npush onto a run-time stack, 188pr.\npush operation (in push-relabel algorithms),\n738–739\nnonsaturating, 739, 745\nsaturating, 739, 745\npush-relabel algorithm, 736–760, 765\nbasic operations in, 738–740\nby discharging an overﬂowing vertex of\nmaximum height, 760ex.\nto ﬁnd a maximum bipartite matching,\n747ex.\ngap heuristic for, 760ex., 766\ngeneric algorithm, 740–748\nwith a queue of overﬂowing vertices, 759ex.\nrelabel-to-front algorithm, 748–760\nquadratic function, 27\nquadratic probing, 272, 283pr.\nquadratic residue, 982pr.\nquantile, 223ex.\nquery, 230\nqueue, 232, 234–235\nin breadth-ﬁrst search, 595\nimplemented by stacks, 236ex.\nlinked-list implementation of, 240ex.\npriority, see priority queue\nin push-relabel algorithms, 759ex.\nquicksort, 170–190\nanalysis of, 174–185\naverage-case analysis of, 181–184\ncompared with insertion sort, 178ex.\ncompared with radix sort, 199\nwith equal element values, 186pr.\ngood worst-case implementation of, 223ex.\n“killer adversary” for, 190\nwith median-of-3 method, 188pr.\nmultithreaded algorithm for, 811pr.\nrandomized version of, 179–180, 187pr.\nstack depth of, 188pr.\ntail-recursive version of, 188pr.\nuse of insertion sort in, 185ex.\nworst-case analysis of, 180–181\nQUICKSORT, 171\nQUICKSORT0, 186pr.\nquotient, 928\nR (set of real numbers), 1158\nRabin-Karp algorithm, 990–995, 1013\nRABIN-KARP-MATCHER, 993\nrace, 787–790\nRACE-EXAMPLE, 788\nradix sort, 197–200\ncompared with quicksort, 199\nRADIX-SORT, 198\nradix tree, 304pr.\nRAM, 23–24\nRANDOM, 117\nrandom-access machine, 23–24",
    "parent_f1911381-6ca7-418b-b52e-72e369b940f2": "QUICKSORT0, 186pr.\nquotient, 928\nR (set of real numbers), 1158\nRabin-Karp algorithm, 990–995, 1013\nRABIN-KARP-MATCHER, 993\nrace, 787–790\nRACE-EXAMPLE, 788\nradix sort, 197–200\ncompared with quicksort, 199\nRADIX-SORT, 198\nradix tree, 304pr.\nRAM, 23–24\nRANDOM, 117\nrandom-access machine, 23–24\nparallel, 811\nrandomized algorithm, 116–117, 122–130\nand average inputs, 28\ncomparison sort, 205pr.\nfor fuzzy sorting of intervals, 189pr.\nfor hiring problem, 123–124\nfor insertion into a binary search tree with\nequal keys, 303pr.\nfor MAX-3-CNF satisﬁability, 1123–1124,\n1139\nMiller-Rabin primality test, 968–975, 983\nmultithreaded, 811pr.\nfor partitioning, 179, 185ex., 187–188pr.\nfor permuting an array, 124–128\nPollard’s rho heuristic, 976–980, 980ex.,\n984\nand probabilistic analysis, 123–124\nquicksort, 179–180, 185ex., 187–188pr.\nrandomized rounding, 1139\nfor searching a compact list, 250pr.\nfor selection, 215–220\nuniversal hashing, 265–268\nworst-case performance of, 180ex.\nRANDOMIZED-HIRE-ASSISTANT, 124\nRANDOMIZED-PARTITION, 179\nRANDOMIZED-QUICKSORT, 179, 303ex.\nrelation to randomly built binary search\ntrees, 304pr.\nrandomized rounding, 1139\nRANDOMIZED-SELECT, 216\nRANDOMIZE-IN-PLACE, 126\nIndex\n1283\nrandomly built binary search tree, 299–303,\n304pr.\nrandom-number generator, 117\nrandom permutation, 124–128\nuniform, 116, 125\nRANDOM-SAMPLE, 130ex.\nrandom sampling, 129ex., 179\nRANDOM-SEARCH, 143pr.\nrandom variable, 1196–1201\nindicator, see indicator random variable\nrange, 1167\nof a matrix, 1228pr.\nrank\ncolumn, 1223\nfull, 1223\nof a matrix, 1223, 1226ex.\nof a node in a disjoint-set forest, 569, 575,\n581ex.\nof a number in an ordered set, 300, 339\nin order-statistic trees, 341–343, 344–345ex.\nrow, 1223\nrate of growth, 28\nray, 1021ex.\nRB-DELETE, 324\nRB-DELETE-FIXUP, 326\nRB-ENUMERATE, 348ex.\nRB-INSERT, 315\nRB-INSERT-FIXUP, 316\nRB-JOIN, 332pr.\nRB-TRANSPLANT, 323\nreachability in a graph (;), 1170\nreal numbers (R), 1158\nreconstructing an optimal solution, in dynamic\nprogramming, 387",
    "parent_350ff29f-570d-4795-a114-8a2ea2705aac": "row, 1223\nrate of growth, 28\nray, 1021ex.\nRB-DELETE, 324\nRB-DELETE-FIXUP, 326\nRB-ENUMERATE, 348ex.\nRB-INSERT, 315\nRB-INSERT-FIXUP, 316\nRB-JOIN, 332pr.\nRB-TRANSPLANT, 323\nreachability in a graph (;), 1170\nreal numbers (R), 1158\nreconstructing an optimal solution, in dynamic\nprogramming, 387\nrecord, 147\nrectangle, 354ex.\nrecurrence, 34, 65–67, 83–113\nsolution by Akra-Bazzi method, 112–113\nsolution by master method, 93–97\nsolution by recursion-tree method, 88–93\nsolution by substitution method, 83–88\nrecurrence equation, see recurrence\nrecursion, 30\nrecursion tree, 37, 88–93\nin proof of master theorem, 98–100\nand the substitution method, 91–92\nRECURSIVE-ACTIVITY-SELECTOR, 419\nrecursive case, 65\nRECURSIVE-FFT, 911\nRECURSIVE-MATRIX-CHAIN, 385\nred-black tree, 308–338\naugmentation of, 346–347\ncompared with B-trees, 484, 490\ndeletion from, 323–330\nin determining whether any line segments\nintersect, 1024\nfor enumerating keys in a range, 348ex.\nheight of, 309\ninsertion into, 315–323\njoining of, 332pr.\nmaximum key of, 311\nminimum key of, 311\npredecessor in, 311\nproperties of, 308–312\nrelaxed, 311ex.\nrestructuring, 474pr.\nrotation in, 312–314\nsearching in, 311\nsuccessor in, 311\nsee also interval tree, order-statistic tree\nREDUCE, 807pr.\nreduced-space van Emde Boas tree, 557pr.\nreducibility, 1067–1068\nreduction algorithm, 1052, 1067\nreduction function, 1067\nreduction, of an array, 807pr.\nreﬂexive relation, 1163\nreﬂexivity of asymptotic notation, 51\nregion, feasible, 847\nregularity condition, 95\nrejection\nby an algorithm, 1058\nby a ﬁnite automaton, 996\nRELABEL, 740\nrelabeled vertex, 740\nrelabel operation, in push-relabel algorithms,\n740, 745\nRELABEL-TO-FRONT, 755\nrelabel-to-front algorithm, 748–760\nphase of, 758\nrelation, 1163–1166\nrelatively prime, 931\nRELAX, 649\nrelaxation\nof an edge, 648–650\nlinear programming, 1125\n1284\nIndex\nrelaxed heap, 530\nrelaxed red-black tree, 311ex.\nrelease time, 447pr.\nremainder, 54, 928\nremainder instruction, 23\nrepeated squaring",
    "parent_502c1ef4-870a-44c6-ae4f-06f8478abec9": "phase of, 758\nrelation, 1163–1166\nrelatively prime, 931\nRELAX, 649\nrelaxation\nof an edge, 648–650\nlinear programming, 1125\n1284\nIndex\nrelaxed heap, 530\nrelaxed red-black tree, 311ex.\nrelease time, 447pr.\nremainder, 54, 928\nremainder instruction, 23\nrepeated squaring\nfor all-pairs shortest paths, 689–691\nfor raising a number to a power, 956\nrepeat, in pseudocode, 20\nrepetition factor, of a string, 1012pr.\nREPETITION-MATCHER, 1013pr.\nrepresentative of a set, 561\nRESET, 459ex.\nresidual capacity, 716, 719\nresidual edge, 716\nresidual network, 715–719\nresidue, 54, 928, 982pr.\nrespecting a set of edges, 626\nreturn edge, 779\nreturn, in pseudocode, 22\nreturn instruction, 23\nreweighting\nin all-pairs shortest paths, 700–702\nin single-source shortest paths, 679pr.\nrho heuristic, 976–980, 980ex., 984\n\u000f.n/-approximation algorithm, 1106, 1123\nRIGHT, 152\nright child, 1178\nright-conversion, 314ex.\nright horizontal ray, 1021ex.\nRIGHT-ROTATE, 313\nright rotation, 312\nright spine, 333pr.\nright subtree, 1178\nrod-cutting, 360–370, 390ex.\nroot\nof a tree, 1176\nof unity, 906–907\nof Z\u0004\nn, 955\nrooted tree, 1176\nrepresentation of, 246–249\nroot list, of a Fibonacci heap, 509\nrotation\ncyclic, 1012ex.\nin a red-black tree, 312–314\nrotational sweep, 1030–1038\nrounding, 1126\nrandomized, 1139\nrow-major order, 394\nrow rank, 1223\nrow vector, 1218\nRSA public-key cryptosystem, 958–965, 983\nRS-vEB tree, 557pr.\nrule of product, 1184\nrule of sum, 1183\nrunning time, 25\naverage-case, 28, 116\nbest-case, 29ex., 49\nexpected, 28, 117\nof a graph algorithm, 588\nand multithreaded computation, 779–780\norder of growth, 28\nrate of growth, 28\nworst-case, 27, 49\nsabermetrics, 412n.\nsafe edge, 626\nSAME-COMPONENT, 563\nsample space, 1189\nsampling, 129ex., 179\nSAT, 1079\nsatellite data, 147, 229\nsatisﬁability, 1072, 1079–1081, 1105,\n1123–1124, 1127ex., 1139\nsatisﬁable formula, 1049, 1079\nsatisfying assignment, 1072, 1079\nsaturated edge, 739\nsaturating push, 739, 745\nscalar ﬂow product, 714ex.\nscalar multiple, 1220\nscaling",
    "parent_f08aa7db-f614-4fd1-a033-362c603d3e11": "sampling, 129ex., 179\nSAT, 1079\nsatellite data, 147, 229\nsatisﬁability, 1072, 1079–1081, 1105,\n1123–1124, 1127ex., 1139\nsatisﬁable formula, 1049, 1079\nsatisfying assignment, 1072, 1079\nsaturated edge, 739\nsaturating push, 739, 745\nscalar ﬂow product, 714ex.\nscalar multiple, 1220\nscaling\nin maximum ﬂow, 762pr., 765\nin single-source shortest paths, 679pr.\nscan, 807pr.\nSCAN, 807pr.\nscapegoat tree, 338\nschedule, 444, 1136pr.\nevent-point, 1023\nscheduler, for multithreaded computations,\n777, 781–783, 812\ncentralized, 782\ngreedy, 782\nwork-stealing algorithm for, 812\nscheduling, 443–446, 447pr., 450, 1104pr.,\n1136pr.\nSchur complement, 820, 834\nIndex\n1285\nSchur complement lemma, 834\nSCRAMBLE-SEARCH, 143pr.\nseam carving, 409pr., 413\nSEARCH, 230\nsearching, 22ex.\nbinary search, 39ex., 799–800\nin binary search trees, 289–291\nin B-trees, 491–492\nin chained hash tables, 258\nin compact lists, 250pr.\nin direct-address tables, 254\nfor an exact interval, 354ex.\nin interval trees, 350–353\nlinear search, 22ex.\nin linked lists, 237\nin open-address hash tables, 270–271\nin proto van Emde Boas structures, 540–541\nin red-black trees, 311\nin an unsorted array, 143pr.\nin Van Emde Boas trees, 550\nsearch tree, see balanced search tree, binary\nsearch tree, B-tree, exponential search\ntree, interval tree, optimal binary search\ntree, order-statistic tree, red-black tree,\nsplay tree, 2-3 tree, 2-3-4 tree\nsecondary clustering, 272\nsecondary hash table, 278\nsecondary storage\nsearch tree for, 484–504\nstacks on, 502pr.\nsecond-best minimum spanning tree, 638pr.\nsecret key, 959, 962\nsegment, see directed segment, line segment\nSEGMENTS-INTERSECT, 1018\nSELECT, 220\nselection, 213\nof activities, 415–422, 450\nand comparison sorts, 222\nin expected linear time, 215–220\nmultithreaded, 805ex.\nin order-statistic trees, 340–341\nin worst-case linear time, 220–224\nselection sort, 29ex.\nselector vertex, 1093\nself-loop, 1168\nself-organizing list, 476pr., 478\nsemiconnected graph, 621ex.\nsentinel, 31, 238–240, 309",
    "parent_574ef714-298c-47d9-9e25-51bf40f31859": "and comparison sorts, 222\nin expected linear time, 215–220\nmultithreaded, 805ex.\nin order-statistic trees, 340–341\nin worst-case linear time, 220–224\nselection sort, 29ex.\nselector vertex, 1093\nself-loop, 1168\nself-organizing list, 476pr., 478\nsemiconnected graph, 621ex.\nsentinel, 31, 238–240, 309\nsequence (h i)\nbitonic, 682pr.\nﬁnite, 1166\ninﬁnite, 1166\ninversion in, 41pr., 122ex., 345ex.\nprobe, 270\nsequential consistency, 779, 812\nserial algorithm versus parallel algorithm, 772\nserialization, of a multithreaded algorithm,\n774, 776\nseries, 108pr., 1146–1148\nstrands being logically in, 778\nset (f g), 1158–1163\ncardinality (j j), 1161\nconvex, 714ex.\ndifference (\u0005), 1159\nindependent, 1101pr.\nintersection (\\), 1159\nmember (2), 1158\nnot a member (62), 1158\nunion ([), 1159\nset-covering problem, 1117–1122, 1139\nweighted, 1135pr.\nset-partition problem, 1101ex.\nshadow of a point, 1038ex.\nshared memory, 772\nShell’s sort, 42\nshift, in string matching, 985\nshift instruction, 24\nshort-circuiting operator, 22\nSHORTEST-PATH, 1050\nshortest paths, 7, 643–707\nall-pairs, 644, 684–707\nBellman-Ford algorithm for, 651–655\nwith bitonic paths, 682pr.\nand breadth-ﬁrst search, 597–600, 644\nconvergence property of, 650, 672–673\nand difference constraints, 664–670\nDijkstra’s algorithm for, 658–664\nin a directed acyclic graph, 655–658\nin \b-dense graphs, 706pr.\nestimate of, 648\nFloyd-Warshall algorithm for, 693–697,\n700ex., 706\nGabow’s scaling algorithm for, 679pr.\nJohnson’s algorithm for, 700–706\nas a linear program, 859–860\nand longest paths, 1048\n1286\nIndex\nby matrix multiplication, 686–693, 706–707\nand negative-weight cycles, 645, 653–654,\n692ex., 700ex.\nwith negative-weight edges, 645–646\nno-path property of, 650, 672\noptimal substructure of, 644–645, 687,\n693–694\npath-relaxation property of, 650, 673\npredecessor-subgraph property of, 650, 676\nproblem variants, 644\nand relaxation, 648–650\nby repeated squaring, 689–691\nsingle-destination, 644\nsingle-pair, 381, 644\nsingle-source, 643–683",
    "parent_d4cd2cee-217b-43dc-b330-1bc782a5cc74": "optimal substructure of, 644–645, 687,\n693–694\npath-relaxation property of, 650, 673\npredecessor-subgraph property of, 650, 676\nproblem variants, 644\nand relaxation, 648–650\nby repeated squaring, 689–691\nsingle-destination, 644\nsingle-pair, 381, 644\nsingle-source, 643–683\ntree of, 647–648, 673–676\ntriangle inequality of, 650, 671\nin an unweighted graph, 381, 597\nupper-bound property of, 650, 671–672\nin a weighted graph, 643\nsibling, 1176\nside of a polygon, 1020ex.\nsignature, 960\nsimple cycle, 1170\nsimple graph, 1170\nsimple path, 1170\nlongest, 382, 1048\nsimple polygon, 1020ex.\nsimple stencil calculation, 809pr.\nsimple uniform hashing, 259\nsimplex, 848\nSIMPLEX, 871\nsimplex algorithm, 848, 864–879, 896–897\nsingle-destination shortest paths, 644\nsingle-pair shortest path, 381, 644\nas a linear program, 859–860\nsingle-source shortest paths, 643–683\nBellman-Ford algorithm for, 651–655\nwith bitonic paths, 682pr.\nand difference constraints, 664–670\nDijkstra’s algorithm for, 658–664\nin a directed acyclic graph, 655–658\nin \b-dense graphs, 706pr.\nGabow’s scaling algorithm for, 679pr.\nas a linear program, 863ex.\nand longest paths, 1048\nsingleton, 1161\nsingly connected graph, 612ex.\nsingly linked list, 236\nsee also linked list\nsingular matrix, 1223\nsingular value decomposition, 842\nsink vertex, 593ex., 709, 712\nsize\nof an algorithm’s input, 25, 926–927,\n1055–1057\nof a binomial tree, 527pr.\nof a boolean combinational circuit, 1072\nof a clique, 1086\nof a set, 1161\nof a subtree in a Fibonacci heap, 524\nof a vertex cover, 1089, 1108\nskip list, 338\nslack, 855\nslack form, 846, 854–857\nuniqueness of, 876\nslackness\ncomplementary, 894pr.\nparallel, 781\nslack variable, 855\nslot\nof a direct-access table, 254\nof a hash table, 256\nSLOW-ALL-PAIRS-SHORTEST-PATHS, 689\nsmoothed analysis, 897\n?Socrates, 790\nsolution\nto an abstract problem, 1054\nbasic, 866\nto a computational problem, 6\nto a concrete problem, 1055\nfeasible, 665, 846, 851\ninfeasible, 851\noptimal, 851",
    "parent_36dcad34-98cc-4cc1-a6a9-d652a3535c5e": "slot\nof a direct-access table, 254\nof a hash table, 256\nSLOW-ALL-PAIRS-SHORTEST-PATHS, 689\nsmoothed analysis, 897\n?Socrates, 790\nsolution\nto an abstract problem, 1054\nbasic, 866\nto a computational problem, 6\nto a concrete problem, 1055\nfeasible, 665, 846, 851\ninfeasible, 851\noptimal, 851\nto a system of linear equations, 814\nsorted linked list, 236\nsee also linked list\nsorting, 5, 16–20, 30–37, 147–212, 797–805\nbubblesort, 40pr.\nbucket sort, 200–204\ncolumnsort, 208pr.\ncomparison sort, 191\ncounting sort, 194–197\nfuzzy, 189pr.\nheapsort, 151–169\ninsertion sort, 12, 16–20\nIndex\n1287\nk-sorting, 207pr.\nlexicographic, 304pr.\nin linear time, 194–204, 206pr.\nlower bounds for, 191–194, 211, 531\nmerge sort, 12, 30–37, 797–805\nby oblivious compare-exchange algorithms,\n208pr.\nin place, 17, 148, 206pr.\nof points by polar angle, 1020ex.\nprobabilistic lower bound for, 205pr.\nquicksort, 170–190\nradix sort, 197–200\nselection sort, 29ex.\nShell’s sort, 42\nstable, 196\ntable of running times, 149\ntopological, 8, 612–615, 623\nusing a binary search tree, 299ex.\nwith variable-length items, 206pr.\n0-1 sorting lemma, 208pr.\nsorting network, 811\nsource vertex, 594, 644, 709, 712\nspan law, 780\nspanning tree, 439, 624\nbottleneck, 640pr.\nmaximum, 1137pr.\nveriﬁcation of, 642\nsee also minimum spanning tree\nspan, of a multithreaded computation, 779\nsparse graph, 589\nall-pairs shortest paths for, 700–705\nand Prim’s algorithm, 638pr.\nsparse-hulled distribution, 1046pr.\nspawn, in pseudocode, 776–777\nspawn edge, 778\nspeedup, 780\nof a randomized multithreaded algorithm,\n811pr.\nspindle, 485\nspine\nof a string-matching automaton, 997ﬁg.\nof a treap, 333pr.\nsplay tree, 338, 482\nspline, 840pr.\nsplitting\nof B-tree nodes, 493–495\nof 2-3-4 trees, 503pr.\nsplitting summations, 1152–1154\nspurious hit, 991\nsquare matrix, 1218\nSQUARE-MATRIX-MULTIPLY, 75, 689\nSQUARE-MATRIX-MULTIPLY-RECURSIVE,\n77\nsquare of a directed graph, 593ex.\nsquare root, modulo a prime, 982pr.\nsquaring, repeated",
    "parent_75e30535-1fdb-4876-8581-a1dc1836120c": "splitting\nof B-tree nodes, 493–495\nof 2-3-4 trees, 503pr.\nsplitting summations, 1152–1154\nspurious hit, 991\nsquare matrix, 1218\nSQUARE-MATRIX-MULTIPLY, 75, 689\nSQUARE-MATRIX-MULTIPLY-RECURSIVE,\n77\nsquare of a directed graph, 593ex.\nsquare root, modulo a prime, 982pr.\nsquaring, repeated\nfor all-pairs shortest paths, 689–691\nfor raising a number to a power, 956\nstability\nnumerical, 813, 815, 842\nof sorting algorithms, 196, 200ex.\nstack, 232–233\nin Graham’s scan, 1030\nimplemented by queues, 236ex.\nlinked-list implementation of, 240ex.\noperations analyzed by accounting method,\n457–458\noperations analyzed by aggregate analysis,\n452–454\noperations analyzed by potential method,\n460–461\nfor procedure execution, 188pr.\non secondary storage, 502pr.\nSTACK-EMPTY, 233\nstandard deviation, 1200\nstandard encoding (h i), 1057\nstandard form, 846, 850–854\nstar-shaped polygon, 1038ex.\nstart state, 995\nstart time, 415\nstate of a ﬁnite automaton, 995\nstatic graph, 562n.\nstatic set of keys, 277\nstatic threading, 773\nstencil, 809pr.\nstencil calculation, 809pr.\nStirling’s approximation, 57\nstorage management, 151, 243–244, 245ex.,\n261ex.\nstore instruction, 23\nstraddle, 1017\nstrand, 777\nﬁnal, 779\nindependent, 789\ninitial, 779\nlogically in parallel, 778\n1288\nIndex\nlogically in series, 778\nStrassen’s algorithm, 79–83, 111–112\nmultithreaded, 795–796\nstreaks, 135–139\nstrictly decreasing, 53\nstrictly increasing, 53\nstring, 985, 1184\nstring matching, 985–1013\nbased on repetition factors, 1012pr.\nby ﬁnite automata, 995–1002\nwith gap characters, 989ex., 1002ex.\nKnuth-Morris-Pratt algorithm for,\n1002–1013\nnaive algorithm for, 988–990\nRabin-Karp algorithm for, 990–995, 1013\nstring-matching automaton, 996–1002,\n1002ex.\nstrongly connected component, 1170\ndecomposition into, 615–621, 623\nSTRONGLY-CONNECTED-COMPONENTS, 617\nstrongly connected graph, 1170\nsubgraph, 1171\npredecessor, see predecessor subgraph\nsubgraph-isomorphism problem, 1100ex.\nsubgroup, 943–946\nsubpath, 1170\nsubproblem graph, 367–368",
    "parent_797b1082-1450-4331-9759-b99d32bfb98a": "1002ex.\nstrongly connected component, 1170\ndecomposition into, 615–621, 623\nSTRONGLY-CONNECTED-COMPONENTS, 617\nstrongly connected graph, 1170\nsubgraph, 1171\npredecessor, see predecessor subgraph\nsubgraph-isomorphism problem, 1100ex.\nsubgroup, 943–946\nsubpath, 1170\nsubproblem graph, 367–368\nsubroutine\ncalling, 21, 23, 25n.\nexecuting, 25n.\nsubsequence, 391\nsubset (\u0007), 1159, 1161\nhereditary family of, 437\nindependent family of, 437\nSUBSET-SUM, 1097\nsubset-sum problem\napproximation algorithm for, 1128–1134,\n1139\nNP-completeness of, 1097–1100\nwith unary target, 1101ex.\nsubstitution method, 83–88\nand recursion trees, 91–92\nsubstring, 1184\nsubtract instruction, 23\nsubtraction of matrices, 1221\nsubtree, 1176\nmaintaining sizes of, in order-statistic trees,\n343–344\nsuccess, in a Bernoulli trial, 1201\nsuccessor\nin binary search trees, 291–292\nin a bit vector with a superimposed binary\ntree, 533\nin a bit vector with a superimposed tree of\nconstant height, 535\nﬁnding ith, of a node in an order-statistic\ntree, 344ex.\nin linked lists, 236\nin order-statistic trees, 347ex.\nin proto van Emde Boas structures, 543–544\nin red-black trees, 311\nin Van Emde Boas trees, 550–551\nSUCCESSOR, 230\nsuch that (W), 1159\nsufﬁx (=), 986\nsufﬁx function, 996\nsufﬁx-function inequality, 999\nsufﬁx-function recursion lemma, 1000\nsum .P/, 1145\nCartesian, 906ex.\ninﬁnite, 1145\nof matrices, 1220\nof polynomials, 898\nrule of, 1183\ntelescoping, 1148\nSUM-ARRAYS, 805pr.\nSUM-ARRAYS0, 805pr.\nsummary\nin a bit vector with a superimposed tree of\nconstant height, 534\nin proto van Emde Boas structures, 540\nin van Emde Boas trees, 546\nsummation, 1145–1157\nin asymptotic notation, 49–50, 1146\nbounding, 1149–1156\nformulas and properties of, 1145–1149\nlinearity of, 1146\nsummation lemma, 908\nsupercomputer, 772\nsuperpolynomial time, 1048\nsupersink, 712\nsupersource, 712\nsurjection, 1167\nSVD, 842\nsweeping, 1021–1029, 1045pr.\nrotational, 1030–1038\nIndex\n1289\nsweep line, 1022\nsweep-line status, 1023–1024\nsymbol table, 253, 262, 265",
    "parent_08b5b018-ea37-40b5-87fd-c80df96d41d5": "linearity of, 1146\nsummation lemma, 908\nsupercomputer, 772\nsuperpolynomial time, 1048\nsupersink, 712\nsupersource, 712\nsurjection, 1167\nSVD, 842\nsweeping, 1021–1029, 1045pr.\nrotational, 1030–1038\nIndex\n1289\nsweep line, 1022\nsweep-line status, 1023–1024\nsymbol table, 253, 262, 265\nsymmetric difference, 763pr.\nsymmetric matrix, 1220, 1222ex., 1226ex.\nsymmetric positive-deﬁnite matrix, 832–835,\n842\nsymmetric relation, 1163\nsymmetry of ‚-notation, 52\nsync, in pseudocode, 776–777\nsystem of difference constraints, 664–670\nsystem of linear equations, 806pr., 813–827,\n840pr.\nTABLE-DELETE, 468\nTABLE-INSERT, 464\ntail\nof a binomial distribution, 1208–1215\nof a linked list, 236\nof a queue, 234\ntail recursion, 188pr., 419\nTAIL-RECURSIVE-QUICKSORT, 188pr.\ntarget, 1097\nTarjan’s off-line least-common-ancestors\nalgorithm, 584pr.\ntask, 443\nTask Parallel Library, 774\ntask scheduling, 443–446, 448pr., 450\ntautology, 1066ex., 1086ex.\nTaylor series, 306pr.\ntelescoping series, 1148\ntelescoping sum, 1148\ntesting\nof primality, 965–975, 983\nof pseudoprimality, 966–968\ntext, in string matching, 985\nthen clause, 20n.\nTheta-notation, 44–47, 64\nthread, 773\nThreading Building Blocks, 774\n3-CNF, 1082\n3-CNF-SAT, 1082\n3-CNF satisﬁability, 1082–1085, 1105\napproximation algorithm for, 1123–1124,\n1139\nand 2-CNF satisﬁability, 1049\n3-COLOR, 1103pr.\n3-conjunctive normal form, 1082\ntight constraint, 865\ntime, see running time\ntime domain, 898\ntime-memory trade-off, 365\ntimestamp, 603, 611ex.\nToeplitz matrix, 921pr.\nto, in pseudocode, 20\nTOP, 1031\ntop-down method, for dynamic programming,\n365\ntop of a stack, 232\ntopological sort, 8, 612–615, 623\nin computing single-source shortest paths in\na dag, 655\nTOPOLOGICAL-SORT, 613\ntotal order, 1165\ntotal path length, 304pr.\ntotal preorder, 1165\ntotal relation, 1165\ntour\nbitonic, 405pr.\nEuler, 623pr., 1048\nof a graph, 1096\ntrack, 486\ntractability, 1048\ntrailing pointer, 295\ntransition function, 995, 1001–1002, 1012ex.\ntransitive closure, 697–699",
    "parent_b328ecbf-1b03-4a1c-a34f-becc08f1a74d": "TOPOLOGICAL-SORT, 613\ntotal order, 1165\ntotal path length, 304pr.\ntotal preorder, 1165\ntotal relation, 1165\ntour\nbitonic, 405pr.\nEuler, 623pr., 1048\nof a graph, 1096\ntrack, 486\ntractability, 1048\ntrailing pointer, 295\ntransition function, 995, 1001–1002, 1012ex.\ntransitive closure, 697–699\nand boolean matrix multiplication, 832ex.\nof dynamic graphs, 705pr., 707\nTRANSITIVE-CLOSURE, 698\ntransitive relation, 1163\ntransitivity of asymptotic notation, 51\nTRANSPLANT, 296, 323\ntranspose\nconjugate, 832ex.\nof a directed graph, 592ex.\nof a matrix, 1217\nof a matrix, multithreaded, 792ex.\ntranspose symmetry of asymptotic notation, 52\ntraveling-salesman problem\napproximation algorithm for, 1111–1117,\n1139\nbitonic euclidean, 405pr.\nbottleneck, 1117ex.\nNP-completeness of, 1096–1097\nwith the triangle inequality, 1112–1115\nwithout the triangle inequality, 1115–1116\n1290\nIndex\ntraversal of a tree, 287, 293ex., 342, 1114\ntreap, 333pr., 338\nTREAP-INSERT, 333pr.\ntree, 1173–1180\nAA-trees, 338\nAVL, 333pr., 337\nbinary, see binary tree\nbinomial, 527pr.\nbisection of, 1181pr.\nbreadth-ﬁrst, 594, 600\nB-trees, 484–504\ndecision, 192–193\ndepth-ﬁrst, 603\ndiameter of, 602ex.\ndynamic, 482\nfree, 1172–1176\nfull walk of, 1114\nfusion, 212, 483\nheap, 151–169\nheight-balanced, 333pr.\nheight of, 1177\ninterval, 348–354\nk-neighbor, 338\nminimum spanning, see minimum spanning\ntree\noptimal binary search, 397–404, 413\norder-statistic, 339–345\nparse, 1082\nrecursion, 37, 88–93\nred-black, see red-black tree\nrooted, 246–249, 1176\nscapegoat, 338\nsearch, see search tree\nshortest-paths, 647–648, 673–676\nspanning, see minimum spanning tree,\nspanning tree\nsplay, 338, 482\ntreap, 333pr., 338\n2-3, 337, 504\n2-3-4, 489, 503pr.\nvan Emde Boas, 531–560\nwalk of, 287, 293ex., 342, 1114\nweight-balanced trees, 338\nTREE-DELETE, 298, 299ex., 323–324\ntree edge, 601, 603, 609\nTREE-INSERT, 294, 315\nTREE-MAXIMUM, 291\nTREE-MINIMUM, 291\nTREE-PREDECESSOR, 292\nTREE-SEARCH, 290\nTREE-SUCCESSOR, 292\ntree walk, 287, 293ex., 342, 1114",
    "parent_f8b4973a-2113-47ea-a91b-ab9fbc4d9f5c": "van Emde Boas, 531–560\nwalk of, 287, 293ex., 342, 1114\nweight-balanced trees, 338\nTREE-DELETE, 298, 299ex., 323–324\ntree edge, 601, 603, 609\nTREE-INSERT, 294, 315\nTREE-MAXIMUM, 291\nTREE-MINIMUM, 291\nTREE-PREDECESSOR, 292\nTREE-SEARCH, 290\nTREE-SUCCESSOR, 292\ntree walk, 287, 293ex., 342, 1114\ntrial, Bernoulli, 1201\ntrial division, 966\ntriangle inequality, 1112\nfor shortest paths, 650, 671\ntriangular matrix, 1219, 1222ex., 1225ex.\ntrichotomy, interval, 348\ntrichotomy property of real numbers, 52\ntridiagonal linear systems, 840pr.\ntridiagonal matrix, 1219\ntrie (radix tree), 304pr.\ny-fast, 558pr.\nTRIM, 1130\ntrimming a list, 1130\ntrivial divisor, 928\ntruth assignment, 1072, 1079\ntruth table, 1070\nTSP, 1096\ntuple, 1162\ntwiddle factor, 912\n2-CNF-SAT, 1086ex.\n2-CNF satisﬁability, 1086ex.\nand 3-CNF satisﬁability, 1049\ntwo-pass method, 571\n2-3-4 heap, 529pr.\n2-3-4 tree, 489\njoining, 503pr.\nsplitting, 503pr.\n2-3 tree, 337, 504\nunary, 1056\nunbounded linear program, 851\nunconditional branch instruction, 23\nuncountable set, 1161\nunderdetermined system of linear equations,\n814\nunderﬂow\nof a queue, 234\nof a stack, 233\nundirected graph, 1168\narticulation point of, 621pr.\nbiconnected component of, 621pr.\nbridge of, 621pr.\nclique in, 1086\ncoloring of, 1103pr., 1180pr.\nIndex\n1291\ncomputing a minimum spanning tree in,\n624–642\nconverting to, from a multigraph, 593ex.\nd-regular, 736ex.\ngrid, 760pr.\nhamiltonian, 1061\nindependent set of, 1101pr.\nmatching of, 732\nnonhamiltonian, 1061\nvertex cover of, 1089, 1108\nsee also graph\nundirected version of a directed graph, 1172\nuniform hashing, 271\nuniform probability distribution, 1191–1192\nuniform random permutation, 116, 125\nunion\nof dynamic sets, see uniting\nof languages, 1058\nof sets ([), 1159\nUNION, 505, 562\ndisjoint-set-forest implementation of, 571\nlinked-list implementation of, 565–567,\n568ex.\nunion by rank, 569\nunique factorization of integers, 931\nunit (1), 928\nuniting\nof Fibonacci heaps, 511–512\nof heaps, 506\nof linked lists, 241ex.",
    "parent_b1c6647c-94da-4016-a4bb-ba9d680fe005": "of languages, 1058\nof sets ([), 1159\nUNION, 505, 562\ndisjoint-set-forest implementation of, 571\nlinked-list implementation of, 565–567,\n568ex.\nunion by rank, 569\nunique factorization of integers, 931\nunit (1), 928\nuniting\nof Fibonacci heaps, 511–512\nof heaps, 506\nof linked lists, 241ex.\nof 2-3-4 heaps, 529pr.\nunit lower-triangular matrix, 1219\nunit-time task, 443\nunit upper-triangular matrix, 1219\nunit vector, 1218\nuniversal collection of hash functions, 265\nuniversal hashing, 265–268\nuniversal sink, 593ex.\nuniverse, 1160\nof keys in van Emde Boas trees, 532\nuniverse size, 532\nunmatched vertex, 732\nunsorted linked list, 236\nsee also linked list\nuntil, in pseudocode, 20\nunweighted longest simple paths, 382\nunweighted shortest paths, 381\nupper bound, 47\nupper-bound property, 650, 671–672\nupper median, 213\nupper square root\n\u000b\n\"p\n\f\n, 546\nupper-triangular matrix, 1219, 1225ex.\nvalid shift, 985\nvalue\nof a ﬂow, 710\nof a function, 1166\nobjective, 847, 851\nvalue over replacement player, 411pr.\nVandermonde matrix, 902, 1226pr.\nvan Emde Boas tree, 531–560\ncluster in, 546\ncompared with proto van Emde Boas\nstructures, 547\ndeletion from, 554–556\ninsertion into, 552–554\nmaximum in, 550\nmembership in, 550\nminimum in, 550\npredecessor in, 551–552\nwith reduced space, 557pr.\nsuccessor in, 550–551\nsummary in, 546\nVar Œ \u0002 (variance), 1199\nvariable\nbasic, 855\nentering, 867\nleaving, 867\nnonbasic, 855\nin pseudocode, 21\nrandom, 1196–1201\nslack, 855\nsee also indicator random variable\nvariable-length code, 429\nvariance, 1199\nof a binomial distribution, 1205\nof a geometric distribution, 1203\nVEB-EMPTY-TREE-INSERT, 553\nvEB tree, see van Emde Boas tree\nVEB-TREE-DELETE, 554\nVEB-TREE-INSERT, 553\nVEB-TREE-MAXIMUM, 550\nVEB-TREE-MEMBER, 550\nVEB-TREE-MINIMUM, 550\nVEB-TREE-PREDECESSOR, 552\nVEB-TREE-SUCCESSOR, 551\n1292\nIndex\nvector, 1218, 1222–1224\nconvolution of, 901\ncross product of, 1016\northonormal, 842\nin the plane, 1015\nVenn diagram, 1160\nveriﬁcation, 1061–1066\nof spanning trees, 642",
    "parent_f38a4cfc-f31c-47af-a2b6-1be5545a0f71": "VEB-TREE-MAXIMUM, 550\nVEB-TREE-MEMBER, 550\nVEB-TREE-MINIMUM, 550\nVEB-TREE-PREDECESSOR, 552\nVEB-TREE-SUCCESSOR, 551\n1292\nIndex\nvector, 1218, 1222–1224\nconvolution of, 901\ncross product of, 1016\northonormal, 842\nin the plane, 1015\nVenn diagram, 1160\nveriﬁcation, 1061–1066\nof spanning trees, 642\nveriﬁcation algorithm, 1063\nvertex\narticulation point, 621pr.\nattributes of, 592\ncapacity of, 714ex.\nin a graph, 1168\nintermediate, 693\nisolated, 1169\noverﬂowing, 736\nof a polygon, 1020ex.\nrelabeled, 740\nselector, 1093\nvertex cover, 1089, 1108, 1124–1127, 1139\nVERTEX-COVER, 1090\nvertex-cover problem\napproximation algorithm for, 1108–1111,\n1139\nNP-completeness of, 1089–1091, 1105\nvertex set, 1168\nviolation, of an equality constraint, 865\nvirtual memory, 24\nViterbi algorithm, 408pr.\nVORP, 411pr.\nwalk of a tree, 287, 293ex., 342, 1114\nweak duality, 880–881, 886ex., 895pr.\nweight\nof a cut, 1127ex.\nof an edge, 591\nmean, 680pr.\nof a path, 643\nweight-balanced tree, 338, 473pr.\nweighted bipartite matching, 530\nweighted matroid, 439–442\nweighted median, 225pr.\nweighted set-covering problem, 1135pr.\nweighted-union heuristic, 566\nweighted vertex cover, 1124–1127, 1139\nweight function\nfor a graph, 591\nin a weighted matroid, 439\nwhile, in pseudocode, 20\nwhite-path theorem, 608\nwhite vertex, 594, 603\nwidget, 1092\nwire, 1071\nWITNESS, 969\nwitness, to the compositeness of a number, 968\nwork law, 780\nwork, of a multithreaded computation, 779\nwork-stealing scheduling algorithm, 812\nworst-case running time, 27, 49\nYen’s improvement to the Bellman-Ford\nalgorithm, 678pr.\ny-fast trie, 558pr.\nYoung tableau, 167pr.\nZ (set of integers), 1158\nZn (equivalence classes modulo n), 928\nZ\u0004\nn (elements of multiplicative group\nmodulo n), 941\nZC\nn (nonzero elements of Zn), 967\nzero matrix, 1218\nzero of a polynomial modulo a prime, 950ex.\n0-1 integer programming, 1100ex., 1125\n0-1 knapsack problem, 425, 427ex., 1137pr.,\n1139\n0-1 sorting lemma, 208pr.\nzonk, 1195ex."
}